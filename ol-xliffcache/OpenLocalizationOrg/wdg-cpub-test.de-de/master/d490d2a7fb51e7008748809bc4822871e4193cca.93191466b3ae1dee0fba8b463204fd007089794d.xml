{"nodes":[{"content":"Optimize animations, media, and images","pos":[2,40]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[42,80]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[81,176],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Create Universal Windows Platform (UWP) apps with smooth animations, high frame rate, and high-performance media capture and playback.","pos":[178,312]},{"content":"Make animations smooth","pos":[317,339]},{"content":"A key aspect of UWP apps is smooth interactions.","pos":[341,389]},{"content":"This includes touch manipulations that \"stick to your finger,\" smooth transitions and animations, and small motions that provide input feedback.","pos":[390,534]},{"content":"In the XAML framework there is a thread called the composition thread that is dedicated to the composition and animation of an app’s visual elements.","pos":[535,684]},{"content":"Because the composition thread is separate from UI thread (the thread that runs framework and developer code), apps can achieve a consistent frame rate and smooth animations regardless of complicated layout passes or extended calculations.","pos":[685,924]},{"content":"This section shows how to use the composition thread to keep an app’s animations buttery smooth.","pos":[925,1021]},{"content":"For more info about animations, see <bpt id=\"p1\">[</bpt>Animations overview<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Mt187350)</ept>.","pos":[1022,1138],"source":" For more info about animations, see [Animations overview](https://msdn.microsoft.com/library/windows/apps/Mt187350)."},{"content":"To learn about increasing an app’s responsiveness while performing intensive computations, see <bpt id=\"p1\">[</bpt>Keep the UI thread responsive<ept id=\"p1\">](keep-the-ui-thread-responsive.md)</ept>.","pos":[1139,1300],"source":" To learn about increasing an app’s responsiveness while performing intensive computations, see [Keep the UI thread responsive](keep-the-ui-thread-responsive.md)."},{"content":"Use independent instead of dependent animations","pos":[1306,1353]},{"content":"Independent animations can be calculated from beginning to end at the time of creation because changes to the property being animated don't affect rest of the objects in a scene.","pos":[1355,1533]},{"content":"Independent animations can therefore run on the composition thread instead of the UI thread.","pos":[1534,1626]},{"content":"This guarantees that they remain smooth because the composition thread is updated at a consistent cadence.","pos":[1627,1733]},{"content":"All of these types of animations are guaranteed to be independent:","pos":[1735,1801]},{"content":"Object animations using key frames","pos":[1807,1841]},{"content":"Zero-duration animations","pos":[1846,1870]},{"pos":[1875,2058],"content":"Animations to the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Canvas.Left<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Hh759771)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Canvas.Top<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/Hh759772)</ept> properties","source":"Animations to the [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/Hh759771) and [**Canvas.Top**](https://msdn.microsoft.com/library/windows/apps/Hh759772) properties"},{"pos":[2063,2171],"content":"Animations to the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UIElement.Opacity<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208962)</ept> property","source":"Animations to the [**UIElement.Opacity**](https://msdn.microsoft.com/library/windows/apps/BR208962) property"},{"pos":[2176,2395],"content":"Animations to properties of type <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Brush<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR228076)</ept> when targeting the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>SolidColorBrush.Color<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242963)</ept> subproperty","source":"Animations to properties of type [**Brush**](https://msdn.microsoft.com/library/windows/apps/BR228076) when targeting the [**SolidColorBrush.Color**](https://msdn.microsoft.com/library/windows/apps/BR242963) subproperty"},{"pos":[2400,2570],"content":"Animations to the following <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UIElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208911)</ept> properties when targeting subproperties of these return value types:","source":"Animations to the following [**UIElement**](https://msdn.microsoft.com/library/windows/apps/BR208911) properties when targeting subproperties of these return value types:"},{"content":"RenderTransform","pos":[2583,2598]},{"content":"Projection","pos":[2687,2697]},{"content":"Clip","pos":[2781,2785]},{"content":"Dependent animations affect layout, which therefore cannot be calculated without extra input from the UI thread.","pos":[2853,2965]},{"content":"Dependent animations include modifications to properties like <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Width<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208751)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Height<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR208718)</ept>.","pos":[2966,3173],"source":" Dependent animations include modifications to properties like [**Width**](https://msdn.microsoft.com/library/windows/apps/BR208751) and [**Height**](https://msdn.microsoft.com/library/windows/apps/BR208718)."},{"content":"By default, dependent animations are not run and require an opt-in from the app developer.","pos":[3174,3264]},{"content":"When enabled, they run smoothly if the UI thread remains unblocked, but they begin to stutter if the framework or app is doing a lot of other work on the UI thread.","pos":[3265,3429]},{"content":"Almost all animations in the XAML framework are independent by default, but there are some actions that you can take to disable this optimization.","pos":[3431,3577]},{"content":"Beware of these scenarios particularly:","pos":[3578,3617]},{"content":"Setting the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>EnableDependentAnimation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR210356)</ept> property to allow a dependent animation to run on the UI thread.","pos":[3623,3788],"source":"Setting the [**EnableDependentAnimation**](https://msdn.microsoft.com/library/windows/apps/BR210356) property to allow a dependent animation to run on the UI thread."},{"content":"Convert these animations into an independent version.","pos":[3789,3842]},{"content":"For example animate <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ScaleTransform.ScaleX<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242946)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ScaleTransform.ScaleY<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242948)</ept> instead of the <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Width<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR208751)</ept> and <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>Height<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/BR208718)</ept> of an object.","pos":[3843,4212],"source":" For example animate [**ScaleTransform.ScaleX**](https://msdn.microsoft.com/library/windows/apps/BR242946) and [**ScaleTransform.ScaleY**](https://msdn.microsoft.com/library/windows/apps/BR242948) instead of the [**Width**](https://msdn.microsoft.com/library/windows/apps/BR208751) and [**Height**](https://msdn.microsoft.com/library/windows/apps/BR208718) of an object."},{"content":"Don’t be afraid to scale objects like images and text.","pos":[4213,4267]},{"content":"The framework applies bilinear scaling only while the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ScaleTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242940)</ept> is being animated.","pos":[4268,4419],"source":" The framework applies bilinear scaling only while the [**ScaleTransform**](https://msdn.microsoft.com/library/windows/apps/BR242940) is being animated."},{"content":"The image/text will be rerasterized at the final size to ensure it’s always clear.","pos":[4420,4502]},{"content":"Making per frame updates, which are effectively dependent animations.","pos":[4507,4576]},{"content":"An example of this is applying transformations in the handler of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CompositonTarget.Rendering<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR228127)</ept> event.","pos":[4577,4743],"source":" An example of this is applying transformations in the handler of the [**CompositonTarget.Rendering**](https://msdn.microsoft.com/library/windows/apps/BR228127) event."},{"content":"Running any animation considered independent in an element with the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CacheMode<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208911-cachemode)</ept> property set to <bpt id=\"p3\">**</bpt>BitmapCache<ept id=\"p3\">**</ept>.","pos":[4748,4932],"source":"Running any animation considered independent in an element with the [**CacheMode**](https://msdn.microsoft.com/library/windows/apps/BR208911-cachemode) property set to **BitmapCache**."},{"content":"This is considered dependent because the cache must be re-rasterized for each frame.","pos":[4933,5017]},{"content":"Don't animate a WebView or MediaElement","pos":[5023,5062]},{"content":"Web content within a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>WebView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR227702)</ept> control is not directly rendered by the XAML framework and it requires extra work to be composed with the rest of the scene.","pos":[5064,5281],"source":"Web content within a [**WebView**](https://msdn.microsoft.com/library/windows/apps/BR227702) control is not directly rendered by the XAML framework and it requires extra work to be composed with the rest of the scene."},{"content":"This extra work adds up when animating the control around the screen and can potentially introduce synchronization issues (for example, the HTML content might not move in sync with the rest of the XAML content on the page).","pos":[5282,5505]},{"content":"When you need to animate a <bpt id=\"p1\">**</bpt>WebView<ept id=\"p1\">**</ept> control, swap it with a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>WebViewBrush<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/BR227702brush)</ept> for the duration of the animation.","pos":[5506,5685],"source":" When you need to animate a **WebView** control, swap it with a [**WebViewBrush**](https://msdn.microsoft.com/library/windows/apps/BR227702brush) for the duration of the animation."},{"content":"Animating a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MediaElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242926)</ept> is a similarly bad idea.","pos":[5687,5800],"source":"Animating a [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/BR242926) is a similarly bad idea."},{"content":"Beyond the performance detriment, it can cause tearing or other artifacts in the video content being played.","pos":[5801,5909]},{"content":"Use infinite animations sparingly","pos":[5915,5948]},{"content":"Most animations execute for a specified amount of time, but setting the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Timeline.Duration<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243207)</ept> property to Forever allows an animation to run indefinitely.","pos":[5950,6164],"source":"Most animations execute for a specified amount of time, but setting the [**Timeline.Duration**](https://msdn.microsoft.com/library/windows/apps/BR243207) property to Forever allows an animation to run indefinitely."},{"content":"We recommend minimizing the use of infinite animations because they continually consume CPU resources and can prevent the CPU from going into a low power or idle state, causing it to run out of power more quickly.","pos":[6165,6378]},{"content":"Adding a handler for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CompositionTarget.Rendering<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR228127)</ept> is similar to running an infinite animation.","pos":[6380,6537],"source":"Adding a handler for [**CompositionTarget.Rendering**](https://msdn.microsoft.com/library/windows/apps/BR228127) is similar to running an infinite animation."},{"content":"Normally the UI thread is active only when there is work to do, but adding handler for this event forces it to run every frame.","pos":[6538,6665]},{"content":"Remove the handler when there is no work to be done and reregister it when it’s needed again.","pos":[6666,6759]},{"content":"Use the animation library","pos":[6765,6790]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.UI.Xaml.Media.Animation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243232)</ept> namespace includes a library of high-performance, smooth animations that have a look and feel consistent with other Windows animations.","pos":[6792,7027],"source":"The [**Windows.UI.Xaml.Media.Animation**](https://msdn.microsoft.com/library/windows/apps/BR243232) namespace includes a library of high-performance, smooth animations that have a look and feel consistent with other Windows animations."},{"content":"The relevant classes have \"Theme\" in their name, and are described in <bpt id=\"p1\">[</bpt>Animations overview<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Mt187350)</ept>.","pos":[7028,7178],"source":" The relevant classes have \"Theme\" in their name, and are described in [Animations overview](https://msdn.microsoft.com/library/windows/apps/Mt187350)."},{"content":"This library supports many common animation scenarios, such as animating the first view of the app and creating state and content transitions.","pos":[7179,7321]},{"content":"We recommend using this animation library whenever possible to increase performance and consistency for UWP UI.","pos":[7322,7433]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   The animation library can't animate all possible properties.","pos":[7435,7506],"source":"**Note**   The animation library can't animate all possible properties."},{"content":"For XAML scenarios where the animation library doesn't apply, see <bpt id=\"p1\">[</bpt>Storyboarded animations<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Mt187354)</ept>.","pos":[7507,7657],"source":" For XAML scenarios where the animation library doesn't apply, see [Storyboarded animations](https://msdn.microsoft.com/library/windows/apps/Mt187354)."},{"content":"Animate CompositeTransform3D properties independently","pos":[7664,7717]},{"content":"You can animate each property of a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CompositeTransform3D<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn914714)</ept> independently, so apply only the animations you need.","pos":[7719,7892],"source":"You can animate each property of a [**CompositeTransform3D**](https://msdn.microsoft.com/library/windows/apps/Dn914714) independently, so apply only the animations you need."},{"content":"For examples and more info, see <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UIElement.Transform3D<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208911-transform3d)</ept>.","pos":[7893,8023],"source":" For examples and more info, see [**UIElement.Transform3D**](https://msdn.microsoft.com/library/windows/apps/BR208911-transform3d)."},{"content":"For more info about animating transforms, see <bpt id=\"p1\">[</bpt>Storyboarded animations<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Mt187354)</ept> and <bpt id=\"p2\">[</bpt>Key-frame and easing function animations<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/Mt187352)</ept>.","pos":[8024,8259],"source":" For more info about animating transforms, see [Storyboarded animations](https://msdn.microsoft.com/library/windows/apps/Mt187354) and [Key-frame and easing function animations](https://msdn.microsoft.com/library/windows/apps/Mt187352)."},{"content":"Optimize media resources","pos":[8264,8288]},{"content":"Audio, video, and images are compelling forms of content that the majority of apps use.","pos":[8290,8377]},{"content":"As media capture rates increase and content moves from standard definition to high definition the amount of resources need to store, decode, and play back this content increases.","pos":[8378,8556]},{"content":"The XAML framework builds on the latest features added to the UWP media engines so apps get these improvements for free.","pos":[8557,8677]},{"content":"Here we explain some additional tricks that allow you to get the most out media in your UWP app.","pos":[8678,8774]},{"content":"Release media streams","pos":[8780,8801]},{"content":"Media files are some of the most common and expensive resources apps typically use.","pos":[8803,8886]},{"content":"Because media file resources can greatly increase the size of your app's memory footprint, you must remember to release the handle to media as soon as the app is finished using it.","pos":[8887,9067]},{"pos":[9069,9400],"content":"For example, if your app working with a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>RandomAccessStream<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR241747)</ept> or an <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>IInputStream<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR241718)</ept> object, be sure to call the close method on the object when your app has finished using it, to release the underlying object.","source":"For example, if your app working with a [**RandomAccessStream**](https://msdn.microsoft.com/library/windows/apps/BR241747) or an [**IInputStream**](https://msdn.microsoft.com/library/windows/apps/BR241718) object, be sure to call the close method on the object when your app has finished using it, to release the underlying object."},{"content":"Display full screen video playback when possible","pos":[9406,9454]},{"content":"In UWP apps, always use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IsFullWindow<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242926-isfullwindow)</ept> property on the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>MediaElement<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242926)</ept> to enable and disable full window rendering.","pos":[9456,9711],"source":"In UWP apps, always use the [**IsFullWindow**](https://msdn.microsoft.com/library/windows/apps/BR242926-isfullwindow) property on the [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/BR242926) to enable and disable full window rendering."},{"content":"This insures system level optimizations are used during media playback.","pos":[9712,9783]},{"content":"The XAML framework can optimize the display of video content when it is the only thing being rendered, resulting in an experience that uses less power and yields higher frame rates.","pos":[9785,9966]},{"content":"For most efficient media playback set the size of a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MediaElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242926)</ept> to be the width and height of the screen and don’t display other XAML elements","pos":[9967,10174],"source":" For most efficient media playback set the size of a [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/BR242926) to be the width and height of the screen and don’t display other XAML elements"},{"content":"There are legitimate reasons to overlay XAML elements on a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MediaElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242926)</ept> that takes up the full width and height of the screen, for example closed captions or momentary transport controls.","pos":[10176,10427],"source":"There are legitimate reasons to overlay XAML elements on a [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/BR242926) that takes up the full width and height of the screen, for example closed captions or momentary transport controls."},{"content":"Making sure to hide these elements (eg.","pos":[10428,10467]},{"content":"setting Visibility=”Collapsed”) when they are not needed pops media playback back into its most efficient state.","pos":[10468,10580]},{"content":"Display deactivation and conserving power","pos":[10586,10627]},{"pos":[10629,10857],"content":"To prevent the display from be deactivating when user action is no longer detected, such as when an app is playing video, you can call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DisplayRequest.RequestActive<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR241818)</ept>.","source":"To prevent the display from be deactivating when user action is no longer detected, such as when an app is playing video, you can call [**DisplayRequest.RequestActive**](https://msdn.microsoft.com/library/windows/apps/BR241818)."},{"pos":[10859,11072],"content":"To conserve power and battery life, you should call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DisplayRequest.RequestRelease<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR241819)</ept> to release the display request as soon as it is no longer required.","source":"To conserve power and battery life, you should call [**DisplayRequest.RequestRelease**](https://msdn.microsoft.com/library/windows/apps/BR241819) to release the display request as soon as it is no longer required."},{"content":"Here are some situations when you should release the display request:","pos":[11074,11143]},{"content":"Video playback is paused, for example by user action, buffering, or adjustment due to limited bandwidth.","pos":[11149,11253]},{"content":"Playback stops.","pos":[11258,11273]},{"content":"For example, the video is done playing or the presentation is over.","pos":[11274,11341]},{"content":"A playback error has occurred.","pos":[11346,11376]},{"content":"For example, network connectivity issues or a corrupted file.","pos":[11377,11438]},{"content":"Put other elements to the side of embedded video","pos":[11444,11492]},{"content":"Often apps offer an embedded view where video is played within a page.","pos":[11494,11564]},{"content":"Now you obviously lost the full screen optimization because the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MediaElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242926)</ept> is not the size of the page and there are other XAML objects drawn.","pos":[11565,11773],"source":" Now you obviously lost the full screen optimization because the [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/BR242926) is not the size of the page and there are other XAML objects drawn."},{"content":"Beware of unintentionally entering this mode by drawing a border around a <bpt id=\"p1\">**</bpt>MediaElement<ept id=\"p1\">**</ept>.","pos":[11774,11865],"source":" Beware of unintentionally entering this mode by drawing a border around a **MediaElement**."},{"content":"Don’t draw XAML elements on top of video when it’s in embedded mode.","pos":[11867,11935]},{"content":"If you do, the framework is forced to do a little extra work to compose the scene.","pos":[11936,12018]},{"content":"Placing transport controls below an embedded media element instead of on top of the video is a good example of optimizing for this situation.","pos":[12019,12160]},{"content":"In this image, the red bar indicates a set of transport controls (play, pause, stop, etc.).","pos":[12161,12252]},{"content":"MediaElement with overlaying elements<ph id=\"ph1\">](images/videowithoverlay.png)</ph> Don’t place these controls on top of media that is not full screen.","pos":[12256,12391],"source":"MediaElement with overlaying elements](images/videowithoverlay.png)\nDon’t place these controls on top of media that is not full screen."},{"content":"Instead place the transport controls somewhere outside of the area where the media is being rendered.","pos":[12392,12493]},{"content":"In the next image, the controls are placed below the media.","pos":[12494,12553]},{"content":"MediaElement with neighboring elements","pos":[12557,12595]},{"content":"Delay setting the source for a MediaElement","pos":[12633,12676]},{"content":"Media engines are expensive objects and the XAML framework delays loading dlls and creating large objects as long as possible.","pos":[12678,12804]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MediaElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242926)</ept> is forced to do this work after its source is set via the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Source<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242926-source)</ept> property or the <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>SetSource<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR242926-setsource)</ept> method.","pos":[12805,13129],"source":" The [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/BR242926) is forced to do this work after its source is set via the [**Source**](https://msdn.microsoft.com/library/windows/apps/BR242926-source) property or the [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR242926-setsource) method."},{"content":"Setting these when the user is really ready to play media delays the majority of the cost associated with the <bpt id=\"p1\">**</bpt>MediaElement<ept id=\"p1\">**</ept> as long as possible.","pos":[13130,13277],"source":" Setting these when the user is really ready to play media delays the majority of the cost associated with the **MediaElement** as long as possible."},{"content":"Set MediaElement.PosterSource","pos":[13283,13312]},{"content":"Setting <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MediaElement.PosterSource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242926-postersource)</ept> enables XAML to release some GPU resources that would have otherwise been used.","pos":[13314,13504],"source":"Setting [**MediaElement.PosterSource**](https://msdn.microsoft.com/library/windows/apps/BR242926-postersource) enables XAML to release some GPU resources that would have otherwise been used."},{"content":"This API allows an app to use as little memory as possible.","pos":[13505,13564]},{"content":"Improve media scrubbing","pos":[13570,13593]},{"content":"Scrubbing is always a tough task for media platforms to make really responsive.","pos":[13595,13674]},{"content":"Generally people accomplish this by changing the value of a Slider.","pos":[13675,13742]},{"content":"Here are a couple tips on how to make this as efficient as possible:","pos":[13743,13811]},{"content":"Either bind the value of a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Slider<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209614)</ept> to <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>MediaElement.Position<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242926-position)</ept> or update it based on a timer.","pos":[13817,14043],"source":"Either bind the value of a [**Slider**](https://msdn.microsoft.com/library/windows/apps/BR209614) to [**MediaElement.Position**](https://msdn.microsoft.com/library/windows/apps/BR242926-position) or update it based on a timer."},{"content":"Don't do both.","pos":[14044,14058]},{"content":"If you choose the latter, make sure to use a reasonable update frequency for your timer.","pos":[14059,14147]},{"content":"The XAML framework only updates <bpt id=\"p1\">**</bpt>MediaElement.Position<ept id=\"p1\">**</ept> only every 250 milliseconds during playback.","pos":[14148,14250],"source":" The XAML framework only updates **MediaElement.Position** only every 250 milliseconds during playback."},{"content":"The size of the step frequency on the Slider must scale with the length of the video.","pos":[14255,14340]},{"pos":[14345,14837],"content":"Subscribe to the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerPressed<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerpressed)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>PointerMoved<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR208911-pointermoved)</ept>, <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>PointerReleased<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerreleased)</ept> events on the slider to set the <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>MediaElement.PlaybackRate<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/BR242926-playbackrate)</ept> property to 0 when the user drags the thumb of the slider.","source":"Subscribe to the [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerpressed), [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/BR208911-pointermoved), [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerreleased) events on the slider to set the [**MediaElement.PlaybackRate**](https://msdn.microsoft.com/library/windows/apps/BR242926-playbackrate) property to 0 when the user drags the thumb of the slider."},{"pos":[14842,15071],"content":"In the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerReleased<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerreleased)</ept> event handler, manually set the media position to the slider position value to achieve optimal thumb snapping while scrubbing.","source":"In the [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerreleased) event handler, manually set the media position to the slider position value to achieve optimal thumb snapping while scrubbing."},{"content":"Match video resolution to device resolution","pos":[15077,15120]},{"content":"Decoding video takes a lot of memory and GPU cycles, so choose a video format close to the resolution it will be displayed at.","pos":[15122,15248]},{"content":"There is no point in using the resources to decode 1080 video if it’s going to get scaled down to a much smaller size.","pos":[15249,15367]},{"content":"Many apps don’t have the same video encoded at different resolutions; but if it is available, use an encoding that is close to the resolution at which it will be displayed.","pos":[15368,15540]},{"content":"Choose recommended formats","pos":[15546,15572]},{"content":"Media format selection can be a sensitive topic and is often driven by business decisions.","pos":[15574,15664]},{"content":"From a UWP performance perspective, we recommend H.264 video as the primary video format and AAC and MP3 as the preferred audio formats.","pos":[15665,15801]},{"content":"For local file playback, MP4 is the preferred file container for video content.","pos":[15802,15881]},{"content":"H.264 decoding is accelerated through most recent graphics hardware.","pos":[15882,15950]},{"content":"Also, although hardware acceleration for VC-1 decoding is broadly available, for a large set of graphics hardware on the market, the acceleration is limited in many cases to a partial acceleration level (or IDCT level), rather than a full-steam level hardware offload (i.e. VLD mode).","pos":[15951,16235]},{"content":"If you have full control of the video content generation process, you must figure out how to keep a good balance between compression efficiency and GOP structure.","pos":[16237,16399]},{"content":"Relatively smaller GOP size with B pictures can increase the performance in seeking or trick modes.","pos":[16400,16499]},{"content":"When including short, low-latency audio effects, for example in games, use WAV files with uncompressed PCM data to reduce processing overhead that is typical for compressed audio formats.","pos":[16501,16688]},{"content":"Hardware audio offloading","pos":[16694,16719]},{"content":"For hardware audio offload to be automatically applied, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MediaElement.AudioCategory<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242926-audiocategory)</ept> must be set to <bpt id=\"p3\">**</bpt>ForegroundOnlyMedia<ept id=\"p3\">**</ept> or <bpt id=\"p4\">**</bpt>BackgroundCapableMedia<ept id=\"p4\">**</ept>.","pos":[16721,16951],"source":"For hardware audio offload to be automatically applied, [**MediaElement.AudioCategory**](https://msdn.microsoft.com/library/windows/apps/BR242926-audiocategory) must be set to **ForegroundOnlyMedia** or **BackgroundCapableMedia**."},{"content":"Hardware audio offload optimizes audio rendering which can improve functionality and battery life.","pos":[16952,17050]},{"content":"Optimize image resources","pos":[17055,17079]},{"content":"Scale images to the appropriate size","pos":[17085,17121]},{"content":"Images are captured at very high resolutions, which can lead to apps using more CPU when decoding the image data and more memory after it’s loaded from disk.","pos":[17123,17280]},{"content":"But there’s no sense decoding and saving a high-resolution image in memory only to display it smaller than its native size.","pos":[17281,17404]},{"content":"Instead, create a version of the image at the exact size it will be drawn on-screen using the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DecodePixelWidth<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243243)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DecodePixelHeight<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR243241)</ept> properties.","pos":[17405,17677],"source":" Instead, create a version of the image at the exact size it will be drawn on-screen using the [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) properties."},{"content":"Don't do this:","pos":[17679,17693]},{"content":"Instead, do this:","pos":[17823,17840]},{"content":"The units for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DecodePixelWidth<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243243)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DecodePixelHeight<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR243241)</ept> are by default physical pixels.","pos":[18039,18251],"source":"The units for [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) are by default physical pixels."},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DecodePixelType<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn298545)</ept> property can be used to change this behavior: setting <bpt id=\"p3\">**</bpt>DecodePixelType<ept id=\"p3\">**</ept> to <bpt id=\"p4\">**</bpt>Logical<ept id=\"p4\">**</ept> results in the decode size automatically accounting for the system’s current scale factor, similar to other XAML content.","pos":[18252,18546],"source":" The [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) property can be used to change this behavior: setting **DecodePixelType** to **Logical** results in the decode size automatically accounting for the system’s current scale factor, similar to other XAML content."},{"content":"It would therefore be generally appropriate to set <bpt id=\"p1\">**</bpt>DecodePixelType<ept id=\"p1\">**</ept> to <bpt id=\"p2\">**</bpt>Logical<ept id=\"p2\">**</ept> if, for instance, you want <bpt id=\"p3\">**</bpt>DecodePixelWidth<ept id=\"p3\">**</ept> and <bpt id=\"p4\">**</bpt>DecodePixelHeight<ept id=\"p4\">**</ept> to match the Height and Width properties of the Image control the image will be displayed in.","pos":[18547,18800],"source":" It would therefore be generally appropriate to set **DecodePixelType** to **Logical** if, for instance, you want **DecodePixelWidth** and **DecodePixelHeight** to match the Height and Width properties of the Image control the image will be displayed in."},{"content":"With the default behavior of using physical pixels, you must account for the system’s current scale factor yourself; and you should listen for scale change notifications in case the user changes their display preferences.","pos":[18801,19022]},{"content":"If DecodePixelWidth/Height are explicitly set larger than the image will be displayed on-screen then the app will unnecessarily use extra memory—up to 4 bytes per pixel—which quickly becomes expensive for large images.","pos":[19024,19242]},{"content":"The image will also be scaled down using bilinear scaling which could cause it to appear blurry for large scale factors.","pos":[19243,19363]},{"content":"If DecodePixelWidth/DecodePixelHeight are explicitly set smaller than the image will be displayed on screen then it will be scaled up and could appear pixelated.","pos":[19365,19526]},{"content":"In some cases where an appropriate decode size cannot be determined ahead of time, you should defer to XAML’s automatic right-size-decoding which will make a best effort attempt to decode the image at the appropriate size if an explicit DecodePixelWidth/DecodePixelHeight is not specified.","pos":[19528,19817]},{"content":"You should set an explicit decode size if you know the size of the image content ahead of time.","pos":[19819,19914]},{"content":"You should also in conjunction set <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DecodePixelType<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn298545)</ept> to <bpt id=\"p3\">**</bpt>Logical<ept id=\"p3\">**</ept> if the supplied decode size is relative to other XAML element sizes.","pos":[19915,20113],"source":" You should also in conjunction set [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) to **Logical** if the supplied decode size is relative to other XAML element sizes."},{"content":"For example, if you explicitly set the content size with Image.Width and Image.Height, you could set DecodePixelType to DecodePixelType.Logical to use the same logical pixel dimensions as an Image control and then explicitly use BitmapImage.DecodePixelWidth and/or BitmapImage.DecodePixelHeight to control the size of the image to achieve potentially large memory savings.","pos":[20114,20486]},{"content":"Note that Image.Stretch should be considered when determining the size of the decoded content.","pos":[20488,20582]},{"content":"Right-sized decoding","pos":[20588,20608]},{"content":"In the event that you don't set an explicit decode size, XAML will make a best effort attempt to save memory by decoding an image to the exact size it will appear on-screen according to the containing page’s initial layout.","pos":[20610,20833]},{"content":"You're advised to write your application in such a way as to make use of this feature when possible.","pos":[20834,20934]},{"content":"This feature will be disabled if any of the following conditions are met.","pos":[20935,21008]},{"pos":[21014,21326],"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BitmapImage<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243235)</ept> is connected to the live XAML tree after setting the content with <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>SetSourceAsync<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/JJ191522)</ept> or <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>UriSource<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource)</ept>.","source":"The [**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235) is connected to the live XAML tree after setting the content with [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) or [**UriSource**](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource)."},{"pos":[21331,21461],"content":"The image is decoded using synchronous decoding such as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SetSource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243255)</ept>.","source":"The image is decoded using synchronous decoding such as [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255)."},{"pos":[21466,21738],"content":"The image is hidden via setting <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Opacity<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208962)</ept> to 0 or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Visibility<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR208911-visibility)</ept> to <bpt id=\"p5\">**</bpt>Collapsed<ept id=\"p5\">**</ept> on the host image element or brush or any parent element.","source":"The image is hidden via setting [**Opacity**](https://msdn.microsoft.com/library/windows/apps/BR208962) to 0 or [**Visibility**](https://msdn.microsoft.com/library/windows/apps/BR208911-visibility) to **Collapsed** on the host image element or brush or any parent element."},{"pos":[21743,21861],"content":"The image control or brush uses a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Stretch<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242968)</ept> of <bpt id=\"p3\">**</bpt>None<ept id=\"p3\">**</ept>.","source":"The image control or brush uses a [**Stretch**](https://msdn.microsoft.com/library/windows/apps/BR242968) of **None**."},{"pos":[21866,21962],"content":"The image is used as a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>NineGrid<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242756)</ept>.","source":"The image is used as a [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756)."},{"pos":[21993,22046],"content":"is set on the image element or on any parent element."},{"content":"The image brush is non-rectangular (such as when applied to a shape or to text).","pos":[22051,22131]},{"content":"In the above scenarios, setting an explicit decode size is the only way to achieve memory savings.","pos":[22133,22231]},{"content":"You should always attach a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BitmapImage<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243235)</ept> to the live tree before setting the source.","pos":[22233,22379],"source":"You should always attach a [**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235) to the live tree before setting the source."},{"content":"Any time an image element or brush is specified in markup, this will automatically be the case.","pos":[22380,22475]},{"content":"Examples are provided below under the heading \"Live tree examples\".","pos":[22476,22543]},{"content":"You should always avoid using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SetSource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243255)</ept> and instead use <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>SetSourceAsync<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/JJ191522)</ept> when setting a stream source.","pos":[22544,22772],"source":" You should always avoid using [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255) and instead use [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) when setting a stream source."},{"content":"And it's a good idea to avoid hiding image content (either with zero opacity or with collapsed visibility) while waiting for the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ImageOpened<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243235-imageopened)</ept> event to be raised.","pos":[22773,23009],"source":" And it's a good idea to avoid hiding image content (either with zero opacity or with collapsed visibility) while waiting for the [**ImageOpened**](https://msdn.microsoft.com/library/windows/apps/BR243235-imageopened) event to be raised."},{"content":"Doing this is a judgment call: you won't benefit from automatic right-sized decoding if it's done.","pos":[23010,23108]},{"content":"If your app must hide image content initially then it should also set the decode size explicitly if possible.","pos":[23109,23218]},{"content":"Live tree examples","pos":[23222,23240]},{"content":"Example 1 (good)—Uniform Resource Identifier (URI) specified in markup.","pos":[23244,23315]},{"content":"Example 2 markup—URI specified in code-behind.","pos":[23389,23435]},{"content":"Example 2 code-behind (good)—connecting the BitmapImage to the tree before setting its UriSource.","pos":[23475,23572]},{"content":"Example 2 code-behind (bad)—setting the the BitmapImage's UriSource before connecting it to the tree.","pos":[23752,23853]},{"content":"Caching optimizations","pos":[24037,24058]},{"content":"Caching optimizations are in effect for images that use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UriSource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource)</ept> to load content from an app package or from the web.","pos":[24060,24252],"source":"Caching optimizations are in effect for images that use [**UriSource**](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource) to load content from an app package or from the web."},{"content":"The URI is used to uniquely identify the underlying content, and internally the XAML framework will not download or decode the content multiple times.","pos":[24253,24403]},{"content":"Instead, it will use the cached software or hardware resources to display the content multiple times.","pos":[24404,24505]},{"content":"The exception to this optimization is if the image is displayed multiple times at different resolutions (which can be specified explicitly or through automatic right-sized decoding).","pos":[24507,24689]},{"content":"Each cache entry also stores the resolution of the image, and if XAML cannot find an image with a source URI that matches the required resolution then it will decode a new version at that size.","pos":[24690,24883]},{"content":"It will not, however, download the encoded image data again.","pos":[24884,24944]},{"pos":[24946,25246],"content":"Consequently, you should embrace using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UriSource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource)</ept> when loading images from an app package, and avoid using a file stream and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>SetSourceAsync<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/JJ191522)</ept> when it's not required.","source":"Consequently, you should embrace using [**UriSource**](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource) when loading images from an app package, and avoid using a file stream and [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) when it's not required."},{"content":"Images in virtualized panels (ListView, for instance)","pos":[25252,25305]},{"content":"If an image is removed from the tree—because the app explicitly removed it, or because it’s in a modern virtualized panel and was implicitly removed when scrolled out of view—then XAML will optimize memory usage by releasing the hardware resources for the image since they are no longer required.","pos":[25307,25603]},{"content":"The memory is not released immediately, but rather is released during the frame update that occurs after one second of the image element no longer being in the tree.","pos":[25604,25769]},{"content":"Consequently, you should strive to use modern virtualized panels to host lists of image content.","pos":[25771,25867]},{"content":"Software-rasterized images","pos":[25873,25899]},{"content":"When an image is used for a non-rectangular brush or for a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>NineGrid<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242756)</ept>, the image will use a software rasterization path, which will not scale images at all.","pos":[25901,26119],"source":"When an image is used for a non-rectangular brush or for a [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756), the image will use a software rasterization path, which will not scale images at all."},{"content":"Additionally, it must store a copy of the image in both software and hardware memory.","pos":[26120,26205]},{"content":"For instance, if an image is used as a brush for an ellipse then the potentially large full image will be stored twice internally.","pos":[26206,26336]},{"content":"When using <bpt id=\"p1\">**</bpt>NineGrid<ept id=\"p1\">**</ept> or a non-rectangular brush, then, your app should pre-scale its images to approximately the size they will be rendered at.","pos":[26337,26483],"source":" When using **NineGrid** or a non-rectangular brush, then, your app should pre-scale its images to approximately the size they will be rendered at."},{"content":"Background thread image-loading","pos":[26489,26520]},{"content":"XAML has an internal optimization that allows it to decode the contents of an image asynchronously to a surface in hardware memory without requiring an intermediate surface in software memory.","pos":[26522,26714]},{"content":"This reduces peak memory usage and rendering latency.","pos":[26715,26768]},{"content":"This feature will be disabled if any of the following conditions are met.","pos":[26769,26842]},{"pos":[26848,26944],"content":"The image is used as a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>NineGrid<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242756)</ept>.","source":"The image is used as a [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756)."},{"pos":[26975,27028],"content":"is set on the image element or on any parent element."},{"content":"The image brush is non-rectangular (such as when applied to a shape or to text).","pos":[27033,27113]},{"content":"SoftwareBitmapSource","pos":[27119,27139]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SoftwareBitmapSource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn997854)</ept> class exchanges interoperable uncompressed images between different WinRT namespaces such as <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>BitmapDecoder<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR226176)</ept>, camera APIs, and XAML.","pos":[27141,27424],"source":"The [**SoftwareBitmapSource**](https://msdn.microsoft.com/library/windows/apps/Dn997854) class exchanges interoperable uncompressed images between different WinRT namespaces such as [**BitmapDecoder**](https://msdn.microsoft.com/library/windows/apps/BR226176), camera APIs, and XAML."},{"content":"This class obviates an extra copy that would typically be necessary with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>WriteableBitmap<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243259)</ept>, and that helps reduce peak memory and source-to-screen latency.","pos":[27425,27642],"source":" This class obviates an extra copy that would typically be necessary with [**WriteableBitmap**](https://msdn.microsoft.com/library/windows/apps/BR243259), and that helps reduce peak memory and source-to-screen latency."},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SoftwareBitmap<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn887358)</ept> that supplies source information can also be configured to use a custom <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>IWICBitmap<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/Ee719675)</ept> to provide a reloadable backing store that allows the app to re-map memory as it sees fit.","pos":[27644,27967],"source":"The [**SoftwareBitmap**](https://msdn.microsoft.com/library/windows/apps/Dn887358) that supplies source information can also be configured to use a custom [**IWICBitmap**](https://msdn.microsoft.com/library/windows/desktop/Ee719675) to provide a reloadable backing store that allows the app to re-map memory as it sees fit."},{"content":"This is an advanced C++ use case.","pos":[27968,28001]},{"content":"Your app should use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SoftwareBitmap<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn887358)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>SoftwareBitmapSource<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/Dn997854)</ept> to interoperate with other WinRT APIs that produce and consume images.","pos":[28003,28261],"source":"Your app should use [**SoftwareBitmap**](https://msdn.microsoft.com/library/windows/apps/Dn887358) and [**SoftwareBitmapSource**](https://msdn.microsoft.com/library/windows/apps/Dn997854) to interoperate with other WinRT APIs that produce and consume images."},{"content":"And your app should use <bpt id=\"p1\">**</bpt>SoftwareBitmapSource<ept id=\"p1\">**</ept> when loading uncompressed image data instead of using <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>WriteableBitmap<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/BR243259)</ept>.","pos":[28262,28445],"source":" And your app should use **SoftwareBitmapSource** when loading uncompressed image data instead of using [**WriteableBitmap**](https://msdn.microsoft.com/library/windows/apps/BR243259)."},{"pos":[28561,28597],"content":"Use GetThumbnailAsync for thumbnails"},{"content":"One use case for scaling images is creating thumbnails.","pos":[28599,28654]},{"content":"Although you could use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DecodePixelWidth<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243243)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DecodePixelHeight<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR243241)</ept> to provide small versions of images, UWP provides even more efficient APIs for retrieving thumbnails.","pos":[28655,28946],"source":" Although you could use [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) to provide small versions of images, UWP provides even more efficient APIs for retrieving thumbnails."},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>GetThumbnailAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR227210)</ept> provides the thumbnails for images that have the file system already cached.","pos":[28947,29105],"source":"[**GetThumbnailAsync**](https://msdn.microsoft.com/library/windows/apps/BR227210) provides the thumbnails for images that have the file system already cached."},{"content":"This provides even better performance than the XAML APIs because the image doesn’t need to be opened or decoded.","pos":[29106,29218]},{"content":"Decode images once","pos":[30310,30328]},{"content":"To prevent images from being decoded more than once, assign the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Image.Source<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242760)</ept> property from an Uri rather than using memory streams.","pos":[30330,30525],"source":"To prevent images from being decoded more than once, assign the [**Image.Source**](https://msdn.microsoft.com/library/windows/apps/BR242760) property from an Uri rather than using memory streams."},{"content":"The XAML framework can associate the same Uri in multiple places with one decoded image, but it cannot do the same for multiple memory streams that contain the same data and creates a different decoded image for each memory stream.","pos":[30526,30757]}],"content":"# Optimize animations, media, and images\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nCreate Universal Windows Platform (UWP) apps with smooth animations, high frame rate, and high-performance media capture and playback.\n\n## Make animations smooth\n\nA key aspect of UWP apps is smooth interactions. This includes touch manipulations that \"stick to your finger,\" smooth transitions and animations, and small motions that provide input feedback. In the XAML framework there is a thread called the composition thread that is dedicated to the composition and animation of an app’s visual elements. Because the composition thread is separate from UI thread (the thread that runs framework and developer code), apps can achieve a consistent frame rate and smooth animations regardless of complicated layout passes or extended calculations. This section shows how to use the composition thread to keep an app’s animations buttery smooth. For more info about animations, see [Animations overview](https://msdn.microsoft.com/library/windows/apps/Mt187350). To learn about increasing an app’s responsiveness while performing intensive computations, see [Keep the UI thread responsive](keep-the-ui-thread-responsive.md).\n\n### Use independent instead of dependent animations\n\nIndependent animations can be calculated from beginning to end at the time of creation because changes to the property being animated don't affect rest of the objects in a scene. Independent animations can therefore run on the composition thread instead of the UI thread. This guarantees that they remain smooth because the composition thread is updated at a consistent cadence.\n\nAll of these types of animations are guaranteed to be independent:\n\n-   Object animations using key frames\n-   Zero-duration animations\n-   Animations to the [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/Hh759771) and [**Canvas.Top**](https://msdn.microsoft.com/library/windows/apps/Hh759772) properties\n-   Animations to the [**UIElement.Opacity**](https://msdn.microsoft.com/library/windows/apps/BR208962) property\n-   Animations to properties of type [**Brush**](https://msdn.microsoft.com/library/windows/apps/BR228076) when targeting the [**SolidColorBrush.Color**](https://msdn.microsoft.com/library/windows/apps/BR242963) subproperty\n-   Animations to the following [**UIElement**](https://msdn.microsoft.com/library/windows/apps/BR208911) properties when targeting subproperties of these return value types:\n\n    -   [**RenderTransform**](https://msdn.microsoft.com/library/windows/apps/BR208911-rendertransform)\n    -   [**Projection**](https://msdn.microsoft.com/library/windows/apps/BR208911-projection)\n    -   [**Clip**](https://msdn.microsoft.com/library/windows/apps/BR208911-clip)\n\nDependent animations affect layout, which therefore cannot be calculated without extra input from the UI thread. Dependent animations include modifications to properties like [**Width**](https://msdn.microsoft.com/library/windows/apps/BR208751) and [**Height**](https://msdn.microsoft.com/library/windows/apps/BR208718). By default, dependent animations are not run and require an opt-in from the app developer. When enabled, they run smoothly if the UI thread remains unblocked, but they begin to stutter if the framework or app is doing a lot of other work on the UI thread.\n\nAlmost all animations in the XAML framework are independent by default, but there are some actions that you can take to disable this optimization. Beware of these scenarios particularly:\n\n-   Setting the [**EnableDependentAnimation**](https://msdn.microsoft.com/library/windows/apps/BR210356) property to allow a dependent animation to run on the UI thread. Convert these animations into an independent version. For example animate [**ScaleTransform.ScaleX**](https://msdn.microsoft.com/library/windows/apps/BR242946) and [**ScaleTransform.ScaleY**](https://msdn.microsoft.com/library/windows/apps/BR242948) instead of the [**Width**](https://msdn.microsoft.com/library/windows/apps/BR208751) and [**Height**](https://msdn.microsoft.com/library/windows/apps/BR208718) of an object. Don’t be afraid to scale objects like images and text. The framework applies bilinear scaling only while the [**ScaleTransform**](https://msdn.microsoft.com/library/windows/apps/BR242940) is being animated. The image/text will be rerasterized at the final size to ensure it’s always clear.\n-   Making per frame updates, which are effectively dependent animations. An example of this is applying transformations in the handler of the [**CompositonTarget.Rendering**](https://msdn.microsoft.com/library/windows/apps/BR228127) event.\n-   Running any animation considered independent in an element with the [**CacheMode**](https://msdn.microsoft.com/library/windows/apps/BR208911-cachemode) property set to **BitmapCache**. This is considered dependent because the cache must be re-rasterized for each frame.\n\n### Don't animate a WebView or MediaElement\n\nWeb content within a [**WebView**](https://msdn.microsoft.com/library/windows/apps/BR227702) control is not directly rendered by the XAML framework and it requires extra work to be composed with the rest of the scene. This extra work adds up when animating the control around the screen and can potentially introduce synchronization issues (for example, the HTML content might not move in sync with the rest of the XAML content on the page). When you need to animate a **WebView** control, swap it with a [**WebViewBrush**](https://msdn.microsoft.com/library/windows/apps/BR227702brush) for the duration of the animation.\n\nAnimating a [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/BR242926) is a similarly bad idea. Beyond the performance detriment, it can cause tearing or other artifacts in the video content being played.\n\n### Use infinite animations sparingly\n\nMost animations execute for a specified amount of time, but setting the [**Timeline.Duration**](https://msdn.microsoft.com/library/windows/apps/BR243207) property to Forever allows an animation to run indefinitely. We recommend minimizing the use of infinite animations because they continually consume CPU resources and can prevent the CPU from going into a low power or idle state, causing it to run out of power more quickly.\n\nAdding a handler for [**CompositionTarget.Rendering**](https://msdn.microsoft.com/library/windows/apps/BR228127) is similar to running an infinite animation. Normally the UI thread is active only when there is work to do, but adding handler for this event forces it to run every frame. Remove the handler when there is no work to be done and reregister it when it’s needed again.\n\n### Use the animation library\n\nThe [**Windows.UI.Xaml.Media.Animation**](https://msdn.microsoft.com/library/windows/apps/BR243232) namespace includes a library of high-performance, smooth animations that have a look and feel consistent with other Windows animations. The relevant classes have \"Theme\" in their name, and are described in [Animations overview](https://msdn.microsoft.com/library/windows/apps/Mt187350). This library supports many common animation scenarios, such as animating the first view of the app and creating state and content transitions. We recommend using this animation library whenever possible to increase performance and consistency for UWP UI.\n\n**Note**   The animation library can't animate all possible properties. For XAML scenarios where the animation library doesn't apply, see [Storyboarded animations](https://msdn.microsoft.com/library/windows/apps/Mt187354).\n\n\n### Animate CompositeTransform3D properties independently\n\nYou can animate each property of a [**CompositeTransform3D**](https://msdn.microsoft.com/library/windows/apps/Dn914714) independently, so apply only the animations you need. For examples and more info, see [**UIElement.Transform3D**](https://msdn.microsoft.com/library/windows/apps/BR208911-transform3d). For more info about animating transforms, see [Storyboarded animations](https://msdn.microsoft.com/library/windows/apps/Mt187354) and [Key-frame and easing function animations](https://msdn.microsoft.com/library/windows/apps/Mt187352).\n\n## Optimize media resources\n\nAudio, video, and images are compelling forms of content that the majority of apps use. As media capture rates increase and content moves from standard definition to high definition the amount of resources need to store, decode, and play back this content increases. The XAML framework builds on the latest features added to the UWP media engines so apps get these improvements for free. Here we explain some additional tricks that allow you to get the most out media in your UWP app.\n\n### Release media streams\n\nMedia files are some of the most common and expensive resources apps typically use. Because media file resources can greatly increase the size of your app's memory footprint, you must remember to release the handle to media as soon as the app is finished using it.\n\nFor example, if your app working with a [**RandomAccessStream**](https://msdn.microsoft.com/library/windows/apps/BR241747) or an [**IInputStream**](https://msdn.microsoft.com/library/windows/apps/BR241718) object, be sure to call the close method on the object when your app has finished using it, to release the underlying object.\n\n### Display full screen video playback when possible\n\nIn UWP apps, always use the [**IsFullWindow**](https://msdn.microsoft.com/library/windows/apps/BR242926-isfullwindow) property on the [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/BR242926) to enable and disable full window rendering. This insures system level optimizations are used during media playback.\n\nThe XAML framework can optimize the display of video content when it is the only thing being rendered, resulting in an experience that uses less power and yields higher frame rates. For most efficient media playback set the size of a [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/BR242926) to be the width and height of the screen and don’t display other XAML elements\n\nThere are legitimate reasons to overlay XAML elements on a [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/BR242926) that takes up the full width and height of the screen, for example closed captions or momentary transport controls. Making sure to hide these elements (eg. setting Visibility=”Collapsed”) when they are not needed pops media playback back into its most efficient state.\n\n### Display deactivation and conserving power\n\nTo prevent the display from be deactivating when user action is no longer detected, such as when an app is playing video, you can call [**DisplayRequest.RequestActive**](https://msdn.microsoft.com/library/windows/apps/BR241818).\n\nTo conserve power and battery life, you should call [**DisplayRequest.RequestRelease**](https://msdn.microsoft.com/library/windows/apps/BR241819) to release the display request as soon as it is no longer required.\n\nHere are some situations when you should release the display request:\n\n-   Video playback is paused, for example by user action, buffering, or adjustment due to limited bandwidth.\n-   Playback stops. For example, the video is done playing or the presentation is over.\n-   A playback error has occurred. For example, network connectivity issues or a corrupted file.\n\n### Put other elements to the side of embedded video\n\nOften apps offer an embedded view where video is played within a page. Now you obviously lost the full screen optimization because the [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/BR242926) is not the size of the page and there are other XAML objects drawn. Beware of unintentionally entering this mode by drawing a border around a **MediaElement**.\n\nDon’t draw XAML elements on top of video when it’s in embedded mode. If you do, the framework is forced to do a little extra work to compose the scene. Placing transport controls below an embedded media element instead of on top of the video is a good example of optimizing for this situation. In this image, the red bar indicates a set of transport controls (play, pause, stop, etc.).\n\n![MediaElement with overlaying elements](images/videowithoverlay.png)\nDon’t place these controls on top of media that is not full screen. Instead place the transport controls somewhere outside of the area where the media is being rendered. In the next image, the controls are placed below the media.\n\n![MediaElement with neighboring elements](images/videowithneighbors.png)\n\n### Delay setting the source for a MediaElement\n\nMedia engines are expensive objects and the XAML framework delays loading dlls and creating large objects as long as possible. The [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/BR242926) is forced to do this work after its source is set via the [**Source**](https://msdn.microsoft.com/library/windows/apps/BR242926-source) property or the [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR242926-setsource) method. Setting these when the user is really ready to play media delays the majority of the cost associated with the **MediaElement** as long as possible.\n\n### Set MediaElement.PosterSource\n\nSetting [**MediaElement.PosterSource**](https://msdn.microsoft.com/library/windows/apps/BR242926-postersource) enables XAML to release some GPU resources that would have otherwise been used. This API allows an app to use as little memory as possible.\n\n### Improve media scrubbing\n\nScrubbing is always a tough task for media platforms to make really responsive. Generally people accomplish this by changing the value of a Slider. Here are a couple tips on how to make this as efficient as possible:\n\n-   Either bind the value of a [**Slider**](https://msdn.microsoft.com/library/windows/apps/BR209614) to [**MediaElement.Position**](https://msdn.microsoft.com/library/windows/apps/BR242926-position) or update it based on a timer. Don't do both. If you choose the latter, make sure to use a reasonable update frequency for your timer. The XAML framework only updates **MediaElement.Position** only every 250 milliseconds during playback.\n-   The size of the step frequency on the Slider must scale with the length of the video.\n-   Subscribe to the [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerpressed), [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/BR208911-pointermoved), [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerreleased) events on the slider to set the [**MediaElement.PlaybackRate**](https://msdn.microsoft.com/library/windows/apps/BR242926-playbackrate) property to 0 when the user drags the thumb of the slider.\n-   In the [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerreleased) event handler, manually set the media position to the slider position value to achieve optimal thumb snapping while scrubbing.\n\n### Match video resolution to device resolution\n\nDecoding video takes a lot of memory and GPU cycles, so choose a video format close to the resolution it will be displayed at. There is no point in using the resources to decode 1080 video if it’s going to get scaled down to a much smaller size. Many apps don’t have the same video encoded at different resolutions; but if it is available, use an encoding that is close to the resolution at which it will be displayed.\n\n### Choose recommended formats\n\nMedia format selection can be a sensitive topic and is often driven by business decisions. From a UWP performance perspective, we recommend H.264 video as the primary video format and AAC and MP3 as the preferred audio formats. For local file playback, MP4 is the preferred file container for video content. H.264 decoding is accelerated through most recent graphics hardware. Also, although hardware acceleration for VC-1 decoding is broadly available, for a large set of graphics hardware on the market, the acceleration is limited in many cases to a partial acceleration level (or IDCT level), rather than a full-steam level hardware offload (i.e. VLD mode).\n\nIf you have full control of the video content generation process, you must figure out how to keep a good balance between compression efficiency and GOP structure. Relatively smaller GOP size with B pictures can increase the performance in seeking or trick modes.\n\nWhen including short, low-latency audio effects, for example in games, use WAV files with uncompressed PCM data to reduce processing overhead that is typical for compressed audio formats.\n\n### Hardware audio offloading\n\nFor hardware audio offload to be automatically applied, [**MediaElement.AudioCategory**](https://msdn.microsoft.com/library/windows/apps/BR242926-audiocategory) must be set to **ForegroundOnlyMedia** or **BackgroundCapableMedia**. Hardware audio offload optimizes audio rendering which can improve functionality and battery life.\n\n## Optimize image resources\n\n### Scale images to the appropriate size\n\nImages are captured at very high resolutions, which can lead to apps using more CPU when decoding the image data and more memory after it’s loaded from disk. But there’s no sense decoding and saving a high-resolution image in memory only to display it smaller than its native size. Instead, create a version of the image at the exact size it will be drawn on-screen using the [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) properties.\n\nDon't do this:\n\n```xml\n<Image Source=\"ms-appx:///Assets/highresCar.jpg\" \n       Width=\"300\" Height=\"200\"/>    <!-- BAD CODE DO NOT USE.-->\n```\n\nInstead, do this:\n\n```xml\n<Image>\n    <Image.Source>\n    <BitmapImage UriSource=\"ms-appx:///Assets/highresCar.jpg\" \n                 DecodePixelWidth=\"300\" DecodePixelHeight=\"200\"/>\n    </Image.Source>\n</Image>\n```\n\nThe units for [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) are by default physical pixels. The [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) property can be used to change this behavior: setting **DecodePixelType** to **Logical** results in the decode size automatically accounting for the system’s current scale factor, similar to other XAML content. It would therefore be generally appropriate to set **DecodePixelType** to **Logical** if, for instance, you want **DecodePixelWidth** and **DecodePixelHeight** to match the Height and Width properties of the Image control the image will be displayed in. With the default behavior of using physical pixels, you must account for the system’s current scale factor yourself; and you should listen for scale change notifications in case the user changes their display preferences.\n\nIf DecodePixelWidth/Height are explicitly set larger than the image will be displayed on-screen then the app will unnecessarily use extra memory—up to 4 bytes per pixel—which quickly becomes expensive for large images. The image will also be scaled down using bilinear scaling which could cause it to appear blurry for large scale factors.\n\nIf DecodePixelWidth/DecodePixelHeight are explicitly set smaller than the image will be displayed on screen then it will be scaled up and could appear pixelated.\n\nIn some cases where an appropriate decode size cannot be determined ahead of time, you should defer to XAML’s automatic right-size-decoding which will make a best effort attempt to decode the image at the appropriate size if an explicit DecodePixelWidth/DecodePixelHeight is not specified.\n\nYou should set an explicit decode size if you know the size of the image content ahead of time. You should also in conjunction set [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) to **Logical** if the supplied decode size is relative to other XAML element sizes. For example, if you explicitly set the content size with Image.Width and Image.Height, you could set DecodePixelType to DecodePixelType.Logical to use the same logical pixel dimensions as an Image control and then explicitly use BitmapImage.DecodePixelWidth and/or BitmapImage.DecodePixelHeight to control the size of the image to achieve potentially large memory savings.\n\nNote that Image.Stretch should be considered when determining the size of the decoded content.\n\n### Right-sized decoding\n\nIn the event that you don't set an explicit decode size, XAML will make a best effort attempt to save memory by decoding an image to the exact size it will appear on-screen according to the containing page’s initial layout. You're advised to write your application in such a way as to make use of this feature when possible. This feature will be disabled if any of the following conditions are met.\n\n-   The [**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235) is connected to the live XAML tree after setting the content with [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) or [**UriSource**](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource).\n-   The image is decoded using synchronous decoding such as [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255).\n-   The image is hidden via setting [**Opacity**](https://msdn.microsoft.com/library/windows/apps/BR208962) to 0 or [**Visibility**](https://msdn.microsoft.com/library/windows/apps/BR208911-visibility) to **Collapsed** on the host image element or brush or any parent element.\n-   The image control or brush uses a [**Stretch**](https://msdn.microsoft.com/library/windows/apps/BR242968) of **None**.\n-   The image is used as a [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756).\n-   `CacheMode=\"BitmapCache\"` is set on the image element or on any parent element.\n-   The image brush is non-rectangular (such as when applied to a shape or to text).\n\nIn the above scenarios, setting an explicit decode size is the only way to achieve memory savings.\n\nYou should always attach a [**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235) to the live tree before setting the source. Any time an image element or brush is specified in markup, this will automatically be the case. Examples are provided below under the heading \"Live tree examples\". You should always avoid using [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255) and instead use [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) when setting a stream source. And it's a good idea to avoid hiding image content (either with zero opacity or with collapsed visibility) while waiting for the [**ImageOpened**](https://msdn.microsoft.com/library/windows/apps/BR243235-imageopened) event to be raised. Doing this is a judgment call: you won't benefit from automatic right-sized decoding if it's done. If your app must hide image content initially then it should also set the decode size explicitly if possible.\n\n**Live tree examples**\n\nExample 1 (good)—Uniform Resource Identifier (URI) specified in markup.\n\n```xml\n<Image x:Name=\"myImage\" UriSource=\"Assets/cool-image.png\"/>\n```\n\nExample 2 markup—URI specified in code-behind.\n\n```xml\n<Image x:Name=\"myImage\"/>\n```\n\nExample 2 code-behind (good)—connecting the BitmapImage to the tree before setting its UriSource.\n\n```vbnet\nvar bitmapImage = new BitmapImage();\nmyImage.Source = bitmapImage;\nbitmapImage.UriSource = new URI(\"ms-appx:///Assets/cool-image.png\", UriKind.RelativeOrAbsolute);\n```\n\nExample 2 code-behind (bad)—setting the the BitmapImage's UriSource before connecting it to the tree.\n\n```vbnet\nvar bitmapImage = new BitmapImage();\nbitmapImage.UriSource = new URI(\"ms-appx:///Assets/cool-image.png\", UriKind.RelativeOrAbsolute);\nmyImage.Source = bitmapImage;\n```\n\n### Caching optimizations\n\nCaching optimizations are in effect for images that use [**UriSource**](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource) to load content from an app package or from the web. The URI is used to uniquely identify the underlying content, and internally the XAML framework will not download or decode the content multiple times. Instead, it will use the cached software or hardware resources to display the content multiple times.\n\nThe exception to this optimization is if the image is displayed multiple times at different resolutions (which can be specified explicitly or through automatic right-sized decoding). Each cache entry also stores the resolution of the image, and if XAML cannot find an image with a source URI that matches the required resolution then it will decode a new version at that size. It will not, however, download the encoded image data again.\n\nConsequently, you should embrace using [**UriSource**](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource) when loading images from an app package, and avoid using a file stream and [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) when it's not required.\n\n### Images in virtualized panels (ListView, for instance)\n\nIf an image is removed from the tree—because the app explicitly removed it, or because it’s in a modern virtualized panel and was implicitly removed when scrolled out of view—then XAML will optimize memory usage by releasing the hardware resources for the image since they are no longer required. The memory is not released immediately, but rather is released during the frame update that occurs after one second of the image element no longer being in the tree.\n\nConsequently, you should strive to use modern virtualized panels to host lists of image content.\n\n### Software-rasterized images\n\nWhen an image is used for a non-rectangular brush or for a [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756), the image will use a software rasterization path, which will not scale images at all. Additionally, it must store a copy of the image in both software and hardware memory. For instance, if an image is used as a brush for an ellipse then the potentially large full image will be stored twice internally. When using **NineGrid** or a non-rectangular brush, then, your app should pre-scale its images to approximately the size they will be rendered at.\n\n### Background thread image-loading\n\nXAML has an internal optimization that allows it to decode the contents of an image asynchronously to a surface in hardware memory without requiring an intermediate surface in software memory. This reduces peak memory usage and rendering latency. This feature will be disabled if any of the following conditions are met.\n\n-   The image is used as a [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756).\n-   `CacheMode=\"BitmapCache\"` is set on the image element or on any parent element.\n-   The image brush is non-rectangular (such as when applied to a shape or to text).\n\n### SoftwareBitmapSource\n\nThe [**SoftwareBitmapSource**](https://msdn.microsoft.com/library/windows/apps/Dn997854) class exchanges interoperable uncompressed images between different WinRT namespaces such as [**BitmapDecoder**](https://msdn.microsoft.com/library/windows/apps/BR226176), camera APIs, and XAML. This class obviates an extra copy that would typically be necessary with [**WriteableBitmap**](https://msdn.microsoft.com/library/windows/apps/BR243259), and that helps reduce peak memory and source-to-screen latency.\n\nThe [**SoftwareBitmap**](https://msdn.microsoft.com/library/windows/apps/Dn887358) that supplies source information can also be configured to use a custom [**IWICBitmap**](https://msdn.microsoft.com/library/windows/desktop/Ee719675) to provide a reloadable backing store that allows the app to re-map memory as it sees fit. This is an advanced C++ use case.\n\nYour app should use [**SoftwareBitmap**](https://msdn.microsoft.com/library/windows/apps/Dn887358) and [**SoftwareBitmapSource**](https://msdn.microsoft.com/library/windows/apps/Dn997854) to interoperate with other WinRT APIs that produce and consume images. And your app should use **SoftwareBitmapSource** when loading uncompressed image data instead of using [**WriteableBitmap**](https://msdn.microsoft.com/library/windows/apps/BR243259).\n\n### <span id=\"use-getthumbnailasync-for-thumbnails\"></span><span id=\"USE-GETTHUMBNAILASYNC-FOR-THUMBNAILS\"></span>Use GetThumbnailAsync for thumbnails\n\nOne use case for scaling images is creating thumbnails. Although you could use [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) to provide small versions of images, UWP provides even more efficient APIs for retrieving thumbnails. [**GetThumbnailAsync**](https://msdn.microsoft.com/library/windows/apps/BR227210) provides the thumbnails for images that have the file system already cached. This provides even better performance than the XAML APIs because the image doesn’t need to be opened or decoded.\n\n> [!div class=\"tabbedCodeSnippets\"]\n```csharp\nFileOpenPicker picker = new FileOpenPicker();\npicker.FileTypeFilter.Add(\".bmp\");\npicker.FileTypeFilter.Add(\".jpg\");\npicker.FileTypeFilter.Add(\".jpeg\");\npicker.FileTypeFilter.Add(\".png\");\npicker.SuggestedStartLocation = PickerLocationId.PicturesLibrary;\n\nStorageFile file = await picker.PickSingleFileAsync();\n\nStorageItemThumbnail fileThumbnail = await file.GetThumbnailAsync(ThumbnailMode.SingleItem, 64);\n\nBitmapImage bmp = new BitmapImage();\nbmp.SetSource(fileThumbnail);\n\nImage img = new Image();\nimg.Source = bmp;\n```\n```vbnet\nDim picker As New FileOpenPicker()\npicker.FileTypeFilter.Add(\".bmp\")\npicker.FileTypeFilter.Add(\".jpg\")\npicker.FileTypeFilter.Add(\".jpeg\")\npicker.FileTypeFilter.Add(\".png\")\npicker.SuggestedStartLocation = PickerLocationId.PicturesLibrary\n\nDim file As StorageFile = Await picker.PickSingleFileAsync()\n\nDim fileThumbnail As StorageItemThumbnail = Await file.GetThumbnailAsync(ThumbnailMode.SingleItem, 64)\n\nDim bmp As New BitmapImage()\nbmp.SetSource(fileThumbnail)\n\nDim img As New Image()\nimg.Source = bmp\n```\n\n### Decode images once\n\nTo prevent images from being decoded more than once, assign the [**Image.Source**](https://msdn.microsoft.com/library/windows/apps/BR242760) property from an Uri rather than using memory streams. The XAML framework can associate the same Uri in multiple places with one decoded image, but it cannot do the same for multiple memory streams that contain the same data and creates a different decoded image for each memory stream.\n"}