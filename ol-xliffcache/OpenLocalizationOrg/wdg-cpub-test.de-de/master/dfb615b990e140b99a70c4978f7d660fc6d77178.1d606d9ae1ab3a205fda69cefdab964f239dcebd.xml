{"nodes":[{"pos":[66,260],"content":"This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the task class defined in the concurrency namespace in ppltasks.h.","needQuote":true,"needEscape":true,"nodes":[{"content":"This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the task class defined in the concurrency namespace in ppltasks.h.","pos":[0,194]}]},{"pos":[268,299],"content":"Asynchronous programming in C++","needQuote":true,"needEscape":true,"nodes":[{"content":"Asynchronous programming in C++","pos":[0,31]}]},{"content":"Asynchronous programming in C++","pos":[307,338]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[340,378]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[379,474],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"** Important APIs **","pos":[476,496]},{"content":"[task class]","pos":[502,514]},{"pos":[519,568],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>concurrency namespace<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">concurrencyNamespace]</ept>","source":"[**concurrency namespace**][concurrencyNamespace]"},{"pos":[573,611],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IAsyncOperation<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">IAsyncOperation]</ept>","source":"[**IAsyncOperation**][IAsyncOperation]"},{"pos":[613,818],"content":"This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the <ph id=\"ph1\">`task`</ph> class that's defined in the <ph id=\"ph2\">`concurrency`</ph> namespace in ppltasks.h.","source":"This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the `task` class that's defined in the `concurrency` namespace in ppltasks.h."},{"content":"Universal Windows Platform (UWP) asynchronous types","pos":[823,874]},{"content":"The Universal Windows Platform (UWP) features a well-defined model for calling asynchronous methods and provides the types that you need to consume such methods.","pos":[876,1037]},{"content":"If you are not familiar with the UWP asynchronous model, read <bpt id=\"p1\">[</bpt>Asynchronous Programming<ept id=\"p1\">]</ept><bpt id=\"p2\">[</bpt><ept id=\"p2\">AsyncProgramming]</ept> before you read the rest of this article.","pos":[1038,1186],"source":" If you are not familiar with the UWP asynchronous model, read [Asynchronous Programming][AsyncProgramming] before you read the rest of this article."},{"content":"Although you can consume the asynchronous UWP APIs directly in C++, the preferred approach is to use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task class<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">task-class]</ept> and its related types and functions, which are contained in the <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>concurrency<ept id=\"p5\">**</ept><ept id=\"p4\">]</ept><bpt id=\"p6\">[</bpt><ept id=\"p6\">concurrencyNamespace]</ept> namespace and defined in <ph id=\"ph1\">`&lt;ppltasks.h&gt;`</ph>.","pos":[1188,1466],"source":"Although you can consume the asynchronous UWP APIs directly in C++, the preferred approach is to use the [**task class**][task-class] and its related types and functions, which are contained in the [**concurrency**][concurrencyNamespace] namespace and defined in `<ppltasks.h>`."},{"content":"The <bpt id=\"p1\">**</bpt>concurrency::task<ept id=\"p1\">**</ept> is a general-purpose type, but when the <bpt id=\"p2\">**</bpt>/ZW<ept id=\"p2\">**</ept> compiler switch—which is required for Universal Windows Platform (UWP) apps and components—is used, the task class encapsulates the UWP asynchronous types so that it's easier to:","pos":[1467,1719],"source":" The **concurrency::task** is a general-purpose type, but when the **/ZW** compiler switch—which is required for Universal Windows Platform (UWP) apps and components—is used, the task class encapsulates the UWP asynchronous types so that it's easier to:"},{"content":"chain multiple asynchronous and synchronous operations together","pos":[1725,1788]},{"content":"handle exceptions in task chains","pos":[1794,1826]},{"content":"perform cancellation in task chains","pos":[1832,1867]},{"content":"ensure that individual tasks run in the appropriate thread context or apartment","pos":[1873,1952]},{"content":"This article provides basic guidance about how to use the <bpt id=\"p1\">**</bpt>task<ept id=\"p1\">**</ept> class with the UWP asynchronous APIs.","pos":[1954,2058],"source":"This article provides basic guidance about how to use the **task** class with the UWP asynchronous APIs."},{"content":"For more complete documentation about <bpt id=\"p1\">**</bpt>task<ept id=\"p1\">**</ept> and its related methods including <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>create\\_task<ept id=\"p3\">**</ept><ept id=\"p2\">]</ept><bpt id=\"p4\">[</bpt><ept id=\"p4\">createTask]</ept>, see <bpt id=\"p5\">[</bpt>Task Parallelism (Concurrency Runtime)<ept id=\"p5\">]</ept><bpt id=\"p6\">[</bpt><ept id=\"p6\">taskParallelism]</ept>.","pos":[2059,2234],"source":" For more complete documentation about **task** and its related methods including [**create\\_task**][createTask], see [Task Parallelism (Concurrency Runtime)][taskParallelism]."},{"content":"For more information about how to create asynchronous public methods for consumption by JavaScript or other UWP-compatible languages, see <bpt id=\"p1\">[</bpt>Creating Asynchronous Operations in C++ for Windows Runtime apps<ept id=\"p1\">]</ept><bpt id=\"p2\">[</bpt><ept id=\"p2\">createAsyncCpp]</ept>.","pos":[2235,2456],"source":" For more information about how to create asynchronous public methods for consumption by JavaScript or other UWP-compatible languages, see [Creating Asynchronous Operations in C++ for Windows Runtime apps][createAsyncCpp]."},{"content":"Consuming an async operation by using a task","pos":[2461,2505]},{"content":"The following example shows how to use the task class to consume an <bpt id=\"p1\">**</bpt>async<ept id=\"p1\">**</ept> method that returns an <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>IAsyncOperation<ept id=\"p3\">**</ept><ept id=\"p2\">]</ept><bpt id=\"p4\">[</bpt><ept id=\"p4\">IAsyncOperation]</ept> interface and whose operation produces a value.","pos":[2507,2694],"source":"The following example shows how to use the task class to consume an **async** method that returns an [**IAsyncOperation**][IAsyncOperation] interface and whose operation produces a value."},{"content":"Here are the basic steps:","pos":[2695,2720]},{"pos":[2726,2800],"content":"Call the <ph id=\"ph1\">`create_task`</ph> method and pass it the <bpt id=\"p1\">**</bpt>IAsyncOperation^<ept id=\"p1\">**</ept> object.","source":"Call the `create_task` method and pass it the **IAsyncOperation^** object."},{"pos":[2806,2953],"content":"Call the member function <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task::then<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">taskThen]</ept> on the task and supply a lambda that will be invoked when the asynchronous operation completes.","source":"Call the member function [**task::then**][taskThen] on the task and supply a lambda that will be invoked when the asynchronous operation completes."},{"content":"The task that's created and returned by the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task::then<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">taskThen]</ept> function is known as a <bpt id=\"p4\">*</bpt>continuation<ept id=\"p4\">*</ept>.","pos":[3957,4066],"source":"The task that's created and returned by the [**task::then**][taskThen] function is known as a *continuation*."},{"content":"The input argument (in this case) to the user-provided lambda is the result that the task operation produces when it completes.","pos":[4067,4194]},{"content":"It's the same value that would be retrieved by calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IAsyncOperation::GetResults<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br206600)</ept> if you were using the <bpt id=\"p3\">**</bpt>IAsyncOperation<ept id=\"p3\">**</ept> interface directly.","pos":[4195,4403],"source":" It's the same value that would be retrieved by calling [**IAsyncOperation::GetResults**](https://msdn.microsoft.com/library/windows/apps/br206600) if you were using the **IAsyncOperation** interface directly."},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task::then<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">taskThen]</ept> method returns immediately, and its delegate doesn't run until the asynchronous work completes successfully.","pos":[4405,4544],"source":"The [**task::then**][taskThen] method returns immediately, and its delegate doesn't run until the asynchronous work completes successfully."},{"content":"In this example, if the asynchronous operation causes an exception to be thrown, or ends in the canceled state as a result of a cancellation request, the continuation will never execute.","pos":[4545,4731]},{"content":"Later, we’ll describe how to write continuations that execute even if the previous task was cancelled or failed.","pos":[4732,4844]},{"content":"Although you declare the task variable on the local stack, it manages its lifetime so that it is not deleted until all of its operations complete and all references to it go out of scope, even if the method returns before the operations complete.","pos":[4846,5092]},{"content":"Creating a chain of tasks","pos":[5097,5122]},{"content":"In asynchronous programming, it's common to define a sequence of operations, also known as <bpt id=\"p1\">*</bpt>task chains<ept id=\"p1\">*</ept>, in which each continuation executes only when the previous one completes.","pos":[5124,5303],"source":"In asynchronous programming, it's common to define a sequence of operations, also known as *task chains*, in which each continuation executes only when the previous one completes."},{"content":"In some cases, the previous (or <bpt id=\"p1\">*</bpt>antecedent<ept id=\"p1\">*</ept>) task produces a value that the continuation accepts as input.","pos":[5304,5411],"source":" In some cases, the previous (or *antecedent*) task produces a value that the continuation accepts as input."},{"content":"By using the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task::then<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">taskThen]</ept> method, you can create task chains in an intuitive and straightforward manner; the method returns a <bpt id=\"p4\">**</bpt>task<ph id=\"ph1\">&lt;T&gt;</ph><ept id=\"p4\">**</ept> where <bpt id=\"p5\">**</bpt>T<ept id=\"p5\">**</ept> is the return type of the lambda function.","pos":[5412,5618],"source":" By using the [**task::then**][taskThen] method, you can create task chains in an intuitive and straightforward manner; the method returns a **task<T>** where **T** is the return type of the lambda function."},{"content":"You can compose multiple continuations into a task chain:","pos":[5619,5676]},{"content":"Task chains are especially useful when a continuation creates a new asynchronous operation; such a task is known as an asynchronous task.","pos":[5712,5849]},{"content":"The following example illustrates a task chain that has two continuations.","pos":[5850,5924]},{"content":"The initial task acquires the handle to an existing file, and when that operation completes, the first continuation starts up a new asynchronous operation to delete the file.","pos":[5925,6099]},{"content":"When that operation completes, the second continuation runs, and outputs a confirmation message.","pos":[6100,6196]},{"content":"The previous example illustrates four important points:","pos":[6708,6763]},{"pos":[6769,6891],"content":"The first continuation converts the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IAsyncAction^<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">IAsyncAction]</ept> object to a <bpt id=\"p4\">**</bpt>task<ph id=\"ph1\">&lt;void&gt;</ph><ept id=\"p4\">**</ept> and returns the <bpt id=\"p5\">**</bpt>task<ept id=\"p5\">**</ept>.","source":"The first continuation converts the [**IAsyncAction^**][IAsyncAction] object to a **task<void>** and returns the **task**."},{"content":"The second continuation performs no error handling, and therefore takes <bpt id=\"p1\">**</bpt>void<ept id=\"p1\">**</ept> and not <bpt id=\"p2\">**</bpt>task<ph id=\"ph1\">&lt;void&gt;</ph><ept id=\"p2\">**</ept> as input.","pos":[6897,7010],"source":"The second continuation performs no error handling, and therefore takes **void** and not **task<void>** as input."},{"content":"It is a value-based continuation.","pos":[7011,7044]},{"pos":[7050,7151],"content":"The second continuation doesn't execute until the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DeleteAsync<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">deleteAsync]</ept> operation completes.","source":"The second continuation doesn't execute until the [**DeleteAsync**][deleteAsync] operation completes."},{"pos":[7157,7353],"content":"Because the second continuation is value-based, if the operation that was started by the call to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DeleteAsync<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">deleteAsync]</ept> throws an exception, the second continuation doesn't execute at all.","source":"Because the second continuation is value-based, if the operation that was started by the call to [**DeleteAsync**][deleteAsync] throws an exception, the second continuation doesn't execute at all."},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  Creating a task chain is just one of the ways to use the <bpt id=\"p2\">**</bpt>task<ept id=\"p2\">**</ept> class to compose asynchronous operations.","pos":[7355,7472],"source":"**Note**  Creating a task chain is just one of the ways to use the **task** class to compose asynchronous operations."},{"content":"You can also compose operations by using join and choice operators <bpt id=\"p1\">**</bpt><ph id=\"ph1\">&amp;&amp;</ph><ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt><ph id=\"ph2\">||</ph><ept id=\"p2\">**</ept>.","pos":[7473,7558],"source":" You can also compose operations by using join and choice operators **&&** and **||**."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Task Parallelism (Concurrency Runtime)<ept id=\"p1\">]</ept><bpt id=\"p2\">[</bpt><ept id=\"p2\">taskParallelism]</ept>.","pos":[7559,7643],"source":" For more information, see [Task Parallelism (Concurrency Runtime)][taskParallelism]."},{"content":"Lambda function return types and task return types","pos":[7648,7698]},{"content":"In a task continuation, the return type of the lambda function is wrapped in a <bpt id=\"p1\">**</bpt>task<ept id=\"p1\">**</ept> object.","pos":[7700,7795],"source":"In a task continuation, the return type of the lambda function is wrapped in a **task** object."},{"content":"If the lambda returns a <bpt id=\"p1\">**</bpt>double<ept id=\"p1\">**</ept>, then the type of the continuation task is <bpt id=\"p2\">**</bpt>task<ph id=\"ph1\">&lt;double&gt;</ph><ept id=\"p2\">**</ept>.","pos":[7796,7891],"source":" If the lambda returns a **double**, then the type of the continuation task is **task<double>**."},{"content":"However, the task object is designed so that it doesn't produce needlessly nested return types.","pos":[7892,7987]},{"content":"If a lambda returns an <bpt id=\"p1\">**</bpt>IAsyncOperation&lt;SyndicationFeed^&gt;^<ept id=\"p1\">**</ept>, the continuation returns a <bpt id=\"p2\">**</bpt>task&lt;SyndicationFeed^&gt;<ept id=\"p2\">**</ept>, not a <bpt id=\"p3\">**</bpt>task&lt;task&lt;SyndicationFeed^&gt;&gt;<ept id=\"p3\">**</ept> or <bpt id=\"p4\">**</bpt>task&lt;IAsyncOperation&lt;SyndicationFeed^&gt;^&gt;^<ept id=\"p4\">**</ept>.","pos":[7988,8194],"source":" If a lambda returns an **IAsyncOperation<SyndicationFeed^>^**, the continuation returns a **task<SyndicationFeed^>**, not a **task<task<SyndicationFeed^>>** or **task<IAsyncOperation<SyndicationFeed^>^>^**."},{"content":"This process is known as <bpt id=\"p1\">*</bpt>asynchronous unwrapping<ept id=\"p1\">*</ept> and it also ensures that the asynchronous operation inside the continuation completes before the next continuation is invoked.","pos":[8195,8372],"source":" This process is known as *asynchronous unwrapping* and it also ensures that the asynchronous operation inside the continuation completes before the next continuation is invoked."},{"content":"In the previous example, notice that the task returns a <bpt id=\"p1\">**</bpt>task<ph id=\"ph1\">&lt;void&gt;</ph><ept id=\"p1\">**</ept> even though its lambda returned an <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>IAsyncInfo<ept id=\"p3\">**</ept><ept id=\"p2\">]</ept><bpt id=\"p4\">[</bpt><ept id=\"p4\">IAsyncInfo]</ept> object.","pos":[8374,8516],"source":"In the previous example, notice that the task returns a **task<void>** even though its lambda returned an [**IAsyncInfo**][IAsyncInfo] object."},{"content":"The following table summarizes the type conversions that occur between a lambda function and the enclosing task:","pos":[8517,8629]},{"content":"lambda return type","pos":[8720,8738]},{"pos":[8785,8796],"content":"return type"},{"content":"TResult","pos":[8801,8808]},{"pos":[8858,8862],"content":"task"},{"pos":[8876,8891],"content":"IAsyncOperation"},{"pos":[8927,8931],"content":"task"},{"content":"IAsyncOperationWithProgress&lt;TResult, TProgress&gt;^","pos":[8945,8993],"source":"IAsyncOperationWithProgress<TResult, TProgress>^"},{"pos":[8996,9000],"content":"task"},{"content":"IAsyncAction^","pos":[9013,9026]},{"pos":[9071,9075],"content":"task"},{"pos":[9089,9113],"content":"IAsyncActionWithProgress"},{"pos":[9139,9143],"content":"task"},{"pos":[9158,9162],"content":"task"},{"pos":[9208,9212],"content":"task"},{"content":"Canceling tasks","pos":[9230,9245]},{"content":"It is often a good idea to give the user the option to cancel an asynchronous operation.","pos":[9247,9335]},{"content":"And in some cases you might have to cancel an operation programmatically from outside the task chain.","pos":[9336,9437]},{"content":"Although each \\*<bpt id=\"p1\">**</bpt>Async<ept id=\"p1\">**</ept> return type has a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Cancel<ept id=\"p3\">**</ept><ept id=\"p2\">]</ept><bpt id=\"p4\">[</bpt><ept id=\"p4\">IAsyncInfoCancel]</ept> method that it inherits from <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>IAsyncInfo<ept id=\"p6\">**</ept><ept id=\"p5\">]</ept><bpt id=\"p7\">[</bpt><ept id=\"p7\">IAsyncInfo]</ept>, it's awkward to expose it to outside methods.","pos":[9438,9617],"source":" Although each \\***Async** return type has a [**Cancel**][IAsyncInfoCancel] method that it inherits from [**IAsyncInfo**][IAsyncInfo], it's awkward to expose it to outside methods."},{"content":"The preferred way to support cancellation in a task chain is to use a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>cancellation\\_token\\_source<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749985.aspx)</ept> to create a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>cancellation\\_token<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749975.aspx)</ept>, and then pass the token to the constructor of the initial task.","pos":[9618,9972],"source":" The preferred way to support cancellation in a task chain is to use a [**cancellation\\_token\\_source**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749985.aspx) to create a [**cancellation\\_token**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749975.aspx), and then pass the token to the constructor of the initial task."},{"content":"If an asynchronous task is created with a cancellation token, and <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>cancellation\\_token\\_source::cancel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750076.aspx)</ept> is called, the task automatically calls <bpt id=\"p3\">**</bpt>Cancel<ept id=\"p3\">**</ept> on the <bpt id=\"p4\">**</bpt>IAsync\\*<ept id=\"p4\">**</ept> operation and passes the cancellation request down its continuation chain.","pos":[9973,10300],"source":" If an asynchronous task is created with a cancellation token, and [**cancellation\\_token\\_source::cancel**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750076.aspx) is called, the task automatically calls **Cancel** on the **IAsync\\*** operation and passes the cancellation request down its continuation chain."},{"content":"The following pseudocode demonstrates the basic approach.","pos":[10301,10358]},{"content":"When a task is canceled, a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task\\_canceled<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">taskCanceled]</ept> exception is propagated down the task chain.","pos":[10684,10790],"source":"When a task is canceled, a [**task\\_canceled**][taskCanceled] exception is propagated down the task chain."},{"content":"Value-based continuations will simply not execute, but task-based continuations will cause the exception to be thrown when <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task::get<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">taskGet]</ept> is called.","pos":[10791,10949],"source":" Value-based continuations will simply not execute, but task-based continuations will cause the exception to be thrown when [**task::get**][taskGet] is called."},{"content":"If you have an error-handling continuation, make sure that it catches the <bpt id=\"p1\">**</bpt>task\\_canceled<ept id=\"p1\">**</ept> exception explicitly.","pos":[10950,11064],"source":" If you have an error-handling continuation, make sure that it catches the **task\\_canceled** exception explicitly."},{"content":"(This exception is not derived from <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Platform::Exception<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh755825.aspx)</ept>.)","pos":[11065,11202],"source":" (This exception is not derived from [**Platform::Exception**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh755825.aspx).)"},{"content":"Cancellation is cooperative.","pos":[11204,11232]},{"content":"If your continuation does some long-running work beyond just invoking a UWP method, then it is your responsibility to check the state of the cancellation token periodically and stop execution if it is canceled.","pos":[11233,11443]},{"content":"After you clean up all resources that were allocated in the continuation, call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>cancel\\_current\\_task<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749945.aspx)</ept> to cancel that task and propagate the cancellation down to any value-based continuations that follow it.","pos":[11444,11729],"source":" After you clean up all resources that were allocated in the continuation, call [**cancel\\_current\\_task**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749945.aspx) to cancel that task and propagate the cancellation down to any value-based continuations that follow it."},{"content":"Here's another example: you can create a task chain that represents the result of a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FileSavePicker<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR207871)</ept> operation.","pos":[11730,11903],"source":" Here's another example: you can create a task chain that represents the result of a [**FileSavePicker**](https://msdn.microsoft.com/library/windows/apps/BR207871) operation."},{"content":"If the user chooses the <bpt id=\"p1\">**</bpt>Cancel<ept id=\"p1\">**</ept> button, the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>IAsyncInfo::Cancel<ept id=\"p3\">**</ept><ept id=\"p2\">]</ept><bpt id=\"p4\">[</bpt><ept id=\"p4\">IAsyncInfoCancel]</ept> method is not called.","pos":[11904,12015],"source":" If the user chooses the **Cancel** button, the [**IAsyncInfo::Cancel**][IAsyncInfoCancel] method is not called."},{"content":"Instead, the operation succeeds but returns <bpt id=\"p1\">**</bpt>nullptr<ept id=\"p1\">**</ept>.","pos":[12016,12072],"source":" Instead, the operation succeeds but returns **nullptr**."},{"content":"The continuation can test the input parameter and call <bpt id=\"p1\">**</bpt>cancel\\_current\\_task<ept id=\"p1\">**</ept> if the input is <bpt id=\"p2\">**</bpt>nullptr<ept id=\"p2\">**</ept>.","pos":[12073,12182],"source":" The continuation can test the input parameter and call **cancel\\_current\\_task** if the input is **nullptr**."},{"pos":[12184,12309],"content":"For more information, see <bpt id=\"p1\">[</bpt>Cancellation in the PPL<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/dd984117.aspx)</ept>","source":"For more information, see [Cancellation in the PPL](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/dd984117.aspx)"},{"content":"Handling errors in a task chain","pos":[12314,12345]},{"pos":[12347,12667],"content":"If you want a continuation to execute even if the antecedent was canceled or threw an exception, then make the continuation a task-based continuation by specifying the input to its lambda function as a <bpt id=\"p1\">**</bpt>task<ph id=\"ph1\">&lt;TResult&gt;</ph><ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>task<ph id=\"ph2\">&lt;void&gt;</ph><ept id=\"p2\">**</ept> if the lambda of the antecedent task returns an <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>IAsyncAction^<ept id=\"p4\">**</ept><ept id=\"p3\">]</ept><bpt id=\"p5\">[</bpt><ept id=\"p5\">IAsyncAction]</ept>.","source":"If you want a continuation to execute even if the antecedent was canceled or threw an exception, then make the continuation a task-based continuation by specifying the input to its lambda function as a **task<TResult>** or **task<void>** if the lambda of the antecedent task returns an [**IAsyncAction^**][IAsyncAction]."},{"content":"To handle errors and cancellation in a task chain, you don't have to make every continuation task-based or enclose every operation that might throw within a <ph id=\"ph1\">`try…catch`</ph> block.","pos":[12669,12844],"source":"To handle errors and cancellation in a task chain, you don't have to make every continuation task-based or enclose every operation that might throw within a `try…catch` block."},{"content":"Instead, you can add a task-based continuation at the end of the chain and handle all errors there.","pos":[12845,12944]},{"content":"Any exception—this includes a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task\\_canceled<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">taskCanceled]</ept> exception—will propagate down the task chain and bypass any value-based continuations, so that you can handle it in the error-handling task-based continuation.","pos":[12945,13169],"source":" Any exception—this includes a [**task\\_canceled**][taskCanceled] exception—will propagate down the task chain and bypass any value-based continuations, so that you can handle it in the error-handling task-based continuation."},{"content":"We can rewrite the previous example to use an error-handling task-based continuation:","pos":[13170,13255]},{"content":"In a task-based continuation, we call the member function <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task::get<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">taskGet]</ept> to get the results of the task.","pos":[14087,14201],"source":"In a task-based continuation, we call the member function [**task::get**][taskGet] to get the results of the task."},{"content":"We still have to call <bpt id=\"p1\">**</bpt>task::get<ept id=\"p1\">**</ept> even if the operation was an <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>IAsyncAction<ept id=\"p3\">**</ept><ept id=\"p2\">]</ept><bpt id=\"p4\">[</bpt><ept id=\"p4\">IAsyncAction]</ept> that produces no result because <bpt id=\"p5\">**</bpt>task::get<ept id=\"p5\">**</ept> also gets any exceptions that have been transported down to the task.","pos":[14202,14415],"source":" We still have to call **task::get** even if the operation was an [**IAsyncAction**][IAsyncAction] that produces no result because **task::get** also gets any exceptions that have been transported down to the task."},{"content":"If the input task is storing an exception, it is thrown at the call to <bpt id=\"p1\">**</bpt>task::get<ept id=\"p1\">**</ept>.","pos":[14416,14501],"source":" If the input task is storing an exception, it is thrown at the call to **task::get**."},{"content":"If you don't call <bpt id=\"p1\">**</bpt>task::get<ept id=\"p1\">**</ept>, or don't use a task-based continuation at the end of the chain, or don't catch the exception type that was thrown, then an <bpt id=\"p2\">**</bpt>unobserved\\_task\\_exception<ept id=\"p2\">**</ept> is thrown when all references to the task have been deleted.","pos":[14502,14750],"source":" If you don't call **task::get**, or don't use a task-based continuation at the end of the chain, or don't catch the exception type that was thrown, then an **unobserved\\_task\\_exception** is thrown when all references to the task have been deleted."},{"content":"Only catch the exceptions that you can handle.","pos":[14752,14798]},{"content":"If your app encounters an error that you can't recover from, it's better to let the app crash than to let it continue to run in an unknown state.","pos":[14799,14944]},{"content":"Also, in general, don't attempt to catch the <bpt id=\"p1\">**</bpt>unobserved\\_task\\_exception<ept id=\"p1\">**</ept> itself.","pos":[14945,15029],"source":" Also, in general, don't attempt to catch the **unobserved\\_task\\_exception** itself."},{"content":"This exception is mainly intended for diagnostic purposes.","pos":[15030,15088]},{"content":"When <bpt id=\"p1\">**</bpt>unobserved\\_task\\_exception<ept id=\"p1\">**</ept> is thrown, it usually indicates a bug in the code.","pos":[15089,15176],"source":" When **unobserved\\_task\\_exception** is thrown, it usually indicates a bug in the code."},{"content":"Often the cause is either an exception that should be handled, or an unrecoverable exception that's caused by some other error in the code.","pos":[15177,15316]},{"content":"Managing the thread context","pos":[15321,15348]},{"content":"The UI of a UWP app runs in a single-threaded apartment (STA).","pos":[15350,15412]},{"content":"A task whose lambda returns either an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IAsyncAction<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">IAsyncAction]</ept> or <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>IAsyncOperation<ept id=\"p5\">**</ept><ept id=\"p4\">]</ept><bpt id=\"p6\">[</bpt><ept id=\"p6\">IAsyncOperation]</ept> is apartment-aware.","pos":[15413,15545],"source":" A task whose lambda returns either an [**IAsyncAction**][IAsyncAction] or [**IAsyncOperation**][IAsyncOperation] is apartment-aware."},{"content":"If the task is created in the STA, then all of its continuations will run also run in it by default, unless you specify otherwise.","pos":[15546,15676]},{"content":"In other words, the entire task chain inherits apartment-awareness from the parent task.","pos":[15677,15765]},{"content":"This behavior helps simplify interactions with UI controls, which can only be accessed from the STA.","pos":[15766,15866]},{"pos":[15868,16215],"content":"For example, in a UWP app, in the member function of any class that represents a XAML page, you can populate a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ListBox<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242868)</ept> control from within a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>task::then<ept id=\"p4\">**</ept><ept id=\"p3\">]</ept><bpt id=\"p5\">[</bpt><ept id=\"p5\">taskThen]</ept> method without having to use the <bpt id=\"p6\">[</bpt><bpt id=\"p7\">**</bpt>Dispatcher<ept id=\"p7\">**</ept><ept id=\"p6\">](https://msdn.microsoft.com/library/windows/apps/BR208211)</ept> object.","source":"For example, in a UWP app, in the member function of any class that represents a XAML page, you can populate a [**ListBox**](https://msdn.microsoft.com/library/windows/apps/BR242868) control from within a [**task::then**][taskThen] method without having to use the [**Dispatcher**](https://msdn.microsoft.com/library/windows/apps/BR208211) object."},{"pos":[16693,16911],"content":"If a task doesn't return an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IAsyncAction<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">IAsyncAction]</ept> or <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>IAsyncOperation<ept id=\"p5\">**</ept><ept id=\"p4\">]</ept><bpt id=\"p6\">[</bpt><ept id=\"p6\">IAsyncOperation]</ept>, then it's not apartment-aware and, by default, its continuations are run on the first available background thread.","source":"If a task doesn't return an [**IAsyncAction**][IAsyncAction] or [**IAsyncOperation**][IAsyncOperation], then it's not apartment-aware and, by default, its continuations are run on the first available background thread."},{"content":"You can override the default thread context for either kind of task by using the overload of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task::then<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">taskThen]</ept> that takes a <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>task\\_continuation\\_context<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749968.aspx)</ept>.","pos":[16913,17154],"source":"You can override the default thread context for either kind of task by using the overload of [**task::then**][taskThen] that takes a [**task\\_continuation\\_context**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749968.aspx)."},{"content":"For example, in some cases, it might be desirable to schedule the continuation of an apartment-aware task on a background thread.","pos":[17155,17284]},{"content":"In such a case, you can pass <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task\\_continuation\\_context::use\\_arbitrary<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">useArbitrary]</ept> to schedule the task’s work on the next available thread in a multi-threaded apartment.","pos":[17285,17465],"source":" In such a case, you can pass [**task\\_continuation\\_context::use\\_arbitrary**][useArbitrary] to schedule the task’s work on the next available thread in a multi-threaded apartment."},{"content":"This can improve the performance of the continuation because its work doesn't have to be synchronized with other work that's happening on the UI thread.","pos":[17466,17618]},{"content":"The following example demonstrates when it's useful to specify the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task\\_continuation\\_context::use\\_arbitrary<ept id=\"p2\">**</ept><ept id=\"p1\">]</ept><bpt id=\"p3\">[</bpt><ept id=\"p3\">useArbitrary]</ept> option, and it also shows how the default continuation context is useful for synchronizing concurrent operations on non-thread-safe collections.","pos":[17620,17895],"source":"The following example demonstrates when it's useful to specify the [**task\\_continuation\\_context::use\\_arbitrary**][useArbitrary] option, and it also shows how the default continuation context is useful for synchronizing concurrent operations on non-thread-safe collections."},{"content":"In this code, we loop through a list of URLs for RSS feeds, and for each URL, we start up an async operation to retrieve the feed data.","pos":[17896,18031]},{"content":"We can’t control the order in which the feeds are retrieved, and we don't really care.","pos":[18032,18118]},{"content":"When each <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>RetrieveFeedAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR210642)</ept> operation completes, the first continuation accepts the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>SyndicationFeed^<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR243485)</ept> object and uses it to initialize an app-defined <ph id=\"ph1\">`FeedData^`</ph> object.","pos":[18119,18415],"source":" When each [**RetrieveFeedAsync**](https://msdn.microsoft.com/library/windows/apps/BR210642) operation completes, the first continuation accepts the [**SyndicationFeed^**](https://msdn.microsoft.com/library/windows/apps/BR243485) object and uses it to initialize an app-defined `FeedData^` object."},{"content":"Because each of these operations is independent from the others, we can potentially speed things up by specifying the <bpt id=\"p1\">**</bpt>task\\_continuation\\_context::use\\_arbitrary<ept id=\"p1\">**</ept> continuation context.","pos":[18416,18603],"source":" Because each of these operations is independent from the others, we can potentially speed things up by specifying the **task\\_continuation\\_context::use\\_arbitrary** continuation context."},{"content":"However, after each <ph id=\"ph1\">`FeedData`</ph> object is initialized, we have to add it to a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Vector<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh441570.aspx)</ept>, which is not a thread-safe collection.","pos":[18604,18807],"source":" However, after each `FeedData` object is initialized, we have to add it to a [**Vector**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh441570.aspx), which is not a thread-safe collection."},{"content":"Therefore, we create a continuation and specify <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task\\_continuation\\_context::use\\_current<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750085.aspx)</ept> to ensure that all the calls to <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Append<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR206632)</ept> occur in the same Application Single-Threaded Apartment (ASTA) context.","pos":[18808,19152],"source":" Therefore, we create a continuation and specify [**task\\_continuation\\_context::use\\_current**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750085.aspx) to ensure that all the calls to [**Append**](https://msdn.microsoft.com/library/windows/apps/BR206632) occur in the same Application Single-Threaded Apartment (ASTA) context."},{"content":"Because <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task\\_continuation\\_context::use\\_default<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750085.aspx)</ept> is the default context, we don’t have to specify it explicitly, but we do so here for the sake of clarity.","pos":[19153,19389],"source":" Because [**task\\_continuation\\_context::use\\_default**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750085.aspx) is the default context, we don’t have to specify it explicitly, but we do so here for the sake of clarity."},{"content":"Nested tasks, which are new tasks that are created inside a continuation, don't inherit apartment-awareness of the initial task.","pos":[21605,21733]},{"content":"Handing progress updates","pos":[21738,21762]},{"content":"Methods that support <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IAsyncOperationWithProgress<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR206594)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>IAsyncActionWithProgress<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR206580withprogress_1)</ept> provide progress updates periodically while the operation is in progress, before it completes.","pos":[21764,22077],"source":"Methods that support [**IAsyncOperationWithProgress**](https://msdn.microsoft.com/library/windows/apps/BR206594) or [**IAsyncActionWithProgress**](https://msdn.microsoft.com/library/windows/apps/BR206580withprogress_1) provide progress updates periodically while the operation is in progress, before it completes."},{"content":"Progress reporting is independent from the notion of tasks and continuations.","pos":[22078,22155]},{"content":"You just supply the delegate for the object’s <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Progress<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br206594)</ept> property.","pos":[22156,22284],"source":" You just supply the delegate for the object’s [**Progress**](https://msdn.microsoft.com/library/windows/apps/br206594) property."},{"content":"A typical use of the delegate is to update a progress bar in the UI.","pos":[22285,22353]},{"content":"Related topics","pos":[22358,22372]},{"pos":[22376,22456],"content":"<bpt id=\"p1\">[</bpt>Creating Asynchronous Operations in C++ for Windows Store apps<ept id=\"p1\">]</ept><bpt id=\"p2\">[</bpt><ept id=\"p2\">createAsyncCpp]</ept>","source":"[Creating Asynchronous Operations in C++ for Windows Store apps][createAsyncCpp]"},{"content":"Visual C++ Language Reference","pos":[22460,22489]},{"pos":[22555,22599],"content":"<bpt id=\"p1\">[</bpt>Asynchronous Programming<ept id=\"p1\">]</ept><bpt id=\"p2\">[</bpt><ept id=\"p2\">AsyncProgramming]</ept>","source":"[Asynchronous Programming][AsyncProgramming]"},{"pos":[22602,22659],"content":"<bpt id=\"p1\">[</bpt>Task Parallelism (Concurrency Runtime)<ept id=\"p1\">]</ept><bpt id=\"p2\">[</bpt><ept id=\"p2\">taskParallelism]</ept>","source":"[Task Parallelism (Concurrency Runtime)][taskParallelism]"},{"pos":[22662,22686],"content":"<bpt id=\"p1\">[</bpt>task class<ept id=\"p1\">]</ept><bpt id=\"p2\">[</bpt><ept id=\"p2\">task-class]</ept>","source":"[task class][task-class]"}],"content":"---\nms.assetid: 34C00F9F-2196-46A3-A32F-0067AB48291B\ndescription: This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the task class defined in the concurrency namespace in ppltasks.h.\ntitle: Asynchronous programming in C++\n---\n\n# Asynchronous programming in C++\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n** Important APIs **\n\n-   [task class]\n-   [**concurrency namespace**][concurrencyNamespace]\n-   [**IAsyncOperation**][IAsyncOperation]\n\nThis article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the `task` class that's defined in the `concurrency` namespace in ppltasks.h.\n\n## Universal Windows Platform (UWP) asynchronous types\n\nThe Universal Windows Platform (UWP) features a well-defined model for calling asynchronous methods and provides the types that you need to consume such methods. If you are not familiar with the UWP asynchronous model, read [Asynchronous Programming][AsyncProgramming] before you read the rest of this article.\n\nAlthough you can consume the asynchronous UWP APIs directly in C++, the preferred approach is to use the [**task class**][task-class] and its related types and functions, which are contained in the [**concurrency**][concurrencyNamespace] namespace and defined in `<ppltasks.h>`. The **concurrency::task** is a general-purpose type, but when the **/ZW** compiler switch—which is required for Universal Windows Platform (UWP) apps and components—is used, the task class encapsulates the UWP asynchronous types so that it's easier to:\n\n-   chain multiple asynchronous and synchronous operations together\n\n-   handle exceptions in task chains\n\n-   perform cancellation in task chains\n\n-   ensure that individual tasks run in the appropriate thread context or apartment\n\nThis article provides basic guidance about how to use the **task** class with the UWP asynchronous APIs. For more complete documentation about **task** and its related methods including [**create\\_task**][createTask], see [Task Parallelism (Concurrency Runtime)][taskParallelism]. For more information about how to create asynchronous public methods for consumption by JavaScript or other UWP-compatible languages, see [Creating Asynchronous Operations in C++ for Windows Runtime apps][createAsyncCpp].\n\n## Consuming an async operation by using a task\n\nThe following example shows how to use the task class to consume an **async** method that returns an [**IAsyncOperation**][IAsyncOperation] interface and whose operation produces a value. Here are the basic steps:\n\n1.  Call the `create_task` method and pass it the **IAsyncOperation^** object.\n\n2.  Call the member function [**task::then**][taskThen] on the task and supply a lambda that will be invoked when the asynchronous operation completes.\n\n\n``` cpp\n#include <ppltasks.h>\nusing namespace concurrency;\nusing namespace Windows::Devices::Enumeration;\n...\nvoid App::TestAsync()\n{    \n    //Call the *Async method that starts the operation.\n    IAsyncOperation<DeviceInformationCollection^>^ deviceOp =\n        DeviceInformation::FindAllAsync();\n\n    // Explicit construction. (Not recommended)\n    // Pass the IAsyncOperation to a task constructor.\n    // task<DeviceInformationCollection^> deviceEnumTask(deviceOp);\n\n    // Recommended:\n    auto deviceEnumTask = create_task(deviceOp);\n\n    // Call the task’s .then member function, and provide\n    // the lambda to be invoked when the async operation completes.\n    deviceEnumTask.then( [this] (DeviceInformationCollection^ devices ) \n    {       \n        for(int i = 0; i < devices->Size; i++)\n        {\n            DeviceInformation^ di = devices->GetAt(i);\n            // Do something with di...          \n        }       \n    }); // end lambda\n    // Continue doing work or return...\n}\n```\n\nThe task that's created and returned by the [**task::then**][taskThen] function is known as a *continuation*. The input argument (in this case) to the user-provided lambda is the result that the task operation produces when it completes. It's the same value that would be retrieved by calling [**IAsyncOperation::GetResults**](https://msdn.microsoft.com/library/windows/apps/br206600) if you were using the **IAsyncOperation** interface directly.\n\nThe [**task::then**][taskThen] method returns immediately, and its delegate doesn't run until the asynchronous work completes successfully. In this example, if the asynchronous operation causes an exception to be thrown, or ends in the canceled state as a result of a cancellation request, the continuation will never execute. Later, we’ll describe how to write continuations that execute even if the previous task was cancelled or failed.\n\nAlthough you declare the task variable on the local stack, it manages its lifetime so that it is not deleted until all of its operations complete and all references to it go out of scope, even if the method returns before the operations complete.\n\n## Creating a chain of tasks\n\nIn asynchronous programming, it's common to define a sequence of operations, also known as *task chains*, in which each continuation executes only when the previous one completes. In some cases, the previous (or *antecedent*) task produces a value that the continuation accepts as input. By using the [**task::then**][taskThen] method, you can create task chains in an intuitive and straightforward manner; the method returns a **task<T>** where **T** is the return type of the lambda function. You can compose multiple continuations into a task chain: `myTask.then(…).then(…).then(…);`\n\nTask chains are especially useful when a continuation creates a new asynchronous operation; such a task is known as an asynchronous task. The following example illustrates a task chain that has two continuations. The initial task acquires the handle to an existing file, and when that operation completes, the first continuation starts up a new asynchronous operation to delete the file. When that operation completes, the second continuation runs, and outputs a confirmation message.\n\n``` cpp\n#include <ppltasks.h>\nusing namespace concurrency;\n...\nvoid App::DeleteWithTasks(String^ fileName)\n{    \n    using namespace Windows::Storage;\n    StorageFolder^ localFolder = ApplicationData::Current::LocalFolder;\n    auto getFileTask = create_task(localFolder->GetFileAsync(fileName));\n\n    getFileTask.then([](StorageFile^ storageFileSample) ->IAsyncAction^ {       \n        return storageFileSample->DeleteAsync();\n    }).then([](void) {\n        OutputDebugString(L\"File deleted.\");\n    });\n}\n```\n\nThe previous example illustrates four important points:\n\n-   The first continuation converts the [**IAsyncAction^**][IAsyncAction] object to a **task<void>** and returns the **task**.\n\n-   The second continuation performs no error handling, and therefore takes **void** and not **task<void>** as input. It is a value-based continuation.\n\n-   The second continuation doesn't execute until the [**DeleteAsync**][deleteAsync] operation completes.\n\n-   Because the second continuation is value-based, if the operation that was started by the call to [**DeleteAsync**][deleteAsync] throws an exception, the second continuation doesn't execute at all.\n\n**Note**  Creating a task chain is just one of the ways to use the **task** class to compose asynchronous operations. You can also compose operations by using join and choice operators **&&** and **||**. For more information, see [Task Parallelism (Concurrency Runtime)][taskParallelism].\n\n## Lambda function return types and task return types\n\nIn a task continuation, the return type of the lambda function is wrapped in a **task** object. If the lambda returns a **double**, then the type of the continuation task is **task<double>**. However, the task object is designed so that it doesn't produce needlessly nested return types. If a lambda returns an **IAsyncOperation<SyndicationFeed^>^**, the continuation returns a **task<SyndicationFeed^>**, not a **task<task<SyndicationFeed^>>** or **task<IAsyncOperation<SyndicationFeed^>^>^**. This process is known as *asynchronous unwrapping* and it also ensures that the asynchronous operation inside the continuation completes before the next continuation is invoked.\n\nIn the previous example, notice that the task returns a **task<void>** even though its lambda returned an [**IAsyncInfo**][IAsyncInfo] object. The following table summarizes the type conversions that occur between a lambda function and the enclosing task:\n\n| | |\n|--------------------------------------------------------|---------------------|\n| lambda return type                                     | `.then` return type |\n| TResult                                                | task<TResult> |\n| IAsyncOperation<TResult>^                        | task<TResult> |\n| IAsyncOperationWithProgress<TResult, TProgress>^ | task<TResult> |\n|IAsyncAction^                                           | task<void>    |\n| IAsyncActionWithProgress<TProgress>^             |task<void>     |\n| task<TResult>                                    |task<TResult>  |\n\n\n## Canceling tasks\n\nIt is often a good idea to give the user the option to cancel an asynchronous operation. And in some cases you might have to cancel an operation programmatically from outside the task chain. Although each \\***Async** return type has a [**Cancel**][IAsyncInfoCancel] method that it inherits from [**IAsyncInfo**][IAsyncInfo], it's awkward to expose it to outside methods. The preferred way to support cancellation in a task chain is to use a [**cancellation\\_token\\_source**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749985.aspx) to create a [**cancellation\\_token**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749975.aspx), and then pass the token to the constructor of the initial task. If an asynchronous task is created with a cancellation token, and [**cancellation\\_token\\_source::cancel**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750076.aspx) is called, the task automatically calls **Cancel** on the **IAsync\\*** operation and passes the cancellation request down its continuation chain. The following pseudocode demonstrates the basic approach.\n\n``` cpp\n//Class member:\ncancellation_token_source m_fileTaskTokenSource;\n\n// Cancel button event handler:\nm_fileTaskTokenSource.cancel();\n\n// task chain\nauto getFileTask2 = create_task(documentsFolder->GetFileAsync(fileName), \n                                m_fileTaskTokenSource.get_token());\n//getFileTask2.then ...\n```\n\nWhen a task is canceled, a [**task\\_canceled**][taskCanceled] exception is propagated down the task chain. Value-based continuations will simply not execute, but task-based continuations will cause the exception to be thrown when [**task::get**][taskGet] is called. If you have an error-handling continuation, make sure that it catches the **task\\_canceled** exception explicitly. (This exception is not derived from [**Platform::Exception**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh755825.aspx).)\n\nCancellation is cooperative. If your continuation does some long-running work beyond just invoking a UWP method, then it is your responsibility to check the state of the cancellation token periodically and stop execution if it is canceled. After you clean up all resources that were allocated in the continuation, call [**cancel\\_current\\_task**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749945.aspx) to cancel that task and propagate the cancellation down to any value-based continuations that follow it. Here's another example: you can create a task chain that represents the result of a [**FileSavePicker**](https://msdn.microsoft.com/library/windows/apps/BR207871) operation. If the user chooses the **Cancel** button, the [**IAsyncInfo::Cancel**][IAsyncInfoCancel] method is not called. Instead, the operation succeeds but returns **nullptr**. The continuation can test the input parameter and call **cancel\\_current\\_task** if the input is **nullptr**.\n\nFor more information, see [Cancellation in the PPL](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/dd984117.aspx)\n\n## Handling errors in a task chain\n\nIf you want a continuation to execute even if the antecedent was canceled or threw an exception, then make the continuation a task-based continuation by specifying the input to its lambda function as a **task<TResult>** or **task<void>** if the lambda of the antecedent task returns an [**IAsyncAction^**][IAsyncAction].\n\nTo handle errors and cancellation in a task chain, you don't have to make every continuation task-based or enclose every operation that might throw within a `try…catch` block. Instead, you can add a task-based continuation at the end of the chain and handle all errors there. Any exception—this includes a [**task\\_canceled**][taskCanceled] exception—will propagate down the task chain and bypass any value-based continuations, so that you can handle it in the error-handling task-based continuation. We can rewrite the previous example to use an error-handling task-based continuation:\n\n``` cpp\n#include <ppltasks.h>\nvoid App::DeleteWithTasksHandleErrors(String^ fileName)\n{    \n    using namespace Windows::Storage;\n    using namespace concurrency;\n\n    StorageFolder^ documentsFolder = KnownFolders::DocumentsLibrary;\n    auto getFileTask = create_task(documentsFolder->GetFileAsync(fileName));\n\n    getFileTask.then([](StorageFile^ storageFileSample)\n    {       \n        return storageFileSample->DeleteAsync();\n    })\n\n    .then([](task<void> t) \n    {\n\n        try\n        {\n            t.get();\n            // .get() didn' t throw, so we succeeded.\n            OutputDebugString(L\"File deleted.\");\n        }\n        catch (Platform::COMException^ e)\n        {\n            //Example output: The system cannot find the specified file.\n            OutputDebugString(e->Message->Data());\n        }\n\n    });\n}\n```\n\nIn a task-based continuation, we call the member function [**task::get**][taskGet] to get the results of the task. We still have to call **task::get** even if the operation was an [**IAsyncAction**][IAsyncAction] that produces no result because **task::get** also gets any exceptions that have been transported down to the task. If the input task is storing an exception, it is thrown at the call to **task::get**. If you don't call **task::get**, or don't use a task-based continuation at the end of the chain, or don't catch the exception type that was thrown, then an **unobserved\\_task\\_exception** is thrown when all references to the task have been deleted.\n\nOnly catch the exceptions that you can handle. If your app encounters an error that you can't recover from, it's better to let the app crash than to let it continue to run in an unknown state. Also, in general, don't attempt to catch the **unobserved\\_task\\_exception** itself. This exception is mainly intended for diagnostic purposes. When **unobserved\\_task\\_exception** is thrown, it usually indicates a bug in the code. Often the cause is either an exception that should be handled, or an unrecoverable exception that's caused by some other error in the code.\n\n## Managing the thread context\n\nThe UI of a UWP app runs in a single-threaded apartment (STA). A task whose lambda returns either an [**IAsyncAction**][IAsyncAction] or [**IAsyncOperation**][IAsyncOperation] is apartment-aware. If the task is created in the STA, then all of its continuations will run also run in it by default, unless you specify otherwise. In other words, the entire task chain inherits apartment-awareness from the parent task. This behavior helps simplify interactions with UI controls, which can only be accessed from the STA.\n\nFor example, in a UWP app, in the member function of any class that represents a XAML page, you can populate a [**ListBox**](https://msdn.microsoft.com/library/windows/apps/BR242868) control from within a [**task::then**][taskThen] method without having to use the [**Dispatcher**](https://msdn.microsoft.com/library/windows/apps/BR208211) object.\n\n``` cpp\n#include <ppltasks.h>\nvoid App::SetFeedText()\n{    \n    using namespace Windows::Web::Syndication;\n    using namespace concurrency;\n    String^ url = \"http://windowsteamblog.com/windows_phone/b/wmdev/atom.aspx\";\n    SyndicationClient^ client = ref new SyndicationClient();\n    auto feedOp = client->RetrieveFeedAsync(ref new Uri(url));\n\n    create_task(feedOp).then([this]  (SyndicationFeed^ feed) \n    {\n        m_TextBlock1->Text = feed->Title->Text;\n    });\n}\n```\n\nIf a task doesn't return an [**IAsyncAction**][IAsyncAction] or [**IAsyncOperation**][IAsyncOperation], then it's not apartment-aware and, by default, its continuations are run on the first available background thread.\n\nYou can override the default thread context for either kind of task by using the overload of [**task::then**][taskThen] that takes a [**task\\_continuation\\_context**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749968.aspx). For example, in some cases, it might be desirable to schedule the continuation of an apartment-aware task on a background thread. In such a case, you can pass [**task\\_continuation\\_context::use\\_arbitrary**][useArbitrary] to schedule the task’s work on the next available thread in a multi-threaded apartment. This can improve the performance of the continuation because its work doesn't have to be synchronized with other work that's happening on the UI thread.\n\nThe following example demonstrates when it's useful to specify the [**task\\_continuation\\_context::use\\_arbitrary**][useArbitrary] option, and it also shows how the default continuation context is useful for synchronizing concurrent operations on non-thread-safe collections. In this code, we loop through a list of URLs for RSS feeds, and for each URL, we start up an async operation to retrieve the feed data. We can’t control the order in which the feeds are retrieved, and we don't really care. When each [**RetrieveFeedAsync**](https://msdn.microsoft.com/library/windows/apps/BR210642) operation completes, the first continuation accepts the [**SyndicationFeed^**](https://msdn.microsoft.com/library/windows/apps/BR243485) object and uses it to initialize an app-defined `FeedData^` object. Because each of these operations is independent from the others, we can potentially speed things up by specifying the **task\\_continuation\\_context::use\\_arbitrary** continuation context. However, after each `FeedData` object is initialized, we have to add it to a [**Vector**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh441570.aspx), which is not a thread-safe collection. Therefore, we create a continuation and specify [**task\\_continuation\\_context::use\\_current**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750085.aspx) to ensure that all the calls to [**Append**](https://msdn.microsoft.com/library/windows/apps/BR206632) occur in the same Application Single-Threaded Apartment (ASTA) context. Because [**task\\_continuation\\_context::use\\_default**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750085.aspx) is the default context, we don’t have to specify it explicitly, but we do so here for the sake of clarity.\n\n``` cpp\n#include <ppltasks.h>\nvoid App::InitDataSource(Vector<Object^>^ feedList, vector<wstring> urls)\n{\n                using namespace concurrency;\n    SyndicationClient^ client = ref new SyndicationClient();\n\n    std::for_each(std::begin(urls), std::end(urls), [=,this] (std::wstring url)\n    {\n        // Create the async operation. feedOp is an \n        // IAsyncOperationWithProgress<SyndicationFeed^, RetrievalProgress>^\n        // but we don’t handle progress in this example.\n\n        auto feedUri = ref new Uri(ref new String(url.c_str()));\n        auto feedOp = client->RetrieveFeedAsync(feedUri);\n\n        // Create the task object and pass it the async operation.\n        // SyndicationFeed^ is the type of the return value\n        // that the feedOp operation will eventually produce.\n\n        // Then, initialize a FeedData object by using the feed info. Each\n        // operation is independent and does not have to happen on the\n        // UI thread. Therefore, we specify use_arbitrary.\n        create_task(feedOp).then([this]  (SyndicationFeed^ feed) -> FeedData^\n        {\n            return GetFeedData(feed);\n        }, task_continuation_context::use_arbitrary())\n\n        // Append the initialized FeedData object to the list\n        // that is the data source for the items collection.\n        // This all has to happen on the same thread.\n        // By using the use_default context, we can append \n        // safely to the Vector without taking an explicit lock.\n        .then([feedList] (FeedData^ fd)\n        {\n            feedList->Append(fd);\n            OutputDebugString(fd->Title->Data());\n        }, task_continuation_context::use_default())\n\n        // The last continuation serves as an error handler. The\n        // call to get() will surface any exceptions that were raised\n        // at any point in the task chain.\n        .then( [this] (task<void> t)\n        {\n            try\n            {\n                t.get();\n            }\n            catch(Platform::InvalidArgumentException^ e)\n            {\n                //TODO handle error.\n                OutputDebugString(e->Message->Data());\n            }\n        }); //end task chain\n\n    }); //end std::for_each\n}\n```\n\nNested tasks, which are new tasks that are created inside a continuation, don't inherit apartment-awareness of the initial task.\n\n## Handing progress updates\n\nMethods that support [**IAsyncOperationWithProgress**](https://msdn.microsoft.com/library/windows/apps/BR206594) or [**IAsyncActionWithProgress**](https://msdn.microsoft.com/library/windows/apps/BR206580withprogress_1) provide progress updates periodically while the operation is in progress, before it completes. Progress reporting is independent from the notion of tasks and continuations. You just supply the delegate for the object’s [**Progress**](https://msdn.microsoft.com/library/windows/apps/br206594) property. A typical use of the delegate is to update a progress bar in the UI.\n\n## Related topics\n\n* [Creating Asynchronous Operations in C++ for Windows Store apps][createAsyncCpp]\n* [Visual C++ Language Reference](http://msdn.microsoft.com/library/windows/apps/hh699871.aspx)\n* [Asynchronous Programming][AsyncProgramming]\n* [Task Parallelism (Concurrency Runtime)][taskParallelism]\n* [task class][task-class]\n \n<!-- LINKS -->\n[AsyncProgramming]: https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh464924.aspx\n[concurrencyNamespace]: https://msdn.microsoft.com/en-us/library/windows/apps/xaml/dd492819.aspx\n[createTask]: https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh913025.aspx\n[createAsyncCpp]: https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750082.aspx\n[deleteAsync]: https://msdn.microsoft.com/library/windows/apps/BR227199\n[IAsyncAction]: https://msdn.microsoft.com/library/windows/apps/BR206580\n[IAsyncOperation]: https://msdn.microsoft.com/library/windows/apps/BR206598\n[IAsyncInfo]: https://msdn.microsoft.com/library/windows/apps/BR206587\n[IAsyncInfoCancel]: https://msdn.microsoft.com/library/windows/apps/windows.foundation.iasyncinfo.cancel\n[taskCanceled]: https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750106.aspx\n[task-class]: https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750113.aspx\n[taskGet]: https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750017.aspx\n[taskParallelism]: https://msdn.microsoft.com/en-us/library/windows/apps/xaml/dd492427.aspx\n[taskThen]: https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750044.aspx\n[useArbitrary]: https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750036.aspx"}