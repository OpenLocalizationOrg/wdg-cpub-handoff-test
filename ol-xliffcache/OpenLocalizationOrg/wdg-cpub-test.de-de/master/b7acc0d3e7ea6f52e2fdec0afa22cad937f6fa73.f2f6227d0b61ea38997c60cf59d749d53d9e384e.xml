{"nodes":[{"pos":[11,35],"content":"Touch controls for games","needQuote":true,"needEscape":true,"nodes":[{"content":"Touch controls for games","pos":[0,24]}]},{"pos":[49,150],"content":"Learn how to add basic touch controls to your Universal Windows Platform (UWP) C++ game with DirectX.","needQuote":true,"needEscape":true,"nodes":[{"content":"Learn how to add basic touch controls to your Universal Windows Platform (UWP) C++ game with DirectX.","pos":[0,101]}]},{"content":"Touch controls for games","pos":[207,231]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[234,272]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[273,368],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Learn how to add basic touch controls to your Universal Windows Platform (UWP) C++ game with DirectX.","pos":[370,471]},{"content":"We show you how to add touch-based controls to move a fixed-plane camera in a Direct3D environment, where dragging with a finger or stylus shifts the camera perspective.","pos":[472,641]},{"content":"You can incorporate these controls in games where you want the player to drag to scroll or pan over a 3D environment, such as a map or playfield.","pos":[643,788]},{"content":"For example, in a strategy or puzzle game, you can use these controls to let the player view a game environment that is larger than the screen by panning left or right.","pos":[789,957]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  Our code also works with mouse-based panning controls.","pos":[961,1025],"source":"**Note**  Our code also works with mouse-based panning controls."},{"content":"The pointer related events are abstracted by the Windows Runtime APIs, so they can handle either touch- or mouse-based pointer events.","pos":[1026,1160]},{"content":"Objectives","pos":[1168,1178]},{"content":"Create a simple touch drag control for panning a fixed-plane camera in a DirectX game.","pos":[1185,1271]},{"content":"Set up the basic touch event infrastructure","pos":[1276,1319]},{"content":"First, we define our basic controller type, the <bpt id=\"p1\">**</bpt>CameraPanController<ept id=\"p1\">**</ept>, in this case.","pos":[1322,1408],"source":"First, we define our basic controller type, the **CameraPanController**, in this case."},{"content":"Here, we define a controller as an abstract idea, the set of behaviors the user can perform.","pos":[1409,1501]},{"pos":[1503,1702],"content":"The <bpt id=\"p1\">**</bpt>CameraPanController<ept id=\"p1\">**</ept> class is a regularly refreshed collection of information about the camera controller state, and provides a way for our app to obtain that information from its update loop.","source":"The **CameraPanController** class is a regularly refreshed collection of information about the camera controller state, and provides a way for our app to obtain that information from its update loop."},{"content":"Now, let's create a header that defines the state of the camera controller, and the basic methods and event handlers that implement the camera controller interactions.","pos":[1967,2134]},{"content":"The private fields contain the current state of the camera controller.","pos":[3610,3680]},{"content":"Let's review them.","pos":[3681,3699]},{"content":"<bpt id=\"p1\">**</bpt>m\\_position<ept id=\"p1\">**</ept> is the position of the camera in the scene space.","pos":[3705,3770],"source":"**m\\_position** is the position of the camera in the scene space."},{"content":"In this example, the z-coordinate value is fixed at 0.","pos":[3771,3825]},{"content":"We could use a DirectX::XMFLOAT2 to represent this value, but for the purposes of this sample and future extensibility, we use a DirectX::XMFLOAT3.","pos":[3826,3973]},{"content":"We pass this value through the <bpt id=\"p1\">**</bpt>get\\_Position<ept id=\"p1\">**</ept> property to the app itself so it can update the viewport accordingly.","pos":[3974,4092],"source":" We pass this value through the **get\\_Position** property to the app itself so it can update the viewport accordingly."},{"pos":[4097,4269],"content":"<bpt id=\"p1\">**</bpt>m\\_panInUse<ept id=\"p1\">**</ept> is a Boolean value that indicates whether a pan operation is active; or, more specifically, whether the player is touching the screen and moving the camera.","source":"**m\\_panInUse** is a Boolean value that indicates whether a pan operation is active; or, more specifically, whether the player is touching the screen and moving the camera."},{"content":"<bpt id=\"p1\">**</bpt>m\\_panPointerID<ept id=\"p1\">**</ept> is a unique ID for the pointer.","pos":[4274,4325],"source":"**m\\_panPointerID** is a unique ID for the pointer."},{"content":"We won't use this in the sample, but it's a good practice to associate your controller state class with a specific pointer.","pos":[4326,4449]},{"content":"<bpt id=\"p1\">**</bpt>m\\_panFirstDown<ept id=\"p1\">**</ept> is the point on the screen where the player first touched the screen or clicked the mouse during the camera pan action.","pos":[4454,4593],"source":"**m\\_panFirstDown** is the point on the screen where the player first touched the screen or clicked the mouse during the camera pan action."},{"content":"We use this value later to set a dead zone to prevent jitter when the screen is touched, or if the mouse shakes a little.","pos":[4594,4715]},{"content":"<bpt id=\"p1\">**</bpt>m\\_panPointerPosition<ept id=\"p1\">**</ept> is the point on the screen where the player has currently moved the pointer.","pos":[4720,4822],"source":"**m\\_panPointerPosition** is the point on the screen where the player has currently moved the pointer."},{"content":"We use it to determine what direction the player wanted to move by examining it relative to <bpt id=\"p1\">**</bpt>m\\_panFirstDown<ept id=\"p1\">**</ept>.","pos":[4823,4935],"source":" We use it to determine what direction the player wanted to move by examining it relative to **m\\_panFirstDown**."},{"content":"<bpt id=\"p1\">**</bpt>m\\_panCommand<ept id=\"p1\">**</ept> is the final computed command for the camera controller: up, down, left, or right.","pos":[4940,5040],"source":"**m\\_panCommand** is the final computed command for the camera controller: up, down, left, or right."},{"content":"Because we are working with a camera fixed to the x-y plane, this could be a DirectX::XMFLOAT2 value instead.","pos":[5041,5150]},{"content":"We use these 3 event handlers to update the camera controller state info.","pos":[5152,5225]},{"pos":[5231,5405],"content":"<bpt id=\"p1\">**</bpt>OnPointerPressed<ept id=\"p1\">**</ept> is an event handler that our app calls when the players presses a finger onto the touch surface and the pointer is moved to the coordinates of the press.","source":"**OnPointerPressed** is an event handler that our app calls when the players presses a finger onto the touch surface and the pointer is moved to the coordinates of the press."},{"content":"<bpt id=\"p1\">**</bpt>OnPointerMoved<ept id=\"p1\">**</ept> is an event handler that our app calls when the player swipes a finger across the touch surface.","pos":[5410,5525],"source":"**OnPointerMoved** is an event handler that our app calls when the player swipes a finger across the touch surface."},{"content":"It updates with the new coordinates of the drag path.","pos":[5526,5579]},{"pos":[5584,5712],"content":"<bpt id=\"p1\">**</bpt>OnPointerReleased<ept id=\"p1\">**</ept> is an event handler that our app calls when the player removes the pressing finger from the touch surface.","source":"**OnPointerReleased** is an event handler that our app calls when the player removes the pressing finger from the touch surface."},{"content":"Finally, we use these methods and properties to initialize, access, and update the camera controller state information.","pos":[5714,5833]},{"pos":[5839,6060],"content":"<bpt id=\"p1\">**</bpt>Initialize<ept id=\"p1\">**</ept> is an event handler that our app calls to initialize the controls and attach them to the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>CoreWindow<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> object that describes your display window.","source":"**Initialize** is an event handler that our app calls to initialize the controls and attach them to the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) object that describes your display window."},{"content":"<bpt id=\"p1\">**</bpt>SetPosition<ept id=\"p1\">**</ept> is a method that our app calls to set the (x, y, and z) coordinates of your controls in the scene space.","pos":[6065,6185],"source":"**SetPosition** is a method that our app calls to set the (x, y, and z) coordinates of your controls in the scene space."},{"content":"Note that our z-coordinate is 0 throughout this tutorial.","pos":[6186,6243]},{"content":"<bpt id=\"p1\">**</bpt>get\\_Position<ept id=\"p1\">**</ept> is a property that our app accesses to get the current position of the camera in the scene space.","pos":[6248,6363],"source":"**get\\_Position** is a property that our app accesses to get the current position of the camera in the scene space."},{"content":"You use this property as the way of communicating the current camera position to the app.","pos":[6364,6453]},{"content":"<bpt id=\"p1\">**</bpt>get\\_FixedLookPoint<ept id=\"p1\">**</ept> is a property that our app accesses to get the current point toward which the controller camera is facing.","pos":[6458,6588],"source":"**get\\_FixedLookPoint** is a property that our app accesses to get the current point toward which the controller camera is facing."},{"content":"In this example, it is locked normal to the x-y plane.","pos":[6589,6643]},{"content":"<bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> is a method that reads the controller state and updates the camera position.","pos":[6648,6735],"source":"**Update** is a method that reads the controller state and updates the camera position."},{"content":"You continually call this <ph id=\"ph1\">&amp;lt;</ph>something<ph id=\"ph2\">&amp;gt;</ph> from the app's main loop to refresh the camera controller data and the camera position in the scene space.","pos":[6736,6886],"source":" You continually call this &lt;something&gt; from the app's main loop to refresh the camera controller data and the camera position in the scene space."},{"content":"Now, you have here all the components you need to implement touch controls.","pos":[6888,6963]},{"content":"You can detect when and where the touch or mouse pointer events have occurred, and what the action is.","pos":[6964,7066]},{"content":"You can set the position and orientation of the camera relative to the scene space, and track the changes.","pos":[7067,7173]},{"content":"Finally, you can communicate the new camera position to the calling app.","pos":[7174,7246]},{"content":"Now, let's connect these pieces together.","pos":[7248,7289]},{"content":"Create the basic touch events","pos":[7294,7323]},{"content":"The Windows Runtime event dispatcher provides 3 events we want our app to handle:","pos":[7326,7407]},{"content":"PointerPressed","pos":[7416,7430]},{"content":"PointerMoved","pos":[7499,7511]},{"content":"PointerReleased","pos":[7580,7595]},{"content":"These events are implemented on the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> type.","pos":[7658,7774],"source":"These events are implemented on the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) type."},{"content":"We assume that you have a <bpt id=\"p1\">**</bpt>CoreWindow<ept id=\"p1\">**</ept> object to work with.","pos":[7775,7836],"source":" We assume that you have a **CoreWindow** object to work with."},{"content":"For more info, see <bpt id=\"p1\">[</bpt>How to set up your UWP C++ app to display a DirectX view<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh465077)</ept>.","pos":[7837,7973],"source":" For more info, see [How to set up your UWP C++ app to display a DirectX view](https://msdn.microsoft.com/library/windows/apps/hh465077)."},{"content":"As these events fire while our app is running, the handlers update the camera controller state info defined in our private fields.","pos":[7975,8105]},{"content":"First, let's populate the touch pointer event handlers.","pos":[8107,8162]},{"content":"In the first event handler, <bpt id=\"p1\">**</bpt>OnPointerPressed<ept id=\"p1\">**</ept>, we get the x-y coordinates of the pointer from the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>CoreWindow<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> that manages our display when the user touches the screen or clicks the mouse.","pos":[8163,8417],"source":" In the first event handler, **OnPointerPressed**, we get the x-y coordinates of the pointer from the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) that manages our display when the user touches the screen or clicks the mouse."},{"content":"OnPointerPressed","pos":[8421,8437]},{"content":"We use this handler to let the current <bpt id=\"p1\">**</bpt>CameraPanController<ept id=\"p1\">**</ept> instance know that camera controller should be treated as active by setting <bpt id=\"p2\">**</bpt>m\\_panInUse<ept id=\"p2\">**</ept> to TRUE.","pos":[9311,9474],"source":"We use this handler to let the current **CameraPanController** instance know that camera controller should be treated as active by setting **m\\_panInUse** to TRUE."},{"content":"That way, when the app calls <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> , it will use the current position data to update the viewport.","pos":[9475,9578],"source":" That way, when the app calls **Update** , it will use the current position data to update the viewport."},{"content":"Now that we've established the base values for the camera movement when the user touches the screen or click-presses in the display window, we must determine what to do when the user either drags the screen press or moves the mouse with button pressed.","pos":[9580,9832]},{"content":"The <bpt id=\"p1\">**</bpt>OnPointerMoved<ept id=\"p1\">**</ept> event handler fires whenever the pointer moves, at every tick that the player drags it on the screen.","pos":[9834,9958],"source":"The **OnPointerMoved** event handler fires whenever the pointer moves, at every tick that the player drags it on the screen."},{"content":"We need to keep the app aware of the current location of the pointer, and this is how we do it.","pos":[9959,10054]},{"content":"OnPointerMoved","pos":[10058,10072]},{"content":"Finally, we need to deactivate the camera pan behavior when the player stops touching the screen.","pos":[10478,10575]},{"content":"We use <bpt id=\"p1\">**</bpt>OnPointerReleased<ept id=\"p1\">**</ept>, which is called when <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>PointerReleased<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208279)</ept> is fired, to set <bpt id=\"p4\">**</bpt>m\\_panInUse<ept id=\"p4\">**</ept> to FALSE and turn off the camera pan movement, and set the pointer ID to 0.","pos":[10576,10815],"source":" We use **OnPointerReleased**, which is called when [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279) is fired, to set **m\\_panInUse** to FALSE and turn off the camera pan movement, and set the pointer ID to 0."},{"content":"OnPointerReleased","pos":[10819,10836]},{"content":"Initialize the touch controls and the controller state","pos":[11269,11323]},{"content":"Let's hook the events and initialize all the basic state fields of the camera controller.","pos":[11326,11415]},{"content":"Initialize","pos":[11419,11429]},{"pos":[12202,12442],"content":"<bpt id=\"p1\">**</bpt>Initialize<ept id=\"p1\">**</ept> takes a reference to the app's <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>CoreWindow<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> instance as a parameter and registers the event handlers we developed to the appropriate events on that <bpt id=\"p4\">**</bpt>CoreWindow<ept id=\"p4\">**</ept>.","source":"**Initialize** takes a reference to the app's [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) instance as a parameter and registers the event handlers we developed to the appropriate events on that **CoreWindow**."},{"content":"Getting and setting the position of the camera controller","pos":[12447,12504]},{"content":"Let's define some methods to get and set the position of the camera controller in the scene space.","pos":[12507,12605]},{"pos":[13102,13236],"content":"<bpt id=\"p1\">**</bpt>SetPosition<ept id=\"p1\">**</ept> is a public method that we can call from our app if we need to set the camera controller position to a specific point.","source":"**SetPosition** is a public method that we can call from our app if we need to set the camera controller position to a specific point."},{"pos":[13238,13428],"content":"<bpt id=\"p1\">**</bpt>get\\_Position<ept id=\"p1\">**</ept> is our most important public property: it's the way our app gets the current position of the camera controller in the scene space so it can update the viewport accordingly.","source":"**get\\_Position** is our most important public property: it's the way our app gets the current position of the camera controller in the scene space so it can update the viewport accordingly."},{"content":"<bpt id=\"p1\">**</bpt>get\\_FixedLookPoint<ept id=\"p1\">**</ept> is a public property that, in this example, obtains a look point that is normal to the x-y plane.","pos":[13430,13551],"source":"**get\\_FixedLookPoint** is a public property that, in this example, obtains a look point that is normal to the x-y plane."},{"content":"You can change this method to use the trigonometric functions, sin and cos, when calculating the x, y, and z coordinate values if you want to create more oblique angles for the fixed camera.","pos":[13552,13742]},{"content":"Updating the camera controller state information","pos":[13747,13795]},{"content":"Now, we perform our calculations that convert the pointer coordinate info tracked in <bpt id=\"p1\">**</bpt>m\\_panPointerPosition<ept id=\"p1\">**</ept> into new coordinate info respective of our 3D scene space.","pos":[13798,13967],"source":"Now, we perform our calculations that convert the pointer coordinate info tracked in **m\\_panPointerPosition** into new coordinate info respective of our 3D scene space."},{"content":"Our app calls this method every time we refresh the main app loop.","pos":[13968,14034]},{"content":"In it we compute the new position information we want to pass to the app which is used to update the view matrix before projection into the viewport.","pos":[14035,14184]},{"content":"Because we don't want touch or mouse jitter to make our camera panning jerky, we set a dead zone around the pointer with a diameter of 32 pixels.","pos":[15340,15485]},{"content":"We also have a velocity value, which in this case is 1:1 with the pixel traversal of the pointer past the dead zone.","pos":[15486,15602]},{"content":"You can adjust this behavior to slow down or speed up the rate of movement.","pos":[15603,15678]},{"content":"Updating the view matrix with the new camera position","pos":[15683,15736]},{"content":"We can now obtain a scene space coordinate that our camera is focused on, and which is updated whenever you tell your app to do so (every 60 seconds in the main app loop, for example).","pos":[15739,15923]},{"content":"This pseudocode suggests the calling behavior you can implement:","pos":[15924,15988]},{"content":"Congratulations!","pos":[16431,16447]},{"content":"You've implemented a simple set of camera panning touch controls in your game.","pos":[16448,16526]},{"content":"Note","pos":[16532,16536]},{"content":"This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.","pos":[16541,16629]},{"content":"If you’re developing for Windows 8.x or Windows Phone 8.x, see the <bpt id=\"p1\">[</bpt>archived documentation<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>.","pos":[16630,16771],"source":" If you’re developing for Windows 8.x or Windows Phone 8.x, see the [archived documentation](http://go.microsoft.com/fwlink/p/?linkid=619132)."}],"content":"---\ntitle: Touch controls for games\ndescription: Learn how to add basic touch controls to your Universal Windows Platform (UWP) C++ game with DirectX.\nms.assetid: 9d40e6e4-46a9-97e9-b848-522d61e8e109\n---\n\n# Touch controls for games\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nLearn how to add basic touch controls to your Universal Windows Platform (UWP) C++ game with DirectX. We show you how to add touch-based controls to move a fixed-plane camera in a Direct3D environment, where dragging with a finger or stylus shifts the camera perspective.\n\nYou can incorporate these controls in games where you want the player to drag to scroll or pan over a 3D environment, such as a map or playfield. For example, in a strategy or puzzle game, you can use these controls to let the player view a game environment that is larger than the screen by panning left or right.\n\n> **Note**  Our code also works with mouse-based panning controls. The pointer related events are abstracted by the Windows Runtime APIs, so they can handle either touch- or mouse-based pointer events.\n\n \n\n## Objectives\n\n\n-   Create a simple touch drag control for panning a fixed-plane camera in a DirectX game.\n\n## Set up the basic touch event infrastructure\n\n\nFirst, we define our basic controller type, the **CameraPanController**, in this case. Here, we define a controller as an abstract idea, the set of behaviors the user can perform.\n\nThe **CameraPanController** class is a regularly refreshed collection of information about the camera controller state, and provides a way for our app to obtain that information from its update loop.\n\n```cpp\nusing namespace Windows::UI::Core;\nusing namespace Windows::System;\nusing namespace Windows::Foundation;\nusing namespace Windows::Devices::Input;\n#include <directxmath.h>\n\n// Methods to get input from the UI pointers\nref class CameraPanController\n{\n}\n```\n\nNow, let's create a header that defines the state of the camera controller, and the basic methods and event handlers that implement the camera controller interactions.\n\n```cpp\nref class CameraPanController\n{\nprivate:\n    // Properties of the controller object\n    DirectX::XMFLOAT3 m_position;               // the position of the camera\n\n    // Properties of the camera pan control\n    bool m_panInUse;                \n    uint32 m_panPointerID;          \n    DirectX::XMFLOAT2 m_panFirstDown;           \n    DirectX::XMFLOAT2 m_panPointerPosition;   \n    DirectX::XMFLOAT3 m_panCommand;         \n    \ninternal:\n    // Accessor to set the position of the controller\n    void SetPosition( _In_ DirectX::XMFLOAT3 pos );\n\n       // Accessor to set the fixed \"look point\" of the controller\n       DirectX::XMFLOAT3 get_FixedLookPoint();\n\n    // Returns the position of the controller object\n    DirectX::XMFLOAT3 get_Position();\n\npublic:\n\n    // Methods to get input from the UI pointers\n    void OnPointerPressed(\n        _In_ Windows::UI::Core::CoreWindow^ sender,\n        _In_ Windows::UI::Core::PointerEventArgs^ args\n        );\n\n    void OnPointerMoved(\n        _In_ Windows::UI::Core::CoreWindow^ sender,\n        _In_ Windows::UI::Core::PointerEventArgs^ args\n        );\n\n    void OnPointerReleased(\n        _In_ Windows::UI::Core::CoreWindow^ sender,\n        _In_ Windows::UI::Core::PointerEventArgs^ args\n        );\n\n    // Set up the Controls supported by this controller\n    void Initialize( _In_ Windows::UI::Core::CoreWindow^ window );\n\n    void Update( Windows::UI::Core::CoreWindow ^window );\n\n};  // Class CameraPanController\n```\n\nThe private fields contain the current state of the camera controller. Let's review them.\n\n-   **m\\_position** is the position of the camera in the scene space. In this example, the z-coordinate value is fixed at 0. We could use a DirectX::XMFLOAT2 to represent this value, but for the purposes of this sample and future extensibility, we use a DirectX::XMFLOAT3. We pass this value through the **get\\_Position** property to the app itself so it can update the viewport accordingly.\n-   **m\\_panInUse** is a Boolean value that indicates whether a pan operation is active; or, more specifically, whether the player is touching the screen and moving the camera.\n-   **m\\_panPointerID** is a unique ID for the pointer. We won't use this in the sample, but it's a good practice to associate your controller state class with a specific pointer.\n-   **m\\_panFirstDown** is the point on the screen where the player first touched the screen or clicked the mouse during the camera pan action. We use this value later to set a dead zone to prevent jitter when the screen is touched, or if the mouse shakes a little.\n-   **m\\_panPointerPosition** is the point on the screen where the player has currently moved the pointer. We use it to determine what direction the player wanted to move by examining it relative to **m\\_panFirstDown**.\n-   **m\\_panCommand** is the final computed command for the camera controller: up, down, left, or right. Because we are working with a camera fixed to the x-y plane, this could be a DirectX::XMFLOAT2 value instead.\n\nWe use these 3 event handlers to update the camera controller state info.\n\n-   **OnPointerPressed** is an event handler that our app calls when the players presses a finger onto the touch surface and the pointer is moved to the coordinates of the press.\n-   **OnPointerMoved** is an event handler that our app calls when the player swipes a finger across the touch surface. It updates with the new coordinates of the drag path.\n-   **OnPointerReleased** is an event handler that our app calls when the player removes the pressing finger from the touch surface.\n\nFinally, we use these methods and properties to initialize, access, and update the camera controller state information.\n\n-   **Initialize** is an event handler that our app calls to initialize the controls and attach them to the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) object that describes your display window.\n-   **SetPosition** is a method that our app calls to set the (x, y, and z) coordinates of your controls in the scene space. Note that our z-coordinate is 0 throughout this tutorial.\n-   **get\\_Position** is a property that our app accesses to get the current position of the camera in the scene space. You use this property as the way of communicating the current camera position to the app.\n-   **get\\_FixedLookPoint** is a property that our app accesses to get the current point toward which the controller camera is facing. In this example, it is locked normal to the x-y plane.\n-   **Update** is a method that reads the controller state and updates the camera position. You continually call this &lt;something&gt; from the app's main loop to refresh the camera controller data and the camera position in the scene space.\n\nNow, you have here all the components you need to implement touch controls. You can detect when and where the touch or mouse pointer events have occurred, and what the action is. You can set the position and orientation of the camera relative to the scene space, and track the changes. Finally, you can communicate the new camera position to the calling app.\n\nNow, let's connect these pieces together.\n\n## Create the basic touch events\n\n\nThe Windows Runtime event dispatcher provides 3 events we want our app to handle:\n\n-   [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208278)\n-   [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208276)\n-   [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279)\n\nThese events are implemented on the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) type. We assume that you have a **CoreWindow** object to work with. For more info, see [How to set up your UWP C++ app to display a DirectX view](https://msdn.microsoft.com/library/windows/apps/hh465077).\n\nAs these events fire while our app is running, the handlers update the camera controller state info defined in our private fields.\n\nFirst, let's populate the touch pointer event handlers. In the first event handler, **OnPointerPressed**, we get the x-y coordinates of the pointer from the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) that manages our display when the user touches the screen or clicks the mouse.\n\n**OnPointerPressed**\n\n```cpp\nvoid CameraPanController::OnPointerPressed(\n                                           _In_ CoreWindow^ sender,\n                                           _In_ PointerEventArgs^ args)\n{\n    // Get the current pointer position.\n    uint32 pointerID = args->CurrentPoint->PointerId;\n    DirectX::XMFLOAT2 position = DirectX::XMFLOAT2( args->CurrentPoint->Position.X, args->CurrentPoint->Position.Y );\n\n    auto device = args->CurrentPoint->PointerDevice;\n    auto deviceType = device->PointerDeviceType;\n    \n\n       if ( !m_panInUse )   // If no pointer is in this control yet.\n    {\n       m_panFirstDown = position;                   // Save the location of the initial contact.\n       m_panPointerPosition = position;\n       m_panPointerID = pointerID;              // Store the id of the pointer using this control.\n       m_panInUse = TRUE;\n    }\n    \n}\n```\n\nWe use this handler to let the current **CameraPanController** instance know that camera controller should be treated as active by setting **m\\_panInUse** to TRUE. That way, when the app calls **Update** , it will use the current position data to update the viewport.\n\nNow that we've established the base values for the camera movement when the user touches the screen or click-presses in the display window, we must determine what to do when the user either drags the screen press or moves the mouse with button pressed.\n\nThe **OnPointerMoved** event handler fires whenever the pointer moves, at every tick that the player drags it on the screen. We need to keep the app aware of the current location of the pointer, and this is how we do it.\n\n**OnPointerMoved**\n\n```cpp\nvoid CameraPanController::OnPointerMoved(\n                                        _In_ CoreWindow ^sender,\n                                        _In_ PointerEventArgs ^args)\n{\n    uint32 pointerID = args->CurrentPoint->PointerId;\n    DirectX::XMFLOAT2 position = DirectX::XMFLOAT2( args->CurrentPoint->Position.X, args->CurrentPoint->Position.Y );\n\n    m_panPointerPosition = position;\n}\n```\n\nFinally, we need to deactivate the camera pan behavior when the player stops touching the screen. We use **OnPointerReleased**, which is called when [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279) is fired, to set **m\\_panInUse** to FALSE and turn off the camera pan movement, and set the pointer ID to 0.\n\n**OnPointerReleased**\n\n```cpp\nvoid CameraPanController::OnPointerReleased(\n                                             _In_ CoreWindow ^sender,\n                                             _In_ PointerEventArgs ^args)\n{\n    uint32 pointerID = args->CurrentPoint->PointerId;\n    DirectX::XMFLOAT2 position = DirectX::XMFLOAT2( args->CurrentPoint->Position.X, args->CurrentPoint->Position.Y );\n\n    m_panInUse = FALSE;\n    m_panPointerID = 0;\n}\n```\n\n## Initialize the touch controls and the controller state\n\n\nLet's hook the events and initialize all the basic state fields of the camera controller.\n\n**Initialize**\n\n```cpp\nvoid CameraPanController::Initialize( _In_ CoreWindow^ window )\n{\n\n    // Start recieving touch/mouse events.\n    window->PointerPressed += \n    ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &CameraPanController::OnPointerPressed);\n\n    window->PointerMoved += \n    ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &CameraPanController::OnPointerMoved);\n\n    window->PointerReleased += \n    ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &CameraPanController::OnPointerReleased);\n\n\n    // Initialize the state of the controller.\n    m_panInUse = FALSE;             \n    m_panPointerID = 0;\n\n    //  Initialize this as it is reset on every frame.\n    m_panCommand = DirectX::XMFLOAT3( 0.0f, 0.0f, 0.0f );\n\n}\n```\n\n**Initialize** takes a reference to the app's [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) instance as a parameter and registers the event handlers we developed to the appropriate events on that **CoreWindow**.\n\n## Getting and setting the position of the camera controller\n\n\nLet's define some methods to get and set the position of the camera controller in the scene space.\n\n```cpp\nvoid CameraPanController::SetPosition( _In_ DirectX::XMFLOAT3 pos )\n{\n    m_position = pos;\n}\n\n// Returns the position of the controller object\nDirectX::XMFLOAT3 CameraPanController::get_Position()\n{\n    return m_position;\n}\n\nDirectX::XMFLOAT3 CameraPanController::get_FixedLookPoint()\n{\n    // For this sample, we don't need to use the trig functions because our\n    // look point is fixed. \n    DirectX::XMFLOAT3 result= m_position;\n    result.z += 1.0f;\n    return result;    \n\n}\n```\n\n**SetPosition** is a public method that we can call from our app if we need to set the camera controller position to a specific point.\n\n**get\\_Position** is our most important public property: it's the way our app gets the current position of the camera controller in the scene space so it can update the viewport accordingly.\n\n**get\\_FixedLookPoint** is a public property that, in this example, obtains a look point that is normal to the x-y plane. You can change this method to use the trigonometric functions, sin and cos, when calculating the x, y, and z coordinate values if you want to create more oblique angles for the fixed camera.\n\n## Updating the camera controller state information\n\n\nNow, we perform our calculations that convert the pointer coordinate info tracked in **m\\_panPointerPosition** into new coordinate info respective of our 3D scene space. Our app calls this method every time we refresh the main app loop. In it we compute the new position information we want to pass to the app which is used to update the view matrix before projection into the viewport.\n\n```cpp\n\nvoid CameraPanController::Update( CoreWindow ^window )\n{\n    if ( m_panInUse )\n    {\n        pointerDelta.x = m_panPointerPosition.x - m_panFirstDown.x;\n        pointerDelta.y = m_panPointerPosition.y - m_panFirstDown.y;\n\n        if ( pointerDelta.x > 16.0f )        // Leave 32 pixel-wide dead spot for being still.\n            m_panCommand.x += 1.0f;\n        else\n            if ( pointerDelta.x < -16.0f )\n                m_panCommand.x += -1.0f;\n\n        if ( pointerDelta.y > 16.0f )        \n            m_panCommand.y += 1.0f;\n        else\n            if (pointerDelta.y < -16.0f )\n                m_panCommand.y += -1.0f;\n    }\n\n       DirectX::XMFLOAT3 command = m_panCommand;\n   \n    // Our velocity is based on the command.\n    DirectX::XMFLOAT3 Velocity;\n    Velocity.x =  command.x;\n    Velocity.y =  command.y;\n    Velocity.z =  0.0f;\n\n    // Integrate\n    m_position.x = m_position.x + Velocity.x;\n    m_position.y = m_position.y + Velocity.y;\n    m_position.z = m_position.z + Velocity.z;\n\n    // Clear the movement input accumulator for use during the next frame.\n    m_panCommand = DirectX::XMFLOAT3( 0.0f, 0.0f, 0.0f );\n\n}\n```\n\nBecause we don't want touch or mouse jitter to make our camera panning jerky, we set a dead zone around the pointer with a diameter of 32 pixels. We also have a velocity value, which in this case is 1:1 with the pixel traversal of the pointer past the dead zone. You can adjust this behavior to slow down or speed up the rate of movement.\n\n## Updating the view matrix with the new camera position\n\n\nWe can now obtain a scene space coordinate that our camera is focused on, and which is updated whenever you tell your app to do so (every 60 seconds in the main app loop, for example). This pseudocode suggests the calling behavior you can implement:\n\n```cpp\n myCameraPanController->Update( m_window ); \n\n // Update the view matrix based on the camera position.\n myCamera->MyMethodToComputeViewMatrix(\n        myController->get_Position(),        // The position in the 3D scene space.\n        myController->get_FixedLookPoint(),      // The point in the space we are looking at.\n        DirectX::XMFLOAT3( 0, 1, 0 )                    // The axis that is \"up\" in our space.\n        );  \n```\n\nCongratulations! You've implemented a simple set of camera panning touch controls in your game.\n\n> **Note**  \nThis article is for Windows 10 developers writing Universal Windows Platform (UWP) apps. If you’re developing for Windows 8.x or Windows Phone 8.x, see the [archived documentation](http://go.microsoft.com/fwlink/p/?linkid=619132).\n\n \n\n \n\n \n\n\n\n\n"}