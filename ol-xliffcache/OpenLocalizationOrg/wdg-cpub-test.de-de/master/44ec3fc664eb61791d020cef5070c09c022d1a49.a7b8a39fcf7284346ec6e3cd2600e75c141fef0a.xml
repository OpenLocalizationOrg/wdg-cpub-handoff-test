{"nodes":[{"pos":[11,53],"content":"Support shadow maps on a range of hardware","needQuote":true,"needEscape":true,"nodes":[{"content":"Support shadow maps on a range of hardware","pos":[0,42]}]},{"pos":[67,160],"content":"Render higher-fidelity shadows on faster devices and faster shadows on less powerful devices.","needQuote":true,"needEscape":true,"nodes":[{"content":"Render higher-fidelity shadows on faster devices and faster shadows on less powerful devices.","pos":[0,93]}]},{"content":"Support shadow maps on a range of hardware","pos":[217,259]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[262,300]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[301,396],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Render higher-fidelity shadows on faster devices and faster shadows on less powerful devices.","pos":[399,492]},{"content":"Part 4 of <bpt id=\"p1\">[</bpt>Walkthrough: Implement shadow volumes using depth buffers in Direct3D 11<ept id=\"p1\">](implementing-depth-buffers-for-shadow-mapping.md)</ept>.","pos":[493,628],"source":" Part 4 of [Walkthrough: Implement shadow volumes using depth buffers in Direct3D 11](implementing-depth-buffers-for-shadow-mapping.md)."},{"content":"Comparison filter types","pos":[633,656]},{"content":"Only use linear filtering if the device can afford the performance penalty.","pos":[659,734]},{"content":"Generally, Direct3D feature level 9\\_1 devices don't have enough power to spare for linear filtering on shadows.","pos":[735,847]},{"content":"Use point filtering instead on these devices.","pos":[848,893]},{"content":"When you use linear filtering, adjust the pixel shader so that it blends the shadow edges.","pos":[894,984]},{"content":"Create the comparison sampler for point filtering:","pos":[986,1036]},{"content":"Then create a sampler for linear filtering:","pos":[2212,2255]},{"content":"Choose a sampler:","pos":[2484,2501]},{"content":"Blend shadow edges with linear filtering:","pos":[3071,3112]},{"content":"Shadow buffer size","pos":[3342,3360]},{"content":"Larger shadow maps won't look as blocky but they take up more space in graphics memory.","pos":[3363,3450]},{"content":"Experiment with different shadow map sizes in your game and observe the results in different types of devices and different display sizes.","pos":[3451,3589]},{"content":"Consider an optimization like cascaded shadow maps to get better results with less graphics memory.","pos":[3590,3689]},{"content":"See <bpt id=\"p1\">[</bpt>Common Techniques to Improve Shadow Depth Maps<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ee416324)</ept>.","pos":[3690,3804],"source":" See [Common Techniques to Improve Shadow Depth Maps](https://msdn.microsoft.com/library/windows/desktop/ee416324)."},{"content":"Shadow buffer depth","pos":[3809,3828]},{"content":"Greater precision in the shadow buffer will give more accurate depth test results, which helps avoid issues like z-buffer fighting.","pos":[3831,3962]},{"content":"But like larger shadow maps, greater precision takes up more memory.","pos":[3963,4031]},{"content":"Experiment with different depth precision types in your game - DXGI\\_FORMAT\\_R24G8\\_TYPELESS versus DXGI\\_FORMAT\\_R16\\_TYPELESS - and observe the speed and quality on different feature levels.","pos":[4032,4224]},{"content":"Optimizing precompiled shaders","pos":[4229,4259]},{"content":"Universal Windows Platform (UWP) apps can use dynamic shader compilation, but it's faster to use dynamic shader linking.","pos":[4262,4382]},{"content":"You can also use compiler directives and <ph id=\"ph1\">`#ifdef`</ph> blocks to create different versions of shaders.","pos":[4383,4480],"source":" You can also use compiler directives and `#ifdef` blocks to create different versions of shaders."},{"content":"This is done by opening the Visual Studio project file in a text editor and adding multiple <ph id=\"ph1\">`&lt;FxcCompiler&gt;`</ph> entries for the HLSL (each with the appropriate preprocessor definitions).","pos":[4481,4663],"source":" This is done by opening the Visual Studio project file in a text editor and adding multiple `<FxcCompiler>` entries for the HLSL (each with the appropriate preprocessor definitions)."},{"content":"Note that this necessitates different filenames; in this case, Visual Studio appends \\_point and \\_linear to the different versions of the shader.","pos":[4664,4810]},{"content":"The project file entry for the linear filtered version of the shader defines LINEAR:","pos":[4812,4896]},{"content":"The project file entry for the linear filtered version of the shader does not include preprocessor definitions:","pos":[7444,7555]}],"content":"---\ntitle: Support shadow maps on a range of hardware\ndescription: Render higher-fidelity shadows on faster devices and faster shadows on less powerful devices.\nms.assetid: d97c0544-44f2-4e29-5e02-54c45e0dff4e\n---\n\n# Support shadow maps on a range of hardware\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\nRender higher-fidelity shadows on faster devices and faster shadows on less powerful devices. Part 4 of [Walkthrough: Implement shadow volumes using depth buffers in Direct3D 11](implementing-depth-buffers-for-shadow-mapping.md).\n\n## Comparison filter types\n\n\nOnly use linear filtering if the device can afford the performance penalty. Generally, Direct3D feature level 9\\_1 devices don't have enough power to spare for linear filtering on shadows. Use point filtering instead on these devices. When you use linear filtering, adjust the pixel shader so that it blends the shadow edges.\n\nCreate the comparison sampler for point filtering:\n\n```cpp\nD3D11_SAMPLER_DESC comparisonSamplerDesc;\nZeroMemory(&comparisonSamplerDesc, sizeof(D3D11_SAMPLER_DESC));\ncomparisonSamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_BORDER;\ncomparisonSamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_BORDER;\ncomparisonSamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_BORDER;\ncomparisonSamplerDesc.BorderColor[0] = 1.0f;\ncomparisonSamplerDesc.BorderColor[1] = 1.0f;\ncomparisonSamplerDesc.BorderColor[2] = 1.0f;\ncomparisonSamplerDesc.BorderColor[3] = 1.0f;\ncomparisonSamplerDesc.MinLOD = 0.f;\ncomparisonSamplerDesc.MaxLOD = D3D11_FLOAT32_MAX;\ncomparisonSamplerDesc.MipLODBias = 0.f;\ncomparisonSamplerDesc.MaxAnisotropy = 0;\ncomparisonSamplerDesc.ComparisonFunc = D3D11_COMPARISON_LESS_EQUAL;\ncomparisonSamplerDesc.Filter = D3D11_FILTER_COMPARISON_MIN_MAG_MIP_POINT;\n\n// Point filtered shadows can be faster, and may be a good choice when\n// rendering on hardware with lower feature levels. This sample has a\n// UI option to enable/disable filtering so you can see the difference\n// in quality and speed.\n\nDX::ThrowIfFailed(\n    pD3DDevice->CreateSamplerState(\n        &comparisonSamplerDesc,\n        &m_comparisonSampler_point\n        )\n    );\n```\n\nThen create a sampler for linear filtering:\n\n```cpp\ncomparisonSamplerDesc.Filter = D3D11_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR;\nDX::ThrowIfFailed(\n    pD3DDevice->CreateSamplerState(\n        &comparisonSamplerDesc,\n        &m_comparisonSampler_linear\n        )\n    );\n```\n\nChoose a sampler:\n\n```cpp\nID3D11PixelShader* pixelShader;\nID3D11SamplerState** comparisonSampler;\nif (m_useLinear)\n{\n    pixelShader = m_shadowPixelShader_linear.Get();\n    comparisonSampler = m_comparisonSampler_linear.GetAddressOf();\n}\nelse\n{\n    pixelShader = m_shadowPixelShader_point.Get();\n    comparisonSampler = m_comparisonSampler_point.GetAddressOf();\n}\n\n// Attach our pixel shader.\ncontext->PSSetShader(\n    pixelShader,\n    nullptr,\n    0\n    );\n\ncontext->PSSetSamplers(0, 1, comparisonSampler);\ncontext->PSSetShaderResources(0, 1, m_shadowResourceView.GetAddressOf());\n```\n\nBlend shadow edges with linear filtering:\n\n```cpp\n// Blends the shadow area into the lit area.\nfloat3 light = lighting * (ambient + DplusS(N, L, NdotL, input.view));\nfloat3 shadow = (1.0f - lighting) * ambient;\nreturn float4(input.color * (light + shadow), 1.f);\n```\n\n## Shadow buffer size\n\n\nLarger shadow maps won't look as blocky but they take up more space in graphics memory. Experiment with different shadow map sizes in your game and observe the results in different types of devices and different display sizes. Consider an optimization like cascaded shadow maps to get better results with less graphics memory. See [Common Techniques to Improve Shadow Depth Maps](https://msdn.microsoft.com/library/windows/desktop/ee416324).\n\n## Shadow buffer depth\n\n\nGreater precision in the shadow buffer will give more accurate depth test results, which helps avoid issues like z-buffer fighting. But like larger shadow maps, greater precision takes up more memory. Experiment with different depth precision types in your game - DXGI\\_FORMAT\\_R24G8\\_TYPELESS versus DXGI\\_FORMAT\\_R16\\_TYPELESS - and observe the speed and quality on different feature levels.\n\n## Optimizing precompiled shaders\n\n\nUniversal Windows Platform (UWP) apps can use dynamic shader compilation, but it's faster to use dynamic shader linking. You can also use compiler directives and `#ifdef` blocks to create different versions of shaders. This is done by opening the Visual Studio project file in a text editor and adding multiple `<FxcCompiler>` entries for the HLSL (each with the appropriate preprocessor definitions). Note that this necessitates different filenames; in this case, Visual Studio appends \\_point and \\_linear to the different versions of the shader.\n\nThe project file entry for the linear filtered version of the shader defines LINEAR:\n\n```\n<FxCompile Include=\"Content\\ShadowPixelShader.hlsl\">\n  <ShaderType Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">Pixel</ShaderType>\n  <ShaderType Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">Pixel</ShaderType>\n  <ShaderType Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Pixel</ShaderType>\n  <ShaderType Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">Pixel</ShaderType>\n  <ShaderType Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Pixel</ShaderType>\n  <ShaderType Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">Pixel</ShaderType>\n  <DisableOptimizations Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">false</DisableOptimizations>\n  <EnableDebuggingInformation Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">true</EnableDebuggingInformation>\n  <DisableOptimizations Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">false</DisableOptimizations>\n  <DisableOptimizations Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">false</DisableOptimizations>\n  <ObjectFileOutput Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">$(OutDir)%(Filename)_linear.cso</ObjectFileOutput>\n  <ObjectFileOutput Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">$(OutDir)%(Filename)_linear.cso</ObjectFileOutput>\n  <ObjectFileOutput Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">$(OutDir)%(Filename)_linear.cso</ObjectFileOutput>\n  <ObjectFileOutput Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">$(OutDir)%(Filename)_linear.cso</ObjectFileOutput>\n  <ObjectFileOutput Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">$(OutDir)%(Filename)_linear.cso</ObjectFileOutput>\n  <ObjectFileOutput Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">$(OutDir)%(Filename)_linear.cso</ObjectFileOutput>\n  <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">LINEAR</PreprocessorDefinitions>\n  <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">LINEAR</PreprocessorDefinitions>\n  <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">LINEAR</PreprocessorDefinitions>\n  <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">LINEAR</PreprocessorDefinitions>\n  <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">LINEAR</PreprocessorDefinitions>\n  <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">LINEAR</PreprocessorDefinitions>\n</FxCompile>\n```\n\nThe project file entry for the linear filtered version of the shader does not include preprocessor definitions:\n\n```\n<FxCompile Include=\"Content\\ShadowPixelShader.hlsl\">\n  <ShaderType Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">Pixel</ShaderType>\n  <ShaderType Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">Pixel</ShaderType>\n  <ShaderType Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Pixel</ShaderType>\n  <ShaderType Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">Pixel</ShaderType>\n  <ShaderType Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Pixel</ShaderType>\n  <ShaderType Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">Pixel</ShaderType>\n  <DisableOptimizations Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">false</DisableOptimizations>\n  <EnableDebuggingInformation Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">true</EnableDebuggingInformation>\n  <DisableOptimizations Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">false</DisableOptimizations>\n  <DisableOptimizations Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">false</DisableOptimizations>\n  <ObjectFileOutput Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">$(OutDir)%(Filename)_point.cso</ObjectFileOutput>\n  <ObjectFileOutput Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">$(OutDir)%(Filename)_point.cso</ObjectFileOutput>\n  <ObjectFileOutput Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">$(OutDir)%(Filename)_point.cso</ObjectFileOutput>\n  <ObjectFileOutput Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">$(OutDir)%(Filename)_point.cso</ObjectFileOutput>\n  <ObjectFileOutput Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">$(OutDir)%(Filename)_point.cso</ObjectFileOutput>\n  <ObjectFileOutput Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">$(OutDir)%(Filename)_point.cso</ObjectFileOutput>\n</FxCompile>\n```\n\n \n\n \n\n\n\n\n"}