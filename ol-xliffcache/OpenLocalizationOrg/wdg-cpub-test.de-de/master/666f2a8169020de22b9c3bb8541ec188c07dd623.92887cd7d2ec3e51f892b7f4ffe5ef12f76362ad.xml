{"nodes":[{"pos":[11,65],"content":"Multisampling in Universal Windows Platform (UWP) apps","needQuote":true,"needEscape":true,"nodes":[{"content":"Multisampling in Universal Windows Platform (UWP) apps","pos":[0,54]}]},{"pos":[79,171],"content":"Learn how to use multisampling in Universal Windows Platform (UWP) apps built with Direct3D.","needQuote":true,"needEscape":true,"nodes":[{"content":"Learn how to use multisampling in Universal Windows Platform (UWP) apps built with Direct3D.","pos":[0,92]}]},{"pos":[323,377],"content":"Multisampling in Universal Windows Platform (UWP) apps"},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[380,418]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[419,514],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Learn how to use multisampling in Universal Windows Platform (UWP) apps built with Direct3D.","pos":[516,608]},{"content":"Multisampling, also known as multi-sample antialiasing, is a graphics technique used to reduce the appearance of aliased edges.","pos":[609,736]},{"content":"It works by drawing more pixels than are actually in the final render target, then averaging values to maintain the appearance of a \"partial\" edge in certain pixels.","pos":[737,902]},{"content":"For a detailed description of how multisampling actually works in Direct3D, see <bpt id=\"p1\">[</bpt>Multisample Anti-Aliasing Rasterization Rules<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/cc627092#Multisample)</ept>.","pos":[903,1104],"source":" For a detailed description of how multisampling actually works in Direct3D, see [Multisample Anti-Aliasing Rasterization Rules](https://msdn.microsoft.com/library/windows/desktop/cc627092#Multisample)."},{"content":"Multisampling and the flip model swap chain","pos":[1109,1152]},{"content":"UWP apps that use DirectX must use flip model swap chains.","pos":[1155,1213]},{"content":"Flip model swap chains don't support multisampling directly, but multisampling can still be applied in a different way by rendering the scene to a multisampled render target view, and then resolving the multisampled render target to the back buffer before presenting.","pos":[1214,1481]},{"content":"This article explains the steps required to add multisampling to your UWP app.","pos":[1482,1560]},{"content":"How to use multisampling","pos":[1566,1590]},{"content":"Direct3D feature levels guarantee support for specific, minimum sample count capabilities, and guarantee certain buffer formats will be available that support multisampling.","pos":[1592,1765]},{"content":"Graphics devices often support a wider range of formats and sample counts than the minimum required.","pos":[1766,1866]},{"content":"Multisampling support can be determined at run-time by checking feature support for multisampling with specific DXGI formats, and then checking the sample counts you can use with each supported format.","pos":[1867,2068]},{"content":"Call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device::CheckFeatureSupport<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476497)</ept> to find out which DXGI formats can be used with multisampling.","pos":[2074,2242],"source":"Call [**ID3D11Device::CheckFeatureSupport**](https://msdn.microsoft.com/library/windows/desktop/ff476497) to find out which DXGI formats can be used with multisampling."},{"content":"Supply the render target formats your game can use.","pos":[2243,2294]},{"content":"Both the render target and resolve target must use the same format, so check for both <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11\\_FORMAT\\_SUPPORT\\_MULTISAMPLE\\_RENDERTARGET<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476134)</ept> and <bpt id=\"p3\">**</bpt>D3D11\\_FORMAT\\_SUPPORT\\_MULTISAMPLE\\_RESOLVE<ept id=\"p3\">**</ept>.","pos":[2295,2551],"source":" Both the render target and resolve target must use the same format, so check for both [**D3D11\\_FORMAT\\_SUPPORT\\_MULTISAMPLE\\_RENDERTARGET**](https://msdn.microsoft.com/library/windows/desktop/ff476134) and **D3D11\\_FORMAT\\_SUPPORT\\_MULTISAMPLE\\_RESOLVE**."},{"content":"**Feature level 9:  ** Although feature level 9 devices <bpt id=\"p1\">[</bpt>guarantee support for multisampled render target formats<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff471324#MultiSample_RenderTarget)</ept>, support is not guaranteed for multisample resolve targets.","pos":[2557,2817],"source":"**Feature level 9:  ** Although feature level 9 devices [guarantee support for multisampled render target formats](https://msdn.microsoft.com/library/windows/desktop/ff471324#MultiSample_RenderTarget), support is not guaranteed for multisample resolve targets."},{"content":"So this check is necessary before trying to use the multisampling technique described in this topic.","pos":[2818,2918]},{"content":"The following code checks multisampling support for all the DXGI\\_FORMAT values:","pos":[2924,3004]},{"pos":[3641,3821],"content":"For each supported format, query for sample count support by calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device::CheckMultisampleQualityLevels<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476499)</ept>.","source":"For each supported format, query for sample count support by calling [**ID3D11Device::CheckMultisampleQualityLevels**](https://msdn.microsoft.com/library/windows/desktop/ff476499)."},{"content":"The following code checks sample size support for supported DXGI formats:","pos":[3827,3900]},{"pos":[4563,4767],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   Use <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID3D11Device2::CheckMultisampleQualityLevels1<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/dn280494)</ept> instead if you need to check multisample support for tiled resource buffers.","source":"**Note**   Use [**ID3D11Device2::CheckMultisampleQualityLevels1**](https://msdn.microsoft.com/library/windows/desktop/dn280494) instead if you need to check multisample support for tiled resource buffers."},{"content":"Create a buffer and render target view with the desired sample count.","pos":[4780,4849]},{"content":"Use the same DXGI\\_FORMAT, width, and height as the swap chain, but specify a sample count greater than 1 and use a multisampled texture dimension (<bpt id=\"p1\">**</bpt>D3D11\\_RTV\\_DIMENSION\\_TEXTURE2DMS<ept id=\"p1\">**</ept> for example).","pos":[4850,5050],"source":" Use the same DXGI\\_FORMAT, width, and height as the swap chain, but specify a sample count greater than 1 and use a multisampled texture dimension (**D3D11\\_RTV\\_DIMENSION\\_TEXTURE2DMS** for example)."},{"content":"If necessary, you can re-create the swap chain with new settings that are optimal for multisampling.","pos":[5051,5151]},{"content":"The following code creates a multisampled render target:","pos":[5157,5213]},{"content":"The depth buffer must have the same width, height, sample count, and texture dimension to match the multisampled render target.","pos":[6426,6553]},{"content":"The following code creates a multisampled depth buffer:","pos":[6559,6614]},{"content":"Now is a good time to create the viewport, because the viewport width and height must also match the render target.","pos":[7566,7681]},{"content":"The following code creates a viewport:","pos":[7687,7725]},{"content":"Render each frame to the multisampled render target.","pos":[8029,8081]},{"content":"When rendering is complete, call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::ResolveSubresource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476474)</ept> before presenting the frame.","pos":[8082,8250],"source":" When rendering is complete, call [**ID3D11DeviceContext::ResolveSubresource**](https://msdn.microsoft.com/library/windows/desktop/ff476474) before presenting the frame."},{"content":"This instructs Direct3D to peform the multisampling operation, computing the value of each pixel for display and placing the result in the back buffer.","pos":[8251,8402]},{"content":"The back buffer then contains the final anti-aliased image and can be presented.","pos":[8403,8483]},{"content":"The following code resolves the subresource before presenting the frame:","pos":[8489,8561]}],"content":"---\ntitle: Multisampling in Universal Windows Platform (UWP) apps\ndescription: Learn how to use multisampling in Universal Windows Platform (UWP) apps built with Direct3D.\nms.assetid: 1cd482b8-32ff-1eb0-4c91-83eb52f08484\n---\n\n# <span id=\"dev_gaming.multisampling__multi-sample_anti_aliasing__in_windows_store_apps\"></span> Multisampling in Universal Windows Platform (UWP) apps\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nLearn how to use multisampling in Universal Windows Platform (UWP) apps built with Direct3D. Multisampling, also known as multi-sample antialiasing, is a graphics technique used to reduce the appearance of aliased edges. It works by drawing more pixels than are actually in the final render target, then averaging values to maintain the appearance of a \"partial\" edge in certain pixels. For a detailed description of how multisampling actually works in Direct3D, see [Multisample Anti-Aliasing Rasterization Rules](https://msdn.microsoft.com/library/windows/desktop/cc627092#Multisample).\n\n## Multisampling and the flip model swap chain\n\n\nUWP apps that use DirectX must use flip model swap chains. Flip model swap chains don't support multisampling directly, but multisampling can still be applied in a different way by rendering the scene to a multisampled render target view, and then resolving the multisampled render target to the back buffer before presenting. This article explains the steps required to add multisampling to your UWP app.\n\n### How to use multisampling\n\nDirect3D feature levels guarantee support for specific, minimum sample count capabilities, and guarantee certain buffer formats will be available that support multisampling. Graphics devices often support a wider range of formats and sample counts than the minimum required. Multisampling support can be determined at run-time by checking feature support for multisampling with specific DXGI formats, and then checking the sample counts you can use with each supported format.\n\n1.  Call [**ID3D11Device::CheckFeatureSupport**](https://msdn.microsoft.com/library/windows/desktop/ff476497) to find out which DXGI formats can be used with multisampling. Supply the render target formats your game can use. Both the render target and resolve target must use the same format, so check for both [**D3D11\\_FORMAT\\_SUPPORT\\_MULTISAMPLE\\_RENDERTARGET**](https://msdn.microsoft.com/library/windows/desktop/ff476134) and **D3D11\\_FORMAT\\_SUPPORT\\_MULTISAMPLE\\_RESOLVE**.\n\n    **Feature level 9:  ** Although feature level 9 devices [guarantee support for multisampled render target formats](https://msdn.microsoft.com/library/windows/desktop/ff471324#MultiSample_RenderTarget), support is not guaranteed for multisample resolve targets. So this check is necessary before trying to use the multisampling technique described in this topic.\n\n    The following code checks multisampling support for all the DXGI\\_FORMAT values:\n\n    ```cpp\n    // Determine the format support for multisampling.\n    for (UINT i = 1; i < DXGI_FORMAT_MAX; i++)\n    {\n        DXGI_FORMAT inFormat = safe_cast<DXGI_FORMAT>(i);\n        UINT formatSupport = 0;\n        HRESULT hr = m_d3dDevice->CheckFormatSupport(inFormat, &formatSupport);\n\n        if ((formatSupport & D3D11_FORMAT_SUPPORT_MULTISAMPLE_RESOLVE) &&\n            (formatSupport & D3D11_FORMAT_SUPPORT_MULTISAMPLE_RENDERTARGET)\n            )\n        {\n            m_supportInfo->SetFormatSupport(i, true);\n        }\n        else\n        {\n            m_supportInfo->SetFormatSupport(i, false);\n        }\n    }\n    ```\n\n2.  For each supported format, query for sample count support by calling [**ID3D11Device::CheckMultisampleQualityLevels**](https://msdn.microsoft.com/library/windows/desktop/ff476499).\n\n    The following code checks sample size support for supported DXGI formats:\n\n    ```cpp\n    // Find available sample sizes for each supported format.\n    for (unsigned int i = 0; i < DXGI_FORMAT_MAX; i++)\n    {\n        for (unsigned int j = 1; j < MAX_SAMPLES_CHECK; j++)\n        {\n            UINT numQualityFlags;\n\n            HRESULT test = m_d3dDevice->CheckMultisampleQualityLevels(\n                (DXGI_FORMAT) i,\n                j,\n                &numQualityFlags\n                );\n\n            if (SUCCEEDED(test) && (numQualityFlags > 0))\n            {\n                m_supportInfo->SetSampleSize(i, j, 1);\n                m_supportInfo->SetQualityFlagsAt(i, j, numQualityFlags);\n            }\n        }\n    }\n    ```\n\n    > **Note**   Use [**ID3D11Device2::CheckMultisampleQualityLevels1**](https://msdn.microsoft.com/library/windows/desktop/dn280494) instead if you need to check multisample support for tiled resource buffers.\n\n     \n\n3.  Create a buffer and render target view with the desired sample count. Use the same DXGI\\_FORMAT, width, and height as the swap chain, but specify a sample count greater than 1 and use a multisampled texture dimension (**D3D11\\_RTV\\_DIMENSION\\_TEXTURE2DMS** for example). If necessary, you can re-create the swap chain with new settings that are optimal for multisampling.\n\n    The following code creates a multisampled render target:\n\n    ```cpp\n    float widthMulti = m_d3dRenderTargetSize.Width;\n    float heightMulti = m_d3dRenderTargetSize.Height;\n\n    D3D11_TEXTURE2D_DESC offScreenSurfaceDesc;\n    ZeroMemory(&offScreenSurfaceDesc, sizeof(D3D11_TEXTURE2D_DESC));\n\n    offScreenSurfaceDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;\n    offScreenSurfaceDesc.Width = static_cast<UINT>(widthMulti);\n    offScreenSurfaceDesc.Height = static_cast<UINT>(heightMulti);\n    offScreenSurfaceDesc.BindFlags = D3D11_BIND_RENDER_TARGET;\n    offScreenSurfaceDesc.MipLevels = 1;\n    offScreenSurfaceDesc.ArraySize = 1;\n    offScreenSurfaceDesc.SampleDesc.Count = m_sampleSize;\n    offScreenSurfaceDesc.SampleDesc.Quality = m_qualityFlags;\n\n    // Create a surface that's multisampled.\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateTexture2D(\n        &offScreenSurfaceDesc,\n        nullptr,\n        &m_offScreenSurface)\n        );\n\n    // Create a render target view. \n    CD3D11_RENDER_TARGET_VIEW_DESC renderTargetViewDesc(D3D11_RTV_DIMENSION_TEXTURE2DMS);\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateRenderTargetView(\n        m_offScreenSurface.Get(),\n        &renderTargetViewDesc,\n        &m_d3dRenderTargetView\n        )\n        );\n    ```\n\n4.  The depth buffer must have the same width, height, sample count, and texture dimension to match the multisampled render target.\n\n    The following code creates a multisampled depth buffer:\n\n    ```cpp\n    // Create a depth stencil view for use with 3D rendering if needed.\n    CD3D11_TEXTURE2D_DESC depthStencilDesc(\n        DXGI_FORMAT_D24_UNORM_S8_UINT,\n        static_cast<UINT>(widthMulti),\n        static_cast<UINT>(heightMulti),\n        1, // This depth stencil view has only one texture.\n        1, // Use a single mipmap level.\n        D3D11_BIND_DEPTH_STENCIL,\n        D3D11_USAGE_DEFAULT,\n        0,\n        m_sampleSize,\n        m_qualityFlags\n        );\n\n    ComPtr<ID3D11Texture2D> depthStencil;\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateTexture2D(\n        &depthStencilDesc,\n        nullptr,\n        &depthStencil\n        )\n        );\n\n    CD3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc(D3D11_DSV_DIMENSION_TEXTURE2DMS);\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateDepthStencilView(\n        depthStencil.Get(),\n        &depthStencilViewDesc,\n        &m_d3dDepthStencilView\n        )\n        );\n    ```\n\n5.  Now is a good time to create the viewport, because the viewport width and height must also match the render target.\n\n    The following code creates a viewport:\n\n    ```cpp\n    // Set the 3D rendering viewport to target the entire window.\n    m_screenViewport = CD3D11_VIEWPORT(\n        0.0f,\n        0.0f,\n        widthMulti / m_scalingFactor,\n        heightMulti / m_scalingFactor\n        );\n\n    m_d3dContext->RSSetViewports(1, &m_screenViewport);\n    ```\n\n6.  Render each frame to the multisampled render target. When rendering is complete, call [**ID3D11DeviceContext::ResolveSubresource**](https://msdn.microsoft.com/library/windows/desktop/ff476474) before presenting the frame. This instructs Direct3D to peform the multisampling operation, computing the value of each pixel for display and placing the result in the back buffer. The back buffer then contains the final anti-aliased image and can be presented.\n\n    The following code resolves the subresource before presenting the frame:\n\n    ```cpp\n    if (m_sampleSize > 1)\n    {\n        unsigned int sub = D3D11CalcSubresource(0, 0, 1);\n\n        m_d3dContext->ResolveSubresource(\n            m_backBuffer.Get(),\n            sub,\n            m_offScreenSurface.Get(),\n            sub,\n            DXGI_FORMAT_B8G8R8A8_UNORM\n            );\n    }\n\n    // The first argument instructs DXGI to block until VSync, putting the application\n    // to sleep until the next VSync. This ensures that we don't waste any cycles rendering\n    // frames that will never be displayed to the screen.\n    hr = m_swapChain->Present(1, 0);\n    ```\n\n \n\n \n\n\n\n\n"}