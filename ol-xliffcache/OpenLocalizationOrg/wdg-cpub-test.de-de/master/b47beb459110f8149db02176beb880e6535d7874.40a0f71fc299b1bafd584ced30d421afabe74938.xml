{"nodes":[{"pos":[11,33],"content":"GLSL-to-HLSL reference","needQuote":true,"needEscape":true,"nodes":[{"content":"GLSL-to-HLSL reference","pos":[0,22]}]},{"pos":[47,277],"content":"You port your OpenGL Shader Language (GLSL) code to Microsoft High Level Shader Language (HLSL) code when you port your graphics architecture from OpenGL ES 2.0 to Direct3D 11 to create a game for Universal Windows Platform (UWP).","needQuote":true,"needEscape":true,"nodes":[{"content":"You port your OpenGL Shader Language (GLSL) code to Microsoft High Level Shader Language (HLSL) code when you port your graphics architecture from OpenGL ES 2.0 to Direct3D 11 to create a game for Universal Windows Platform (UWP).","pos":[0,230]}]},{"content":"GLSL-to-HLSL reference","pos":[334,356]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[359,397]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[398,493],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"You port your OpenGL Shader Language (GLSL) code to Microsoft High Level Shader Language (HLSL) code when you <bpt id=\"p1\">[</bpt>port your graphics architecture from OpenGL ES 2.0 to Direct3D 11<ept id=\"p1\">](port-from-opengl-es-2-0-to-directx-11-1.md)</ept> to create a game for Universal Windows Platform (UWP).","pos":[495,771],"source":"You port your OpenGL Shader Language (GLSL) code to Microsoft High Level Shader Language (HLSL) code when you [port your graphics architecture from OpenGL ES 2.0 to Direct3D 11](port-from-opengl-es-2-0-to-directx-11-1.md) to create a game for Universal Windows Platform (UWP)."},{"content":"The GLSL that is referred to herein is compatible with OpenGL ES 2.0; the HLSL is compatible with Direct3D 11.","pos":[772,882]},{"content":"For info about the differences between Direct3D 11 and previous versions of Direct3D, see <bpt id=\"p1\">[</bpt>Feature mapping<ept id=\"p1\">](feature-mapping.md)</ept>.","pos":[883,1011],"source":" For info about the differences between Direct3D 11 and previous versions of Direct3D, see [Feature mapping](feature-mapping.md)."},{"content":"Comparing OpenGL ES 2.0 with Direct3D 11","pos":[1018,1058]},{"content":"Porting GLSL variables to HLSL","pos":[1075,1105]},{"content":"Porting GLSL types to HLSL","pos":[1124,1150]},{"content":"Porting GLSL pre-defined global variables to HLSL","pos":[1165,1214]},{"content":"Examples of porting GLSL variables to HLSL","pos":[1273,1315]},{"content":"Uniform, attribute, and varying in GLSL","pos":[1337,1376]},{"content":"Constant buffers and data transfers in HLSL","pos":[1430,1473]},{"content":"Examples of porting OpenGL rendering code to Direct3D","pos":[1526,1579]},{"content":"Related topics","pos":[1597,1611]},{"content":"Comparing OpenGL ES 2.0 with Direct3D 11","pos":[1634,1674]},{"content":"OpenGL ES 2.0 and Direct3D 11 have many similarities.","pos":[1677,1730]},{"content":"They both have similar rendering pipelines and graphics features.","pos":[1731,1796]},{"content":"But Direct3D 11 is a rendering implementation and API, not a specification; OpenGL ES 2.0 is a rendering specification and API, not an implementation.","pos":[1797,1947]},{"content":"Direct3D 11 and OpenGL ES 2.0 generally differ in these ways:","pos":[1948,2009]},{"content":"OpenGL ES 2.0","pos":[2013,2026]},{"content":"Direct3D 11","pos":[2117,2128]},{"content":"Hardware and operating system agnostic specification with vendor provided implementations","pos":[2467,2556]},{"content":"Microsoft implementation of hardware abstraction and certification on Windows platforms","pos":[2571,2658]},{"content":"Abstracted for hardware diversity, runtime manages most resources","pos":[2694,2759]},{"content":"Direct access to hardware layout; app can manage resources and processing","pos":[2798,2871]},{"content":"Provides higher-level modules via third-party libraries (for example, Simple DirectMedia Layer (SDL))","pos":[2921,3022]},{"content":"Higher-level modules, like Direct2D, are built upon lower modules to simplify development for Windows apps","pos":[3025,3131]},{"content":"Hardware vendors differentiate via extensions","pos":[3148,3193]},{"content":"Microsoft adds optional features to the API in a generic way so they aren't specific to any particular hardware vendor","pos":[3252,3370]},{"content":"GLSL and HLSL generally differ in these ways:","pos":[3377,3422]},{"content":"GLSL","pos":[3540,3544]},{"content":"HLSL","pos":[3567,3571]},{"content":"Procedural, step-centric (C like)","pos":[3634,3667]},{"content":"Object oriented, data-centric (C++ like)","pos":[3690,3730]},{"content":"Shader compilation integrated into the graphics API","pos":[3777,3828]},{"content":"The HLSL compiler <bpt id=\"p1\">[</bpt>compiles the shader<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509633)</ept> to an intermediate binary representation before Direct3D passes it to the driver.","pos":[3851,4033],"source":"The HLSL compiler [compiles the shader](https://msdn.microsoft.com/library/windows/desktop/bb509633) to an intermediate binary representation before Direct3D passes it to the driver."},{"content":"Note<ph id=\"ph1\">&lt;/strong&gt;</ph>  This binary representation is hardware independent.","pos":[4062,4128],"source":"Note</strong>  This binary representation is hardware independent."},{"content":"It's typically compiled at app build time, rather than at app run time.","pos":[4129,4200]},{"content":"<bpt id=\"p1\">[</bpt>Variable<ept id=\"p1\">](#variables)</ept> storage modifiers","pos":[4268,4308],"source":"[Variable](#variables) storage modifiers"},{"content":"Constant buffers and data transfers via input layout declarations","pos":[4331,4396]},{"content":"Types","pos":[4447,4452]},{"content":"Typical vector type: vec2/3/4","pos":[4469,4498]},{"content":"lowp, mediump, highp","pos":[4506,4526]},{"content":"Typical vector type: float2/3/4","pos":[4556,4587]},{"content":"min10float, min16float","pos":[4595,4617]},{"content":"texture2D [Function]","pos":[4667,4687]},{"content":"<bpt id=\"p1\">[</bpt>texture.Sample<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509695)</ept> [datatype.Function]","pos":[4710,4807],"source":"[texture.Sample](https://msdn.microsoft.com/library/windows/desktop/bb509695) [datatype.Function]"},{"content":"sampler2D [datatype]","pos":[4854,4874]},{"content":"<bpt id=\"p1\">[</bpt>Texture2D<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff471525)</ept> [datatype]","pos":[4897,4980],"source":"[Texture2D](https://msdn.microsoft.com/library/windows/desktop/ff471525) [datatype]"},{"content":"Row-major matrices (default)","pos":[5026,5054]},{"content":"Column-major matrices (default)","pos":[5077,5108],"source":"Column-major matrices (default)\n"},{"content":"Note<ph id=\"ph1\">&lt;/strong&gt;</ph>   Use the <ph id=\"ph2\">&lt;strong&gt;</ph>row_major<ph id=\"ph3\">&lt;/strong&gt;</ph> type-modifier to change the layout for one variable.","pos":[5137,5240],"source":"Note</strong>   Use the <strong>row_major</strong> type-modifier to change the layout for one variable."},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Variable Syntax<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509706)</ept>.","pos":[5241,5339],"source":" For more info, see [Variable Syntax](https://msdn.microsoft.com/library/windows/desktop/bb509706)."},{"content":"You can also specify a compiler flag or a pragma to change the global default.","pos":[5340,5418]},{"content":"Fragment shader","pos":[5487,5502]},{"content":"Pixel shader","pos":[5525,5537]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  HLSL has textures and samplers as two separate objects.","pos":[5573,5638],"source":"**Note**  HLSL has textures and samplers as two separate objects."},{"content":"In GLSL, like Direct3D 9, the texture binding is part of the sampler state.","pos":[5639,5714]},{"content":"In GLSL, you present much of the OpenGL state as pre-defined global variables.","pos":[5719,5797]},{"content":"For example, with GLSL, you use the <bpt id=\"p1\">**</bpt>gl\\_Position<ept id=\"p1\">**</ept> variable to specify vertex position and the <bpt id=\"p2\">**</bpt>gl\\_FragColor<ept id=\"p2\">**</ept> variable to specify fragment color.","pos":[5798,5948],"source":" For example, with GLSL, you use the **gl\\_Position** variable to specify vertex position and the **gl\\_FragColor** variable to specify fragment color."},{"content":"In HLSL, you pass Direct3D state explicitly from the app code to the shader.","pos":[5949,6025]},{"content":"For example, with Direct3D and HLSL, the input to the vertex shader must match the data format in the vertex buffer, and the structure of a constant buffer in the app code must match the structure of a constant buffer (<bpt id=\"p1\">[</bpt>cbuffer<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509581)</ept>) in shader code.","pos":[6026,6332],"source":" For example, with Direct3D and HLSL, the input to the vertex shader must match the data format in the vertex buffer, and the structure of a constant buffer in the app code must match the structure of a constant buffer ([cbuffer](https://msdn.microsoft.com/library/windows/desktop/bb509581)) in shader code."},{"content":"Porting GLSL variables to HLSL","pos":[6337,6367]},{"content":"In GLSL, you apply modifiers (qualifiers) to a global shader variable declaration to give that variable a specific behavior in your shaders.","pos":[6370,6510]},{"content":"In HLSL, you don’t need these modifiers because you define the flow of the shader with the arguments that you pass to your shader and that you return from your shader.","pos":[6511,6678]},{"content":"GLSL variable behavior","pos":[6796,6818]},{"content":"HLSL equivalent","pos":[6841,6856]},{"content":"uniform","pos":[6930,6937]},{"content":"You pass a uniform variable from the app code into either or both vertex and fragment shaders.","pos":[6954,7048]},{"content":"You must set the values of all uniforms before you draw any triangles with those shaders so their values stay the same throughout the drawing of a triangle mesh.","pos":[7049,7210]},{"content":"These values are uniform.","pos":[7211,7236]},{"content":"Some uniforms are set for the entire frame and others uniquely to one particular vertex-pixel shader pair.","pos":[7237,7343]},{"content":"Uniform variables are per-polygon variables.","pos":[7351,7395]},{"content":"Use constant buffer.","pos":[7425,7445]},{"content":"See <bpt id=\"p1\">[</bpt>How to: Create a Constant Buffer<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476896)</ept> and <bpt id=\"p2\">[</bpt>Shader Constants<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/bb509581)</ept>.","pos":[7453,7637],"source":"See [How to: Create a Constant Buffer](https://msdn.microsoft.com/library/windows/desktop/ff476896) and [Shader Constants](https://msdn.microsoft.com/library/windows/desktop/bb509581)."},{"content":"varying","pos":[7699,7706]},{"content":"You initialize a varying variable inside the vertex shader and pass it through to an identically named varying variable in the fragment shader.","pos":[7723,7866]},{"content":"Because the vertex shader only sets the value of the varying variables at each vertex, the rasterizer interpolates those values (in a perspective-correct manner) to generate per fragment values to pass into the fragment shader.","pos":[7867,8094]},{"content":"These variables vary across each triangle.","pos":[8095,8137]},{"content":"Use the structure that you return from your vertex shader as the input to your pixel shader.","pos":[8164,8256]},{"content":"Make sure the semantic values match.","pos":[8257,8293]},{"content":"attribute","pos":[8350,8359]},{"content":"An attribute is a part of the description of a vertex that you pass from the app code to the vertex shader alone.","pos":[8376,8489]},{"content":"Unlike a uniform, you set each attribute’s value for each vertex, which, in turn, allows each vertex to have a different value.","pos":[8490,8617]},{"content":"Attribute variables are per-vertex variables.","pos":[8618,8663]},{"content":"Define a vertex buffer in your Direct3D app code and match it to the vertex input defined in the vertex shader.","pos":[8693,8804]},{"content":"Optionally, define an index buffer.","pos":[8805,8840]},{"content":"See <bpt id=\"p1\">[</bpt>How to: Create a Vertex Buffer<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476899)</ept> and <bpt id=\"p2\">[</bpt>How to: Create an Index Buffer<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476897)</ept>.","pos":[8841,9037],"source":" See [How to: Create a Vertex Buffer](https://msdn.microsoft.com/library/windows/desktop/ff476899) and [How to: Create an Index Buffer](https://msdn.microsoft.com/library/windows/desktop/ff476897)."},{"content":"Create an input layout in your Direct3D app code and match semantic values with those in the vertex input.","pos":[9045,9151]},{"content":"See <bpt id=\"p1\">[</bpt>Create the input layout<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb205117#Create_the_Input_Layout)</ept>.","pos":[9152,9267],"source":" See [Create the input layout](https://msdn.microsoft.com/library/windows/desktop/bb205117#Create_the_Input_Layout)."},{"content":"const","pos":[9329,9334]},{"content":"Constants that are compiled into the shader and never change.","pos":[9351,9412]},{"content":"Use a <ph id=\"ph1\">&lt;strong&gt;</ph>static const<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[9439,9475],"source":"Use a <strong>static const</strong>."},{"content":"static<ph id=\"ph1\">&lt;/strong&gt;</ph> means the value isn't exposed to constant buffers, <ph id=\"ph2\">&lt;strong&gt;</ph>const<ph id=\"ph3\">&lt;/strong&gt;</ph> means the shader can't change the value.","pos":[9484,9614],"source":"static</strong> means the value isn't exposed to constant buffers, <strong>const</strong> means the shader can't change the value."},{"content":"So, the value is known at compile time based on its initializer.","pos":[9615,9679]},{"content":"In GLSL, variables without modifiers are just ordinary global variables that are private to each shader.","pos":[9713,9817]},{"pos":[9819,10117],"content":"When you pass data to textures (<bpt id=\"p1\">[</bpt>Texture2D<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff471525)</ept> in HLSL) and their associated samplers (<bpt id=\"p2\">[</bpt>SamplerState<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/bb509644)</ept> in HLSL), you typically declare them as global variables in the pixel shader.","source":"When you pass data to textures ([Texture2D](https://msdn.microsoft.com/library/windows/desktop/ff471525) in HLSL) and their associated samplers ([SamplerState](https://msdn.microsoft.com/library/windows/desktop/bb509644) in HLSL), you typically declare them as global variables in the pixel shader."},{"content":"Porting GLSL types to HLSL","pos":[10122,10148]},{"content":"Use this table to port your GLSL types to HLSL.","pos":[10151,10198]},{"content":"GLSL type","pos":[10316,10325]},{"content":"HLSL type","pos":[10348,10357]},{"content":"scalar types: float, int, bool","pos":[10420,10450]},{"content":"scalar types: float, int, bool","pos":[10476,10506]},{"content":"also, uint, double","pos":[10514,10532]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Scalar Types<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509646)</ept>.","pos":[10540,10635],"source":"For more info, see [Scalar Types](https://msdn.microsoft.com/library/windows/desktop/bb509646)."},{"content":"vector type","pos":[10689,10700]},{"content":"floating-point vector: vec2, vec3, vec4","pos":[10714,10753]},{"content":"Boolean vector: bvec2, bvec3, bvec4","pos":[10763,10798]},{"content":"signed integer vector: ivec2, ivec3, ivec4","pos":[10808,10850]},{"content":"vector type","pos":[10887,10898]},{"content":"float2, float3, float4, and float1","pos":[10912,10946]},{"content":"bool2, bool3, bool4, and bool1","pos":[10956,10986]},{"content":"int2, int3, int4, and int1","pos":[10996,11022]},{"content":"These types also have vector expansions similar to float, bool, and int:","pos":[11035,11107]},{"content":"uint","pos":[11121,11125]},{"content":"min10float, min16float","pos":[11135,11157]},{"content":"min12int, min16int","pos":[11167,11185]},{"content":"min16uint","pos":[11195,11204]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Vector Type<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509707)</ept> and <bpt id=\"p2\">[</bpt>Keywords<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/bb509568)</ept>.","pos":[11230,11400],"source":"For more info, see [Vector Type](https://msdn.microsoft.com/library/windows/desktop/bb509707) and [Keywords](https://msdn.microsoft.com/library/windows/desktop/bb509568)."},{"content":"vector is also type defined as float4 (typedef vector <ph id=\"ph1\">&amp;lt;</ph>float, 4<ph id=\"ph2\">&amp;gt;</ph> vector;).","pos":[11408,11488],"source":"vector is also type defined as float4 (typedef vector &lt;float, 4&gt; vector;)."},{"content":"For more info, see <bpt id=\"p1\">[</bpt>User-Defined Type<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509702)</ept>.","pos":[11489,11589],"source":" For more info, see [User-Defined Type](https://msdn.microsoft.com/library/windows/desktop/bb509702)."},{"content":"matrix type","pos":[11642,11653]},{"content":"mat2: 2x2 float matrix","pos":[11667,11689]},{"content":"mat3: 3x3 float matrix","pos":[11699,11721]},{"content":"mat4: 4x4 float matrix","pos":[11731,11753]},{"content":"matrix type","pos":[11790,11801]},{"content":"float2x2","pos":[11815,11823]},{"content":"float3x3","pos":[11833,11841]},{"content":"float4x4","pos":[11851,11859]},{"content":"also, float1x1, float1x2, float1x3, float1x4, float2x1, float2x3, float2x4, float3x1, float3x2, float3x4, float4x1, float4x2, float4x3","pos":[11869,12003]},{"content":"These types also have matrix expansions similar to float:","pos":[12016,12073]},{"content":"int, uint, bool","pos":[12087,12102]},{"content":"min10float, min16float","pos":[12112,12134]},{"content":"min12int, min16int","pos":[12144,12162]},{"content":"min16uint","pos":[12172,12181]},{"content":"You can also use the <bpt id=\"p1\">[</bpt>matrix type<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509623)</ept> to define a matrix.","pos":[12207,12322],"source":"You can also use the [matrix type](https://msdn.microsoft.com/library/windows/desktop/bb509623) to define a matrix."},{"content":"For example: matrix <ph id=\"ph1\">&amp;lt;</ph>float, 2, 2<ph id=\"ph2\">&amp;gt;</ph> fMatrix = {0.0f, 0.1, 2.1f, 2.2f};","pos":[12330,12404],"source":"For example: matrix &lt;float, 2, 2&gt; fMatrix = {0.0f, 0.1, 2.1f, 2.2f};"},{"content":"matrix is also type defined as float4x4 (typedef matrix <ph id=\"ph1\">&amp;lt;</ph>float, 4, 4<ph id=\"ph2\">&amp;gt;</ph> matrix;).","pos":[12412,12497],"source":"matrix is also type defined as float4x4 (typedef matrix &lt;float, 4, 4&gt; matrix;)."},{"content":"For more info, see <bpt id=\"p1\">[</bpt>User-Defined Type<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509702)</ept>.","pos":[12498,12598],"source":" For more info, see [User-Defined Type](https://msdn.microsoft.com/library/windows/desktop/bb509702)."},{"content":"precision qualifiers for float, int, sampler","pos":[12652,12696]},{"content":"highp","pos":[12713,12718]},{"content":"This qualifier provides minimum precision requirements that are greater than that provided by min16float and less than a full 32-bit float.","pos":[12726,12865]},{"content":"Equivalent in HLSL is:","pos":[12866,12888]},{"content":"highp float -<ph id=\"ph1\">&amp;gt;</ph> float","pos":[12896,12919],"source":"highp float -&gt; float"},{"content":"highp int -<ph id=\"ph1\">&amp;gt;</ph> int","pos":[12927,12946],"source":"highp int -&gt; int"},{"content":"mediump","pos":[12963,12970]},{"content":"This qualifier applied to float and int is equivalent to min16float and min12int in HLSL.","pos":[12978,13067]},{"content":"Minimum 10 bits of mantissa, not like min10float.","pos":[13068,13117]},{"content":"lowp","pos":[13134,13138]},{"content":"This qualifier applied to float provides a floating point range of -2 to 2.","pos":[13146,13221]},{"content":"Equivalent to min10float in HLSL.","pos":[13222,13255]},{"content":"precision types","pos":[13296,13311]},{"content":"min16float: minimum 16-bit floating point value","pos":[13325,13372]},{"content":"min10float","pos":[13385,13395]},{"content":"Minimum fixed-point signed 2.8 bit value (2 bits of whole number and 8 bits fractional component).","pos":[13403,13501]},{"content":"The 8-bit fractional component can be inclusive of 1 instead of exclusive to give it the full inclusive range of -2 to 2.","pos":[13502,13623]},{"content":"min16int: minimum 16-bit signed integer","pos":[13637,13676]},{"content":"min12int: minimum 12-bit signed integer","pos":[13689,13728]},{"content":"This type is for 10Level9 (<bpt id=\"p1\">[</bpt>9_x feature levels<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476876)</ept>) in which integers are represented by floating point numbers.","pos":[13736,13906],"source":"This type is for 10Level9 ([9_x feature levels](https://msdn.microsoft.com/library/windows/desktop/ff476876)) in which integers are represented by floating point numbers."},{"content":"This is the precision you can get when you emulate an integer with a 16-bit floating point number.","pos":[13907,14005]},{"content":"min16uint: minimum 16-bit unsigned integer","pos":[14019,14061]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Scalar Types<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509646)</ept> and <bpt id=\"p2\">[</bpt>Using HLSL minimum precision<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/hh968108)</ept>.","pos":[14076,14267],"source":"For more info, see [Scalar Types](https://msdn.microsoft.com/library/windows/desktop/bb509646) and [Using HLSL minimum precision](https://msdn.microsoft.com/library/windows/desktop/hh968108)."},{"content":"sampler2D","pos":[14317,14326]},{"content":"Texture2D","pos":[14350,14359]},{"content":"samplerCube","pos":[14468,14479]},{"content":"TextureCube","pos":[14503,14514]},{"content":"Porting GLSL pre-defined global variables to HLSL","pos":[14613,14662]},{"content":"Use this table to port GLSL pre-defined global variables to HLSL.","pos":[14665,14730]},{"content":"GLSL pre-defined global variable","pos":[14848,14880]},{"content":"HLSL semantics","pos":[14903,14917]},{"content":"gl_Position","pos":[14991,15002]},{"content":"This variable is type <ph id=\"ph1\">&lt;strong&gt;</ph>vec4<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[15019,15063],"source":"This variable is type <strong>vec4</strong>."},{"content":"Vertex position","pos":[15071,15086]},{"content":"for example - gl_Position = position;","pos":[15094,15131]},{"content":"SV_Position","pos":[15161,15172]},{"content":"POSITION in Direct3D 9","pos":[15180,15202]},{"content":"This semantic is type <ph id=\"ph1\">&lt;strong&gt;</ph>float4<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[15210,15256],"source":"This semantic is type <strong>float4</strong>."},{"content":"Vertex shader output","pos":[15264,15284]},{"content":"Vertex position","pos":[15292,15307]},{"content":"for example - float4 vPosition : SV_Position;","pos":[15315,15360]},{"content":"gl_PointSize","pos":[15422,15434]},{"content":"This variable is type <ph id=\"ph1\">&lt;strong&gt;</ph>float<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[15451,15496],"source":"This variable is type <strong>float</strong>."},{"content":"Point size","pos":[15504,15514]},{"content":"PSIZE","pos":[15544,15549]},{"content":"No meaning unless you target Direct3D 9","pos":[15557,15596]},{"content":"This semantic is type <ph id=\"ph1\">&lt;strong&gt;</ph>float<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[15604,15649],"source":"This semantic is type <strong>float</strong>."},{"content":"Vertex shader output","pos":[15657,15677]},{"content":"Point size","pos":[15685,15695]},{"content":"gl_FragColor","pos":[15756,15768]},{"content":"This variable is type <ph id=\"ph1\">&lt;strong&gt;</ph>vec4<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[15785,15829],"source":"This variable is type <strong>vec4</strong>."},{"content":"Fragment color","pos":[15837,15851]},{"content":"for example - gl_FragColor = vec4(colorVarying, 1.0);","pos":[15859,15912]},{"content":"SV_Target","pos":[15942,15951]},{"content":"COLOR in Direct3D 9","pos":[15959,15978]},{"content":"This semantic is type <ph id=\"ph1\">&lt;strong&gt;</ph>float4<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[15986,16032],"source":"This semantic is type <strong>float4</strong>."},{"content":"Pixel shader output","pos":[16040,16059]},{"content":"Pixel color","pos":[16067,16078]},{"content":"for example - float4 Color[4] : SV_Target;","pos":[16086,16128]},{"content":"gl_FragData[n]","pos":[16190,16204]},{"content":"This variable is type <ph id=\"ph1\">&lt;strong&gt;</ph>vec4<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[16221,16265],"source":"This variable is type <strong>vec4</strong>."},{"content":"Fragment color for color attachment n","pos":[16273,16310]},{"content":"SV_Target[n]","pos":[16340,16352]},{"content":"This semantic is type <ph id=\"ph1\">&lt;strong&gt;</ph>float4<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[16360,16406],"source":"This semantic is type <strong>float4</strong>."},{"content":"Pixel shader output value that is stored in n render target, where 0 <ph id=\"ph1\">&amp;lt;</ph>= n <ph id=\"ph2\">&amp;lt;</ph>= 7.","pos":[16414,16499],"source":"Pixel shader output value that is stored in n render target, where 0 &lt;= n &lt;= 7."},{"content":"gl_FragCoord","pos":[16560,16572]},{"content":"This variable is type <ph id=\"ph1\">&lt;strong&gt;</ph>vec4<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[16589,16633],"source":"This variable is type <strong>vec4</strong>."},{"content":"Fragment position within frame buffer","pos":[16641,16678]},{"content":"SV_Position","pos":[16708,16719]},{"content":"Not available in Direct3D 9","pos":[16727,16754]},{"content":"This semantic is type <ph id=\"ph1\">&lt;strong&gt;</ph>float4<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[16762,16808],"source":"This semantic is type <strong>float4</strong>."},{"content":"Pixel shader input","pos":[16816,16834]},{"content":"Screen space coordinates","pos":[16842,16866]},{"content":"for example - float4 screenSpace : SV_Position","pos":[16874,16920]},{"content":"gl_FrontFacing","pos":[16982,16996]},{"content":"This variable is type <ph id=\"ph1\">&lt;strong&gt;</ph>bool<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[17013,17057],"source":"This variable is type <strong>bool</strong>."},{"content":"Determines whether fragment belongs to a front-facing primitive.","pos":[17065,17129]},{"content":"SV_IsFrontFace","pos":[17159,17173]},{"content":"VFACE in Direct3D 9","pos":[17181,17200]},{"content":"SV_IsFrontFace is type <ph id=\"ph1\">&lt;strong&gt;</ph>bool<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[17208,17253],"source":"SV_IsFrontFace is type <strong>bool</strong>."},{"content":"VFACE is type <ph id=\"ph1\">&lt;strong&gt;</ph>float<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[17261,17298],"source":"VFACE is type <strong>float</strong>."},{"content":"Pixel shader input","pos":[17306,17324]},{"content":"Primitive facing","pos":[17332,17348]},{"content":"gl_PointCoord","pos":[17409,17422]},{"content":"This variable is type <ph id=\"ph1\">&lt;strong&gt;</ph>vec2<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[17439,17483],"source":"This variable is type <strong>vec2</strong>."},{"content":"Fragment position within a point (point rasterization only)","pos":[17491,17550]},{"content":"SV_Position","pos":[17580,17591]},{"content":"VPOS in Direct3D 9","pos":[17599,17617]},{"content":"SV_Position is type <ph id=\"ph1\">&lt;strong&gt;</ph>float4<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[17625,17669],"source":"SV_Position is type <strong>float4</strong>."},{"content":"VPOS is type <ph id=\"ph1\">&lt;strong&gt;</ph>float2<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[17677,17714],"source":"VPOS is type <strong>float2</strong>."},{"content":"Pixel shader input","pos":[17722,17740]},{"content":"The pixel or sample position in screen space","pos":[17748,17792]},{"content":"for example - float4 pos : SV_Position","pos":[17800,17838]},{"content":"gl_FragDepth","pos":[17900,17912]},{"content":"This variable is type <ph id=\"ph1\">&lt;strong&gt;</ph>float<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[17929,17974],"source":"This variable is type <strong>float</strong>."},{"content":"Depth buffer data","pos":[17982,17999]},{"content":"SV_Depth","pos":[18029,18037]},{"content":"DEPTH in Direct3D 9","pos":[18045,18064]},{"content":"SV_Depth is type <ph id=\"ph1\">&lt;strong&gt;</ph>float<ph id=\"ph2\">&lt;/strong&gt;</ph>.","pos":[18072,18112],"source":"SV_Depth is type <strong>float</strong>."},{"content":"Pixel shader output","pos":[18120,18139]},{"content":"Depth buffer data","pos":[18147,18164]},{"content":"You use semantics to specify position, color, and so on for vertex shader input and pixel shader input.","pos":[18202,18305]},{"content":"You must match the semantics values in the input layout with the vertex shader input.","pos":[18306,18391]},{"content":"For examples, see <bpt id=\"p1\">[</bpt>Examples of porting GLSL variables to HLSL<ept id=\"p1\">](#example1)</ept>.","pos":[18392,18466],"source":" For examples, see [Examples of porting GLSL variables to HLSL](#example1)."},{"content":"For more info about the HLSL semantics, see <bpt id=\"p1\">[</bpt>Semantics<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509647)</ept>.","pos":[18467,18584],"source":" For more info about the HLSL semantics, see [Semantics](https://msdn.microsoft.com/library/windows/desktop/bb509647)."},{"content":"Examples of porting GLSL variables to HLSL","pos":[18589,18631]},{"content":"Here we show examples of using GLSL variables in OpenGL/GLSL code and then the equivalent example in Direct3D/HLSL code.","pos":[18634,18754]},{"content":"Uniform, attribute, and varying in GLSL","pos":[18760,18799]},{"content":"OpenGL app code","pos":[18801,18816]},{"content":"GLSL vertex shader code","pos":[19214,19237]},{"content":"GLSL fragment shader code","pos":[19497,19522]},{"content":"Constant buffers and data transfers in HLSL","pos":[19792,19835]},{"content":"Here is an example of how you pass data to the HLSL vertex shader that then flows through to the pixel shader.","pos":[19837,19947]},{"content":"In your app code, define a vertex and a constant buffer.","pos":[19948,20004]},{"content":"Then, in your vertex shader code, define the constant buffer as a <bpt id=\"p1\">[</bpt>cbuffer<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509581)</ept> and store the per-vertex data and the pixel shader input data.","pos":[20005,20204],"source":" Then, in your vertex shader code, define the constant buffer as a [cbuffer](https://msdn.microsoft.com/library/windows/desktop/bb509581) and store the per-vertex data and the pixel shader input data."},{"content":"Here we use structures called <bpt id=\"p1\">**</bpt>VertexShaderInput<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>PixelShaderInput<ept id=\"p2\">**</ept>.","pos":[20205,20282],"source":" Here we use structures called **VertexShaderInput** and **PixelShaderInput**."},{"content":"Direct3D app code","pos":[20284,20301]},{"content":"HLSL vertex shader code","pos":[20898,20921]},{"content":"HLSL pixel shader code","pos":[21604,21626]},{"content":"Examples of porting OpenGL rendering code to Direct3D","pos":[22000,22053]},{"content":"Here we show an example of rendering in OpenGL ES 2.0 code and then the equivalent example in Direct3D 11 code.","pos":[22056,22167]},{"content":"OpenGL rendering code","pos":[22169,22190]},{"content":"Direct3D rendering code","pos":[23030,23053]},{"content":"Related topics","pos":[23709,23723]},{"content":"Port from OpenGL ES 2.0 to Direct3D 11","pos":[23729,23767]}],"content":"---\ntitle: GLSL-to-HLSL reference\ndescription: You port your OpenGL Shader Language (GLSL) code to Microsoft High Level Shader Language (HLSL) code when you port your graphics architecture from OpenGL ES 2.0 to Direct3D 11 to create a game for Universal Windows Platform (UWP).\nms.assetid: 979d19f6-ef0c-64e4-89c2-a31e1c7b7692\n---\n\n# GLSL-to-HLSL reference\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nYou port your OpenGL Shader Language (GLSL) code to Microsoft High Level Shader Language (HLSL) code when you [port your graphics architecture from OpenGL ES 2.0 to Direct3D 11](port-from-opengl-es-2-0-to-directx-11-1.md) to create a game for Universal Windows Platform (UWP). The GLSL that is referred to herein is compatible with OpenGL ES 2.0; the HLSL is compatible with Direct3D 11. For info about the differences between Direct3D 11 and previous versions of Direct3D, see [Feature mapping](feature-mapping.md).\n\n-   [Comparing OpenGL ES 2.0 with Direct3D 11](#compare)\n-   [Porting GLSL variables to HLSL](#variables)\n-   [Porting GLSL types to HLSL](#types)\n-   [Porting GLSL pre-defined global variables to HLSL](#porting_glsl_pre-defined_global_variables_to_hlsl)\n-   [Examples of porting GLSL variables to HLSL](#example1)\n    -   [Uniform, attribute, and varying in GLSL](#uniform___attribute__and_varying_in_glsl)\n    -   [Constant buffers and data transfers in HLSL](#constant_buffers_and_data_transfers_in_hlsl)\n-   [Examples of porting OpenGL rendering code to Direct3D](#example2)\n-   [Related topics](#related_topics)\n\n## Comparing OpenGL ES 2.0 with Direct3D 11\n\n\nOpenGL ES 2.0 and Direct3D 11 have many similarities. They both have similar rendering pipelines and graphics features. But Direct3D 11 is a rendering implementation and API, not a specification; OpenGL ES 2.0 is a rendering specification and API, not an implementation. Direct3D 11 and OpenGL ES 2.0 generally differ in these ways:\n\n| OpenGL ES 2.0                                                                                         | Direct3D 11                                                                                                            |\n|-------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------|\n| Hardware and operating system agnostic specification with vendor provided implementations             | Microsoft implementation of hardware abstraction and certification on Windows platforms                                |\n| Abstracted for hardware diversity, runtime manages most resources                                     | Direct access to hardware layout; app can manage resources and processing                                              |\n| Provides higher-level modules via third-party libraries (for example, Simple DirectMedia Layer (SDL)) | Higher-level modules, like Direct2D, are built upon lower modules to simplify development for Windows apps             |\n| Hardware vendors differentiate via extensions                                                         | Microsoft adds optional features to the API in a generic way so they aren't specific to any particular hardware vendor |\n\n \n\nGLSL and HLSL generally differ in these ways:\n\n<table>\n<colgroup>\n<col width=\"50%\" />\n<col width=\"50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th align=\"left\">GLSL</th>\n<th align=\"left\">HLSL</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td align=\"left\">Procedural, step-centric (C like)</td>\n<td align=\"left\">Object oriented, data-centric (C++ like)</td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\">Shader compilation integrated into the graphics API</td>\n<td align=\"left\">The HLSL compiler [compiles the shader](https://msdn.microsoft.com/library/windows/desktop/bb509633) to an intermediate binary representation before Direct3D passes it to the driver.\n<div class=\"alert\">\n<strong>Note</strong>  This binary representation is hardware independent. It's typically compiled at app build time, rather than at app run time.\n</div>\n<div>\n \n</div></td>\n</tr>\n<tr class=\"odd\">\n<td align=\"left\">[Variable](#variables) storage modifiers</td>\n<td align=\"left\">Constant buffers and data transfers via input layout declarations</td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p>[Types](#types)</p>\n<p>Typical vector type: vec2/3/4</p>\n<p>lowp, mediump, highp</p></td>\n<td align=\"left\"><p>Typical vector type: float2/3/4</p>\n<p>min10float, min16float</p></td>\n</tr>\n<tr class=\"odd\">\n<td align=\"left\">texture2D [Function]</td>\n<td align=\"left\">[texture.Sample](https://msdn.microsoft.com/library/windows/desktop/bb509695) [datatype.Function]</td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\">sampler2D [datatype]</td>\n<td align=\"left\">[Texture2D](https://msdn.microsoft.com/library/windows/desktop/ff471525) [datatype]</td>\n</tr>\n<tr class=\"odd\">\n<td align=\"left\">Row-major matrices (default)</td>\n<td align=\"left\">Column-major matrices (default)\n<div class=\"alert\">\n<strong>Note</strong>   Use the <strong>row_major</strong> type-modifier to change the layout for one variable. For more info, see [Variable Syntax](https://msdn.microsoft.com/library/windows/desktop/bb509706). You can also specify a compiler flag or a pragma to change the global default.\n</div>\n<div>\n \n</div></td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\">Fragment shader</td>\n<td align=\"left\">Pixel shader</td>\n</tr>\n</tbody>\n</table>\n\n \n\n> **Note**  HLSL has textures and samplers as two separate objects. In GLSL, like Direct3D 9, the texture binding is part of the sampler state.\n\n \n\nIn GLSL, you present much of the OpenGL state as pre-defined global variables. For example, with GLSL, you use the **gl\\_Position** variable to specify vertex position and the **gl\\_FragColor** variable to specify fragment color. In HLSL, you pass Direct3D state explicitly from the app code to the shader. For example, with Direct3D and HLSL, the input to the vertex shader must match the data format in the vertex buffer, and the structure of a constant buffer in the app code must match the structure of a constant buffer ([cbuffer](https://msdn.microsoft.com/library/windows/desktop/bb509581)) in shader code.\n\n## Porting GLSL variables to HLSL\n\n\nIn GLSL, you apply modifiers (qualifiers) to a global shader variable declaration to give that variable a specific behavior in your shaders. In HLSL, you don’t need these modifiers because you define the flow of the shader with the arguments that you pass to your shader and that you return from your shader.\n\n<table>\n<colgroup>\n<col width=\"50%\" />\n<col width=\"50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th align=\"left\">GLSL variable behavior</th>\n<th align=\"left\">HLSL equivalent</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td align=\"left\"><p><strong>uniform</strong></p>\n<p>You pass a uniform variable from the app code into either or both vertex and fragment shaders. You must set the values of all uniforms before you draw any triangles with those shaders so their values stay the same throughout the drawing of a triangle mesh. These values are uniform. Some uniforms are set for the entire frame and others uniquely to one particular vertex-pixel shader pair.</p>\n<p>Uniform variables are per-polygon variables.</p></td>\n<td align=\"left\"><p>Use constant buffer.</p>\n<p>See [How to: Create a Constant Buffer](https://msdn.microsoft.com/library/windows/desktop/ff476896) and [Shader Constants](https://msdn.microsoft.com/library/windows/desktop/bb509581).</p></td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p><strong>varying</strong></p>\n<p>You initialize a varying variable inside the vertex shader and pass it through to an identically named varying variable in the fragment shader. Because the vertex shader only sets the value of the varying variables at each vertex, the rasterizer interpolates those values (in a perspective-correct manner) to generate per fragment values to pass into the fragment shader. These variables vary across each triangle.</p></td>\n<td align=\"left\">Use the structure that you return from your vertex shader as the input to your pixel shader. Make sure the semantic values match.</td>\n</tr>\n<tr class=\"odd\">\n<td align=\"left\"><p><strong>attribute</strong></p>\n<p>An attribute is a part of the description of a vertex that you pass from the app code to the vertex shader alone. Unlike a uniform, you set each attribute’s value for each vertex, which, in turn, allows each vertex to have a different value. Attribute variables are per-vertex variables.</p></td>\n<td align=\"left\"><p>Define a vertex buffer in your Direct3D app code and match it to the vertex input defined in the vertex shader. Optionally, define an index buffer. See [How to: Create a Vertex Buffer](https://msdn.microsoft.com/library/windows/desktop/ff476899) and [How to: Create an Index Buffer](https://msdn.microsoft.com/library/windows/desktop/ff476897).</p>\n<p>Create an input layout in your Direct3D app code and match semantic values with those in the vertex input. See [Create the input layout](https://msdn.microsoft.com/library/windows/desktop/bb205117#Create_the_Input_Layout).</p></td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p><strong>const</strong></p>\n<p>Constants that are compiled into the shader and never change.</p></td>\n<td align=\"left\">Use a <strong>static const</strong>. <strong>static</strong> means the value isn't exposed to constant buffers, <strong>const</strong> means the shader can't change the value. So, the value is known at compile time based on its initializer.</td>\n</tr>\n</tbody>\n</table>\n\n \n\nIn GLSL, variables without modifiers are just ordinary global variables that are private to each shader.\n\nWhen you pass data to textures ([Texture2D](https://msdn.microsoft.com/library/windows/desktop/ff471525) in HLSL) and their associated samplers ([SamplerState](https://msdn.microsoft.com/library/windows/desktop/bb509644) in HLSL), you typically declare them as global variables in the pixel shader.\n\n## Porting GLSL types to HLSL\n\n\nUse this table to port your GLSL types to HLSL.\n\n<table>\n<colgroup>\n<col width=\"50%\" />\n<col width=\"50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th align=\"left\">GLSL type</th>\n<th align=\"left\">HLSL type</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td align=\"left\">scalar types: float, int, bool</td>\n<td align=\"left\"><p>scalar types: float, int, bool</p>\n<p>also, uint, double</p>\n<p>For more info, see [Scalar Types](https://msdn.microsoft.com/library/windows/desktop/bb509646).</p></td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p>vector type</p>\n<ul>\n<li>floating-point vector: vec2, vec3, vec4</li>\n<li>Boolean vector: bvec2, bvec3, bvec4</li>\n<li>signed integer vector: ivec2, ivec3, ivec4</li>\n</ul></td>\n<td align=\"left\"><p>vector type</p>\n<ul>\n<li>float2, float3, float4, and float1</li>\n<li>bool2, bool3, bool4, and bool1</li>\n<li>int2, int3, int4, and int1</li>\n<li><p>These types also have vector expansions similar to float, bool, and int:</p>\n<ul>\n<li>uint</li>\n<li>min10float, min16float</li>\n<li>min12int, min16int</li>\n<li>min16uint</li>\n</ul></li>\n</ul>\n<p>For more info, see [Vector Type](https://msdn.microsoft.com/library/windows/desktop/bb509707) and [Keywords](https://msdn.microsoft.com/library/windows/desktop/bb509568).</p>\n<p>vector is also type defined as float4 (typedef vector &lt;float, 4&gt; vector;). For more info, see [User-Defined Type](https://msdn.microsoft.com/library/windows/desktop/bb509702).</p></td>\n</tr>\n<tr class=\"odd\">\n<td align=\"left\"><p>matrix type</p>\n<ul>\n<li>mat2: 2x2 float matrix</li>\n<li>mat3: 3x3 float matrix</li>\n<li>mat4: 4x4 float matrix</li>\n</ul></td>\n<td align=\"left\"><p>matrix type</p>\n<ul>\n<li>float2x2</li>\n<li>float3x3</li>\n<li>float4x4</li>\n<li>also, float1x1, float1x2, float1x3, float1x4, float2x1, float2x3, float2x4, float3x1, float3x2, float3x4, float4x1, float4x2, float4x3</li>\n<li><p>These types also have matrix expansions similar to float:</p>\n<ul>\n<li>int, uint, bool</li>\n<li>min10float, min16float</li>\n<li>min12int, min16int</li>\n<li>min16uint</li>\n</ul></li>\n</ul>\n<p>You can also use the [matrix type](https://msdn.microsoft.com/library/windows/desktop/bb509623) to define a matrix.</p>\n<p>For example: matrix &lt;float, 2, 2&gt; fMatrix = {0.0f, 0.1, 2.1f, 2.2f};</p>\n<p>matrix is also type defined as float4x4 (typedef matrix &lt;float, 4, 4&gt; matrix;). For more info, see [User-Defined Type](https://msdn.microsoft.com/library/windows/desktop/bb509702).</p></td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p>precision qualifiers for float, int, sampler</p>\n<ul>\n<li><p>highp</p>\n<p>This qualifier provides minimum precision requirements that are greater than that provided by min16float and less than a full 32-bit float. Equivalent in HLSL is:</p>\n<p>highp float -&gt; float</p>\n<p>highp int -&gt; int</p></li>\n<li><p>mediump</p>\n<p>This qualifier applied to float and int is equivalent to min16float and min12int in HLSL. Minimum 10 bits of mantissa, not like min10float.</p></li>\n<li><p>lowp</p>\n<p>This qualifier applied to float provides a floating point range of -2 to 2. Equivalent to min10float in HLSL.</p></li>\n</ul></td>\n<td align=\"left\"><p>precision types</p>\n<ul>\n<li>min16float: minimum 16-bit floating point value</li>\n<li><p>min10float</p>\n<p>Minimum fixed-point signed 2.8 bit value (2 bits of whole number and 8 bits fractional component). The 8-bit fractional component can be inclusive of 1 instead of exclusive to give it the full inclusive range of -2 to 2.</p></li>\n<li>min16int: minimum 16-bit signed integer</li>\n<li><p>min12int: minimum 12-bit signed integer</p>\n<p>This type is for 10Level9 ([9_x feature levels](https://msdn.microsoft.com/library/windows/desktop/ff476876)) in which integers are represented by floating point numbers. This is the precision you can get when you emulate an integer with a 16-bit floating point number.</p></li>\n<li>min16uint: minimum 16-bit unsigned integer</li>\n</ul>\n<p>For more info, see [Scalar Types](https://msdn.microsoft.com/library/windows/desktop/bb509646) and [Using HLSL minimum precision](https://msdn.microsoft.com/library/windows/desktop/hh968108).</p></td>\n</tr>\n<tr class=\"odd\">\n<td align=\"left\">sampler2D</td>\n<td align=\"left\">[Texture2D](https://msdn.microsoft.com/library/windows/desktop/ff471525)</td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\">samplerCube</td>\n<td align=\"left\">[TextureCube](https://msdn.microsoft.com/library/windows/desktop/bb509700)</td>\n</tr>\n</tbody>\n</table>\n\n \n\n## Porting GLSL pre-defined global variables to HLSL\n\n\nUse this table to port GLSL pre-defined global variables to HLSL.\n\n<table>\n<colgroup>\n<col width=\"50%\" />\n<col width=\"50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th align=\"left\">GLSL pre-defined global variable</th>\n<th align=\"left\">HLSL semantics</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td align=\"left\"><p><strong>gl_Position</strong></p>\n<p>This variable is type <strong>vec4</strong>.</p>\n<p>Vertex position</p>\n<p>for example - gl_Position = position;</p></td>\n<td align=\"left\"><p>SV_Position</p>\n<p>POSITION in Direct3D 9</p>\n<p>This semantic is type <strong>float4</strong>.</p>\n<p>Vertex shader output</p>\n<p>Vertex position</p>\n<p>for example - float4 vPosition : SV_Position;</p></td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p><strong>gl_PointSize</strong></p>\n<p>This variable is type <strong>float</strong>.</p>\n<p>Point size</p></td>\n<td align=\"left\"><p>PSIZE</p>\n<p>No meaning unless you target Direct3D 9</p>\n<p>This semantic is type <strong>float</strong>.</p>\n<p>Vertex shader output</p>\n<p>Point size</p></td>\n</tr>\n<tr class=\"odd\">\n<td align=\"left\"><p><strong>gl_FragColor</strong></p>\n<p>This variable is type <strong>vec4</strong>.</p>\n<p>Fragment color</p>\n<p>for example - gl_FragColor = vec4(colorVarying, 1.0);</p></td>\n<td align=\"left\"><p>SV_Target</p>\n<p>COLOR in Direct3D 9</p>\n<p>This semantic is type <strong>float4</strong>.</p>\n<p>Pixel shader output</p>\n<p>Pixel color</p>\n<p>for example - float4 Color[4] : SV_Target;</p></td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p><strong>gl_FragData[n]</strong></p>\n<p>This variable is type <strong>vec4</strong>.</p>\n<p>Fragment color for color attachment n</p></td>\n<td align=\"left\"><p>SV_Target[n]</p>\n<p>This semantic is type <strong>float4</strong>.</p>\n<p>Pixel shader output value that is stored in n render target, where 0 &lt;= n &lt;= 7.</p></td>\n</tr>\n<tr class=\"odd\">\n<td align=\"left\"><p><strong>gl_FragCoord</strong></p>\n<p>This variable is type <strong>vec4</strong>.</p>\n<p>Fragment position within frame buffer</p></td>\n<td align=\"left\"><p>SV_Position</p>\n<p>Not available in Direct3D 9</p>\n<p>This semantic is type <strong>float4</strong>.</p>\n<p>Pixel shader input</p>\n<p>Screen space coordinates</p>\n<p>for example - float4 screenSpace : SV_Position</p></td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p><strong>gl_FrontFacing</strong></p>\n<p>This variable is type <strong>bool</strong>.</p>\n<p>Determines whether fragment belongs to a front-facing primitive.</p></td>\n<td align=\"left\"><p>SV_IsFrontFace</p>\n<p>VFACE in Direct3D 9</p>\n<p>SV_IsFrontFace is type <strong>bool</strong>.</p>\n<p>VFACE is type <strong>float</strong>.</p>\n<p>Pixel shader input</p>\n<p>Primitive facing</p></td>\n</tr>\n<tr class=\"odd\">\n<td align=\"left\"><p><strong>gl_PointCoord</strong></p>\n<p>This variable is type <strong>vec2</strong>.</p>\n<p>Fragment position within a point (point rasterization only)</p></td>\n<td align=\"left\"><p>SV_Position</p>\n<p>VPOS in Direct3D 9</p>\n<p>SV_Position is type <strong>float4</strong>.</p>\n<p>VPOS is type <strong>float2</strong>.</p>\n<p>Pixel shader input</p>\n<p>The pixel or sample position in screen space</p>\n<p>for example - float4 pos : SV_Position</p></td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p><strong>gl_FragDepth</strong></p>\n<p>This variable is type <strong>float</strong>.</p>\n<p>Depth buffer data</p></td>\n<td align=\"left\"><p>SV_Depth</p>\n<p>DEPTH in Direct3D 9</p>\n<p>SV_Depth is type <strong>float</strong>.</p>\n<p>Pixel shader output</p>\n<p>Depth buffer data</p></td>\n</tr>\n</tbody>\n</table>\n\n \n\nYou use semantics to specify position, color, and so on for vertex shader input and pixel shader input. You must match the semantics values in the input layout with the vertex shader input. For examples, see [Examples of porting GLSL variables to HLSL](#example1). For more info about the HLSL semantics, see [Semantics](https://msdn.microsoft.com/library/windows/desktop/bb509647).\n\n## Examples of porting GLSL variables to HLSL\n\n\nHere we show examples of using GLSL variables in OpenGL/GLSL code and then the equivalent example in Direct3D/HLSL code.\n\n### Uniform, attribute, and varying in GLSL\n\nOpenGL app code\n\n``` syntax\n// Uniform values can be set in app code and then processed in the shader code.\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\n// Incoming position of vertex\nattribute vec4 position;\n \n// Incoming color for the vertex\nattribute vec3 color;\n \n// The varying variable tells the shader pipeline to pass it  \n// on to the fragment shader.\nvarying vec3 colorVarying;\n```\n\nGLSL vertex shader code\n\n``` syntax\n//The shader entry point is the main method.\nvoid main()\n{\ncolorVarying = color; //Use the varying variable to pass the color to the fragment shader\ngl_Position = position; //Copy the position to the gl_Position pre-defined global variable\n}\n```\n\nGLSL fragment shader code\n\n``` syntax\nvoid main()\n{\n//Pad the colorVarying vec3 with a 1.0 for alpha to create a vec4 color\n//and assign that color to the gl_FragColor pre-defined global variable\n//This color then becomes the fragment's color.\ngl_FragColor = vec4(colorVarying, 1.0);\n}\n```\n\n### Constant buffers and data transfers in HLSL\n\nHere is an example of how you pass data to the HLSL vertex shader that then flows through to the pixel shader. In your app code, define a vertex and a constant buffer. Then, in your vertex shader code, define the constant buffer as a [cbuffer](https://msdn.microsoft.com/library/windows/desktop/bb509581) and store the per-vertex data and the pixel shader input data. Here we use structures called **VertexShaderInput** and **PixelShaderInput**.\n\nDirect3D app code\n\n```cpp\nstruct ConstantBuffer\n{\n    XMFLOAT4X4 model;\n    XMFLOAT4X4 view;\n    XMFLOAT4X4 projection;\n};\nstruct SimpleCubeVertex\n{\n    XMFLOAT3 pos;   // position\n    XMFLOAT3 color; // color\n};\n\n // Create an input layout that matches the layout defined in the vertex shader code.\n const D3D11_INPUT_ELEMENT_DESC basicVertexLayoutDesc[] =\n {\n     { \"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,  0, D3D11_INPUT_PER_VERTEX_DATA, 0 },\n     { \"COLOR\",    0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },\n };\n\n// Create vertex and index buffers that define a geometry.\n```\n\nHLSL vertex shader code\n\n``` syntax\ncbuffer ModelViewProjectionCB : register( b0 )\n{\n    matrix model; \n    matrix view;\n    matrix projection;\n};\n// The POSITION and COLOR semantics must match the semantics in the input layout Direct3D app code.\nstruct VertexShaderInput\n{\n    float3 pos : POSITION; // Incoming position of vertex \n    float3 color : COLOR; // Incoming color for the vertex\n};\n\nstruct PixelShaderInput\n{\n    float4 pos : SV_Position; // Copy the vertex position.\n    float4 color : COLOR; // Pass the color to the pixel shader.\n};\n\nPixelShaderInput main(VertexShaderInput input)\n{\n    PixelShaderInput vertexShaderOutput;\n\n    // shader source code\n\n    return vertexShaderOutput;\n}\n```\n\nHLSL pixel shader code\n\n``` syntax\n// Collect input from the vertex shader. \n// The COLOR semantic must match the semantic in the vertex shader code.\nstruct PixelShaderInput\n{\n    float4 pos : SV_Position;\n    float4 color : COLOR; // Color for the pixel\n};\n\n// Set the pixel color value for the renter target. \nfloat4 main(PixelShaderInput input) : SV_Target\n{\n    return input.color;\n}\n```\n\n## Examples of porting OpenGL rendering code to Direct3D\n\n\nHere we show an example of rendering in OpenGL ES 2.0 code and then the equivalent example in Direct3D 11 code.\n\nOpenGL rendering code\n\n``` syntax\n// Bind shaders to the pipeline. \n// Both vertex shader and fragment shader are in a program.\nglUseProgram(m_shader->getProgram());\n \n// Input asssembly \n// Get the position and color attributes of the vertex.\n\nm_positionLocation = glGetAttribLocation(m_shader->getProgram(), \"position\");\nglEnableVertexAttribArray(m_positionLocation);\n\nm_colorLocation = glGetAttribColor(m_shader->getProgram(), \"color\");\nglEnableVertexAttribArray(m_colorLocation);\n \n// Bind the vertex buffer object to the input assembler.\nglBindBuffer(GL_ARRAY_BUFFER, m_geometryBuffer);\nglVertexAttribPointer(m_positionLocation, 4, GL_FLOAT, GL_FALSE, 0, NULL);\nglBindBuffer(GL_ARRAY_BUFFER, m_colorBuffer);\nglVertexAttribPointer(m_colorLocation, 3, GL_FLOAT, GL_FALSE, 0, NULL);\n \n// Draw a triangle with 3 vertices.\nglDrawArray(GL_TRIANGLES, 0, 3);\n```\n\nDirect3D rendering code\n\n```cpp\n// Bind the vertex shader and pixel shader to the pipeline.\nm_d3dDeviceContext->VSSetShader(vertexShader.Get(),nullptr,0);\nm_d3dDeviceContext->PSSetShader(pixelShader.Get(),nullptr,0);\n \n// Declare the inputs that the shaders expect.\nm_d3dDeviceContext->IASetInputLayout(inputLayout.Get());\nm_d3dDeviceContext->IASetVertexBuffers(0, 1, vertexBuffer.GetAddressOf(), &stride, &offset);\n\n// Set the primitive’s topology.\nm_d3dDeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n\n// Draw a triangle with 3 vertices. triangleVertices is an array of 3 vertices.\nm_d3dDeviceContext->Draw(ARRAYSIZE(triangleVertices),0);\n```\n\n## Related topics\n\n\n* [Port from OpenGL ES 2.0 to Direct3D 11](port-from-opengl-es-2-0-to-directx-11-1.md)\n\n \n\n \n\n\n\n\n"}