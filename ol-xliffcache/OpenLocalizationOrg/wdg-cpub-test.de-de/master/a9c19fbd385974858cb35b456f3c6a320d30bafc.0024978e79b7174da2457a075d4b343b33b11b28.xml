{"nodes":[{"pos":[11,47],"content":"Create depth buffer device resources","needQuote":true,"needEscape":true,"nodes":[{"content":"Create depth buffer device resources","pos":[0,36]}]},{"pos":[61,165],"content":"Learn how to create the Direct3D device resources necessary to support depth testing for shadow volumes.","needQuote":true,"needEscape":true,"nodes":[{"content":"Learn how to create the Direct3D device resources necessary to support depth testing for shadow volumes.","pos":[0,104]}]},{"content":"Create depth buffer device resources","pos":[222,258]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[261,299]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[300,395],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Learn how to create the Direct3D device resources necessary to support depth testing for shadow volumes.","pos":[398,502]},{"content":"Part 1 of <bpt id=\"p1\">[</bpt>Walkthrough: Implement shadow volumes using depth buffers in Direct3D 11<ept id=\"p1\">](implementing-depth-buffers-for-shadow-mapping.md)</ept>.","pos":[503,638],"source":" Part 1 of [Walkthrough: Implement shadow volumes using depth buffers in Direct3D 11](implementing-depth-buffers-for-shadow-mapping.md)."},{"content":"Resources you'll need","pos":[643,664]},{"content":"Rendering a depth map for shadow volumes requires the following Direct3D device-dependent resources:","pos":[667,767]},{"content":"A resource (buffer) for the depth map","pos":[773,810]},{"content":"A depth stencil view and shader resource view for the resource","pos":[815,877]},{"content":"A comparison sampler state object","pos":[882,915]},{"content":"Constant buffers for light POV matrices","pos":[920,959]},{"content":"A viewport for rendering the shadow map (typically a square viewport)","pos":[964,1033]},{"content":"A rendering state object to enable front face culling","pos":[1038,1091]},{"content":"You will also need a rendering state object to switch back to back face culling, if you don't already use one.","pos":[1096,1206]},{"content":"Note that creation of these resources needs to be included in a device-dependent resource creation routine, that way your renderer can recreate them if (for example) a new device driver is installed, or the user moves your app to a monitor attached to a different graphics adapter.","pos":[1208,1489]},{"content":"Check feature support","pos":[1494,1515]},{"pos":[1518,1862],"content":"Before creating the depth map, call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CheckFeatureSupport<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476497)</ept> method on the Direct3D device, request <bpt id=\"p3\">**</bpt>D3D11\\_FEATURE\\_D3D9\\_SHADOW\\_SUPPORT<ept id=\"p3\">**</ept>, and provide a <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>D3D11\\_FEATURE\\_DATA\\_D3D9\\_SHADOW\\_SUPPORT<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/desktop/jj247569)</ept> structure.","source":"Before creating the depth map, call the [**CheckFeatureSupport**](https://msdn.microsoft.com/library/windows/desktop/ff476497) method on the Direct3D device, request **D3D11\\_FEATURE\\_D3D9\\_SHADOW\\_SUPPORT**, and provide a [**D3D11\\_FEATURE\\_DATA\\_D3D9\\_SHADOW\\_SUPPORT**](https://msdn.microsoft.com/library/windows/desktop/jj247569) structure."},{"content":"If this feature is not supported, do not try to load shaders compiled for shader model 4 level 9\\_x that call sample comparison functions.","pos":[2274,2412]},{"content":"In many cases, lack of support for this feature means that the GPU is a legacy device with a driver that isn't updated to support at least WDDM 1.2.","pos":[2413,2561]},{"content":"If the device supports at least feature level 10\\_0 then you can load a sample comparison shader compiled for shader model 4\\_0 instead.","pos":[2562,2698]},{"content":"Create depth buffer","pos":[2703,2722]},{"content":"First, try creating the depth map with a higher-precision depth format.","pos":[2725,2796]},{"content":"Set up matching shader resource view properties first.","pos":[2797,2851]},{"content":"If the resource creation fails, for example due to low device memory or a format that the hardware doesn't support, try a lower-precision format and change properties to match.","pos":[2852,3028]},{"content":"This step is optional if you only need a low-precision depth format, for example when rendering on medium-resolution Direct3D feature level 9\\_1 devices.","pos":[3030,3183]},{"content":"Then create the resource views.","pos":[3744,3775]},{"content":"Set the mip slice to zero on the depth stencil view and set mip levels to 1 on the shader resource view.","pos":[3776,3880]},{"content":"Both have a texture dimension of TEXTURE2D, and both need to use a matching <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DXGI\\_FORMAT<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb173059)</ept>.","pos":[3881,4037],"source":" Both have a texture dimension of TEXTURE2D, and both need to use a matching [**DXGI\\_FORMAT**](https://msdn.microsoft.com/library/windows/desktop/bb173059)."},{"content":"Create comparison state","pos":[4925,4948]},{"content":"Now create the comparison sampler state object.","pos":[4951,4998]},{"content":"Feature level 9\\_1 only supports D3D11\\_COMPARISON\\_LESS\\_EQUAL.","pos":[4999,5063]},{"content":"Filtering choices are explained more in <bpt id=\"p1\">[</bpt>Supporting shadow maps on a range of hardware<ept id=\"p1\">](target-a-range-of-hardware.md)</ept> - or you can just pick point filtering for faster shadow maps.","pos":[5064,5245],"source":" Filtering choices are explained more in [Supporting shadow maps on a range of hardware](target-a-range-of-hardware.md) - or you can just pick point filtering for faster shadow maps."},{"content":"Note that you can specify the D3D11\\_TEXTURE\\_ADDRESS\\_BORDER address mode and it will work on feature level 9\\_1 devices.","pos":[5247,5369]},{"content":"This applies to pixel shaders that don't test whether the pixel is in the light's view frustum before doing the depth test.","pos":[5370,5493]},{"content":"By specifying 0 or 1 for each border, you can control whether pixels outside the light's view frustum pass or fail the depth test, and therefore whether they are lit or in shadow.","pos":[5494,5673]},{"pos":[5675,5851],"content":"On feature level 9\\_1, the following required values must be set: <bpt id=\"p1\">**</bpt>MinLOD<ept id=\"p1\">**</ept> is set to zero, <bpt id=\"p2\">**</bpt>MaxLOD<ept id=\"p2\">**</ept> is set to <bpt id=\"p3\">**</bpt>D3D11\\_FLOAT32\\_MAX<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>MaxAnisotropy<ept id=\"p4\">**</ept> is set to zero.","source":"On feature level 9\\_1, the following required values must be set: **MinLOD** is set to zero, **MaxLOD** is set to **D3D11\\_FLOAT32\\_MAX**, and **MaxAnisotropy** is set to zero."},{"content":"Create render states","pos":[7030,7050]},{"content":"Now create a render state you can use to enable front face culling.","pos":[7053,7120]},{"content":"Note that feature level 9\\_1 devices require <bpt id=\"p1\">**</bpt>DepthClipEnable<ept id=\"p1\">**</ept> set to <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept>.","pos":[7121,7202],"source":" Note that feature level 9\\_1 devices require **DepthClipEnable** set to **true**."},{"content":"Create a render state you can use to enable back face culling.","pos":[7672,7734]},{"content":"If your rendering code already turns on back face culling, then you can skip this step.","pos":[7735,7822]},{"content":"Create constant buffers","pos":[8236,8259]},{"content":"Don't forget to create a constant buffer for rendering from the light's point of view.","pos":[8262,8348]},{"content":"You can also use this constant buffer to specify the light position to the shader.","pos":[8349,8431]},{"content":"Use a perspective matrix for point lights, and use an orthogonal matrix for directional lights (such as sunlight).","pos":[8432,8546]},{"content":"Fill the constant buffer data.","pos":[8746,8776]},{"content":"Update the constant buffers once during initialization, and again if the light values have changed since the previous frame.","pos":[8777,8901]},{"content":"Create a viewport","pos":[9901,9918]},{"content":"You need a separate viewport to render to the shadow map.","pos":[9921,9978]},{"content":"The viewport isn't a device-based resource; you're free to create it elsewhere in your code.","pos":[9979,10071]},{"content":"Creating the viewport along with the shadow map can help make it more convenient to keep the dimension of the viewport congruent with the shadow map dimension.","pos":[10072,10231]},{"pos":[10499,10653],"content":"In the next part of this walkthrough, learn how to create the shadow map by <bpt id=\"p1\">[</bpt>rendering to the depth buffer<ept id=\"p1\">](render-the-shadow-map-to-the-depth-buffer.md)</ept>.","source":"In the next part of this walkthrough, learn how to create the shadow map by [rendering to the depth buffer](render-the-shadow-map-to-the-depth-buffer.md)."}],"content":"---\ntitle: Create depth buffer device resources\ndescription: Learn how to create the Direct3D device resources necessary to support depth testing for shadow volumes.\nms.assetid: 86d5791b-1faa-17e4-44a8-bbba07062756\n---\n\n# Create depth buffer device resources\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\nLearn how to create the Direct3D device resources necessary to support depth testing for shadow volumes. Part 1 of [Walkthrough: Implement shadow volumes using depth buffers in Direct3D 11](implementing-depth-buffers-for-shadow-mapping.md).\n\n## Resources you'll need\n\n\nRendering a depth map for shadow volumes requires the following Direct3D device-dependent resources:\n\n-   A resource (buffer) for the depth map\n-   A depth stencil view and shader resource view for the resource\n-   A comparison sampler state object\n-   Constant buffers for light POV matrices\n-   A viewport for rendering the shadow map (typically a square viewport)\n-   A rendering state object to enable front face culling\n-   You will also need a rendering state object to switch back to back face culling, if you don't already use one.\n\nNote that creation of these resources needs to be included in a device-dependent resource creation routine, that way your renderer can recreate them if (for example) a new device driver is installed, or the user moves your app to a monitor attached to a different graphics adapter.\n\n## Check feature support\n\n\nBefore creating the depth map, call the [**CheckFeatureSupport**](https://msdn.microsoft.com/library/windows/desktop/ff476497) method on the Direct3D device, request **D3D11\\_FEATURE\\_D3D9\\_SHADOW\\_SUPPORT**, and provide a [**D3D11\\_FEATURE\\_DATA\\_D3D9\\_SHADOW\\_SUPPORT**](https://msdn.microsoft.com/library/windows/desktop/jj247569) structure.\n\n```cpp\nD3D11_FEATURE_DATA_D3D9_SHADOW_SUPPORT isD3D9ShadowSupported;\nZeroMemory(&isD3D9ShadowSupported, sizeof(isD3D9ShadowSupported));\npD3DDevice->CheckFeatureSupport(\n    D3D11_FEATURE_D3D9_SHADOW_SUPPORT,\n    &isD3D9ShadowSupported,\n    sizeof(D3D11_FEATURE_D3D9_SHADOW_SUPPORT)\n    );\n\nif (isD3D9ShadowSupported.SupportsDepthAsTextureWithLessEqualComparisonFilter)\n{\n    // Init shadow map resources\n\n```\n\nIf this feature is not supported, do not try to load shaders compiled for shader model 4 level 9\\_x that call sample comparison functions. In many cases, lack of support for this feature means that the GPU is a legacy device with a driver that isn't updated to support at least WDDM 1.2. If the device supports at least feature level 10\\_0 then you can load a sample comparison shader compiled for shader model 4\\_0 instead.\n\n## Create depth buffer\n\n\nFirst, try creating the depth map with a higher-precision depth format. Set up matching shader resource view properties first. If the resource creation fails, for example due to low device memory or a format that the hardware doesn't support, try a lower-precision format and change properties to match.\n\nThis step is optional if you only need a low-precision depth format, for example when rendering on medium-resolution Direct3D feature level 9\\_1 devices.\n\n```cpp\nD3D11_TEXTURE2D_DESC shadowMapDesc;\nZeroMemory(&shadowMapDesc, sizeof(D3D11_TEXTURE2D_DESC));\nshadowMapDesc.Format = DXGI_FORMAT_R24G8_TYPELESS;\nshadowMapDesc.MipLevels = 1;\nshadowMapDesc.ArraySize = 1;\nshadowMapDesc.SampleDesc.Count = 1;\nshadowMapDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_DEPTH_STENCIL;\nshadowMapDesc.Height = static_cast<UINT>(m_shadowMapDimension);\nshadowMapDesc.Width = static_cast<UINT>(m_shadowMapDimension);\n\nHRESULT hr = pD3DDevice->CreateTexture2D(\n    &shadowMapDesc,\n    nullptr,\n    &m_shadowMap\n    );\n```\n\nThen create the resource views. Set the mip slice to zero on the depth stencil view and set mip levels to 1 on the shader resource view. Both have a texture dimension of TEXTURE2D, and both need to use a matching [**DXGI\\_FORMAT**](https://msdn.microsoft.com/library/windows/desktop/bb173059).\n\n```cpp\nD3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;\nZeroMemory(&depthStencilViewDesc, sizeof(D3D11_DEPTH_STENCIL_VIEW_DESC));\ndepthStencilViewDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;\ndepthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;\ndepthStencilViewDesc.Texture2D.MipSlice = 0;\n\nD3D11_SHADER_RESOURCE_VIEW_DESC shaderResourceViewDesc;\nZeroMemory(&shaderResourceViewDesc, sizeof(D3D11_SHADER_RESOURCE_VIEW_DESC));\nshaderResourceViewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;\nshaderResourceViewDesc.Format = DXGI_FORMAT_R24_UNORM_X8_TYPELESS;\nshaderResourceViewDesc.Texture2D.MipLevels = 1;\n\nhr = pD3DDevice->CreateDepthStencilView(\n    m_shadowMap.Get(),\n    &depthStencilViewDesc,\n    &m_shadowDepthView\n    );\n\nhr = pD3DDevice->CreateShaderResourceView(\n    m_shadowMap.Get(),\n    &shaderResourceViewDesc,\n    &m_shadowResourceView\n    );\n```\n\n## Create comparison state\n\n\nNow create the comparison sampler state object. Feature level 9\\_1 only supports D3D11\\_COMPARISON\\_LESS\\_EQUAL. Filtering choices are explained more in [Supporting shadow maps on a range of hardware](target-a-range-of-hardware.md) - or you can just pick point filtering for faster shadow maps.\n\nNote that you can specify the D3D11\\_TEXTURE\\_ADDRESS\\_BORDER address mode and it will work on feature level 9\\_1 devices. This applies to pixel shaders that don't test whether the pixel is in the light's view frustum before doing the depth test. By specifying 0 or 1 for each border, you can control whether pixels outside the light's view frustum pass or fail the depth test, and therefore whether they are lit or in shadow.\n\nOn feature level 9\\_1, the following required values must be set: **MinLOD** is set to zero, **MaxLOD** is set to **D3D11\\_FLOAT32\\_MAX**, and **MaxAnisotropy** is set to zero.\n\n```cpp\nD3D11_SAMPLER_DESC comparisonSamplerDesc;\nZeroMemory(&comparisonSamplerDesc, sizeof(D3D11_SAMPLER_DESC));\ncomparisonSamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_BORDER;\ncomparisonSamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_BORDER;\ncomparisonSamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_BORDER;\ncomparisonSamplerDesc.BorderColor[0] = 1.0f;\ncomparisonSamplerDesc.BorderColor[1] = 1.0f;\ncomparisonSamplerDesc.BorderColor[2] = 1.0f;\ncomparisonSamplerDesc.BorderColor[3] = 1.0f;\ncomparisonSamplerDesc.MinLOD = 0.f;\ncomparisonSamplerDesc.MaxLOD = D3D11_FLOAT32_MAX;\ncomparisonSamplerDesc.MipLODBias = 0.f;\ncomparisonSamplerDesc.MaxAnisotropy = 0;\ncomparisonSamplerDesc.ComparisonFunc = D3D11_COMPARISON_LESS_EQUAL;\ncomparisonSamplerDesc.Filter = D3D11_FILTER_COMPARISON_MIN_MAG_MIP_POINT;\n\n// Point filtered shadows can be faster, and may be a good choice when\n// rendering on hardware with lower feature levels. This sample has a\n// UI option to enable/disable filtering so you can see the difference\n// in quality and speed.\n\nDX::ThrowIfFailed(\n    pD3DDevice->CreateSamplerState(\n        &comparisonSamplerDesc,\n        &m_comparisonSampler_point\n        )\n    );\n```\n\n## Create render states\n\n\nNow create a render state you can use to enable front face culling. Note that feature level 9\\_1 devices require **DepthClipEnable** set to **true**.\n\n```cpp\nD3D11_RASTERIZER_DESC drawingRenderStateDesc;\nZeroMemory(&drawingRenderStateDesc, sizeof(D3D11_RASTERIZER_DESC));\ndrawingRenderStateDesc.CullMode = D3D11_CULL_BACK;\ndrawingRenderStateDesc.FillMode = D3D11_FILL_SOLID;\ndrawingRenderStateDesc.DepthClipEnable = true; // Feature level 9_1 requires DepthClipEnable == true\nDX::ThrowIfFailed(\n    pD3DDevice->CreateRasterizerState(\n        &drawingRenderStateDesc,\n        &m_drawingRenderState\n        )\n    );\n```\n\nCreate a render state you can use to enable back face culling. If your rendering code already turns on back face culling, then you can skip this step.\n\n```cpp\nD3D11_RASTERIZER_DESC shadowRenderStateDesc;\nZeroMemory(&shadowRenderStateDesc, sizeof(D3D11_RASTERIZER_DESC));\nshadowRenderStateDesc.CullMode = D3D11_CULL_FRONT;\nshadowRenderStateDesc.FillMode = D3D11_FILL_SOLID;\nshadowRenderStateDesc.DepthClipEnable = true;\n\nDX::ThrowIfFailed(\n    pD3DDevice->CreateRasterizerState(\n        &shadowRenderStateDesc,\n        &m_shadowRenderState\n        )\n    );\n```\n\n## Create constant buffers\n\n\nDon't forget to create a constant buffer for rendering from the light's point of view. You can also use this constant buffer to specify the light position to the shader. Use a perspective matrix for point lights, and use an orthogonal matrix for directional lights (such as sunlight).\n\n```cpp\nDX::ThrowIfFailed(\n    m_deviceResources->GetD3DDevice()->CreateBuffer(\n        &viewProjectionConstantBufferDesc,\n        nullptr,\n        &m_lightViewProjectionBuffer\n        )\n    );\n```\n\nFill the constant buffer data. Update the constant buffers once during initialization, and again if the light values have changed since the previous frame.\n\n```cpp\n{\n    XMMATRIX lightPerspectiveMatrix = XMMatrixPerspectiveFovRH(\n        XM_PIDIV2,\n        1.0f,\n        12.f,\n        50.f\n        );\n\n    XMStoreFloat4x4(\n        &m_lightViewProjectionBufferData.projection,\n        XMMatrixTranspose(lightPerspectiveMatrix)\n        );\n\n    // Point light at (20, 15, 20), pointed at the origin. POV up-vector is along the y-axis.\n    static const XMVECTORF32 eye = { 20.0f, 15.0f, 20.0f, 0.0f };\n    static const XMVECTORF32 at = { 0.0f, 0.0f, 0.0f, 0.0f };\n    static const XMVECTORF32 up = { 0.0f, 1.0f, 0.0f, 0.0f };\n\n    XMStoreFloat4x4(\n        &m_lightViewProjectionBufferData.view,\n        XMMatrixTranspose(XMMatrixLookAtRH(eye, at, up))\n        );\n\n    // Store the light position to help calculate the shadow offset.\n    XMStoreFloat4(&m_lightViewProjectionBufferData.pos, eye);\n}\n```\n\n```cpp\ncontext->UpdateSubresource(\n    m_lightViewProjectionBuffer.Get(),\n    0,\n    NULL,\n    &m_lightViewProjectionBufferData,\n    0,\n    0\n    );\n```\n\n## Create a viewport\n\n\nYou need a separate viewport to render to the shadow map. The viewport isn't a device-based resource; you're free to create it elsewhere in your code. Creating the viewport along with the shadow map can help make it more convenient to keep the dimension of the viewport congruent with the shadow map dimension.\n\n```cpp\n// Init viewport for shadow rendering\nZeroMemory(&m_shadowViewport, sizeof(D3D11_VIEWPORT));\nm_shadowViewport.Height = m_shadowMapDimension;\nm_shadowViewport.Width = m_shadowMapDimension;\nm_shadowViewport.MinDepth = 0.f;\nm_shadowViewport.MaxDepth = 1.f;\n```\n\nIn the next part of this walkthrough, learn how to create the shadow map by [rendering to the depth buffer](render-the-shadow-map-to-the-depth-buffer.md).\n\n \n\n \n\n\n\n\n"}