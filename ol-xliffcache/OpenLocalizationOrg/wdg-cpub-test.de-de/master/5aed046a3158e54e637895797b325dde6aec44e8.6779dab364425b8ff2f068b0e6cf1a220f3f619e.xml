{"nodes":[{"content":"Optimize your XAML layout","pos":[2,27]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[29,67]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[68,163],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Important APIs","pos":[167,181]},{"content":"Panel","pos":[192,197]},{"content":"Layout is the process of defining the visual structure for your UI.","pos":[260,327]},{"content":"The primary mechanism for describing layout in XAML is through panels, which are container objects that enable you to position and arrange the UI elements within them.","pos":[328,495]},{"content":"Layout can be an expensive part of a XAML app—both in CPU usage and memory overhead.","pos":[496,580]},{"content":"Here are some simple steps you can take to improve the layout performance of your XAML app.","pos":[581,672]},{"content":"Reduce layout structure","pos":[677,700]},{"content":"The biggest gain in layout performance comes from simplifying the hierarchical structure of the tree of UI elements.","pos":[702,818]},{"content":"Panels exist in the visual tree, but they are structural elements, not <bpt id=\"p1\">*</bpt>pixel producing elements<ept id=\"p1\">*</ept> like a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Button<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/BR209265)</ept> or a <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>Rectangle<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/BR243371)</ept>.","pos":[819,1074],"source":" Panels exist in the visual tree, but they are structural elements, not *pixel producing elements* like a [**Button**](https://msdn.microsoft.com/library/windows/apps/BR209265) or a [**Rectangle**](https://msdn.microsoft.com/library/windows/apps/BR243371)."},{"content":"Simplifying the tree by reducing the number of non-pixel-producing elements typically provides a significant performance increase.","pos":[1075,1205]},{"content":"Many UIs are implemented by nesting panels which results in deep, complex trees of panels and elements.","pos":[1207,1310]},{"content":"It is convenient to nest panels, but in many cases the same UI can be achieved with a more complex single panel.","pos":[1311,1423]},{"content":"Using a single panel provides better performance.","pos":[1424,1473]},{"content":"When to reduce layout structure","pos":[1479,1510]},{"content":"Reducing layout structure in a trivial way—for example, reducing one nested panel from your top-level page—does not have a noticeable effect.","pos":[1512,1653]},{"content":"The largest performance gains come from reducing layout structure that's repeated in the UI, like in a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ListView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>GridView<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242705)</ept>.","pos":[1655,1907],"source":"The largest performance gains come from reducing layout structure that's repeated in the UI, like in a [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878) or [**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242705)."},{"content":"These <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ItemsControl<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242803)</ept> elements use a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DataTemplate<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242348)</ept>, which defines a subtree of UI elements that is instantiated many times.","pos":[1908,2155],"source":" These [**ItemsControl**](https://msdn.microsoft.com/library/windows/apps/BR242803) elements use a [**DataTemplate**](https://msdn.microsoft.com/library/windows/apps/BR242348), which defines a subtree of UI elements that is instantiated many times."},{"content":"When the same subtree is being duplicated many times in your app, any improvements to the performance of that subtree has a multiplicative effect on the overall performance of your app.","pos":[2156,2341]},{"content":"Examples","pos":[2347,2355]},{"content":"Consider the following UI.","pos":[2357,2383]},{"content":"Form layout example<ph id=\"ph1\">](images/layout-perf-ex1.png)</ph> These examples shows 3 ways of implementing the same UI.","pos":[2387,2492],"source":"Form layout example](images/layout-perf-ex1.png)\nThese examples shows 3 ways of implementing the same UI."},{"content":"Each implementation choice results in nearly identical pixels on the screen, but differs substantially in the implementation details.","pos":[2493,2626]},{"pos":[2628,2727],"content":"Option1: Nested <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StackPanel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209635)</ept> elements","source":"Option1: Nested [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/BR209635) elements"},{"content":"Although this is the simplest model, it uses 5 panel elements and results in significant overhead.","pos":[2729,2827]},{"pos":[3516,3603],"content":"Option 2: A single <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Grid<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept>","source":"Option 2: A single [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704)"},{"pos":[3605,3737],"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Grid<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept> adds some complexity, but uses only a single panel element.","source":"The [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704) adds some complexity, but uses only a single panel element."},{"pos":[4864,4961],"content":"Option 3: A single <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>RelativePanel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn879546)</ept>:","source":"Option 3: A single [**RelativePanel**](https://msdn.microsoft.com/library/windows/apps/Dn879546):"},{"pos":[4963,5155],"content":"This single panel is also a bit more complex than using nested panels, but may be easier to understand and maintain than a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Grid<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept>.","source":"This single panel is also a bit more complex than using nested panels, but may be easier to understand and maintain than a [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704)."},{"content":"As these examples show, there are many ways of achieving the same UI.","pos":[6213,6282]},{"content":"You should choose by carefully considering all the tradeoffs, including performance, readability, and maintainability.","pos":[6283,6401]},{"content":"Use single-cell grids for overlapping UI","pos":[6406,6446]},{"content":"A common UI requirement is to have a layout where elements overlap each other.","pos":[6448,6526]},{"content":"Typically padding, margins, alignments, and transforms are used to position the elements this way.","pos":[6527,6625]},{"content":"The XAML <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Grid<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept> control is optimized to improve layout performance for elements that overlap.","pos":[6626,6781],"source":" The XAML [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704) control is optimized to improve layout performance for elements that overlap."},{"content":"<bpt id=\"p1\">**</bpt>Important<ept id=\"p1\">**</ept>  To see the improvement, use a single-cell <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Grid<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept>.","pos":[6783,6909],"source":"**Important**  To see the improvement, use a single-cell [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704)."},{"content":"Do not define <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>RowDefinitions<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242704-rowdefinitions)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ColumnDefinitions<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242704-columndefinitions)</ept>.","pos":[6910,7121],"source":" Do not define [**RowDefinitions**](https://msdn.microsoft.com/library/windows/apps/BR242704-rowdefinitions) or [**ColumnDefinitions**](https://msdn.microsoft.com/library/windows/apps/BR242704-columndefinitions)."},{"content":"Examples","pos":[7127,7135]},{"content":"Text overlaid on a circle","pos":[7336,7361]},{"content":"Two text blocks in a grid","pos":[7590,7615]},{"content":"Use a panel's built-in border properties","pos":[7649,7689]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Grid<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StackPanel<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR209635)</ept>, <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>RelativePanel<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/Dn879546)</ept>, and <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>ContentPresenter<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/BR209378)</ept> controls have built-in border properties that let you draw a border around them without adding an additional <bpt id=\"p9\">[</bpt><bpt id=\"p10\">**</bpt>Border<ept id=\"p10\">**</ept><ept id=\"p9\">](https://msdn.microsoft.com/library/windows/apps/BR209250)</ept> element to your XAML.","pos":[7691,8202],"source":"[**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704), [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/BR209635), [**RelativePanel**](https://msdn.microsoft.com/library/windows/apps/Dn879546), and [**ContentPresenter**](https://msdn.microsoft.com/library/windows/apps/BR209378) controls have built-in border properties that let you draw a border around them without adding an additional [**Border**](https://msdn.microsoft.com/library/windows/apps/BR209250) element to your XAML."},{"content":"The new properties that support the built-in border are: <bpt id=\"p1\">**</bpt>BorderBrush<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>BorderThickness<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>CornerRadius<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>Padding<ept id=\"p4\">**</ept>.","pos":[8203,8332],"source":" The new properties that support the built-in border are: **BorderBrush**, **BorderThickness**, **CornerRadius**, and **Padding**."},{"content":"Each of these is a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyProperty<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242362)</ept>, so you can use them with bindings and animations.","pos":[8333,8485],"source":" Each of these is a [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/BR242362), so you can use them with bindings and animations."},{"content":"They’re designed to be a full replacement for a separate <bpt id=\"p1\">**</bpt>Border<ept id=\"p1\">**</ept> element.","pos":[8486,8562],"source":" They’re designed to be a full replacement for a separate **Border** element."},{"content":"If your UI has <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Border<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209250)</ept> elements around these panels, use the built-in border instead, which saves an extra element in the layout structure of your app.","pos":[8564,8778],"source":"If your UI has [**Border**](https://msdn.microsoft.com/library/windows/apps/BR209250) elements around these panels, use the built-in border instead, which saves an extra element in the layout structure of your app."},{"content":"As mentioned previously, this can be a significant savings, especially in the case of repeated UI.","pos":[8779,8877]},{"content":"Examples","pos":[8883,8891]},{"pos":[9145,9200],"content":"Use <bpt id=\"p1\">**</bpt>SizeChanged<ept id=\"p1\">**</ept> events to respond to layout changes","source":"Use **SizeChanged** events to respond to layout changes"},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FrameworkElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208706)</ept> class exposes two similar events for responding to layout changes: <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>LayoutUpdated<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR208706-layoutupdated)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>SizeChanged<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR208706-sizechanged)</ept>.","pos":[9202,9538],"source":"The [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/BR208706) class exposes two similar events for responding to layout changes: [**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/BR208706-layoutupdated) and [**SizeChanged**](https://msdn.microsoft.com/library/windows/apps/BR208706-sizechanged)."},{"content":"You might be using one of these events to receive notification when an element is resized during layout.","pos":[9539,9643]},{"content":"The semantics of the two events are different, and there are important performance considerations in choosing between them.","pos":[9644,9767]},{"content":"For good performance, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SizeChanged<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208706-sizechanged)</ept> is almost always the right choice.","pos":[9769,9913],"source":"For good performance, [**SizeChanged**](https://msdn.microsoft.com/library/windows/apps/BR208706-sizechanged) is almost always the right choice."},{"content":"<bpt id=\"p1\">**</bpt>SizeChanged<ept id=\"p1\">**</ept> has intuitive semantics.","pos":[9914,9954],"source":"**SizeChanged** has intuitive semantics."},{"content":"It is raised during layout when the size of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FrameworkElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208706)</ept> has been updated.","pos":[9955,10101],"source":" It is raised during layout when the size of the [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/BR208706) has been updated."},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>LayoutUpdated<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208706-layoutupdated)</ept> is also raised during layout, but it has global semantics—it is raised on every element whenever any element is updated.","pos":[10103,10315],"source":"[**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/BR208706-layoutupdated) is also raised during layout, but it has global semantics—it is raised on every element whenever any element is updated."},{"content":"It is typical to only do local processing in the event handler, in which case the code is run more often than needed.","pos":[10316,10433]},{"content":"Use <bpt id=\"p1\">**</bpt>LayoutUpdated<ept id=\"p1\">**</ept> only if you need to know when an element is repositioned without changing size (which is uncommon).","pos":[10434,10555],"source":" Use **LayoutUpdated** only if you need to know when an element is repositioned without changing size (which is uncommon)."},{"content":"Choosing between panels","pos":[10560,10583]},{"content":"Performance is typically not a consideration when choosing between individual panels.","pos":[10585,10670]},{"content":"That choice is typically made by considering which panel provides the layout behavior that is closest to the UI you’re implementing.","pos":[10671,10803]},{"content":"For example, if you’re choosing between <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Grid<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StackPanel<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR209635)</ept> , and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>RelativePanel<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/Dn879546)</ept>, you should choose the panel that provides the closest mapping to your mental model of the implementation.","pos":[10804,11179],"source":" For example, if you’re choosing between [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704), [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/BR209635) , and [**RelativePanel**](https://msdn.microsoft.com/library/windows/apps/Dn879546), you should choose the panel that provides the closest mapping to your mental model of the implementation."},{"content":"Every XAML panel is optimized for good performance, and all the panels provide similar performance for similar UI.","pos":[11181,11295]}],"content":"# Optimize your XAML layout\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n**Important APIs**\n\n-   [**Panel**](https://msdn.microsoft.com/library/windows/apps/BR227511)\n\nLayout is the process of defining the visual structure for your UI. The primary mechanism for describing layout in XAML is through panels, which are container objects that enable you to position and arrange the UI elements within them. Layout can be an expensive part of a XAML app—both in CPU usage and memory overhead. Here are some simple steps you can take to improve the layout performance of your XAML app.\n\n## Reduce layout structure\n\nThe biggest gain in layout performance comes from simplifying the hierarchical structure of the tree of UI elements. Panels exist in the visual tree, but they are structural elements, not *pixel producing elements* like a [**Button**](https://msdn.microsoft.com/library/windows/apps/BR209265) or a [**Rectangle**](https://msdn.microsoft.com/library/windows/apps/BR243371). Simplifying the tree by reducing the number of non-pixel-producing elements typically provides a significant performance increase.\n\nMany UIs are implemented by nesting panels which results in deep, complex trees of panels and elements. It is convenient to nest panels, but in many cases the same UI can be achieved with a more complex single panel. Using a single panel provides better performance.\n\n### When to reduce layout structure\n\nReducing layout structure in a trivial way—for example, reducing one nested panel from your top-level page—does not have a noticeable effect.\n\nThe largest performance gains come from reducing layout structure that's repeated in the UI, like in a [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878) or [**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242705). These [**ItemsControl**](https://msdn.microsoft.com/library/windows/apps/BR242803) elements use a [**DataTemplate**](https://msdn.microsoft.com/library/windows/apps/BR242348), which defines a subtree of UI elements that is instantiated many times. When the same subtree is being duplicated many times in your app, any improvements to the performance of that subtree has a multiplicative effect on the overall performance of your app.\n\n### Examples\n\nConsider the following UI.\n\n![Form layout example](images/layout-perf-ex1.png)\nThese examples shows 3 ways of implementing the same UI. Each implementation choice results in nearly identical pixels on the screen, but differs substantially in the implementation details.\n\nOption1: Nested [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/BR209635) elements\n\nAlthough this is the simplest model, it uses 5 panel elements and results in significant overhead.\n\n```xml\n  <StackPanel>\n  <TextBlock Text=\"Options:\" />\n  <StackPanel Orientation=\"Horizontal\">\n      <CheckBox Content=\"Power User\" />\n      <CheckBox Content=\"Admin\" Margin=\"20,0,0,0\" />\n  </StackPanel>\n  <TextBlock Text=\"Basic information:\" />\n  <StackPanel Orientation=\"Horizontal\">\n      <TextBlock Text=\"Name:\" Width=\"75\" />\n      <TextBox Width=\"200\" />\n  </StackPanel>\n  <StackPanel Orientation=\"Horizontal\">\n      <TextBlock Text=\"Email:\" Width=\"75\" />\n      <TextBox Width=\"200\" />\n  </StackPanel>\n  <StackPanel Orientation=\"Horizontal\">\n      <TextBlock Text=\"Password:\" Width=\"75\" />\n      <TextBox Width=\"200\" />\n  </StackPanel>\n  <Button Content=\"Save\" />\n</StackPanel>\n```\n\nOption 2: A single [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704)\n\nThe [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704) adds some complexity, but uses only a single panel element.\n\n```\n  <Grid>\n  <Grid.RowDefinitions>\n      <RowDefinition Height=\"Auto\" />\n      <RowDefinition Height=\"Auto\" />\n      <RowDefinition Height=\"Auto\" />\n      <RowDefinition Height=\"Auto\" />\n      <RowDefinition Height=\"Auto\" />\n      <RowDefinition Height=\"Auto\" />\n      <RowDefinition Height=\"Auto\" />\n  </Grid.RowDefinitions>\n  <Grid.ColumnDefinitions>\n      <ColumnDefinition Width=\"Auto\" />\n      <ColumnDefinition Width=\"Auto\" />\n  </Grid.ColumnDefinitions>\n  <TextBlock Text=\"Options:\" Grid.ColumnSpan=\"2\" />\n  <CheckBox Content=\"Power User\" Grid.Row=\"1\" Grid.ColumnSpan=\"2\" />\n  <CheckBox Content=\"Admin\" Margin=\"150,0,0,0” Grid.Row=\"1\" Grid.ColumnSpan=\"2\" />\n  <TextBlock Text=\"Basic information:\" Grid.Row=\"2\" Grid.ColumnSpan=\"2\" />\n  <TextBlock Text=\"Name:\" Width=\"75\" Grid.Row=\"3\" />\n  <TextBox Width=\"200\" Grid.Row=\"3\" Grid.Column=\"1\" />\n  <TextBlock Text=\"Email:\" Width=\"75\" Grid.Row=\"4\" />\n  <TextBox Width=\"200\" Grid.Row=\"4\" Grid.Column=\"1\" />\n  <TextBlock Text=\"Password:\" Width=\"75\" Grid.Row=\"5\" />\n  <TextBox Width=\"200\" Grid.Row=\"5\" Grid.Column=\"1\" />\n  <Button Content=\"Save\" Grid.Row=\"6\" />\n</Grid>\n```\n\nOption 3: A single [**RelativePanel**](https://msdn.microsoft.com/library/windows/apps/Dn879546):\n\nThis single panel is also a bit more complex than using nested panels, but may be easier to understand and maintain than a [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704).\n\n```xml\n<RelativePanel>\n  <TextBlock Text=\"Options:\" x:Name=\"Options\" />\n  <CheckBox Content=\"Power User\" x:Name=\"PowerUser\" RelativePanel.Below=\"Options\" />\n  <CheckBox Content=\"Admin\" Margin=\"20,0,0,0\" \n            RelativePanel.RightOf=\"PowerUser\" RelativePanel.Below=\"Options\" />\n  <TextBlock Text=\"Basic information:\" x:Name=\"BasicInformation\"\n           RelativePanel.Below=\"PowerUser\" />\n  <TextBlock Text=\"Name:\" RelativePanel.AlignVerticalCenterWith=\"NameBox\" />\n  <TextBox Width=\"200\" Margin=\"75,0,0,0\" x:Name=\"NameBox\"               \n           RelativePanel.Below=\"BasicInformation\" />\n  <TextBlock Text=\"Email:\"  RelativePanel.AlignVerticalCenterWith=\"EmailBox\" />\n  <TextBox Width=\"200\" Margin=\"75,0,0,0\" x:Name=\"EmailBox\"\n           RelativePanel.Below=\"NameBox\" />\n  <TextBlock Text=\"Password:\" RelativePanel.AlignVerticalCenterWith=\"PasswordBox\" />\n  <TextBox Width=\"200\" Margin=\"75,0,0,0\" x:Name=\"PasswordBox\"\n           RelativePanel.Below=\"EmailBox\" />\n  <Button Content=\"Save\" RelativePanel.Below=\"PasswordBox\" />\n</RelativePanel>\n```\n\nAs these examples show, there are many ways of achieving the same UI. You should choose by carefully considering all the tradeoffs, including performance, readability, and maintainability.\n\n## Use single-cell grids for overlapping UI\n\nA common UI requirement is to have a layout where elements overlap each other. Typically padding, margins, alignments, and transforms are used to position the elements this way. The XAML [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704) control is optimized to improve layout performance for elements that overlap.\n\n**Important**  To see the improvement, use a single-cell [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704). Do not define [**RowDefinitions**](https://msdn.microsoft.com/library/windows/apps/BR242704-rowdefinitions) or [**ColumnDefinitions**](https://msdn.microsoft.com/library/windows/apps/BR242704-columndefinitions).\n\n### Examples\n\n```xml\n<Grid>\n    <Ellipse Fill=\"Red\" Width=\"200\" Height=\"200\" />\n    <TextBlock Text=\"Test\" \n               HorizontalAlignment=\"Center\" \n               VerticalAlignment=\"Center\" />\n</Grid>\n```\n\n![Text overlaid on a circle](images/layout-perf-ex2.png)\n\n```xml\n<Grid Width=\"200\" BorderBrush=\"Black\" BorderThickness=\"1\">\n    <TextBlock Text=\"Test1\" HorizontalAlignment=\"Left\" />\n    <TextBlock Text=\"Test2\" HorizontalAlignment=\"Right\" />\n</Grid>\n```\n\n![Two text blocks in a grid](images/layout-perf-ex3.png)\n\n## Use a panel's built-in border properties\n\n[**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704), [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/BR209635), [**RelativePanel**](https://msdn.microsoft.com/library/windows/apps/Dn879546), and [**ContentPresenter**](https://msdn.microsoft.com/library/windows/apps/BR209378) controls have built-in border properties that let you draw a border around them without adding an additional [**Border**](https://msdn.microsoft.com/library/windows/apps/BR209250) element to your XAML. The new properties that support the built-in border are: **BorderBrush**, **BorderThickness**, **CornerRadius**, and **Padding**. Each of these is a [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/BR242362), so you can use them with bindings and animations. They’re designed to be a full replacement for a separate **Border** element.\n\nIf your UI has [**Border**](https://msdn.microsoft.com/library/windows/apps/BR209250) elements around these panels, use the built-in border instead, which saves an extra element in the layout structure of your app. As mentioned previously, this can be a significant savings, especially in the case of repeated UI.\n\n### Examples\n\n```xml\n<RelativePanel BorderBrush=\"Red\" BorderThickness=\"2\" CornerRadius=\"10\" Padding=\"12\">\n    <TextBox x:Name=\"textBox1\" RelativePanel.AlignLeftWithPanel=\"True\"/>\n    <Button Content=\"Submit\" RelativePanel.Below=\"textBox1\"/>\n</RelativePanel>\n```\n\n## Use **SizeChanged** events to respond to layout changes\n\nThe [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/BR208706) class exposes two similar events for responding to layout changes: [**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/BR208706-layoutupdated) and [**SizeChanged**](https://msdn.microsoft.com/library/windows/apps/BR208706-sizechanged). You might be using one of these events to receive notification when an element is resized during layout. The semantics of the two events are different, and there are important performance considerations in choosing between them.\n\nFor good performance, [**SizeChanged**](https://msdn.microsoft.com/library/windows/apps/BR208706-sizechanged) is almost always the right choice. **SizeChanged** has intuitive semantics. It is raised during layout when the size of the [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/BR208706) has been updated.\n\n[**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/BR208706-layoutupdated) is also raised during layout, but it has global semantics—it is raised on every element whenever any element is updated. It is typical to only do local processing in the event handler, in which case the code is run more often than needed. Use **LayoutUpdated** only if you need to know when an element is repositioned without changing size (which is uncommon).\n\n## Choosing between panels\n\nPerformance is typically not a consideration when choosing between individual panels. That choice is typically made by considering which panel provides the layout behavior that is closest to the UI you’re implementing. For example, if you’re choosing between [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704), [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/BR209635) , and [**RelativePanel**](https://msdn.microsoft.com/library/windows/apps/Dn879546), you should choose the panel that provides the closest mapping to your mental model of the implementation.\n\nEvery XAML panel is optimized for good performance, and all the panels provide similar performance for similar UI.\n"}