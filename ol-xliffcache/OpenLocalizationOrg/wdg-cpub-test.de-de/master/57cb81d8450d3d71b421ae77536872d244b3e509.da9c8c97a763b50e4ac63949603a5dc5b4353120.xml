{"nodes":[{"content":"Universal Windows Platform Components and optimizing interop","pos":[2,62]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[64,102]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[103,198],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Create Universal Windows Platform (UWP) apps that use UWP Components and interop between native and managed types while avoiding interop performance issues.","pos":[200,356]},{"content":"Best practices for interoperability with UWP Components","pos":[361,416]},{"content":"If you are not careful, using UWP Components can have a large impact on your app performance.","pos":[418,511]},{"content":"This section discusses how to get good performance when your app uses UWP Components.","pos":[512,597]},{"content":"Introduction","pos":[603,615]},{"content":"Interoperability can have a big impact on performance and you might be using it without even realizing that you are.","pos":[617,733]},{"content":"The UWP handles a lot of the interoperability for you so that you can be more productive and reuse code that was written in other languages.","pos":[734,874]},{"content":"We encourage you to take advantage of what the UWP does for you, but be aware that it can impact performance.","pos":[875,984]},{"content":"This section discusses things you can do to lessen the impact that interoperability has on your app's performance.","pos":[985,1099]},{"content":"The UWP has a library of types that are accessible from any language that can write a UWP app.","pos":[1101,1195]},{"content":"You use the UWP types in C\\# or Microsoft Visual Basic the same way you use .NET objects.","pos":[1196,1285]},{"content":"You don't need to make platform invoke method calls to access the UWP components.","pos":[1286,1367]},{"content":"This makes writing your apps much less complex, but it is important to realize that there might be more interoperability occurring than you expect.","pos":[1368,1515]},{"content":"If a UWP component is written in a language other than C\\# or Visual Basic, you cross interoperability boundaries when you use that component.","pos":[1516,1658]},{"content":"Crossing interoperability boundaries can impact the performance of an app.","pos":[1659,1733]},{"content":"When you develop a UWP app in C\\# or Visual Basic, the two most common set of APIs that you use are the UWP APIs and the .NET APIs for UWP apps.","pos":[1735,1879]},{"content":"In general, types that are defined in the UWP are in namespaces that begin with \"Windows.\"","pos":[1880,1970]},{"content":"and .NET types are in namespaces that begin with \"System.\"","pos":[1971,2029]},{"content":"There are exceptions, though.","pos":[2030,2059]},{"content":"The types in .NET for UWP apps do not require interoperability when they are used.","pos":[2060,2142]},{"content":"If you find that you have bad performance in an area that uses UWP, you might be able to use .NET for UWP apps instead to get better performance.","pos":[2143,2288]},{"content":"Note","pos":[2292,2296]},{"content":"Most of the UWP components that ship with Windows 10 are implemented in C++ so you cross interoperability boundaries when you use them from C\\# or Visual Basic.","pos":[2301,2461]},{"content":"As always, make sure to measure your app to see if using UWP components affects your app's performance before you invest in making changes to your code.","pos":[2462,2614]},{"content":"In this topic, when we say \"UWP components\", we mean components that are written in a language other than C\\# or Visual Basic.","pos":[2616,2742]},{"content":"Each time you access a property or call a method on a UWP component, an interoperability cost is incurred.","pos":[2747,2853]},{"content":"In fact, creating a UWP component is more costly than creating a .NET object.","pos":[2854,2931]},{"content":"The reasons for this are that the UWP must execute code that transitions from your app's language to the component's language.","pos":[2932,3058]},{"content":"Also, if you pass data to the component, the data must be converted between managed and unmanaged types.","pos":[3059,3163]},{"content":"Using UWP Components efficiently","pos":[3169,3201]},{"content":"If you find that you need to get better performance, you can ensure that your code uses UWP components as efficiently as possible.","pos":[3203,3333]},{"content":"This section discusses some tips for improving performance when you use UWP components.","pos":[3334,3421]},{"content":"It takes a significant number of calls in a short period of time for the performance impact to be noticeable.","pos":[3423,3532]},{"content":"A well-designed application that encapsulates calls to UWP components from business logic and other managed code should not incur huge interoperability costs.","pos":[3533,3691]},{"content":"But if your tests indicate that using UWP components is affecting your app's performance, the tips discussed in this section help you improve performance.","pos":[3692,3846]},{"content":"Consider using .NET for UWP apps","pos":[3852,3884]},{"content":"There are certain cases where you can accomplish a task by using either UWP or .NET for UWP apps.","pos":[3886,3983]},{"content":"It is a good idea to try to not mix .NET types and UWP types.","pos":[3984,4045]},{"content":"Try to stay in one or the other.","pos":[4046,4078]},{"content":"For example, you can parse a stream of xml by using either the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.Data.Xml.Dom.XmlDocument<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR206173)</ept> type (a UWP type) or the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>System.Xml.XmlReader<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.xml.xmlreader.aspx)</ept> type (a .NET type).","pos":[4079,4396],"source":" For example, you can parse a stream of xml by using either the [**Windows.Data.Xml.Dom.XmlDocument**](https://msdn.microsoft.com/library/windows/apps/BR206173) type (a UWP type) or the [**System.Xml.XmlReader**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.xml.xmlreader.aspx) type (a .NET type)."},{"content":"Use the API that is from the same technology as the stream.","pos":[4397,4456]},{"content":"For example, if you read xml from a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MemoryStream<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.memorystream.aspx)</ept>, use the <bpt id=\"p3\">**</bpt>System.Xml.XmlReader<ept id=\"p3\">**</ept> type, because both types are .NET types.","pos":[4457,4674],"source":" For example, if you read xml from a [**MemoryStream**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.memorystream.aspx), use the **System.Xml.XmlReader** type, because both types are .NET types."},{"content":"If you read from a file, use the <bpt id=\"p1\">**</bpt>Windows.Data.Xml.Dom.XmlDocument<ept id=\"p1\">**</ept> type because the file APIs and <bpt id=\"p2\">**</bpt>XmlDocument<ept id=\"p2\">**</ept> are UWP components.","pos":[4675,4811],"source":" If you read from a file, use the **Windows.Data.Xml.Dom.XmlDocument** type because the file APIs and **XmlDocument** are UWP components."},{"content":"Copy Window Runtime objects to .NET types","pos":[4817,4858]},{"content":"When a UWP component returns a UWP object, it might be beneficial to copy the returned object into a .NET object.","pos":[4860,4973]},{"content":"Two places where this is especially important is when you're working with collections and streams.","pos":[4974,5072]},{"content":"If you call a UWP API that returns a collection and then you save and access that collection many times, it might be beneficial to copy the collection into a .NET collection and use the .NET version from then on.","pos":[5074,5286]},{"content":"Cache the results of calls to UWP components for later use","pos":[5292,5350]},{"content":"You might be able to get better performance by saving values into local variables instead of accessing a UWP type multiple times.","pos":[5352,5481]},{"content":"This can be especially beneficial if you use a value inside of a loop.","pos":[5482,5552]},{"content":"Measure your app to see if using local variables improves your app's performance.","pos":[5553,5634]},{"content":"Using cached values can increase your app's speed because it will spend less time on interoperability.","pos":[5635,5737]},{"content":"Combine calls to UWP components","pos":[5743,5774]},{"content":"Try to complete tasks with the fewest number of calls to UWP objects as possible.","pos":[5776,5857]},{"content":"For example, it is usually better to read a large amount of data from a stream than to read small amounts at a time.","pos":[5858,5974]},{"content":"Use APIs that bundle work in as few calls as possible instead of APIs that do less work and require more calls.","pos":[5976,6087]},{"content":"For example, prefer to create an object by calling constructors that initialize multiple properties instead of calling the default constructor and assigning properties one at a time.","pos":[6088,6270]},{"content":"Building a UWP components","pos":[6276,6301]},{"content":"If you write a UWP Component that can be used by apps written in C++ or JavaScript, make sure that your component is designed for good performance.","pos":[6303,6450]},{"content":"All the suggestions for getting good performance in apps apply to getting good performance in components.","pos":[6451,6556]},{"content":"Measure your component to find out which APIs have high traffic patterns and for those areas, consider providing APIs that enable your users to do work with few calls.","pos":[6557,6724]},{"content":"Keep your app fast when you use interop in managed code","pos":[6729,6784]},{"content":"The UWP makes it easy to interoperate between native and managed code, but if you're not careful it can incur performance costs.","pos":[6786,6914]},{"content":"Here we show you how to get good performance when you use interop in your managed UWP apps.","pos":[6915,7006]},{"content":"The UWP allows developers to write apps using XAML with their language of choice thanks to the projections of the UWP APIs available in each language.","pos":[7008,7158]},{"content":"When writing an app in C\\# or Visual Basic, this convenience comes at an interop cost because the UWP APIs are usually implemented in native code, and any UWP invocation from C\\# or Visual Basic requires that the CLR transition from a managed to a native stack frame and marshal function parameters to representations accessible by native code.","pos":[7159,7503]},{"content":"This overhead is negligible for most apps.","pos":[7504,7546]},{"content":"But when you make many calls (hundreds of thousands, to millions) to UWP APIs in the critical path of an app, this cost can become noticeable.","pos":[7547,7689]},{"content":"In general you want to ensure that the time spent in transition between languages is small relative to the execution of the rest of your code.","pos":[7690,7832]},{"content":"This is illustrated by the following diagram.","pos":[7833,7878]},{"content":"Interop transitions should not dominate the program execution time.","pos":[7882,7949]},{"content":"The types listed at <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>.NET for Windows apps<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/br230232.aspx)</ept> don't incur this interop cost when used from C\\# or Visual Basic.","pos":[7983,8170],"source":"\nThe types listed at [**.NET for Windows apps**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/br230232.aspx) don't incur this interop cost when used from C\\# or Visual Basic."},{"content":"As a rule of thumb, you can assume that types in namespaces which begin with “Windows.”","pos":[8171,8258]},{"content":"are part of the UWP, and types in namespaces which begin with “System.”","pos":[8259,8330]},{"content":"are .NET types.","pos":[8331,8346]},{"content":"Keep in mind that even simple usage of UWP types such as allocation or property access incurs an interop cost.","pos":[8347,8457]},{"content":"You should measure your app and determine if interop is taking up a large portion of your apps execution time before optimizing your interop costs.","pos":[8459,8606]},{"content":"When analyzing your app’s performance with Visual Studio, you can easily get an upper bound on your interop costs by using the <bpt id=\"p1\">**</bpt>Functions<ept id=\"p1\">**</ept> view and looking at inclusive time spent in methods which call into the UWP.","pos":[8607,8824],"source":" When analyzing your app’s performance with Visual Studio, you can easily get an upper bound on your interop costs by using the **Functions** view and looking at inclusive time spent in methods which call into the UWP."},{"content":"If your app is slow because of interop overhead, you can improve its performance by reducing calls to UWP APIs on hot code paths.","pos":[8826,8955]},{"content":"For example, a game engine that is doing tons of physics calculations by constantly querying the position and dimensions of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UIElements<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208911)</ept> can save a lot of time by storing the necessary info from <bpt id=\"p3\">**</bpt>UIElements<ept id=\"p3\">**</ept> to local variables, doing calculations on these cached values, and assigning the end result back to the <bpt id=\"p4\">**</bpt>UIElements<ept id=\"p4\">**</ept> after the calculations are done.","pos":[8956,9379],"source":" For example, a game engine that is doing tons of physics calculations by constantly querying the position and dimensions of [**UIElements**](https://msdn.microsoft.com/library/windows/apps/BR208911) can save a lot of time by storing the necessary info from **UIElements** to local variables, doing calculations on these cached values, and assigning the end result back to the **UIElements** after the calculations are done."},{"content":"Another example: if a collection is heavily accessed by C\\# or Visual Basic code, then it is more efficient to use a collection from the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>System.Collections<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.collections.aspx)</ept> namespace, rather than a collection from the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Windows.Foundation.Collections<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR206657)</ept> namespace.","pos":[9380,9776],"source":" Another example: if a collection is heavily accessed by C\\# or Visual Basic code, then it is more efficient to use a collection from the [**System.Collections**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.collections.aspx) namespace, rather than a collection from the [**Windows.Foundation.Collections**](https://msdn.microsoft.com/library/windows/apps/BR206657) namespace."},{"content":"You may also consider combining calls to UWP components; one example where this is possible is by using the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.Storage.BulkAccess<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR207676)</ept> APIs.","pos":[9777,9981],"source":" You may also consider combining calls to UWP components; one example where this is possible is by using the [**Windows.Storage.BulkAccess**](https://msdn.microsoft.com/library/windows/apps/BR207676) APIs."},{"content":"Building a UWP component","pos":[9987,10011]},{"content":"If you write a UWP component for use in apps written in C++ or JavaScript, make sure that your component is designed for good performance.","pos":[10013,10151]},{"content":"Your API surface defines your interop boundary and defines the degree to which your users will have to think about the guidance in this topic.","pos":[10152,10294]},{"content":"If you are distributing your components to other parties then this becomes especially important.","pos":[10295,10391]},{"content":"All of the suggestions for getting good performance in apps apply to getting good performance in components.","pos":[10393,10501]},{"content":"Measure your component to find out which APIs have high traffic patterns, and for those areas, consider providing APIs that enable your users to do work with few calls.","pos":[10502,10670]},{"content":"Significant effort was put into designing the UWP to allow apps to use it without requiring frequent crossing of the interop boundary.","pos":[10671,10805]}],"content":"# Universal Windows Platform Components and optimizing interop\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nCreate Universal Windows Platform (UWP) apps that use UWP Components and interop between native and managed types while avoiding interop performance issues.\n\n## Best practices for interoperability with UWP Components\n\nIf you are not careful, using UWP Components can have a large impact on your app performance. This section discusses how to get good performance when your app uses UWP Components.\n\n### Introduction\n\nInteroperability can have a big impact on performance and you might be using it without even realizing that you are. The UWP handles a lot of the interoperability for you so that you can be more productive and reuse code that was written in other languages. We encourage you to take advantage of what the UWP does for you, but be aware that it can impact performance. This section discusses things you can do to lessen the impact that interoperability has on your app's performance.\n\nThe UWP has a library of types that are accessible from any language that can write a UWP app. You use the UWP types in C\\# or Microsoft Visual Basic the same way you use .NET objects. You don't need to make platform invoke method calls to access the UWP components. This makes writing your apps much less complex, but it is important to realize that there might be more interoperability occurring than you expect. If a UWP component is written in a language other than C\\# or Visual Basic, you cross interoperability boundaries when you use that component. Crossing interoperability boundaries can impact the performance of an app.\n\nWhen you develop a UWP app in C\\# or Visual Basic, the two most common set of APIs that you use are the UWP APIs and the .NET APIs for UWP apps. In general, types that are defined in the UWP are in namespaces that begin with \"Windows.\" and .NET types are in namespaces that begin with \"System.\" There are exceptions, though. The types in .NET for UWP apps do not require interoperability when they are used. If you find that you have bad performance in an area that uses UWP, you might be able to use .NET for UWP apps instead to get better performance.\n\n**Note**  \nMost of the UWP components that ship with Windows 10 are implemented in C++ so you cross interoperability boundaries when you use them from C\\# or Visual Basic. As always, make sure to measure your app to see if using UWP components affects your app's performance before you invest in making changes to your code.\n\nIn this topic, when we say \"UWP components\", we mean components that are written in a language other than C\\# or Visual Basic.\n\n \n\nEach time you access a property or call a method on a UWP component, an interoperability cost is incurred. In fact, creating a UWP component is more costly than creating a .NET object. The reasons for this are that the UWP must execute code that transitions from your app's language to the component's language. Also, if you pass data to the component, the data must be converted between managed and unmanaged types.\n\n### Using UWP Components efficiently\n\nIf you find that you need to get better performance, you can ensure that your code uses UWP components as efficiently as possible. This section discusses some tips for improving performance when you use UWP components.\n\nIt takes a significant number of calls in a short period of time for the performance impact to be noticeable. A well-designed application that encapsulates calls to UWP components from business logic and other managed code should not incur huge interoperability costs. But if your tests indicate that using UWP components is affecting your app's performance, the tips discussed in this section help you improve performance.\n\n### Consider using .NET for UWP apps\n\nThere are certain cases where you can accomplish a task by using either UWP or .NET for UWP apps. It is a good idea to try to not mix .NET types and UWP types. Try to stay in one or the other. For example, you can parse a stream of xml by using either the [**Windows.Data.Xml.Dom.XmlDocument**](https://msdn.microsoft.com/library/windows/apps/BR206173) type (a UWP type) or the [**System.Xml.XmlReader**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.xml.xmlreader.aspx) type (a .NET type). Use the API that is from the same technology as the stream. For example, if you read xml from a [**MemoryStream**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.memorystream.aspx), use the **System.Xml.XmlReader** type, because both types are .NET types. If you read from a file, use the **Windows.Data.Xml.Dom.XmlDocument** type because the file APIs and **XmlDocument** are UWP components.\n\n### Copy Window Runtime objects to .NET types\n\nWhen a UWP component returns a UWP object, it might be beneficial to copy the returned object into a .NET object. Two places where this is especially important is when you're working with collections and streams.\n\nIf you call a UWP API that returns a collection and then you save and access that collection many times, it might be beneficial to copy the collection into a .NET collection and use the .NET version from then on.\n\n### Cache the results of calls to UWP components for later use\n\nYou might be able to get better performance by saving values into local variables instead of accessing a UWP type multiple times. This can be especially beneficial if you use a value inside of a loop. Measure your app to see if using local variables improves your app's performance. Using cached values can increase your app's speed because it will spend less time on interoperability.\n\n### Combine calls to UWP components\n\nTry to complete tasks with the fewest number of calls to UWP objects as possible. For example, it is usually better to read a large amount of data from a stream than to read small amounts at a time.\n\nUse APIs that bundle work in as few calls as possible instead of APIs that do less work and require more calls. For example, prefer to create an object by calling constructors that initialize multiple properties instead of calling the default constructor and assigning properties one at a time.\n\n### Building a UWP components\n\nIf you write a UWP Component that can be used by apps written in C++ or JavaScript, make sure that your component is designed for good performance. All the suggestions for getting good performance in apps apply to getting good performance in components. Measure your component to find out which APIs have high traffic patterns and for those areas, consider providing APIs that enable your users to do work with few calls.\n\n## Keep your app fast when you use interop in managed code\n\nThe UWP makes it easy to interoperate between native and managed code, but if you're not careful it can incur performance costs. Here we show you how to get good performance when you use interop in your managed UWP apps.\n\nThe UWP allows developers to write apps using XAML with their language of choice thanks to the projections of the UWP APIs available in each language. When writing an app in C\\# or Visual Basic, this convenience comes at an interop cost because the UWP APIs are usually implemented in native code, and any UWP invocation from C\\# or Visual Basic requires that the CLR transition from a managed to a native stack frame and marshal function parameters to representations accessible by native code. This overhead is negligible for most apps. But when you make many calls (hundreds of thousands, to millions) to UWP APIs in the critical path of an app, this cost can become noticeable. In general you want to ensure that the time spent in transition between languages is small relative to the execution of the rest of your code. This is illustrated by the following diagram.\n\n![Interop transitions should not dominate the program execution time.](images/interop-transitions.png)\nThe types listed at [**.NET for Windows apps**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/br230232.aspx) don't incur this interop cost when used from C\\# or Visual Basic. As a rule of thumb, you can assume that types in namespaces which begin with “Windows.” are part of the UWP, and types in namespaces which begin with “System.” are .NET types. Keep in mind that even simple usage of UWP types such as allocation or property access incurs an interop cost.\n\nYou should measure your app and determine if interop is taking up a large portion of your apps execution time before optimizing your interop costs. When analyzing your app’s performance with Visual Studio, you can easily get an upper bound on your interop costs by using the **Functions** view and looking at inclusive time spent in methods which call into the UWP.\n\nIf your app is slow because of interop overhead, you can improve its performance by reducing calls to UWP APIs on hot code paths. For example, a game engine that is doing tons of physics calculations by constantly querying the position and dimensions of [**UIElements**](https://msdn.microsoft.com/library/windows/apps/BR208911) can save a lot of time by storing the necessary info from **UIElements** to local variables, doing calculations on these cached values, and assigning the end result back to the **UIElements** after the calculations are done. Another example: if a collection is heavily accessed by C\\# or Visual Basic code, then it is more efficient to use a collection from the [**System.Collections**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.collections.aspx) namespace, rather than a collection from the [**Windows.Foundation.Collections**](https://msdn.microsoft.com/library/windows/apps/BR206657) namespace. You may also consider combining calls to UWP components; one example where this is possible is by using the [**Windows.Storage.BulkAccess**](https://msdn.microsoft.com/library/windows/apps/BR207676) APIs.\n\n### Building a UWP component\n\nIf you write a UWP component for use in apps written in C++ or JavaScript, make sure that your component is designed for good performance. Your API surface defines your interop boundary and defines the degree to which your users will have to think about the guidance in this topic. If you are distributing your components to other parties then this becomes especially important.\n\nAll of the suggestions for getting good performance in apps apply to getting good performance in components. Measure your component to find out which APIs have high traffic patterns, and for those areas, consider providing APIs that enable your users to do work with few calls. Significant effort was put into designing the UWP to allow apps to use it without requiring frequent crossing of the interop boundary.\n\n \n"}