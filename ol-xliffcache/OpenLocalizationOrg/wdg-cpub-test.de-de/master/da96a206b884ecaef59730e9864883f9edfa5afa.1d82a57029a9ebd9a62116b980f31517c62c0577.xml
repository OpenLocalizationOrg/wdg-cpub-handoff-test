{"nodes":[{"pos":[17,208],"content":"This topic explains the XML/XAML namespace (xmlns) mappings as found in the root element of most XAML files. It also describes how to produce similar mappings for custom types and assemblies.","needQuote":true,"needEscape":true,"nodes":[{"content":"This topic explains the XML/XAML namespace (xmlns) mappings as found in the root element of most XAML files. It also describes how to produce similar mappings for custom types and assemblies.","pos":[0,191],"nodes":[{"content":"This topic explains the XML/XAML namespace (xmlns) mappings as found in the root element of most XAML files.","pos":[0,108]},{"content":"It also describes how to produce similar mappings for custom types and assemblies.","pos":[109,191]}]}]},{"pos":[216,253],"content":"XAML namespaces and namespace mapping","needQuote":true,"needEscape":true,"nodes":[{"content":"XAML namespaces and namespace mapping","pos":[0,37]}]},{"content":"XAML namespaces and namespace mapping","pos":[310,347]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[349,387]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[388,483],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"This topic explains the XML/XAML namespace (<bpt id=\"p1\">**</bpt>xmlns<ept id=\"p1\">**</ept>) mappings as found in the root element of most XAML files.","pos":[485,597],"source":"This topic explains the XML/XAML namespace (**xmlns**) mappings as found in the root element of most XAML files."},{"content":"It also describes how to produce similar mappings for custom types and assemblies.","pos":[598,680]},{"content":"How XAML namespaces relate to code definition and type libraries","pos":[685,749]},{"content":"Both in its general purpose and for its application to Windows Runtime app programming, XAML is used to declare objects, properties of those objects, and object-property relationships expressed as hierarchies.","pos":[751,960]},{"content":"The objects you declare in XAML are backed by type libraries or other representations that are defined by other programming techniques and languages.","pos":[961,1110]},{"content":"These libraries might be:","pos":[1111,1136]},{"content":"The built-in set of objects for the Windows Runtime.","pos":[1142,1194]},{"content":"This is a fixed set of objects, and accessing these objects from XAML uses internal type-mapping and activation logic.","pos":[1195,1313]},{"content":"Distributed libraries that are provided either by Microsoft or by third parties.","pos":[1318,1398]},{"content":"Libraries that represent the definition of a third-party control that your app incorporates and your package redistributes.","pos":[1403,1526]},{"content":"Your own library, which is part of your project and which holds some or all of your user code definitions.","pos":[1531,1637]},{"content":"Backing type info is associated with particular XAML namespace definitions.","pos":[1639,1714]},{"content":"XAML frameworks such as the Windows Runtime can aggregate multiple assemblies and multiple code namespaces to map to a single XAML namespace.","pos":[1715,1856]},{"content":"This enables the concept of a XAML vocabulary that covers a larger programming framework or technology.","pos":[1857,1960]},{"content":"A XAML vocabulary can be quite extensiveâ€”for example, most of the XAML documented for Windows Runtime apps in this reference constitutes a single XAML vocabulary.","pos":[1961,2123]},{"content":"A XAML vocabulary is also extensible: you extend it by adding types to the backing code definitions, making sure to include the types in code namespaces that are already used as mapped namespace sources for the XAML vocabulary.","pos":[2124,2351]},{"content":"A XAML processor can look up types and members from the backing assemblies associated with that XAML namespace when it creates a run-time object representation.","pos":[2353,2513]},{"content":"This is why XAML is useful as a way to formalize and exchange definitions of object-construction behavior, and why XAML is used as a UI definition technique for a Windows Store app.","pos":[2514,2695]},{"content":"XAML namespaces in typical XAML markup usage","pos":[2700,2744]},{"content":"A XAML file almost always declares a default XAML namespace in its root element.","pos":[2746,2826]},{"content":"The default XAML namespace defines which elements you can declare without qualifying them by a prefix.","pos":[2827,2929]},{"content":"For example, if you declare an element <ph id=\"ph1\">`&lt;Balloon /&gt;`</ph>, a XAML parser will expect that an element <bpt id=\"p1\">**</bpt>Balloon<ept id=\"p1\">**</ept> exists and is valid in the default XAML namespace.","pos":[2930,3088],"source":" For example, if you declare an element `<Balloon />`, a XAML parser will expect that an element **Balloon** exists and is valid in the default XAML namespace."},{"content":"In contrast, if <bpt id=\"p1\">**</bpt>Balloon<ept id=\"p1\">**</ept> is not in the defined default XAML namespace, you must instead qualify that element name with a prefix, for example <ph id=\"ph1\">`&lt;party:Balloon /&gt;`</ph>.","pos":[3089,3253],"source":" In contrast, if **Balloon** is not in the defined default XAML namespace, you must instead qualify that element name with a prefix, for example `<party:Balloon />`."},{"content":"The prefix indicates that the element exists in a different XAML namespace than the default namespace, and you must map a XAML namespace to the prefix <bpt id=\"p1\">**</bpt>party<ept id=\"p1\">**</ept> before you can use this element.","pos":[3254,3447],"source":" The prefix indicates that the element exists in a different XAML namespace than the default namespace, and you must map a XAML namespace to the prefix **party** before you can use this element."},{"content":"XAML namespaces apply to the specific element on which they are declared, and also to any element that is contained by that element in the XAML structure.","pos":[3448,3602]},{"content":"For this reason, XAML namespaces are almost always declared on root elements of a XAML file to take advantage of this inheritance.","pos":[3603,3733]},{"content":"The default and XAML language XAML namespace declarations","pos":[3738,3795]},{"content":"Within the root element of most XAML files, there are two <bpt id=\"p1\">**</bpt>xmlns<ept id=\"p1\">**</ept> declarations.","pos":[3797,3878],"source":"Within the root element of most XAML files, there are two **xmlns** declarations."},{"content":"The first declaration maps a XAML namespace as the default:","pos":[3879,3938]},{"content":"This is the same XAML namespace identifier used in several predecessor Microsoft technologies that also use XAML as a UI definition markup format.","pos":[4008,4154]},{"content":"The use of the same identifier is deliberate, and is helpful when you migrate previously defined UI to a Windows Runtime app using C++, C#, or Visual Basic.","pos":[4155,4311]},{"pos":[4313,4449],"content":"The second declaration maps a separate XAML namespace for the XAML-defined language elements, mapping it (typically) to the \"x:\" prefix:"},{"pos":[4508,4669],"content":"This <bpt id=\"p1\">**</bpt>xmlns<ept id=\"p1\">**</ept> value, and the \"x:\" prefix it is mapped to, is also identical to the definitions used in several predecessor Microsoft technologies that use XAML.","source":"This **xmlns** value, and the \"x:\" prefix it is mapped to, is also identical to the definitions used in several predecessor Microsoft technologies that use XAML."},{"content":"The relationship between these declarations is that XAML is a language definition, and the Windows Runtime is one implementation that uses XAML as a language and defines a specific vocabulary where its types are referenced in XAML.","pos":[4671,4902]},{"content":"The XAML language specifies certain language elements, and each of these should be accessible through XAML processor implementations working against the XAML namespace.","pos":[4904,5072]},{"content":"The \"x:\" mapping convention for the XAML language XAML namespace is followed by project templates, sample code, and the documentation for language features.","pos":[5073,5229]},{"content":"The XAML language namespace defines several commonly used features that are necessary even for basic Windows Runtime apps using C++, C#, or Visual Basic.","pos":[5230,5383]},{"content":"For example, to join any code-behind to a XAML file through a partial class, you must name that class as the <bpt id=\"p1\">[</bpt>x:Class attribute<ept id=\"p1\">](x-class-attribute.md)</ept> in the root element of the relevant XAML file.","pos":[5384,5581],"source":" For example, to join any code-behind to a XAML file through a partial class, you must name that class as the [x:Class attribute](x-class-attribute.md) in the root element of the relevant XAML file."},{"content":"Or, any element as defined in a XAML page as a keyed resource in a <bpt id=\"p1\">[</bpt>ResourceDictionary and XAML resource references<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt187273)</ept> must have the <bpt id=\"p2\">[</bpt>x:Key attribute<ept id=\"p2\">](x-key-attribute.md)</ept> set on the object element in question.","pos":[5582,5847],"source":" Or, any element as defined in a XAML page as a keyed resource in a [ResourceDictionary and XAML resource references](https://msdn.microsoft.com/library/windows/apps/mt187273) must have the [x:Key attribute](x-key-attribute.md) set on the object element in question."},{"content":"Other XAML namespaces","pos":[5852,5873]},{"content":"In addition to the default namespace and the XAML language XAML namespace \"x:\", you may also see other mapped XAML namespaces in the initial default XAML for apps as generated by Microsoft Visual Studio.","pos":[5875,6078]},{"content":"d: (http://schemas.microsoft.com/expression/blend/2008)","pos":[6086,6141]},{"content":"The \"d:\" XAML namespace is intended for designer support, specifically designer support in the XAML design surfaces of Microsoft Visual Studio.","pos":[6145,6288]},{"content":"The\" d:\" XAML namespace enables designer or design-time attributes on XAML elements.","pos":[6289,6373]},{"content":"These designer attributes affect only the design aspects of how XAML behaves.","pos":[6374,6451]},{"content":"The designer attributes are ignored when the same XAML is loaded by the Windows Runtime XAML parser when an app runs.","pos":[6452,6569]},{"content":"Generally, the designer attributes are valid on any XAML element, but in practice there are only certain scenarios where applying a designer attribute yourself is appropriate.","pos":[6570,6745]},{"content":"In particular, many of the designer attributes are intended to provide a better experience for interacting with data contexts and data sources while you are developing XAML and code that use data binding.","pos":[6746,6950]},{"content":"<bpt id=\"p1\">**</bpt>d:DesignHeight and d:DesignWidth attributes:<ept id=\"p1\">**</ept> These attributes are sometimes applied to the root of a XAML file that Visual Studio or another XAML designer surface creates for you.","pos":[6956,7139],"source":"**d:DesignHeight and d:DesignWidth attributes:** These attributes are sometimes applied to the root of a XAML file that Visual Studio or another XAML designer surface creates for you."},{"content":"For example, these attributes are set on the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UserControl<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227647)</ept> root of the XAML that is created if you add a new <bpt id=\"p3\">**</bpt>UserControl<ept id=\"p3\">**</ept> to your app project.","pos":[7140,7347],"source":" For example, these attributes are set on the [**UserControl**](https://msdn.microsoft.com/library/windows/apps/br227647) root of the XAML that is created if you add a new **UserControl** to your app project."},{"content":"These attributes make it easier to design the composition of the XAML content, so that you have some anticipation of the layout constraints that might exist once that XAML content is used for a control instance or other part of a larger UI page.","pos":[7348,7593]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  If you are migrating XAML from Microsoft Silverlight you might have these attributes on root elements that represent an entire UI page.","pos":[7598,7743],"source":"**Note**  If you are migrating XAML from Microsoft Silverlight you might have these attributes on root elements that represent an entire UI page."},{"content":"You might want to remove the attributes in this case.","pos":[7744,7797]},{"content":"Other features of the XAML designers such as the simulator are probably more useful for designing page layouts that handle scaling and view states well than is a fixed size page layout using <bpt id=\"p1\">**</bpt>d:DesignHeight<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>d:DesignWidth<ept id=\"p2\">**</ept>.","pos":[7798,8030],"source":" Other features of the XAML designers such as the simulator are probably more useful for designing page layouts that handle scaling and view states well than is a fixed size page layout using **d:DesignHeight** and **d:DesignWidth**."},{"pos":[8036,8260],"content":"<bpt id=\"p1\">**</bpt>d:DataContext attribute:<ept id=\"p1\">**</ept> You can set this attribute on a page root or a control to override any explicit or inherited <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>DataContext<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208713)</ept> that object otherwise has.","source":"**d:DataContext attribute:** You can set this attribute on a page root or a control to override any explicit or inherited [**DataContext**](https://msdn.microsoft.com/library/windows/apps/br208713) that object otherwise has."},{"pos":[8265,8505],"content":"<bpt id=\"p1\">**</bpt>d:DesignSource attribute:<ept id=\"p1\">**</ept> Specifies a design-time data source for a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>CollectionViewSource<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br209833)</ept>, overriding <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>Source<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br209835)</ept>.","source":"**d:DesignSource attribute:** Specifies a design-time data source for a [**CollectionViewSource**](https://msdn.microsoft.com/library/windows/apps/br209833), overriding [**Source**](https://msdn.microsoft.com/library/windows/apps/br209835)."},{"content":"<bpt id=\"p1\">**</bpt>d:DesignInstance and d:DesignData markup extensions:<ept id=\"p1\">**</ept> These markup extensions are used to provide the design-time data resources for either <bpt id=\"p2\">**</bpt>d:DataContext<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>d:DesignSource<ept id=\"p3\">**</ept>.","pos":[8510,8693],"source":"**d:DesignInstance and d:DesignData markup extensions:** These markup extensions are used to provide the design-time data resources for either **d:DataContext** or **d:DesignSource**."},{"content":"We won't fully document how to use design-time data resources here.","pos":[8694,8761]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Design-Time Attributes<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkId=272504)</ept>.","pos":[8762,8855],"source":" For more info, see [Design-Time Attributes](http://go.microsoft.com/fwlink/p/?LinkId=272504)."},{"content":"For some usage examples, see <bpt id=\"p1\">[</bpt>Sample data on the design surface, and for prototyping<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt517866)</ept>.","pos":[8856,9000],"source":" For some usage examples, see [Sample data on the design surface, and for prototyping](https://msdn.microsoft.com/library/windows/apps/mt517866)."},{"content":"**mc: (http://schemas.openxmlformats.org/markup-compatibility/2006) **","pos":[9006,9076]},{"content":"\" mc:\" indicates and supports a markup compatibility mode for reading XAML.","pos":[9078,9153]},{"content":"Typically, the \"d:\" prefix is associated with the attribute <bpt id=\"p1\">**</bpt>mc:Ignorable<ept id=\"p1\">**</ept>.","pos":[9154,9231],"source":" Typically, the \"d:\" prefix is associated with the attribute **mc:Ignorable**."},{"content":"This technique enables run-time XAML parsers to ignore the design attributes in \"d:\".","pos":[9232,9317]},{"pos":[9323,9349],"content":"<bpt id=\"p1\">**</bpt>local:<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>common:<ept id=\"p2\">**</ept>","source":"**local:** and **common:**"},{"content":"\"local:\" is a prefix that is often mapped for you within the XAML pages for a templated Windows Store app project.","pos":[9351,9465]},{"content":"It's mapped to refer to the same namespace that's created to contain the <bpt id=\"p1\">[</bpt>x:Class attribute<ept id=\"p1\">](x-class-attribute.md)</ept> and code for all the XAML files including app.xaml.","pos":[9466,9632],"source":" It's mapped to refer to the same namespace that's created to contain the [x:Class attribute](x-class-attribute.md) and code for all the XAML files including app.xaml."},{"content":"So long as you define any custom classes you want to use in XAML in this same namespace, you can use the <bpt id=\"p1\">**</bpt>local:<ept id=\"p1\">**</ept> prefix to refer to your custom types in XAML.","pos":[9633,9794],"source":" So long as you define any custom classes you want to use in XAML in this same namespace, you can use the **local:** prefix to refer to your custom types in XAML."},{"content":"A related prefix that comes from a templated Windows Store app project is <bpt id=\"p1\">**</bpt>common:<ept id=\"p1\">**</ept>.","pos":[9795,9881],"source":" A related prefix that comes from a templated Windows Store app project is **common:**."},{"content":"This prefix refers to a nested \"Common\" namespace that contains utility classes such as converters and commands, and you can find the definitions in the Common folder in the <bpt id=\"p1\">**</bpt>Solution Explorer<ept id=\"p1\">**</ept> view.","pos":[9882,10083],"source":" This prefix refers to a nested \"Common\" namespace that contains utility classes such as converters and commands, and you can find the definitions in the Common folder in the **Solution Explorer** view."},{"content":"vsm:","pos":[10091,10095]},{"content":"Do not use.","pos":[10099,10110]},{"content":"\"vsm:\" is a prefix that is sometimes seen in older XAML templates imported from other Microsoft technologies.","pos":[10111,10220]},{"content":"The namespace originally addressed a legacy namespace tooling issue.","pos":[10221,10289]},{"content":"You should delete XAML namespace definitions for \"vsm:\" in any XAML you use for the Windows Runtime, and change any prefix usages for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>VisualState<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209007)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>VisualStateGroup<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br209014)</ept> and related objects to use the default XAML namespace instead.","pos":[10290,10644],"source":" You should delete XAML namespace definitions for \"vsm:\" in any XAML you use for the Windows Runtime, and change any prefix usages for [**VisualState**](https://msdn.microsoft.com/library/windows/apps/br209007), [**VisualStateGroup**](https://msdn.microsoft.com/library/windows/apps/br209014) and related objects to use the default XAML namespace instead."},{"content":"For more info on XAML migration, see <bpt id=\"p1\">[</bpt>Migrating Silverlight or WPF XAML/code to a Windows Runtime app<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br229571)</ept>.","pos":[10645,10806],"source":" For more info on XAML migration, see [Migrating Silverlight or WPF XAML/code to a Windows Runtime app](https://msdn.microsoft.com/library/windows/apps/br229571)."},{"content":"Mapping custom types to XAML namespaces and prefixes","pos":[10811,10863]},{"content":"You can map a XAML namespace so that you can use XAML to access your own custom types.","pos":[10865,10951]},{"content":"In other words, you are mapping a code namespace as it exists in a code representation that defines the custom type, and assigning it a XAML namespace along with a prefix for usage.","pos":[10952,11133]},{"content":"Custom types for XAML can be defined either in a Microsoft .NET language (C# or Microsoft Visual Basic) or in C++.","pos":[11134,11248]},{"content":"The mapping is made by defining an <bpt id=\"p1\">**</bpt>xmlns<ept id=\"p1\">**</ept> prefix.","pos":[11249,11301],"source":" The mapping is made by defining an **xmlns** prefix."},{"content":"For example, <ph id=\"ph1\">`xmlns:myTypes`</ph> defines a new XAML namespace that is accessed by prefixing all usages with the token <ph id=\"ph2\">`myTypes:`</ph>.","pos":[11302,11427],"source":" For example, `xmlns:myTypes` defines a new XAML namespace that is accessed by prefixing all usages with the token `myTypes:`."},{"content":"An <bpt id=\"p1\">**</bpt>xmlns<ept id=\"p1\">**</ept> definition includes a value as well as the prefix naming.","pos":[11429,11499],"source":"An **xmlns** definition includes a value as well as the prefix naming."},{"content":"The value is a string that goes inside quotation marks, following an equal sign.","pos":[11500,11580]},{"content":"A common XML convention is to associate the XML namespace with a Uniform Resource Identifier (URI), so that there is a convention for uniqueness and identification.","pos":[11581,11745]},{"content":"You also see this convention for the default XAML namespace and the XAML language XAML namespace, as well as for some lesser-used XAML namespaces that are used by Windows Runtime XAML.","pos":[11746,11930]},{"content":"But for a XAML namespace that maps custom types, instead of specifying a URI, you begin the prefix definition with the token \"using:\".","pos":[11931,12065]},{"content":"Following the \"using:\" token, you then name the code namespace.","pos":[12066,12129]},{"pos":[12131,12377],"content":"For example, to map a \"custom1\" prefix that enables you to reference a \"CustomClasses\" namespace, and use classes from that namespace or assembly as object elements in XAML, your XAML page should include the following mapping on the root element:"},{"content":"Partial classes of the same page scope do not need to be mapped.","pos":[12417,12481]},{"content":"For example, you don't need prefixes to reference any event handlers that you defined for handling events from the XAML UI definition of your page.","pos":[12482,12629]},{"content":"Also, many of the starting XAML pages from Visual Studio generated projects for a Windows Runtime app using C++, C#, or Visual Basic already map a \"local:\" prefix, which references the project-specified default namespace and the namespace used by partial class definitions.","pos":[12630,12903]},{"content":"CLR language rules","pos":[12909,12927]},{"content":"If you are writing your backing code in a .NET language (C# or Microsoft Visual Basic), you might be using conventions that use a dot (\".\") as part of namespace names to create a conceptual hierarchy of code namespaces.","pos":[12929,13148]},{"content":"If your namespace definition contains a dot, the dot should be part of the value you specify after the \"using:\" token.","pos":[13149,13267]},{"content":"If your code-behind file or code definition file is a C++ file, there are certain conventions that still follow the common language runtime (CLR) language form, so that there is no difference in the XAML syntax.","pos":[13269,13480]},{"content":"If you declare nested namespaces in C++, the separator between the successive nested namespace strings should be \".\" rather than \"::\" when you specify the value that follows the \"using:\" token.","pos":[13481,13674]},{"content":"Don't use nested types (such as nesting an enumeration within a class) when you define your code for use with XAML.","pos":[13676,13791]},{"content":"Nested types can't be evaluated.","pos":[13792,13824]},{"content":"There's no way for the XAML parser to distinguish that a dot is part of the nested type name rather than part of the namespace name.","pos":[13825,13957]},{"content":"Custom types and assemblies","pos":[13962,13989]},{"content":"The name of the assembly that defines the backing types for a XAML namespace is not specified in the mapping.","pos":[13991,14100]},{"content":"The logic for which assemblies are available is controlled at the app-definition level and is part of basic app deployment and security principles.","pos":[14101,14248]},{"content":"Declare any assembly that you want included as a code-definition source for XAML as a dependent assembly in project settings.","pos":[14249,14374]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Creating Windows Runtime components in C# and Visual Basic<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh441572.aspx)</ept>.","pos":[14375,14523],"source":" For more info, see [Creating Windows Runtime components in C# and Visual Basic](https://msdn.microsoft.com/library/windows/apps/xaml/hh441572.aspx)."},{"content":"If you are referencing custom types from the primary app's application definition or page definitions, those types are available without further dependent assembly configuration, but you still must map the code namespace that contains those types.","pos":[14525,14772]},{"content":"A common convention is to map the prefix \"local\" for the default code namespace of any given XAML page.","pos":[14773,14876]},{"content":"This convention is often included in starting project templates for XAML projects.","pos":[14877,14959]},{"content":"Attached properties","pos":[14964,14983]},{"content":"If you are referencing attached properties, the owner-type portion of the attached property name must either be in the default XAML namespace or be prefixed.","pos":[14985,15142]},{"content":"It's rare to prefix attributes separately from their elements but this is one case where it's sometimes required, particularly for a custom attached property.","pos":[15143,15301]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Custom attached properties<ept id=\"p1\">](custom-attached-properties.md)</ept>.","pos":[15302,15381],"source":" For more info, see [Custom attached properties](custom-attached-properties.md)."},{"content":"Related topics","pos":[15386,15400]},{"content":"XAML overview","pos":[15405,15418]},{"content":"XAML syntax guide","pos":[15441,15458]},{"content":"Creating Windows Runtime components in C# and Visual Basic","pos":[15485,15543]},{"content":"C#, VB, and C++ project templates for Windows Runtime apps","pos":[15616,15674]},{"content":"Migrating Silverlight or WPF XAML/code to a Windows Runtime app","pos":[15737,15800]}],"content":"---\ndescription: This topic explains the XML/XAML namespace (xmlns) mappings as found in the root element of most XAML files. It also describes how to produce similar mappings for custom types and assemblies.\ntitle: XAML namespaces and namespace mapping\nms.assetid: A19DFF78-E692-47AE-8221-AB5EA9470E8B\n---\n\n# XAML namespaces and namespace mapping\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nThis topic explains the XML/XAML namespace (**xmlns**) mappings as found in the root element of most XAML files. It also describes how to produce similar mappings for custom types and assemblies.\n\n## How XAML namespaces relate to code definition and type libraries\n\nBoth in its general purpose and for its application to Windows Runtime app programming, XAML is used to declare objects, properties of those objects, and object-property relationships expressed as hierarchies. The objects you declare in XAML are backed by type libraries or other representations that are defined by other programming techniques and languages. These libraries might be:\n\n-   The built-in set of objects for the Windows Runtime. This is a fixed set of objects, and accessing these objects from XAML uses internal type-mapping and activation logic.\n-   Distributed libraries that are provided either by Microsoft or by third parties.\n-   Libraries that represent the definition of a third-party control that your app incorporates and your package redistributes.\n-   Your own library, which is part of your project and which holds some or all of your user code definitions.\n\nBacking type info is associated with particular XAML namespace definitions. XAML frameworks such as the Windows Runtime can aggregate multiple assemblies and multiple code namespaces to map to a single XAML namespace. This enables the concept of a XAML vocabulary that covers a larger programming framework or technology. A XAML vocabulary can be quite extensiveâ€”for example, most of the XAML documented for Windows Runtime apps in this reference constitutes a single XAML vocabulary. A XAML vocabulary is also extensible: you extend it by adding types to the backing code definitions, making sure to include the types in code namespaces that are already used as mapped namespace sources for the XAML vocabulary.\n\nA XAML processor can look up types and members from the backing assemblies associated with that XAML namespace when it creates a run-time object representation. This is why XAML is useful as a way to formalize and exchange definitions of object-construction behavior, and why XAML is used as a UI definition technique for a Windows Store app.\n\n## XAML namespaces in typical XAML markup usage\n\nA XAML file almost always declares a default XAML namespace in its root element. The default XAML namespace defines which elements you can declare without qualifying them by a prefix. For example, if you declare an element `<Balloon />`, a XAML parser will expect that an element **Balloon** exists and is valid in the default XAML namespace. In contrast, if **Balloon** is not in the defined default XAML namespace, you must instead qualify that element name with a prefix, for example `<party:Balloon />`. The prefix indicates that the element exists in a different XAML namespace than the default namespace, and you must map a XAML namespace to the prefix **party** before you can use this element. XAML namespaces apply to the specific element on which they are declared, and also to any element that is contained by that element in the XAML structure. For this reason, XAML namespaces are almost always declared on root elements of a XAML file to take advantage of this inheritance.\n\n## The default and XAML language XAML namespace declarations\n\nWithin the root element of most XAML files, there are two **xmlns** declarations. The first declaration maps a XAML namespace as the default: `xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"`\n\nThis is the same XAML namespace identifier used in several predecessor Microsoft technologies that also use XAML as a UI definition markup format. The use of the same identifier is deliberate, and is helpful when you migrate previously defined UI to a Windows Runtime app using C++, C#, or Visual Basic.\n\nThe second declaration maps a separate XAML namespace for the XAML-defined language elements, mapping it (typically) to the \"x:\" prefix: `xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"`\n\nThis **xmlns** value, and the \"x:\" prefix it is mapped to, is also identical to the definitions used in several predecessor Microsoft technologies that use XAML.\n\nThe relationship between these declarations is that XAML is a language definition, and the Windows Runtime is one implementation that uses XAML as a language and defines a specific vocabulary where its types are referenced in XAML.\n\nThe XAML language specifies certain language elements, and each of these should be accessible through XAML processor implementations working against the XAML namespace. The \"x:\" mapping convention for the XAML language XAML namespace is followed by project templates, sample code, and the documentation for language features. The XAML language namespace defines several commonly used features that are necessary even for basic Windows Runtime apps using C++, C#, or Visual Basic. For example, to join any code-behind to a XAML file through a partial class, you must name that class as the [x:Class attribute](x-class-attribute.md) in the root element of the relevant XAML file. Or, any element as defined in a XAML page as a keyed resource in a [ResourceDictionary and XAML resource references](https://msdn.microsoft.com/library/windows/apps/mt187273) must have the [x:Key attribute](x-key-attribute.md) set on the object element in question.\n\n## Other XAML namespaces\n\nIn addition to the default namespace and the XAML language XAML namespace \"x:\", you may also see other mapped XAML namespaces in the initial default XAML for apps as generated by Microsoft Visual Studio.\n\n### **d: (http://schemas.microsoft.com/expression/blend/2008)**\n\nThe \"d:\" XAML namespace is intended for designer support, specifically designer support in the XAML design surfaces of Microsoft Visual Studio. The\" d:\" XAML namespace enables designer or design-time attributes on XAML elements. These designer attributes affect only the design aspects of how XAML behaves. The designer attributes are ignored when the same XAML is loaded by the Windows Runtime XAML parser when an app runs. Generally, the designer attributes are valid on any XAML element, but in practice there are only certain scenarios where applying a designer attribute yourself is appropriate. In particular, many of the designer attributes are intended to provide a better experience for interacting with data contexts and data sources while you are developing XAML and code that use data binding.\n\n-   **d:DesignHeight and d:DesignWidth attributes:** These attributes are sometimes applied to the root of a XAML file that Visual Studio or another XAML designer surface creates for you. For example, these attributes are set on the [**UserControl**](https://msdn.microsoft.com/library/windows/apps/br227647) root of the XAML that is created if you add a new **UserControl** to your app project. These attributes make it easier to design the composition of the XAML content, so that you have some anticipation of the layout constraints that might exist once that XAML content is used for a control instance or other part of a larger UI page.\n\n   **Note**  If you are migrating XAML from Microsoft Silverlight you might have these attributes on root elements that represent an entire UI page. You might want to remove the attributes in this case. Other features of the XAML designers such as the simulator are probably more useful for designing page layouts that handle scaling and view states well than is a fixed size page layout using **d:DesignHeight** and **d:DesignWidth**.\n\n-   **d:DataContext attribute:** You can set this attribute on a page root or a control to override any explicit or inherited [**DataContext**](https://msdn.microsoft.com/library/windows/apps/br208713) that object otherwise has.\n-   **d:DesignSource attribute:** Specifies a design-time data source for a [**CollectionViewSource**](https://msdn.microsoft.com/library/windows/apps/br209833), overriding [**Source**](https://msdn.microsoft.com/library/windows/apps/br209835).\n-   **d:DesignInstance and d:DesignData markup extensions:** These markup extensions are used to provide the design-time data resources for either **d:DataContext** or **d:DesignSource**. We won't fully document how to use design-time data resources here. For more info, see [Design-Time Attributes](http://go.microsoft.com/fwlink/p/?LinkId=272504). For some usage examples, see [Sample data on the design surface, and for prototyping](https://msdn.microsoft.com/library/windows/apps/mt517866).\n\n### **mc: (http://schemas.openxmlformats.org/markup-compatibility/2006) **\n\n\" mc:\" indicates and supports a markup compatibility mode for reading XAML. Typically, the \"d:\" prefix is associated with the attribute **mc:Ignorable**. This technique enables run-time XAML parsers to ignore the design attributes in \"d:\".\n\n### **local:** and **common:**\n\n\"local:\" is a prefix that is often mapped for you within the XAML pages for a templated Windows Store app project. It's mapped to refer to the same namespace that's created to contain the [x:Class attribute](x-class-attribute.md) and code for all the XAML files including app.xaml. So long as you define any custom classes you want to use in XAML in this same namespace, you can use the **local:** prefix to refer to your custom types in XAML. A related prefix that comes from a templated Windows Store app project is **common:**. This prefix refers to a nested \"Common\" namespace that contains utility classes such as converters and commands, and you can find the definitions in the Common folder in the **Solution Explorer** view.\n\n### **vsm:**\n\nDo not use. \"vsm:\" is a prefix that is sometimes seen in older XAML templates imported from other Microsoft technologies. The namespace originally addressed a legacy namespace tooling issue. You should delete XAML namespace definitions for \"vsm:\" in any XAML you use for the Windows Runtime, and change any prefix usages for [**VisualState**](https://msdn.microsoft.com/library/windows/apps/br209007), [**VisualStateGroup**](https://msdn.microsoft.com/library/windows/apps/br209014) and related objects to use the default XAML namespace instead. For more info on XAML migration, see [Migrating Silverlight or WPF XAML/code to a Windows Runtime app](https://msdn.microsoft.com/library/windows/apps/br229571).\n\n## Mapping custom types to XAML namespaces and prefixes\n\nYou can map a XAML namespace so that you can use XAML to access your own custom types. In other words, you are mapping a code namespace as it exists in a code representation that defines the custom type, and assigning it a XAML namespace along with a prefix for usage. Custom types for XAML can be defined either in a Microsoft .NET language (C# or Microsoft Visual Basic) or in C++. The mapping is made by defining an **xmlns** prefix. For example, `xmlns:myTypes` defines a new XAML namespace that is accessed by prefixing all usages with the token `myTypes:`.\n\nAn **xmlns** definition includes a value as well as the prefix naming. The value is a string that goes inside quotation marks, following an equal sign. A common XML convention is to associate the XML namespace with a Uniform Resource Identifier (URI), so that there is a convention for uniqueness and identification. You also see this convention for the default XAML namespace and the XAML language XAML namespace, as well as for some lesser-used XAML namespaces that are used by Windows Runtime XAML. But for a XAML namespace that maps custom types, instead of specifying a URI, you begin the prefix definition with the token \"using:\". Following the \"using:\" token, you then name the code namespace.\n\nFor example, to map a \"custom1\" prefix that enables you to reference a \"CustomClasses\" namespace, and use classes from that namespace or assembly as object elements in XAML, your XAML page should include the following mapping on the root element: `xmlns:custom1=\"using:CustomClasses\"`\n\nPartial classes of the same page scope do not need to be mapped. For example, you don't need prefixes to reference any event handlers that you defined for handling events from the XAML UI definition of your page. Also, many of the starting XAML pages from Visual Studio generated projects for a Windows Runtime app using C++, C#, or Visual Basic already map a \"local:\" prefix, which references the project-specified default namespace and the namespace used by partial class definitions.\n\n### CLR language rules\n\nIf you are writing your backing code in a .NET language (C# or Microsoft Visual Basic), you might be using conventions that use a dot (\".\") as part of namespace names to create a conceptual hierarchy of code namespaces. If your namespace definition contains a dot, the dot should be part of the value you specify after the \"using:\" token.\n\nIf your code-behind file or code definition file is a C++ file, there are certain conventions that still follow the common language runtime (CLR) language form, so that there is no difference in the XAML syntax. If you declare nested namespaces in C++, the separator between the successive nested namespace strings should be \".\" rather than \"::\" when you specify the value that follows the \"using:\" token.\n\nDon't use nested types (such as nesting an enumeration within a class) when you define your code for use with XAML. Nested types can't be evaluated. There's no way for the XAML parser to distinguish that a dot is part of the nested type name rather than part of the namespace name.\n\n## Custom types and assemblies\n\nThe name of the assembly that defines the backing types for a XAML namespace is not specified in the mapping. The logic for which assemblies are available is controlled at the app-definition level and is part of basic app deployment and security principles. Declare any assembly that you want included as a code-definition source for XAML as a dependent assembly in project settings. For more info, see [Creating Windows Runtime components in C# and Visual Basic](https://msdn.microsoft.com/library/windows/apps/xaml/hh441572.aspx).\n\nIf you are referencing custom types from the primary app's application definition or page definitions, those types are available without further dependent assembly configuration, but you still must map the code namespace that contains those types. A common convention is to map the prefix \"local\" for the default code namespace of any given XAML page. This convention is often included in starting project templates for XAML projects.\n\n## Attached properties\n\nIf you are referencing attached properties, the owner-type portion of the attached property name must either be in the default XAML namespace or be prefixed. It's rare to prefix attributes separately from their elements but this is one case where it's sometimes required, particularly for a custom attached property. For more info, see [Custom attached properties](custom-attached-properties.md).\n\n## Related topics\n\n* [XAML overview](xaml-overview.md)\n* [XAML syntax guide](xaml-syntax-guide.md)\n* [Creating Windows Runtime components in C# and Visual Basic](https://msdn.microsoft.com/library/windows/apps/xaml/hh441572.aspx)\n* [C#, VB, and C++ project templates for Windows Runtime apps](https://msdn.microsoft.com/library/windows/apps/hh768232)\n* [Migrating Silverlight or WPF XAML/code to a Windows Runtime app](https://msdn.microsoft.com/library/windows/apps/br229571)\n \n\n"}