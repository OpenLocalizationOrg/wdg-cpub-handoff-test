{"nodes":[{"pos":[60,93],"content":"Use a timer to submit a work item","needQuote":true,"needEscape":true,"nodes":[{"content":"Use a timer to submit a work item","pos":[0,33]}]},{"pos":[107,171],"content":"Learn how to create a work item that runs after a timer elapses.","needQuote":true,"needEscape":true,"nodes":[{"content":"Learn how to create a work item that runs after a timer elapses.","pos":[0,64]}]},{"content":"Use a timer to submit a work item","pos":[178,211]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[213,251]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[252,347],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"** Important APIs **","pos":[349,369]},{"content":"Windows.UI.Core namespace","pos":[378,403]},{"content":"Windows.System.Threading namespace","pos":[472,506]},{"content":"Learn how to create a work item that runs after a timer elapses.","pos":[569,633]},{"content":"Create a single-shot timer","pos":[638,664]},{"content":"Use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CreateTimer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Hh967921)</ept> method to create a timer for the work item.","pos":[666,793],"source":"Use the [**CreateTimer**](https://msdn.microsoft.com/library/windows/apps/Hh967921) method to create a timer for the work item."},{"content":"Supply a lambda that accomplishes the work, and use the <bpt id=\"p1\">*</bpt>delay<ept id=\"p1\">*</ept> parameter to specify how long the thread pool waits before it can assign the work item to an available thread.","pos":[794,968],"source":" Supply a lambda that accomplishes the work, and use the *delay* parameter to specify how long the thread pool waits before it can assign the work item to an available thread."},{"content":"The delay is specified using a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TimeSpan<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR225996)</ept> structure.","pos":[969,1083],"source":" The delay is specified using a [**TimeSpan**](https://msdn.microsoft.com/library/windows/apps/BR225996) structure."},{"pos":[1085,1249],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  You can use <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>CoreDispatcher.RunAsync<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/Hh750317)</ept> to access the UI and show progress from the work item.","source":"**Note**  You can use [**CoreDispatcher.RunAsync**](https://msdn.microsoft.com/library/windows/apps/Hh750317) to access the UI and show progress from the work item."},{"content":"The following example creates a work item that runs in three minutes:","pos":[1251,1320]},{"content":"Provide a completion handler","pos":[2684,2712]},{"content":"If needed, handle cancellation and completion of the work item with a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TimerDestroyedHandler<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Hh967926)</ept>.","pos":[2714,2870],"source":"If needed, handle cancellation and completion of the work item with a [**TimerDestroyedHandler**](https://msdn.microsoft.com/library/windows/apps/Hh967926)."},{"content":"Use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CreateTimer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Hh967921)</ept> overload to supply an additional lambda.","pos":[2871,2995],"source":" Use the [**CreateTimer**](https://msdn.microsoft.com/library/windows/apps/Hh967921) overload to supply an additional lambda."},{"content":"This runs when the timer is cancelled or when the work item completes.","pos":[2996,3066]},{"content":"The following example creates a timer that submits the work item, and calls a method when the work item finishes or the timer is cancelled:","pos":[3068,3207]},{"content":"Cancel the timer","pos":[5963,5979]},{"content":"If the timer is still counting down, but the work item is no longer needed, call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Cancel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR230588)</ept>.","pos":[5981,6133],"source":"If the timer is still counting down, but the work item is no longer needed, call [**Cancel**](https://msdn.microsoft.com/library/windows/apps/BR230588)."},{"content":"The timer is cancelled and the work item won't be submitted to the thread pool.","pos":[6134,6213]},{"content":"Remarks","pos":[6328,6335]},{"content":"Universal Windows Platform (UWP) apps can't use <bpt id=\"p1\">**</bpt>Thread.Sleep<ept id=\"p1\">**</ept> because it can block the UI thread.","pos":[6337,6437],"source":"Universal Windows Platform (UWP) apps can't use **Thread.Sleep** because it can block the UI thread."},{"content":"You can use a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ThreadPoolTimer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR230587)</ept> to create a work item instead, and this will delay the task accomplished by the work item without blocking the UI thread.","pos":[6438,6653],"source":" You can use a [**ThreadPoolTimer**](https://msdn.microsoft.com/library/windows/apps/BR230587) to create a work item instead, and this will delay the task accomplished by the work item without blocking the UI thread."},{"content":"See the <bpt id=\"p1\">[</bpt>thread pool sample<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=255387)</ept> for a complete code sample that demonstrates work items, timer work items, and periodic work items.","pos":[6655,6832],"source":"See the [thread pool sample](http://go.microsoft.com/fwlink/p/?linkid=255387) for a complete code sample that demonstrates work items, timer work items, and periodic work items."},{"content":"The code sample was originally written for Windows 8.1 but the code can be re-used in Windows 10.","pos":[6833,6930]},{"pos":[6932,7038],"content":"For information about repeating timers, see <bpt id=\"p1\">[</bpt>Create a periodic work item<ept id=\"p1\">](create-a-periodic-work-item.md)</ept>.","source":"For information about repeating timers, see [Create a periodic work item](create-a-periodic-work-item.md)."},{"content":"Related topics","pos":[7043,7057]},{"content":"Submit a work item to the thread pool","pos":[7062,7099]},{"content":"Best practices for using the thread pool","pos":[7146,7186]},{"content":"Use a timer to submit a work item","pos":[7236,7269]}],"content":"---\nms.assetid: AAE467F9-B3C7-4366-99A2-8A880E5692BE\ntitle: Use a timer to submit a work item\ndescription: Learn how to create a work item that runs after a timer elapses.\n---\n# Use a timer to submit a work item\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n** Important APIs **\n\n-   [**Windows.UI.Core namespace**](https://msdn.microsoft.com/library/windows/apps/BR208383)\n-   [**Windows.System.Threading namespace**](https://msdn.microsoft.com/library/windows/apps/BR229642)\n\nLearn how to create a work item that runs after a timer elapses.\n\n## Create a single-shot timer\n\nUse the [**CreateTimer**](https://msdn.microsoft.com/library/windows/apps/Hh967921) method to create a timer for the work item. Supply a lambda that accomplishes the work, and use the *delay* parameter to specify how long the thread pool waits before it can assign the work item to an available thread. The delay is specified using a [**TimeSpan**](https://msdn.microsoft.com/library/windows/apps/BR225996) structure.\n\n**Note**  You can use [**CoreDispatcher.RunAsync**](https://msdn.microsoft.com/library/windows/apps/Hh750317) to access the UI and show progress from the work item.\n\nThe following example creates a work item that runs in three minutes:\n\n> [!div class=\"tabbedCodeSnippets\"]\n``` csharp\nTimeSpan delay = TimeSpan.FromMinutes(3);\n            \nThreadPoolTimer DelayTimer = ThreadPoolTimer.CreateTimer(\n    (source) =&gt;\n    {\n        // \n        // TODO: Work\n        // \n        \n        // \n        // Update the UI thread by using the UI core dispatcher.\n        // \n        Dispatcher.RunAsync(\n            CoreDispatcherPriority.High,\n            () =&gt;\n            {\n                // \n                // UI components can be accessed within this scope.\n                // \n\n            });\n\n    }, delay);\n```\n``` cpp\nTimeSpan delay;\ndelay.Duration = 3 * 60 * 10000000; // 10,000,000 ticks per second\n\nThreadPoolTimer ^ DelayTimer = ThreadPoolTimer::CreateTimer(\n        ref new TimerElapsedHandler([this](ThreadPoolTimer^ source)\n        {\n            // \n            // TODO: Work\n            // \n            \n            // \n            // Update the UI thread by using the UI core dispatcher.\n            // \n            Dispatcher-&gt;RunAsync(CoreDispatcherPriority::High,\n                ref new DispatchedHandler([this]()\n                {\n                    // \n                    // UI components can be accessed within this scope.\n                    // \n\n                    ExampleUIUpdateMethod(&quot;Timer completed.&quot;);\n\n                }));\n\n        }), delay);\n```\n\n## Provide a completion handler\n\nIf needed, handle cancellation and completion of the work item with a [**TimerDestroyedHandler**](https://msdn.microsoft.com/library/windows/apps/Hh967926). Use the [**CreateTimer**](https://msdn.microsoft.com/library/windows/apps/Hh967921) overload to supply an additional lambda. This runs when the timer is cancelled or when the work item completes.\n\nThe following example creates a timer that submits the work item, and calls a method when the work item finishes or the timer is cancelled:\n\n> [!div class=\"tabbedCodeSnippets\"]\n``` csharp\nTimeSpan delay = TimeSpan.FromMinutes(3);\n            \nbool completed = false;\n\nThreadPoolTimer DelayTimer = ThreadPoolTimer.CreateTimer(\n    (source) =&gt;\n    {\n        // \n        // TODO: Work\n        // \n\n        // \n        // Update the UI thread by using the UI core dispatcher.\n        // \n        Dispatcher.RunAsync(\n                CoreDispatcherPriority.High,\n                () =&gt;\n                {\n                    // \n                    // UI components can be accessed within this scope.\n                    // \n\n                });\n\n        completed = true;\n    },\n    delay,\n    (source) =&gt;\n    {\n        // \n        // TODO: Handle work cancellation/completion.\n        // \n\n\n        // \n        // Update the UI thread by using the UI core dispatcher.\n        // \n        Dispatcher.RunAsync(\n            CoreDispatcherPriority.High,\n            () =&gt;\n            {\n                // \n                // UI components can be accessed within this scope.\n                // \n\n                if (completed)\n                {\n                    // Timer completed.\n                }\n                else\n                {\n                    // Timer cancelled.\n                }\n\n            });\n    });\n```\n``` cpp\nTimeSpan delay;\ndelay.Duration = 3 * 60 * 10000000; // 10,000,000 ticks per second\n\ncompleted = false;\n\nThreadPoolTimer ^ DelayTimer = ThreadPoolTimer::CreateTimer(\n        ref new TimerElapsedHandler([&amp;](ThreadPoolTimer ^ source)\n        {\n            // \n            // TODO: Work\n            // \n\n            // \n            // Update the UI thread by using the UI core dispatcher.\n            // \n            Dispatcher-&gt;RunAsync(CoreDispatcherPriority::High,\n                ref new DispatchedHandler([&amp;]()\n                {\n                    // \n                    // UI components can be accessed within this scope.\n                    // \n\n                }));\n\n            completed = true;\n\n        }),\n        delay,\n        ref new TimerDestroyedHandler([&amp;](ThreadPoolTimer ^ source)\n        {\n            // \n            // TODO: Handle work cancellation/completion.\n            // \n\n            Dispatcher-&gt;RunAsync(CoreDispatcherPriority::High,\n                ref new DispatchedHandler([&amp;]()\n                {\n                    // \n                    // Update the UI thread by using the UI core dispatcher.\n                    // \n\n                    if (completed)\n                    {\n                        // Timer completed.\n                    }\n                    else\n                    {\n                        // Timer cancelled.\n                    }\n\n                }));\n        }));\n```\n\n## Cancel the timer\n\nIf the timer is still counting down, but the work item is no longer needed, call [**Cancel**](https://msdn.microsoft.com/library/windows/apps/BR230588). The timer is cancelled and the work item won't be submitted to the thread pool.\n\n> [!div class=\"tabbedCodeSnippets\"]\n``` csharp\nDelayTimer.Cancel();\n```\n``` cpp\nDelayTimer-&gt;Cancel();\n```\n\n## Remarks\n\nUniversal Windows Platform (UWP) apps can't use **Thread.Sleep** because it can block the UI thread. You can use a [**ThreadPoolTimer**](https://msdn.microsoft.com/library/windows/apps/BR230587) to create a work item instead, and this will delay the task accomplished by the work item without blocking the UI thread.\n\nSee the [thread pool sample](http://go.microsoft.com/fwlink/p/?linkid=255387) for a complete code sample that demonstrates work items, timer work items, and periodic work items. The code sample was originally written for Windows 8.1 but the code can be re-used in Windows 10.\n\nFor information about repeating timers, see [Create a periodic work item](create-a-periodic-work-item.md).\n\n## Related topics\n\n* [Submit a work item to the thread pool](submit-a-work-item-to-the-thread-pool.md)\n* [Best practices for using the thread pool](best-practices-for-using-the-thread-pool.md)\n* [Use a timer to submit a work item](use-a-timer-to-submit-a-work-item.md)\n \n\n \n\n"}