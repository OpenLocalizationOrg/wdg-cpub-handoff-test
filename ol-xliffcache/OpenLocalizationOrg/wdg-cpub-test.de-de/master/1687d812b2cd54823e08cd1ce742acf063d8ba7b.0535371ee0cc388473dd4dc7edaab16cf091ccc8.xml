{"nodes":[{"pos":[11,56],"content":"Set up DirectX resources and display an image","needQuote":true,"needEscape":true,"nodes":[{"content":"Set up DirectX resources and display an image","pos":[0,45]}]},{"pos":[70,210],"content":"Here, we show you how to create a Direct3D device, swap chain, and render-target view, and how to present the rendered image to the display.","needQuote":true,"needEscape":true,"nodes":[{"content":"Here, we show you how to create a Direct3D device, swap chain, and render-target view, and how to present the rendered image to the display.","pos":[0,140]}]},{"content":"Set up DirectX resources and display an image","pos":[267,312]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[315,353]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[354,449],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Here, we show you how to create a Direct3D device, swap chain, and render-target view, and how to present the rendered image to the display.","pos":[451,591]},{"pos":[593,711],"content":"<bpt id=\"p1\">**</bpt>Objective:<ept id=\"p1\">**</ept> To set up DirectX resources in a C++ Universal Windows Platform (UWP) app and to display a solid color.","source":"**Objective:** To set up DirectX resources in a C++ Universal Windows Platform (UWP) app and to display a solid color."},{"content":"Prerequisites","pos":[716,729]},{"content":"We assume that you are familiar with C++.","pos":[732,773]},{"content":"You also need basic experience with graphics programming concepts.","pos":[774,840]},{"pos":[842,875],"content":"<bpt id=\"p1\">**</bpt>Time to complete:<ept id=\"p1\">**</ept> 20 minutes.","source":"**Time to complete:** 20 minutes."},{"content":"Instructions","pos":[880,892]},{"content":"1. Declaring Direct3D interface variables with ComPtr","pos":[898,951]},{"content":"We declare Direct3D interface variables with the ComPtr <bpt id=\"p1\">[</bpt>smart pointer<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh279674.aspx)</ept> template from the Windows Runtime C++ Template Library (WRL), so we can manage the lifetime of those variables in an exception safe manner.","pos":[953,1227],"source":"We declare Direct3D interface variables with the ComPtr [smart pointer](https://msdn.microsoft.com/library/windows/apps/hh279674.aspx) template from the Windows Runtime C++ Template Library (WRL), so we can manage the lifetime of those variables in an exception safe manner."},{"content":"We can then use those variables to access the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ComPtr class<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br244983.aspx)</ept> and its members.","pos":[1228,1372],"source":" We can then use those variables to access the [**ComPtr class**](https://msdn.microsoft.com/library/windows/apps/br244983.aspx) and its members."},{"content":"For example:","pos":[1373,1385]},{"content":"If you declare <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11RenderTargetView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</ept> with ComPtr, you can then use ComPtr’s <bpt id=\"p3\">**</bpt>GetAddressOf<ept id=\"p3\">**</ept> method to get the address of the pointer to <bpt id=\"p4\">**</bpt>ID3D11RenderTargetView<ept id=\"p4\">**</ept> (\\*\\*ID3D11RenderTargetView) to pass to <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ID3D11DeviceContext::OMSetRenderTargets<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ff476464)</ept>.","pos":[1604,1983],"source":"If you declare [**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582) with ComPtr, you can then use ComPtr’s **GetAddressOf** method to get the address of the pointer to **ID3D11RenderTargetView** (\\*\\*ID3D11RenderTargetView) to pass to [**ID3D11DeviceContext::OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464)."},{"content":"<bpt id=\"p1\">**</bpt>OMSetRenderTargets<ept id=\"p1\">**</ept> binds the render target to the <bpt id=\"p2\">[</bpt>output-merger stage<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/bb205120)</ept> to specify the render target as the output target.","pos":[1984,2171],"source":"**OMSetRenderTargets** binds the render target to the [output-merger stage](https://msdn.microsoft.com/library/windows/desktop/bb205120) to specify the render target as the output target."},{"content":"After the sample app is started, it initializes and loads, and is then ready to run.","pos":[2173,2257]},{"content":"2. Creating the Direct3D device","pos":[2263,2294]},{"content":"To use the Direct3D API to render a scene, we must first create a Direct3D device that represents the display adapter.","pos":[2296,2414]},{"content":"To create the Direct3D device, we call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11CreateDevice<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</ept> function.","pos":[2415,2552],"source":" To create the Direct3D device, we call the [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) function."},{"content":"We specify levels 9.1 through 11.1 in the array of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D\\_FEATURE\\_LEVEL<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476329)</ept> values.","pos":[2553,2698],"source":" We specify levels 9.1 through 11.1 in the array of [**D3D\\_FEATURE\\_LEVEL**](https://msdn.microsoft.com/library/windows/desktop/ff476329) values."},{"content":"Direct3D walks the array in order and returns the highest supported feature level.","pos":[2699,2781]},{"content":"So, to get the highest feature level available, we list the <bpt id=\"p1\">**</bpt>D3D\\_FEATURE\\_LEVEL<ept id=\"p1\">**</ept> array entries from highest to lowest.","pos":[2782,2903],"source":" So, to get the highest feature level available, we list the **D3D\\_FEATURE\\_LEVEL** array entries from highest to lowest."},{"content":"We pass the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11\\_CREATE\\_DEVICE\\_BGRA\\_SUPPORT<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476107#D3D11_CREATE_DEVICE_BGRA_SUPPORT)</ept> flag to the <bpt id=\"p3\">*</bpt>Flags<ept id=\"p3\">*</ept> parameter to make Direct3D resources interoperate with Direct2D.","pos":[2904,3137],"source":" We pass the [**D3D11\\_CREATE\\_DEVICE\\_BGRA\\_SUPPORT**](https://msdn.microsoft.com/library/windows/desktop/ff476107#D3D11_CREATE_DEVICE_BGRA_SUPPORT) flag to the *Flags* parameter to make Direct3D resources interoperate with Direct2D."},{"content":"If we use the debug build, we also pass the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11\\_CREATE\\_DEVICE\\_DEBUG<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476107#D3D11_CREATE_DEVICE_DEBUG)</ept> flag.","pos":[3138,3309],"source":" If we use the debug build, we also pass the [**D3D11\\_CREATE\\_DEVICE\\_DEBUG**](https://msdn.microsoft.com/library/windows/desktop/ff476107#D3D11_CREATE_DEVICE_DEBUG) flag."},{"content":"For more info about debugging apps, see <bpt id=\"p1\">[</bpt>Using the debug layer to debug apps<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/jj200584)</ept>.","pos":[3310,3449],"source":" For more info about debugging apps, see [Using the debug layer to debug apps](https://msdn.microsoft.com/library/windows/desktop/jj200584)."},{"pos":[3451,3840],"content":"We obtain the Direct3D 11.1 device (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept>) and device context (<bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext1<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept>) by querying the Direct3D 11 device and device context that are returned from <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>D3D11CreateDevice<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</ept>.","source":"We obtain the Direct3D 11.1 device ([**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575)) and device context ([**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598)) by querying the Direct3D 11 device and device context that are returned from [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082)."},{"content":"3. Creating the swap chain","pos":[5575,5601]},{"content":"Next, we create a swap chain that the device uses for rendering and display.","pos":[5603,5679]},{"content":"We declare and initialize a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DXGI\\_SWAP\\_CHAIN\\_DESC1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404528)</ept> structure to describe the swap chain.","pos":[5680,5837],"source":" We declare and initialize a [**DXGI\\_SWAP\\_CHAIN\\_DESC1**](https://msdn.microsoft.com/library/windows/desktop/hh404528) structure to describe the swap chain."},{"content":"Then, we set up the swap chain as flip-model (that is, a swap chain that has the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DXGI\\_SWAP\\_EFFECT\\_FLIP\\_SEQUENTIAL<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb173077#DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL)</ept> value set in the <bpt id=\"p3\">**</bpt>SwapEffect<ept id=\"p3\">**</ept> member) and set the <bpt id=\"p4\">**</bpt>Format<ept id=\"p4\">**</ept> member to <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>DXGI\\_FORMAT\\_B8G8R8A8\\_UNORM<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/bb173059#DXGI_FORMAT_B8G8R8A8_UNORM)</ept>.","pos":[5838,6253],"source":" Then, we set up the swap chain as flip-model (that is, a swap chain that has the [**DXGI\\_SWAP\\_EFFECT\\_FLIP\\_SEQUENTIAL**](https://msdn.microsoft.com/library/windows/desktop/bb173077#DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL) value set in the **SwapEffect** member) and set the **Format** member to [**DXGI\\_FORMAT\\_B8G8R8A8\\_UNORM**](https://msdn.microsoft.com/library/windows/desktop/bb173059#DXGI_FORMAT_B8G8R8A8_UNORM)."},{"content":"We set the <bpt id=\"p1\">**</bpt>Count<ept id=\"p1\">**</ept> member of the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>DXGI\\_SAMPLE\\_DESC<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/bb173072)</ept> structure that the <bpt id=\"p4\">**</bpt>SampleDesc<ept id=\"p4\">**</ept> member specifies to 1 and the <bpt id=\"p5\">**</bpt>Quality<ept id=\"p5\">**</ept> member of <bpt id=\"p6\">**</bpt>DXGI\\_SAMPLE\\_DESC<ept id=\"p6\">**</ept> to zero because flip-model doesn’t support multiple sample antialiasing (MSAA).","pos":[6254,6563],"source":" We set the **Count** member of the [**DXGI\\_SAMPLE\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/bb173072) structure that the **SampleDesc** member specifies to 1 and the **Quality** member of **DXGI\\_SAMPLE\\_DESC** to zero because flip-model doesn’t support multiple sample antialiasing (MSAA)."},{"content":"We set the <bpt id=\"p1\">**</bpt>BufferCount<ept id=\"p1\">**</ept> member to 2 so the swap chain can use a front buffer to present to the display device and a back buffer that serves as the render target.","pos":[6564,6728],"source":" We set the **BufferCount** member to 2 so the swap chain can use a front buffer to present to the display device and a back buffer that serves as the render target."},{"content":"We obtain the underlying DXGI device by querying the Direct3D 11.1 device.","pos":[6730,6804]},{"content":"To minimize power consumption, which is important to do on battery-powered devices such as laptops and tablets, we call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGIDevice1::SetMaximumFrameLatency<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff471334)</ept> method with 1 as the maximum number of back buffer frames that DXGI can queue.","pos":[6805,7111],"source":" To minimize power consumption, which is important to do on battery-powered devices such as laptops and tablets, we call the [**IDXGIDevice1::SetMaximumFrameLatency**](https://msdn.microsoft.com/library/windows/desktop/ff471334) method with 1 as the maximum number of back buffer frames that DXGI can queue."},{"content":"This ensures that the app is rendered only after the vertical blank.","pos":[7112,7180]},{"content":"To finally create the swap chain, we need to get the parent factory from the DXGI device.","pos":[7182,7271]},{"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGIDevice::GetAdapter<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb174531)</ept> to get the adapter for the device, and then call <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>IDXGIObject::GetParent<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/bb174542)</ept> on the adapter to get the parent factory (<bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>IDXGIFactory2<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/hh404556)</ept>).","pos":[7272,7634],"source":" We call [**IDXGIDevice::GetAdapter**](https://msdn.microsoft.com/library/windows/desktop/bb174531) to get the adapter for the device, and then call [**IDXGIObject::GetParent**](https://msdn.microsoft.com/library/windows/desktop/bb174542) on the adapter to get the parent factory ([**IDXGIFactory2**](https://msdn.microsoft.com/library/windows/desktop/hh404556))."},{"content":"To create the swap chain, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGIFactory2::CreateSwapChainForCoreWindow<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404559)</ept> with the swap-chain descriptor and the app’s core window.","pos":[7635,7837],"source":" To create the swap chain, we call [**IDXGIFactory2::CreateSwapChainForCoreWindow**](https://msdn.microsoft.com/library/windows/desktop/hh404559) with the swap-chain descriptor and the app’s core window."},{"content":"4. Creating the render-target view","pos":[10333,10367]},{"content":"To render graphics to the window, we need to create a render-target view.","pos":[10369,10442]},{"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain::GetBuffer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb174570)</ept> to get the swap chain’s back buffer to use when we create the render-target view.","pos":[10443,10625],"source":" We call [**IDXGISwapChain::GetBuffer**](https://msdn.microsoft.com/library/windows/desktop/bb174570) to get the swap chain’s back buffer to use when we create the render-target view."},{"content":"We specify the back buffer as a 2D texture (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Texture2D<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept>).","pos":[10626,10754],"source":" We specify the back buffer as a 2D texture ([**ID3D11Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff476635))."},{"content":"To create the render-target view, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device::CreateRenderTargetView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476517)</ept> with the swap chain’s back buffer.","pos":[10755,10935],"source":" To create the render-target view, we call [**ID3D11Device::CreateRenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476517) with the swap chain’s back buffer."},{"content":"We must specify to draw to the entire core window by specifying the view port (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11\\_VIEWPORT<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476260)</ept>) as the full size of the swap chain's back buffer.","pos":[10936,11148],"source":" We must specify to draw to the entire core window by specifying the view port ([**D3D11\\_VIEWPORT**](https://msdn.microsoft.com/library/windows/desktop/ff476260)) as the full size of the swap chain's back buffer."},{"content":"We use the view port in a call to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::RSSetViewports<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476480)</ept> to bind the view port to the <bpt id=\"p3\">[</bpt>rasterizer stage<ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/bb205125)</ept> of the pipeline.","pos":[11149,11411],"source":" We use the view port in a call to [**ID3D11DeviceContext::RSSetViewports**](https://msdn.microsoft.com/library/windows/desktop/ff476480) to bind the view port to the [rasterizer stage](https://msdn.microsoft.com/library/windows/desktop/bb205125) of the pipeline."},{"content":"The rasterizer stage converts vector information into a raster image.","pos":[11412,11481]},{"content":"In this case, we don't require a conversion because we are just displaying a solid color.","pos":[11482,11571]},{"content":"5. Presenting the rendered image","pos":[12764,12796]},{"content":"We enter an endless loop to continually render and display the scene.","pos":[12798,12867]},{"content":"In this loop, we call:","pos":[12869,12891]},{"pos":[12897,13054],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::OMSetRenderTargets<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476464)</ept> to specify the render target as the output target.","source":"[**ID3D11DeviceContext::OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464) to specify the render target as the output target."},{"pos":[13059,13213],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::ClearRenderTargetView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476388)</ept> to clear the render target to a solid color.","source":"[**ID3D11DeviceContext::ClearRenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476388) to clear the render target to a solid color."},{"pos":[13218,13353],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain::Present<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb174576)</ept> to present the rendered image to the window.","source":"[**IDXGISwapChain::Present**](https://msdn.microsoft.com/library/windows/desktop/bb174576) to present the rendered image to the window."},{"content":"Because we previously set the maximum frame latency to 1, Windows generally slows down the render loop to the screen refresh rate, typically around 60 Hz.","pos":[13355,13509]},{"content":"Windows slows down the render loop by making the app sleep when the app calls <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Present<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb174576)</ept>.","pos":[13510,13663],"source":" Windows slows down the render loop by making the app sleep when the app calls [**Present**](https://msdn.microsoft.com/library/windows/desktop/bb174576)."},{"content":"Windows makes the app sleep until the screen is refreshed.","pos":[13664,13722]},{"content":"6. Resizing the app window and the swap chain’s buffer","pos":[14947,15001]},{"content":"If the size of the app window changes, the app must resize the swap chain’s buffers, recreate the render-target view, and then present the resized rendered image.","pos":[15003,15165]},{"content":"To resize the swap chain’s buffers, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain::ResizeBuffers<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb174577)</ept>.","pos":[15166,15307],"source":" To resize the swap chain’s buffers, we call [**IDXGISwapChain::ResizeBuffers**](https://msdn.microsoft.com/library/windows/desktop/bb174577)."},{"content":"In this call, we leave the number of buffers and the format of the buffers unchanged (the <bpt id=\"p1\">*</bpt>BufferCount<ept id=\"p1\">*</ept> parameter to two and the <bpt id=\"p2\">*</bpt>NewFormat<ept id=\"p2\">*</ept> parameter to <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DXGI\\_FORMAT\\_B8G8R8A8\\_UNORM<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/bb173059#DXGI_FORMAT_B8G8R8A8_UNORM)</ept>).","pos":[15308,15587],"source":" In this call, we leave the number of buffers and the format of the buffers unchanged (the *BufferCount* parameter to two and the *NewFormat* parameter to [**DXGI\\_FORMAT\\_B8G8R8A8\\_UNORM**](https://msdn.microsoft.com/library/windows/desktop/bb173059#DXGI_FORMAT_B8G8R8A8_UNORM))."},{"content":"We make the size of the swap chain’s back buffer the same size as the resized window.","pos":[15588,15673]},{"content":"After we resize the swap chain’s buffers, we create the new render target and present the new rendered image similarly to when we initialized the app.","pos":[15674,15824]},{"content":"Summary and next steps","pos":[16156,16178]},{"content":"We created a Direct3D device, swap chain, and render-target view, and presented the rendered image to the display.","pos":[16181,16295]},{"content":"Next, we also draw a triangle on the display.","pos":[16297,16342]},{"content":"Creating shaders and drawing primitives","pos":[16345,16384]}],"content":"---\ntitle: Set up DirectX resources and display an image\ndescription: Here, we show you how to create a Direct3D device, swap chain, and render-target view, and how to present the rendered image to the display.\nms.assetid: d54d96fe-3522-4acb-35f4-bb11c3a5b064\n---\n\n# Set up DirectX resources and display an image\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nHere, we show you how to create a Direct3D device, swap chain, and render-target view, and how to present the rendered image to the display.\n\n**Objective:** To set up DirectX resources in a C++ Universal Windows Platform (UWP) app and to display a solid color.\n\n## Prerequisites\n\n\nWe assume that you are familiar with C++. You also need basic experience with graphics programming concepts.\n\n**Time to complete:** 20 minutes.\n\n## Instructions\n\n### 1. Declaring Direct3D interface variables with ComPtr\n\nWe declare Direct3D interface variables with the ComPtr [smart pointer](https://msdn.microsoft.com/library/windows/apps/hh279674.aspx) template from the Windows Runtime C++ Template Library (WRL), so we can manage the lifetime of those variables in an exception safe manner. We can then use those variables to access the [**ComPtr class**](https://msdn.microsoft.com/library/windows/apps/br244983.aspx) and its members. For example:\n\n```cpp\n    ComPtr<ID3D11RenderTargetView> m_renderTargetView;\n    m_d3dDeviceContext->OMSetRenderTargets(\n        1,\n        m_renderTargetView.GetAddressOf(),\n        nullptr // Use no depth stencil.\n        );\n```\n\nIf you declare [**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582) with ComPtr, you can then use ComPtr’s **GetAddressOf** method to get the address of the pointer to **ID3D11RenderTargetView** (\\*\\*ID3D11RenderTargetView) to pass to [**ID3D11DeviceContext::OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464). **OMSetRenderTargets** binds the render target to the [output-merger stage](https://msdn.microsoft.com/library/windows/desktop/bb205120) to specify the render target as the output target.\n\nAfter the sample app is started, it initializes and loads, and is then ready to run.\n\n### 2. Creating the Direct3D device\n\nTo use the Direct3D API to render a scene, we must first create a Direct3D device that represents the display adapter. To create the Direct3D device, we call the [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) function. We specify levels 9.1 through 11.1 in the array of [**D3D\\_FEATURE\\_LEVEL**](https://msdn.microsoft.com/library/windows/desktop/ff476329) values. Direct3D walks the array in order and returns the highest supported feature level. So, to get the highest feature level available, we list the **D3D\\_FEATURE\\_LEVEL** array entries from highest to lowest. We pass the [**D3D11\\_CREATE\\_DEVICE\\_BGRA\\_SUPPORT**](https://msdn.microsoft.com/library/windows/desktop/ff476107#D3D11_CREATE_DEVICE_BGRA_SUPPORT) flag to the *Flags* parameter to make Direct3D resources interoperate with Direct2D. If we use the debug build, we also pass the [**D3D11\\_CREATE\\_DEVICE\\_DEBUG**](https://msdn.microsoft.com/library/windows/desktop/ff476107#D3D11_CREATE_DEVICE_DEBUG) flag. For more info about debugging apps, see [Using the debug layer to debug apps](https://msdn.microsoft.com/library/windows/desktop/jj200584).\n\nWe obtain the Direct3D 11.1 device ([**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575)) and device context ([**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598)) by querying the Direct3D 11 device and device context that are returned from [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082).\n\n```cpp\n        // First, create the Direct3D device.\n\n        // This flag is required in order to enable compatibility with Direct2D.\n        UINT creationFlags = D3D11_CREATE_DEVICE_BGRA_SUPPORT;\n\n#if defined(_DEBUG)\n        // If the project is in a debug build, enable debugging via SDK Layers with this flag.\n        creationFlags |= D3D11_CREATE_DEVICE_DEBUG;\n#endif\n\n        // This array defines the ordering of feature levels that D3D should attempt to create.\n        D3D_FEATURE_LEVEL featureLevels[] =\n        {\n            D3D_FEATURE_LEVEL_11_1,\n            D3D_FEATURE_LEVEL_11_0,\n            D3D_FEATURE_LEVEL_10_1,\n            D3D_FEATURE_LEVEL_10_0,\n            D3D_FEATURE_LEVEL_9_3,\n            D3D_FEATURE_LEVEL_9_1\n        };\n\n        ComPtr<ID3D11Device> d3dDevice;\n        ComPtr<ID3D11DeviceContext> d3dDeviceContext;\n        DX::ThrowIfFailed(\n            D3D11CreateDevice(\n                nullptr,                    // Specify nullptr to use the default adapter.\n                D3D_DRIVER_TYPE_HARDWARE,\n                nullptr,                    // leave as nullptr if hardware is used\n                creationFlags,              // optionally set debug and Direct2D compatibility flags\n                featureLevels,\n                ARRAYSIZE(featureLevels),\n                D3D11_SDK_VERSION,          // always set this to D3D11_SDK_VERSION\n                &d3dDevice,\n                nullptr,\n                &d3dDeviceContext\n                )\n            );\n\n        // Retrieve the Direct3D 11.1 interfaces.\n        DX::ThrowIfFailed(\n            d3dDevice.As(&m_d3dDevice)\n            );\n\n        DX::ThrowIfFailed(\n            d3dDeviceContext.As(&m_d3dDeviceContext)\n            );\n```\n\n### 3. Creating the swap chain\n\nNext, we create a swap chain that the device uses for rendering and display. We declare and initialize a [**DXGI\\_SWAP\\_CHAIN\\_DESC1**](https://msdn.microsoft.com/library/windows/desktop/hh404528) structure to describe the swap chain. Then, we set up the swap chain as flip-model (that is, a swap chain that has the [**DXGI\\_SWAP\\_EFFECT\\_FLIP\\_SEQUENTIAL**](https://msdn.microsoft.com/library/windows/desktop/bb173077#DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL) value set in the **SwapEffect** member) and set the **Format** member to [**DXGI\\_FORMAT\\_B8G8R8A8\\_UNORM**](https://msdn.microsoft.com/library/windows/desktop/bb173059#DXGI_FORMAT_B8G8R8A8_UNORM). We set the **Count** member of the [**DXGI\\_SAMPLE\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/bb173072) structure that the **SampleDesc** member specifies to 1 and the **Quality** member of **DXGI\\_SAMPLE\\_DESC** to zero because flip-model doesn’t support multiple sample antialiasing (MSAA). We set the **BufferCount** member to 2 so the swap chain can use a front buffer to present to the display device and a back buffer that serves as the render target.\n\nWe obtain the underlying DXGI device by querying the Direct3D 11.1 device. To minimize power consumption, which is important to do on battery-powered devices such as laptops and tablets, we call the [**IDXGIDevice1::SetMaximumFrameLatency**](https://msdn.microsoft.com/library/windows/desktop/ff471334) method with 1 as the maximum number of back buffer frames that DXGI can queue. This ensures that the app is rendered only after the vertical blank.\n\nTo finally create the swap chain, we need to get the parent factory from the DXGI device. We call [**IDXGIDevice::GetAdapter**](https://msdn.microsoft.com/library/windows/desktop/bb174531) to get the adapter for the device, and then call [**IDXGIObject::GetParent**](https://msdn.microsoft.com/library/windows/desktop/bb174542) on the adapter to get the parent factory ([**IDXGIFactory2**](https://msdn.microsoft.com/library/windows/desktop/hh404556)). To create the swap chain, we call [**IDXGIFactory2::CreateSwapChainForCoreWindow**](https://msdn.microsoft.com/library/windows/desktop/hh404559) with the swap-chain descriptor and the app’s core window.\n\n```cpp\n            // If the swap chain does not exist, create it.\n            DXGI_SWAP_CHAIN_DESC1 swapChainDesc = {0};\n\n            swapChainDesc.Stereo = false;\n            swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\n            swapChainDesc.Scaling = DXGI_SCALING_NONE;\n            swapChainDesc.Flags = 0;\n\n            // Use automatic sizing.\n            swapChainDesc.Width = 0;\n            swapChainDesc.Height = 0;\n\n            // This is the most common swap chain format.\n            swapChainDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;\n\n            // Don't use multi-sampling.\n            swapChainDesc.SampleDesc.Count = 1;\n            swapChainDesc.SampleDesc.Quality = 0;\n\n            // Use two buffers to enable the flip effect.\n            swapChainDesc.BufferCount = 2;\n\n            // We recommend using this swap effect for all applications.\n            swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;\n\n\n            // Once the swap chain description is configured, it must be\n            // created on the same adapter as the existing D3D Device.\n\n            // First, retrieve the underlying DXGI Device from the D3D Device.\n            ComPtr<IDXGIDevice2> dxgiDevice;\n            DX::ThrowIfFailed(\n                m_d3dDevice.As(&dxgiDevice)\n                );\n\n            // Ensure that DXGI does not queue more than one frame at a time. This both reduces\n            // latency and ensures that the application will only render after each VSync, minimizing\n            // power consumption.\n            DX::ThrowIfFailed(\n                dxgiDevice->SetMaximumFrameLatency(1)\n                );\n\n            // Next, get the parent factory from the DXGI Device.\n            ComPtr<IDXGIAdapter> dxgiAdapter;\n            DX::ThrowIfFailed(\n                dxgiDevice->GetAdapter(&dxgiAdapter)\n                );\n\n            ComPtr<IDXGIFactory2> dxgiFactory;\n            DX::ThrowIfFailed(\n                dxgiAdapter->GetParent(IID_PPV_ARGS(&dxgiFactory))\n                );\n\n            // Finally, create the swap chain.\n            CoreWindow^ window = m_window.Get();\n            DX::ThrowIfFailed(\n                dxgiFactory->CreateSwapChainForCoreWindow(\n                    m_d3dDevice.Get(),\n                    reinterpret_cast<IUnknown*>(window),\n                    &swapChainDesc,\n                    nullptr, // Allow on all displays.\n                    &m_swapChain\n                    )\n                );\n```\n\n### 4. Creating the render-target view\n\nTo render graphics to the window, we need to create a render-target view. We call [**IDXGISwapChain::GetBuffer**](https://msdn.microsoft.com/library/windows/desktop/bb174570) to get the swap chain’s back buffer to use when we create the render-target view. We specify the back buffer as a 2D texture ([**ID3D11Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff476635)). To create the render-target view, we call [**ID3D11Device::CreateRenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476517) with the swap chain’s back buffer. We must specify to draw to the entire core window by specifying the view port ([**D3D11\\_VIEWPORT**](https://msdn.microsoft.com/library/windows/desktop/ff476260)) as the full size of the swap chain's back buffer. We use the view port in a call to [**ID3D11DeviceContext::RSSetViewports**](https://msdn.microsoft.com/library/windows/desktop/ff476480) to bind the view port to the [rasterizer stage](https://msdn.microsoft.com/library/windows/desktop/bb205125) of the pipeline. The rasterizer stage converts vector information into a raster image. In this case, we don't require a conversion because we are just displaying a solid color.\n\n```cpp\n        // Once the swap chain is created, create a render target view.  This will\n        // allow Direct3D to render graphics to the window.\n\n        ComPtr<ID3D11Texture2D> backBuffer;\n        DX::ThrowIfFailed(\n            m_swapChain->GetBuffer(0, IID_PPV_ARGS(&backBuffer))\n            );\n\n        DX::ThrowIfFailed(\n            m_d3dDevice->CreateRenderTargetView(\n                backBuffer.Get(),\n                nullptr,\n                &m_renderTargetView\n                )\n            );\n\n\n        // After the render target view is created, specify that the viewport,\n        // which describes what portion of the window to draw to, should cover\n        // the entire window.\n\n        D3D11_TEXTURE2D_DESC backBufferDesc = {0};\n        backBuffer->GetDesc(&backBufferDesc);\n\n        D3D11_VIEWPORT viewport;\n        viewport.TopLeftX = 0.0f;\n        viewport.TopLeftY = 0.0f;\n        viewport.Width = static_cast<float>(backBufferDesc.Width);\n        viewport.Height = static_cast<float>(backBufferDesc.Height);\n        viewport.MinDepth = D3D11_MIN_DEPTH;\n        viewport.MaxDepth = D3D11_MAX_DEPTH;\n\n        m_d3dDeviceContext->RSSetViewports(1, &viewport);\n```\n\n### 5. Presenting the rendered image\n\nWe enter an endless loop to continually render and display the scene.\n\nIn this loop, we call:\n\n1.  [**ID3D11DeviceContext::OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464) to specify the render target as the output target.\n2.  [**ID3D11DeviceContext::ClearRenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476388) to clear the render target to a solid color.\n3.  [**IDXGISwapChain::Present**](https://msdn.microsoft.com/library/windows/desktop/bb174576) to present the rendered image to the window.\n\nBecause we previously set the maximum frame latency to 1, Windows generally slows down the render loop to the screen refresh rate, typically around 60 Hz. Windows slows down the render loop by making the app sleep when the app calls [**Present**](https://msdn.microsoft.com/library/windows/desktop/bb174576). Windows makes the app sleep until the screen is refreshed.\n\n```cpp\n        // Enter the render loop.  Note that Windows Store apps should never exit.\n        while (true)\n        {\n            // Process events incoming to the window.\n            m_window->Dispatcher->ProcessEvents(CoreProcessEventsOption::ProcessAllIfPresent);\n\n            // Specify the render target we created as the output target.\n            m_d3dDeviceContext->OMSetRenderTargets(\n                1,\n                m_renderTargetView.GetAddressOf(),\n                nullptr // Use no depth stencil.\n                );\n\n            // Clear the render target to a solid color.\n            const float clearColor[4] = { 0.071f, 0.04f, 0.561f, 1.0f };\n            m_d3dDeviceContext->ClearRenderTargetView(\n                m_renderTargetView.Get(),\n                clearColor\n                );\n\n            // Present the rendered image to the window.  Because the maximum frame latency is set to 1,\n            // the render loop will generally be throttled to the screen refresh rate, typically around\n            // 60 Hz, by sleeping the application on Present until the screen is refreshed.\n            DX::ThrowIfFailed(\n                m_swapChain->Present(1, 0)\n                );\n        }\n```\n\n### 6. Resizing the app window and the swap chain’s buffer\n\nIf the size of the app window changes, the app must resize the swap chain’s buffers, recreate the render-target view, and then present the resized rendered image. To resize the swap chain’s buffers, we call [**IDXGISwapChain::ResizeBuffers**](https://msdn.microsoft.com/library/windows/desktop/bb174577). In this call, we leave the number of buffers and the format of the buffers unchanged (the *BufferCount* parameter to two and the *NewFormat* parameter to [**DXGI\\_FORMAT\\_B8G8R8A8\\_UNORM**](https://msdn.microsoft.com/library/windows/desktop/bb173059#DXGI_FORMAT_B8G8R8A8_UNORM)). We make the size of the swap chain’s back buffer the same size as the resized window. After we resize the swap chain’s buffers, we create the new render target and present the new rendered image similarly to when we initialized the app.\n\n```cpp\n            // If the swap chain already exists, resize it.\n            DX::ThrowIfFailed(\n                m_swapChain->ResizeBuffers(\n                    2,\n                    0,\n                    0,\n                    DXGI_FORMAT_B8G8R8A8_UNORM,\n                    0\n                    )\n                );\n```\n\n## Summary and next steps\n\n\nWe created a Direct3D device, swap chain, and render-target view, and presented the rendered image to the display.\n\nNext, we also draw a triangle on the display.\n\n[Creating shaders and drawing primitives](creating-shaders-and-drawing-primitives.md)\n\n \n\n \n\n\n\n\n"}