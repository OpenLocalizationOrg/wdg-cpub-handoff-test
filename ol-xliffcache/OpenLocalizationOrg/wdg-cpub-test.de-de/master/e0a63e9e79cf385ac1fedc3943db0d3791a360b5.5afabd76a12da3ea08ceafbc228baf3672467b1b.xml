{"nodes":[{"pos":[11,74],"content":"Custom events and event accessors in Windows Runtime Components","needQuote":true,"needEscape":true,"nodes":[{"content":"Custom events and event accessors in Windows Runtime Components","pos":[0,63]}]},{"pos":[88,307],"content":".NET Framework support for Windows Runtime Components makes it easy to declare events components by hiding the differences between the Universal Windows Platform (UWP) event pattern and the .NET Framework event pattern.","needQuote":true,"needEscape":true,"nodes":[{"content":".NET Framework support for Windows Runtime Components makes it easy to declare events components by hiding the differences between the Universal Windows Platform (UWP) event pattern and the .NET Framework event pattern.","pos":[0,219]}]},{"content":"Custom events and event accessors in Windows Runtime Components","pos":[364,427]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[430,468]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[469,564],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"\\[Some information relates to pre-released product which may be substantially modified before it's commercially released.","pos":[567,688]},{"content":"Microsoft makes no warranties, express or implied, with respect to the information provided here.\\]","pos":[689,788]},{"content":".NET Framework support for Windows Runtime Components makes it easy to declare events components by hiding the differences between the Universal Windows Platform (UWP) event pattern and the .NET Framework event pattern.","pos":[790,1009]},{"content":"However, when you declare custom event accessors in a Windows Runtime Component, you must follow the pattern used in the UWP.","pos":[1010,1135]},{"content":"Registering events","pos":[1140,1158]},{"content":"When you register to handle an event in the UWP, the add accessor returns a token.","pos":[1161,1243]},{"content":"To unregister, you pass this token to the remove accessor.","pos":[1244,1302]},{"content":"This means that the add and remove accessors for UWP events have different signatures from the accessors you're used to.","pos":[1303,1423]},{"content":"Fortunately, the Visual Basic and C# compilers simplify this process: When you declare an event with custom accessors in a Windows Runtime Component, the compilers automatically use the UWP pattern.","pos":[1425,1623]},{"content":"For example, you get a compiler error if your add accessor doesn't return a token.","pos":[1624,1706]},{"content":"The .NET Framework provides two types to support the implementation:","pos":[1707,1775]},{"pos":[1781,1937],"content":"The <bpt id=\"p1\">[</bpt>EventRegistrationToken<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.eventregistrationtoken.aspx)</ept> structure represents the token.","source":"The [EventRegistrationToken](https://msdn.microsoft.com/library/windows/apps/windows.foundation.eventregistrationtoken.aspx) structure represents the token."},{"content":"The <bpt id=\"p1\">[</bpt>EventRegistrationTokenTable<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">](https://msdn.microsoft.com/library/hh138412.aspx)</ept> class creates tokens and maintains a mapping between tokens and event handlers.","pos":[1942,2114],"source":"The [EventRegistrationTokenTable&lt;T&gt;](https://msdn.microsoft.com/library/hh138412.aspx) class creates tokens and maintains a mapping between tokens and event handlers."},{"content":"The generic type argument is the event argument type.","pos":[2115,2168]},{"content":"You create an instance of this class for each event, the first time an event handler is registered for that event.","pos":[2169,2283]},{"content":"The following code for the NumberChanged event shows the basic pattern for UWP events.","pos":[2285,2371]},{"content":"In this example, the constructor for the event argument object, NumberChangedEventArgs, takes a single integer parameter that represents the changed numeric value.","pos":[2372,2535]},{"pos":[2539,2660],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  This is the same pattern the compilers use for ordinary events that you declare in a Windows Runtime Component.","source":"**Note**  This is the same pattern the compilers use for ordinary events that you declare in a Windows Runtime Component."},{"content":"The static (Shared in Visual Basic) GetOrCreateEventRegistrationTokenTable method creates the event’s instance of the EventRegistrationTokenTable<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph> object lazily.","pos":[5050,5219],"source":"The static (Shared in Visual Basic) GetOrCreateEventRegistrationTokenTable method creates the event’s instance of the EventRegistrationTokenTable&lt;T&gt; object lazily."},{"content":"Pass the class-level field that will hold the token table instance to this method.","pos":[5220,5302]},{"content":"If the field is empty, the method creates the table, stores a reference to the table in the field, and returns a reference to the table.","pos":[5303,5439]},{"content":"If the field already contains a token table reference, the method just returns that reference.","pos":[5440,5534]},{"content":"<bpt id=\"p1\">**</bpt>Important<ept id=\"p1\">**</ept>  To ensure thread safety, the field that holds the event’s instance of EventRegistrationTokenTable<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph> must be a class-level field.","pos":[5538,5688],"source":"**Important**  To ensure thread safety, the field that holds the event’s instance of EventRegistrationTokenTable&lt;T&gt; must be a class-level field."},{"content":"If it is a class-level field, the GetOrCreateEventRegistrationTokenTable method ensures that when multiple threads try to create the token table, all threads get the same instance of the table.","pos":[5689,5882]},{"content":"For a given event, all calls to the GetOrCreateEventRegistrationTokenTable method must use the same class-level field.","pos":[5883,6001]},{"pos":[6003,6309],"content":"Calling the GetOrCreateEventRegistrationTokenTable method in the remove accessor and in the <bpt id=\"p1\">[</bpt>RaiseEvent<ept id=\"p1\">](https://msdn.microsoft.com/library/fwd3bwed.aspx)</ept> method (the OnRaiseEvent method in C#) ensures that no exceptions occur if these methods are called before any event handler delegates have been added.","source":"Calling the GetOrCreateEventRegistrationTokenTable method in the remove accessor and in the [RaiseEvent](https://msdn.microsoft.com/library/fwd3bwed.aspx) method (the OnRaiseEvent method in C#) ensures that no exceptions occur if these methods are called before any event handler delegates have been added."},{"content":"The other members of the EventRegistrationTokenTable<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph> class that are used in the UWP event pattern include the following:","pos":[6311,6440],"source":"The other members of the EventRegistrationTokenTable&lt;T&gt; class that are used in the UWP event pattern include the following:"},{"pos":[6446,6663],"content":"The <bpt id=\"p1\">[</bpt>AddEventHandler<ept id=\"p1\">](https://msdn.microsoft.com/library/hh138458.aspx)</ept> method generates a token for the event handler delegate, stores the delegate in the table, adds it to the invocation list, and returns the token.","source":"The [AddEventHandler](https://msdn.microsoft.com/library/hh138458.aspx) method generates a token for the event handler delegate, stores the delegate in the table, adds it to the invocation list, and returns the token."},{"pos":[6668,6848],"content":"The <bpt id=\"p1\">[</bpt>RemoveEventHandler(EventRegistrationToken)<ept id=\"p1\">](https://msdn.microsoft.com/library/hh138425.aspx)</ept> method overload removes the delegate from the table and from the invocation list.","source":"The [RemoveEventHandler(EventRegistrationToken)](https://msdn.microsoft.com/library/hh138425.aspx) method overload removes the delegate from the table and from the invocation list."},{"pos":[6855,6984],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  The AddEventHandler and RemoveEventHandler(EventRegistrationToken) methods lock the table to help ensure thread safety.","source":"**Note**  The AddEventHandler and RemoveEventHandler(EventRegistrationToken) methods lock the table to help ensure thread safety."},{"content":"The <bpt id=\"p1\">[</bpt>InvocationList<ept id=\"p1\">](https://msdn.microsoft.com/library/hh138465.aspx)</ept> property returns a delegate that includes all the event handlers that are currently registered to handle the event.","pos":[6990,7176],"source":"The [InvocationList](https://msdn.microsoft.com/library/hh138465.aspx) property returns a delegate that includes all the event handlers that are currently registered to handle the event."},{"content":"Use this delegate to raise the event, or use the methods of the Delegate class to invoke the handlers individually.","pos":[7177,7292]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  We recommend that you follow the pattern shown in the example provided earlier in this article, and copy the delegate to a temporary variable before invoking it.","pos":[7299,7470],"source":"**Note**  We recommend that you follow the pattern shown in the example provided earlier in this article, and copy the delegate to a temporary variable before invoking it."},{"content":"This avoids a race condition in which one thread removes the last handler, reducing the delegate to null just before another thread tries to invoke the delegate.","pos":[7471,7632]},{"content":"Delegates are immutable, so the copy is still valid.","pos":[7633,7685]},{"content":"Place your own code in the accessors as appropriate.","pos":[7687,7739]},{"content":"If thread safety is an issue, you must provide your own locking for your code.","pos":[7740,7818]},{"content":"C# users: When you write custom event accessors in the UWP event pattern, the compiler doesn't provide the usual syntactic shortcuts.","pos":[7820,7953]},{"content":"It generates errors if you use the name of the event in your code.","pos":[7954,8020]},{"content":"Visual Basic users: In the .NET Framework, an event is just a multicast delegate that represents all the registered event handlers.","pos":[8022,8153]},{"content":"Raising the event just means invoking the delegate.","pos":[8154,8205]},{"content":"Visual Basic syntax generally hides the interactions with the delegate, and the compiler copies the delegate before invoking it, as described in the note about thread safety.","pos":[8206,8380]},{"content":"When you create a custom event in a Windows Runtime Component, you have to deal with the delegate directly.","pos":[8381,8488]},{"content":"This also means that you can, for example, use the <bpt id=\"p1\">[</bpt>MulticastDelegate.GetInvocationList<ept id=\"p1\">](https://msdn.microsoft.com/library/system.multicastdelegate.getinvocationlist.aspx)</ept> method to get an array that contains a separate delegate for each event handler, if you want to invoke the handlers separately.","pos":[8489,8789],"source":" This also means that you can, for example, use the [MulticastDelegate.GetInvocationList](https://msdn.microsoft.com/library/system.multicastdelegate.getinvocationlist.aspx) method to get an array that contains a separate delegate for each event handler, if you want to invoke the handlers separately."},{"content":"Related topics","pos":[8794,8808]},{"content":"Events (Visual Basic)","pos":[8813,8834]},{"content":"Events (C# Programming Guide)","pos":[8889,8918]},{"content":".NET for Windows Store Apps Overview","pos":[8973,9009]},{"content":".NET for UWP apps","pos":[9082,9099]},{"content":"Walkthrough: Creating a Simple Windows Runtime Component and calling it from JavaScript","pos":[9172,9259]}],"content":"---\ntitle: Custom events and event accessors in Windows Runtime Components\ndescription: .NET Framework support for Windows Runtime Components makes it easy to declare events components by hiding the differences between the Universal Windows Platform (UWP) event pattern and the .NET Framework event pattern.\nms.assetid: 6A66D80A-5481-47F8-9499-42AC8FDA0EB4\n---\n\n# Custom events and event accessors in Windows Runtime Components\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\n\\[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\\]\n\n.NET Framework support for Windows Runtime Components makes it easy to declare events components by hiding the differences between the Universal Windows Platform (UWP) event pattern and the .NET Framework event pattern. However, when you declare custom event accessors in a Windows Runtime Component, you must follow the pattern used in the UWP.\n\n## Registering events\n\n\nWhen you register to handle an event in the UWP, the add accessor returns a token. To unregister, you pass this token to the remove accessor. This means that the add and remove accessors for UWP events have different signatures from the accessors you're used to.\n\nFortunately, the Visual Basic and C# compilers simplify this process: When you declare an event with custom accessors in a Windows Runtime Component, the compilers automatically use the UWP pattern. For example, you get a compiler error if your add accessor doesn't return a token. The .NET Framework provides two types to support the implementation:\n\n-   The [EventRegistrationToken](https://msdn.microsoft.com/library/windows/apps/windows.foundation.eventregistrationtoken.aspx) structure represents the token.\n-   The [EventRegistrationTokenTable&lt;T&gt;](https://msdn.microsoft.com/library/hh138412.aspx) class creates tokens and maintains a mapping between tokens and event handlers. The generic type argument is the event argument type. You create an instance of this class for each event, the first time an event handler is registered for that event.\n\nThe following code for the NumberChanged event shows the basic pattern for UWP events. In this example, the constructor for the event argument object, NumberChangedEventArgs, takes a single integer parameter that represents the changed numeric value.\n\n> **Note**  This is the same pattern the compilers use for ordinary events that you declare in a Windows Runtime Component.\n\n \n> [!div class=\"tabbedCodeSnippets\"]\n> ```csharp\n> private EventRegistrationTokenTable<EventHandler<NumberChangedEventArgs>> \n>     m_NumberChangedTokenTable = null;\n> \n> public event EventHandler<NumberChangedEventArgs> NumberChanged\n> {\n>     add\n>     {\n>         return EventRegistrationTokenTable<EventHandler<NumberChangedEventArgs>>\n>             .GetOrCreateEventRegistrationTokenTable(ref m_NumberChangedTokenTable)\n>             .AddEventHandler(value);\n>     }\n>     remove\n>     {\n>         EventRegistrationTokenTable<EventHandler<NumberChangedEventArgs>>\n>             .GetOrCreateEventRegistrationTokenTable(ref m_NumberChangedTokenTable)\n>             .RemoveEventHandler(value);\n>     }\n> }\n> \n> internal void OnNumberChanged(int newValue)\n> {\n>     EventHandler<NumberChangedEventArgs> temp = \n>         EventRegistrationTokenTable<EventHandler<NumberChangedEventArgs>>\n>         .GetOrCreateEventRegistrationTokenTable(ref m_NumberChangedTokenTable)\n>         .InvocationList;\n>     if (temp != null)\n>     {\n>         temp(this, new NumberChangedEventArgs(newValue));\n>     }\n> }\n> ```\n> ```vb\n> Private m_NumberChangedTokenTable As  _\n>     EventRegistrationTokenTable(Of EventHandler(Of NumberChangedEventArgs))\n> \n> Public Custom Event NumberChanged As EventHandler(Of NumberChangedEventArgs)\n> \n>     AddHandler(ByVal handler As EventHandler(Of NumberChangedEventArgs))\n>         Return EventRegistrationTokenTable(Of EventHandler(Of NumberChangedEventArgs)).\n>             GetOrCreateEventRegistrationTokenTable(m_NumberChangedTokenTable).\n>             AddEventHandler(handler)\n>     End AddHandler\n> \n>     RemoveHandler(ByVal token As EventRegistrationToken)\n>         EventRegistrationTokenTable(Of EventHandler(Of NumberChangedEventArgs)).\n>             GetOrCreateEventRegistrationTokenTable(m_NumberChangedTokenTable).\n>             RemoveEventHandler(token)\n>     End RemoveHandler\n> \n>     RaiseEvent(ByVal sender As Class1, ByVal args As NumberChangedEventArgs)\n>         Dim temp As EventHandler(Of NumberChangedEventArgs) = _\n>             EventRegistrationTokenTable(Of EventHandler(Of NumberChangedEventArgs)).\n>             GetOrCreateEventRegistrationTokenTable(m_NumberChangedTokenTable).\n>             InvocationList\n>         If temp IsNot Nothing Then\n>             temp(sender, args)\n>         End If\n>     End RaiseEvent\n> End Event\n> ```\n\nThe static (Shared in Visual Basic) GetOrCreateEventRegistrationTokenTable method creates the event’s instance of the EventRegistrationTokenTable&lt;T&gt; object lazily. Pass the class-level field that will hold the token table instance to this method. If the field is empty, the method creates the table, stores a reference to the table in the field, and returns a reference to the table. If the field already contains a token table reference, the method just returns that reference.\n\n> **Important**  To ensure thread safety, the field that holds the event’s instance of EventRegistrationTokenTable&lt;T&gt; must be a class-level field. If it is a class-level field, the GetOrCreateEventRegistrationTokenTable method ensures that when multiple threads try to create the token table, all threads get the same instance of the table. For a given event, all calls to the GetOrCreateEventRegistrationTokenTable method must use the same class-level field.\n\nCalling the GetOrCreateEventRegistrationTokenTable method in the remove accessor and in the [RaiseEvent](https://msdn.microsoft.com/library/fwd3bwed.aspx) method (the OnRaiseEvent method in C#) ensures that no exceptions occur if these methods are called before any event handler delegates have been added.\n\nThe other members of the EventRegistrationTokenTable&lt;T&gt; class that are used in the UWP event pattern include the following:\n\n-   The [AddEventHandler](https://msdn.microsoft.com/library/hh138458.aspx) method generates a token for the event handler delegate, stores the delegate in the table, adds it to the invocation list, and returns the token.\n-   The [RemoveEventHandler(EventRegistrationToken)](https://msdn.microsoft.com/library/hh138425.aspx) method overload removes the delegate from the table and from the invocation list.\n\n    >**Note**  The AddEventHandler and RemoveEventHandler(EventRegistrationToken) methods lock the table to help ensure thread safety.\n\n-   The [InvocationList](https://msdn.microsoft.com/library/hh138465.aspx) property returns a delegate that includes all the event handlers that are currently registered to handle the event. Use this delegate to raise the event, or use the methods of the Delegate class to invoke the handlers individually.\n\n    >**Note**  We recommend that you follow the pattern shown in the example provided earlier in this article, and copy the delegate to a temporary variable before invoking it. This avoids a race condition in which one thread removes the last handler, reducing the delegate to null just before another thread tries to invoke the delegate. Delegates are immutable, so the copy is still valid.\n\nPlace your own code in the accessors as appropriate. If thread safety is an issue, you must provide your own locking for your code.\n\nC# users: When you write custom event accessors in the UWP event pattern, the compiler doesn't provide the usual syntactic shortcuts. It generates errors if you use the name of the event in your code.\n\nVisual Basic users: In the .NET Framework, an event is just a multicast delegate that represents all the registered event handlers. Raising the event just means invoking the delegate. Visual Basic syntax generally hides the interactions with the delegate, and the compiler copies the delegate before invoking it, as described in the note about thread safety. When you create a custom event in a Windows Runtime Component, you have to deal with the delegate directly. This also means that you can, for example, use the [MulticastDelegate.GetInvocationList](https://msdn.microsoft.com/library/system.multicastdelegate.getinvocationlist.aspx) method to get an array that contains a separate delegate for each event handler, if you want to invoke the handlers separately.\n\n## Related topics\n\n* [Events (Visual Basic)](https://msdn.microsoft.com/library/ms172877.aspx)\n* [Events (C# Programming Guide)](https://msdn.microsoft.com/library/awbftdfh.aspx)\n* [.NET for Windows Store Apps Overview](https://msdn.microsoft.com/library/windows/apps/xaml/br230302.aspx)\n* [.NET for UWP apps](https://msdn.microsoft.com/library/windows/apps/xaml/mt185501.aspx)\n* [Walkthrough: Creating a Simple Windows Runtime Component and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)\n\n"}