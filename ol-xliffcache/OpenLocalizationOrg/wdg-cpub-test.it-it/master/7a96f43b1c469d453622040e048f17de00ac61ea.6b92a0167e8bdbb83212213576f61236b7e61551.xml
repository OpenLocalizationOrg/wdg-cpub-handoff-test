{"nodes":[{"pos":[11,42],"content":"Convert the rendering framework","needQuote":true,"needEscape":true,"nodes":[{"content":"Convert the rendering framework","pos":[0,31]}]},{"pos":[56,280],"content":"Shows how to convert a simple rendering framework from Direct3D 9 to Direct3D 11, including how to port geometry buffers, how to compile and load HLSL shader programs, and how to implement the rendering chain in Direct3D 11.","needQuote":true,"needEscape":true,"nodes":[{"content":"Shows how to convert a simple rendering framework from Direct3D 9 to Direct3D 11, including how to port geometry buffers, how to compile and load HLSL shader programs, and how to implement the rendering chain in Direct3D 11.","pos":[0,224]}]},{"content":"Convert the rendering framework","pos":[337,368]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[371,409]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[410,505],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Summary","pos":[509,516]},{"content":"Part 1: Initialize Direct3D 11","pos":[525,555]},{"content":"Part 2: Convert the rendering framework","pos":[631,670]},{"content":"Part 3: Port the game loop","pos":[676,702]},{"content":"Shows how to convert a simple rendering framework from Direct3D 9 to Direct3D 11, including how to port geometry buffers, how to compile and load HLSL shader programs, and how to implement the rendering chain in Direct3D 11.","pos":[777,1001]},{"content":"Part 2 of the <bpt id=\"p1\">[</bpt>Port a simple Direct3D 9 app to DirectX 11 and Universal Windows Platform (UWP)<ept id=\"p1\">](walkthrough--simple-port-from-direct3d-9-to-11-1.md)</ept> walkthrough.","pos":[1002,1163],"source":" Part 2 of the [Port a simple Direct3D 9 app to DirectX 11 and Universal Windows Platform (UWP)](walkthrough--simple-port-from-direct3d-9-to-11-1.md) walkthrough."},{"content":"Convert effects to HLSL shaders","pos":[1168,1199]},{"content":"The following example is a simple D3DX technique, written for the legacy Effects API, for hardware vertex transformation and pass-through color data.","pos":[1202,1351]},{"content":"Direct3D 9 shader code","pos":[1353,1375]},{"content":"In Direct3D 11, we can still use our HLSL shaders.","pos":[2606,2656]},{"content":"We put each shader in its own HLSL file so that Visual Studio compiles them into separate files and later, we'll load them as separate Direct3D resources.","pos":[2657,2811]},{"content":"We set the target level to <bpt id=\"p1\">[</bpt>Shader Model 4 Level 9\\_1 (/4\\_0\\_level\\_9\\_1)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476876)</ept> because these shaders are written for DirectX 9.1 GPUs.","pos":[2812,3004],"source":" We set the target level to [Shader Model 4 Level 9\\_1 (/4\\_0\\_level\\_9\\_1)](https://msdn.microsoft.com/library/windows/desktop/ff476876) because these shaders are written for DirectX 9.1 GPUs."},{"content":"When we defined the input layout, we made sure it represented the same data structure we use to store per-vertex data in system memory and in GPU memory.","pos":[3006,3159]},{"content":"Similarly, the output of a vertex shader should match the structure used as input to the pixel shader.","pos":[3160,3262]},{"content":"The rules are not the same as passing data from one function to another in C++; you can omit unused variables at the end of the structure.","pos":[3263,3401]},{"content":"But the order can't be rearranged and you can't skip content in the middle of the data structure.","pos":[3402,3499]},{"content":"Note","pos":[3505,3509]},{"content":"The rules in Direct3D 9 for binding vertex shaders to pixel shaders were more relaxed than the rules in Direct3D 11.","pos":[3514,3630]},{"content":"The Direct3D 9 arrangement was flexible, but inefficient.","pos":[3631,3688]},{"content":"It's possible that your HLSL files uses older syntax for shader semantics - for example, COLOR instead of SV\\_TARGET.","pos":[3693,3810]},{"content":"If so you'll need to enable HLSL compatibility mode (/Gec compiler option) or update the shader <bpt id=\"p1\">[</bpt>semantics<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509647)</ept> to the current syntax.","pos":[3811,4002],"source":" If so you'll need to enable HLSL compatibility mode (/Gec compiler option) or update the shader [semantics](https://msdn.microsoft.com/library/windows/desktop/bb509647) to the current syntax."},{"content":"The vertex shader in this example has been updated with current syntax.","pos":[4003,4074]},{"content":"Here's our hardware transformation vertex shader, this time defined in its own file.","pos":[4076,4160]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  Vertex shaders are required to output the SV\\_POSITION system value semantic.","pos":[4164,4251],"source":"**Note**  Vertex shaders are required to output the SV\\_POSITION system value semantic."},{"content":"This semantic resolves the vertex position data to coordinate values where x is between -1 and 1, y is between -1 and 1, z is divided by the original homogeneous coordinate w value (z/w), and w is 1 divided by the original w value (1/w).","pos":[4252,4489]},{"content":"HLSL vertex shader (feature level 9.1)","pos":[4494,4532]},{"content":"This is all we need for our pass-through pixel shader.","pos":[5395,5449]},{"content":"Even though we call it a pass-through, it's actually getting perspective-correct interpolated color data for each pixel.","pos":[5450,5570]},{"content":"Note that the SV\\_TARGET system value semantic is applied to the color value output by our pixel shader as required by the API.","pos":[5571,5698]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  Shader level 9\\_x pixel shaders cannot read from the SV\\_POSITION system value semantic.","pos":[5702,5800],"source":"**Note**  Shader level 9\\_x pixel shaders cannot read from the SV\\_POSITION system value semantic."},{"content":"Model 4.0 (and higher) pixel shaders can use SV\\_POSITION to retrieve the pixel location on the screen, where x is between 0 and the render target width and y is between 0 and the render target height (each offset by 0.5).","pos":[5801,6023]},{"content":"Most pixel shaders are much more complex than a pass through; note that higher Direct3D feature levels allow a much greater number of calculations per shader program.","pos":[6028,6194]},{"content":"HLSL pixel shader (feature level 9.1)","pos":[6196,6233]},{"content":"Compile and load shaders","pos":[6637,6661]},{"content":"Direct3D 9 games often used the Effects library as a convenient way to implement programmable pipelines.","pos":[6664,6768]},{"content":"Effects could be compiled at run-time using the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3DXCreateEffectFromFile function<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb172768)</ept> method.","pos":[6769,6925],"source":" Effects could be compiled at run-time using the [**D3DXCreateEffectFromFile function**](https://msdn.microsoft.com/library/windows/desktop/bb172768) method."},{"content":"Loading an effect in Direct3D 9","pos":[6927,6958]},{"content":"Direct3D 11 works with shader programs as binary resources.","pos":[7378,7437]},{"content":"Shaders are compiled when the project is built and then treated as resources.","pos":[7438,7515]},{"content":"So our example will load the shader bytecode into system memory, use the Direct3D device interface to create a Direct3D resource for each shader, and point to the Direct3D shader resources when we set up each frame.","pos":[7516,7731]},{"content":"Loading a shader resource in Direct3D 11","pos":[7733,7773]},{"content":"To include the shader bytecode in your compiled app package, just add the HLSL file to the Visual Studio project.","pos":[8330,8443]},{"content":"Visual Studio will use the <bpt id=\"p1\">[</bpt>Effect-Compiler Tool<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb232919)</ept> (FXC) to compile HLSL files into compiled shader objects (.CSO files) and include them in the app package.","pos":[8444,8661],"source":" Visual Studio will use the [Effect-Compiler Tool](https://msdn.microsoft.com/library/windows/desktop/bb232919) (FXC) to compile HLSL files into compiled shader objects (.CSO files) and include them in the app package."},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   Be sure to set the correct target feature level for the HLSL compiler: right-click the HLSL source file in Visual Studio, select Properties, and change the <bpt id=\"p2\">**</bpt>Shader Model<ept id=\"p2\">**</ept> setting under <bpt id=\"p3\">**</bpt>HLSL Compiler -<ph id=\"ph1\">&amp;gt;</ph> General<ept id=\"p3\">**</ept>.","pos":[8665,8895],"source":"**Note**   Be sure to set the correct target feature level for the HLSL compiler: right-click the HLSL source file in Visual Studio, select Properties, and change the **Shader Model** setting under **HLSL Compiler -&gt; General**."},{"content":"Direct3D checks this property against the hardware capabilities when your app creates the Direct3D shader resource.","pos":[8896,9011]},{"content":"hlsl shader properties","pos":[9018,9040]},{"content":"hlsl shader type","pos":[9080,9096]},{"content":"This is a good place to create the input layout, which corresponds to the vertex stream declaration in Direct3D 9.","pos":[9136,9250]},{"content":"The per-vertex data structure needs to match what the vertex shader uses; in Direct3D 11 we have more control over the input layout; we can define the array size and bit length of floating-point vectors and specify semantics for the vertex shader.","pos":[9251,9498]},{"content":"We create a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11\\_INPUT\\_ELEMENT\\_DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476180)</ept> structure and use it to inform Direct3D what the per-vertex data will look like.","pos":[9499,9686],"source":" We create a [**D3D11\\_INPUT\\_ELEMENT\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476180) structure and use it to inform Direct3D what the per-vertex data will look like."},{"content":"We waited until after we loaded the vertex shader to define the input layout because the API validates the input layout against the vertex shader resource.","pos":[9687,9842]},{"content":"If the input layout isn't compatible then Direct3D throws an exception.","pos":[9843,9914]},{"content":"Per-vertex data has to be stored in compatible types in system memory.","pos":[9916,9986]},{"content":"DirectXMath data types can help; for example, DXGI\\_FORMAT\\_R32G32B32\\_FLOAT corresponds to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>XMFLOAT3<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ee419475)</ept>.","pos":[9987,10155],"source":" DirectXMath data types can help; for example, DXGI\\_FORMAT\\_R32G32B32\\_FLOAT corresponds to [**XMFLOAT3**](https://msdn.microsoft.com/library/windows/desktop/ee419475)."},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   Constant buffers use a fixed input layout that aligns to four floating-point numbers at a time.","pos":[10159,10265],"source":"**Note**   Constant buffers use a fixed input layout that aligns to four floating-point numbers at a time."},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>XMFLOAT4<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ee419608)</ept> (and its derivatives) are recommended for constant buffer data.","pos":[10266,10405],"source":"[**XMFLOAT4**](https://msdn.microsoft.com/library/windows/desktop/ee419608) (and its derivatives) are recommended for constant buffer data."},{"content":"Setting the input layout in Direct3D 11","pos":[10410,10449]},{"content":"Create geometry resources","pos":[10742,10767]},{"content":"In Direct3D 9 we stored geometry resources by creating buffers on the Direct3D device, locking the memory, and copying data from CPU memory to GPU memory.","pos":[10770,10924]},{"content":"Direct3D 9","pos":[10926,10936]},{"content":"DirectX 11 follows a simpler process.","pos":[11414,11451]},{"content":"The API automatically copies the data from system memory to the GPU.","pos":[11452,11520]},{"content":"We can use COM smart pointers to help make programming easier.","pos":[11521,11583]},{"content":"DirectX 11","pos":[11585,11595]},{"content":"Implement the rendering chain","pos":[12060,12089]},{"content":"Direct3D 9 games often used an effect-based rendering chain.","pos":[12092,12152]},{"content":"This type of rendering chain sets up the effect object, provides it with the resources it needs, and lets it render each pass.","pos":[12153,12279]},{"content":"Direct3D 9 rendering chain","pos":[12281,12307]},{"content":"The DirectX 11 rendering chain will still do the same tasks, but the rendering passes need to be implemented differently.","pos":[13807,13928]},{"content":"Instead of putting the specifics in FX files and letting the rendering techniques be more-or-less opaque to our C++ code, we'll set up all our rendering in C++.","pos":[13929,14089]},{"content":"Here's how our rendering chain will look.","pos":[14091,14132]},{"content":"We need to supply the input layout we created after loading the vertex shader, supply each of the shader objects, and specify the constant buffers for each shader to use.","pos":[14133,14303]},{"content":"This example doesn't include multiple rendering passes, but if it did we'd do a similar rendering chain for each pass, changing the setup as needed.","pos":[14304,14452]},{"content":"Direct3D 11 rendering chain","pos":[14454,14481]},{"content":"The swap chain is part of graphics infrastructure, so we use our DXGI swap chain to present the completed frame.","pos":[16438,16550]},{"content":"DXGI blocks the call until the next vsync; then it returns, and our game loop can continue to the next iteration.","pos":[16551,16664]},{"content":"Presenting a frame to the screen using DirectX 11","pos":[16666,16715]},{"content":"The rendering chain we just created will be called from a game loop implemented in the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IFrameworkView::Run<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh700505)</ept> method.","pos":[16757,16935],"source":"The rendering chain we just created will be called from a game loop implemented in the [**IFrameworkView::Run**](https://msdn.microsoft.com/library/windows/apps/hh700505) method."},{"content":"This is shown in <bpt id=\"p1\">[</bpt>Part 3: Viewport and game loop<ept id=\"p1\">](simple-port-from-direct3d-9-to-11-1-part-3--viewport-and-game-loop.md)</ept>.","pos":[16936,17057],"source":" This is shown in [Part 3: Viewport and game loop](simple-port-from-direct3d-9-to-11-1-part-3--viewport-and-game-loop.md)."}],"content":"---\ntitle: Convert the rendering framework\ndescription: Shows how to convert a simple rendering framework from Direct3D 9 to Direct3D 11, including how to port geometry buffers, how to compile and load HLSL shader programs, and how to implement the rendering chain in Direct3D 11.\nms.assetid: f6ca1147-9bb8-719a-9a2c-b7ee3e34bd18\n---\n\n# Convert the rendering framework\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n**Summary**\n\n-   [Part 1: Initialize Direct3D 11](simple-port-from-direct3d-9-to-11-1-part-1--initializing-direct3d.md)\n-   Part 2: Convert the rendering framework\n-   [Part 3: Port the game loop](simple-port-from-direct3d-9-to-11-1-part-3--viewport-and-game-loop.md)\n\n\nShows how to convert a simple rendering framework from Direct3D 9 to Direct3D 11, including how to port geometry buffers, how to compile and load HLSL shader programs, and how to implement the rendering chain in Direct3D 11. Part 2 of the [Port a simple Direct3D 9 app to DirectX 11 and Universal Windows Platform (UWP)](walkthrough--simple-port-from-direct3d-9-to-11-1.md) walkthrough.\n\n## Convert effects to HLSL shaders\n\n\nThe following example is a simple D3DX technique, written for the legacy Effects API, for hardware vertex transformation and pass-through color data.\n\nDirect3D 9 shader code\n\n```cpp\n// Global variables\nmatrix g_mWorld;        // world matrix for object\nmatrix g_View;          // view matrix\nmatrix g_Projection;    // projection matrix\n\n// Shader pipeline structures\nstruct VS_OUTPUT\n{\n    float4 Position   : POSITION;   // vertex position\n    float4 Color      : COLOR0;     // vertex diffuse color\n};\n\nstruct PS_OUTPUT\n{\n    float4 RGBColor : COLOR0;  // Pixel color    \n};\n\n// Vertex shader\nVS_OUTPUT RenderSceneVS(float3 vPos : POSITION, \n                        float3 vColor : COLOR0)\n{\n    VS_OUTPUT Output;\n    \n    float4 pos = float4(vPos, 1.0f);\n\n    // Transform the position from object space to homogeneous projection space\n    pos = mul(pos, g_mWorld);\n    pos = mul(pos, g_View);\n    pos = mul(pos, g_Projection);\n\n    Output.Position = pos;\n    \n    // Just pass through the color data\n    Output.Color = float4(vColor, 1.0f);\n    \n    return Output;\n}\n\n// Pixel shader\nPS_OUTPUT RenderScenePS(VS_OUTPUT In) \n{ \n    PS_OUTPUT Output;\n\n    Output.RGBColor = In.Color;\n\n    return Output;\n}\n\n// Technique\ntechnique RenderSceneSimple\n{\n    pass P0\n    {          \n        VertexShader = compile vs_2_0 RenderSceneVS();\n        PixelShader  = compile ps_2_0 RenderScenePS(); \n    }\n}\n```\n\nIn Direct3D 11, we can still use our HLSL shaders. We put each shader in its own HLSL file so that Visual Studio compiles them into separate files and later, we'll load them as separate Direct3D resources. We set the target level to [Shader Model 4 Level 9\\_1 (/4\\_0\\_level\\_9\\_1)](https://msdn.microsoft.com/library/windows/desktop/ff476876) because these shaders are written for DirectX 9.1 GPUs.\n\nWhen we defined the input layout, we made sure it represented the same data structure we use to store per-vertex data in system memory and in GPU memory. Similarly, the output of a vertex shader should match the structure used as input to the pixel shader. The rules are not the same as passing data from one function to another in C++; you can omit unused variables at the end of the structure. But the order can't be rearranged and you can't skip content in the middle of the data structure.\n\n> **Note**  \nThe rules in Direct3D 9 for binding vertex shaders to pixel shaders were more relaxed than the rules in Direct3D 11. The Direct3D 9 arrangement was flexible, but inefficient.\n\n \n\nIt's possible that your HLSL files uses older syntax for shader semantics - for example, COLOR instead of SV\\_TARGET. If so you'll need to enable HLSL compatibility mode (/Gec compiler option) or update the shader [semantics](https://msdn.microsoft.com/library/windows/desktop/bb509647) to the current syntax. The vertex shader in this example has been updated with current syntax.\n\nHere's our hardware transformation vertex shader, this time defined in its own file.\n\n> **Note**  Vertex shaders are required to output the SV\\_POSITION system value semantic. This semantic resolves the vertex position data to coordinate values where x is between -1 and 1, y is between -1 and 1, z is divided by the original homogeneous coordinate w value (z/w), and w is 1 divided by the original w value (1/w).\n\n \n\nHLSL vertex shader (feature level 9.1)\n\n```cpp\ncbuffer ModelViewProjectionConstantBuffer : register(b0)\n{\n    matrix mWorld;       // world matrix for object\n    matrix View;        // view matrix\n    matrix Projection;  // projection matrix\n};\n\nstruct VS_INPUT\n{\n    float3 vPos   : POSITION;\n    float3 vColor : COLOR0;\n};\n\nstruct VS_OUTPUT\n{\n    float4 Position : SV_POSITION; // Vertex shaders must output SV_POSITION\n    float4 Color    : COLOR0;\n};\n\nVS_OUTPUT main(VS_INPUT input) // main is the default function name\n{\n    VS_OUTPUT Output;\n\n    float4 pos = float4(input.vPos, 1.0f);\n\n    // Transform the position from object space to homogeneous projection space\n    pos = mul(pos, mWorld);\n    pos = mul(pos, View);\n    pos = mul(pos, Projection);\n    Output.Position = pos;\n\n    // Just pass through the color data\n    Output.Color = float4(input.vColor, 1.0f);\n\n    return Output;\n}\n```\n\nThis is all we need for our pass-through pixel shader. Even though we call it a pass-through, it's actually getting perspective-correct interpolated color data for each pixel. Note that the SV\\_TARGET system value semantic is applied to the color value output by our pixel shader as required by the API.\n\n> **Note**  Shader level 9\\_x pixel shaders cannot read from the SV\\_POSITION system value semantic. Model 4.0 (and higher) pixel shaders can use SV\\_POSITION to retrieve the pixel location on the screen, where x is between 0 and the render target width and y is between 0 and the render target height (each offset by 0.5).\n\n \n\nMost pixel shaders are much more complex than a pass through; note that higher Direct3D feature levels allow a much greater number of calculations per shader program.\n\nHLSL pixel shader (feature level 9.1)\n\n```cpp\nstruct PS_INPUT\n{\n    float4 Position : SV_POSITION;  // interpolated vertex position (system value)\n    float4 Color    : COLOR0;       // interpolated diffuse color\n};\n\nstruct PS_OUTPUT\n{\n    float4 RGBColor : SV_TARGET;  // pixel color (your PS computes this system value)\n};\n\nPS_OUTPUT main(PS_INPUT In)\n{\n    PS_OUTPUT Output;\n\n    Output.RGBColor = In.Color;\n\n    return Output;\n}\n```\n\n## Compile and load shaders\n\n\nDirect3D 9 games often used the Effects library as a convenient way to implement programmable pipelines. Effects could be compiled at run-time using the [**D3DXCreateEffectFromFile function**](https://msdn.microsoft.com/library/windows/desktop/bb172768) method.\n\nLoading an effect in Direct3D 9\n\n```cpp\n// Turn off preshader optimization to keep calculations on the GPU\nDWORD dwShaderFlags = D3DXSHADER_NO_PRESHADER;\n\n// Only enable debug info when compiling for a debug target\n#if defined (DEBUG) || defined (_DEBUG)\ndwShaderFlags |= D3DXSHADER_DEBUG;\n#endif\n\nD3DXCreateEffectFromFile(\n    m_pd3dDevice,\n    L\"CubeShaders.fx\",\n    NULL,\n    NULL,\n    dwShaderFlags,\n    NULL,\n    &m_pEffect,\n    NULL\n    );\n```\n\nDirect3D 11 works with shader programs as binary resources. Shaders are compiled when the project is built and then treated as resources. So our example will load the shader bytecode into system memory, use the Direct3D device interface to create a Direct3D resource for each shader, and point to the Direct3D shader resources when we set up each frame.\n\nLoading a shader resource in Direct3D 11\n\n```cpp\n// BasicReaderWriter is a tested file loader used in SDK samples.\nBasicReaderWriter^ readerWriter = ref new BasicReaderWriter();\n\n\n// Load vertex shader:\nPlatform::Array<byte>^ vertexShaderData =\n    readerWriter->ReadData(\"CubeVertexShader.cso\");\n\n// This call allocates a device resource, validates the vertex shader \n// with the device feature level, and stores the vertex shader bits in \n// graphics memory.\nm_d3dDevice->CreateVertexShader(\n    vertexShaderData->Data,\n    vertexShaderData->Length,\n    nullptr,\n    &m_vertexShader\n    );\n```\n\nTo include the shader bytecode in your compiled app package, just add the HLSL file to the Visual Studio project. Visual Studio will use the [Effect-Compiler Tool](https://msdn.microsoft.com/library/windows/desktop/bb232919) (FXC) to compile HLSL files into compiled shader objects (.CSO files) and include them in the app package.\n\n> **Note**   Be sure to set the correct target feature level for the HLSL compiler: right-click the HLSL source file in Visual Studio, select Properties, and change the **Shader Model** setting under **HLSL Compiler -&gt; General**. Direct3D checks this property against the hardware capabilities when your app creates the Direct3D shader resource.\n\n \n\n![hlsl shader properties](images/hlslshaderpropertiesmenu.png)![hlsl shader type](images/hlslshadertypeproperties.png)\n\nThis is a good place to create the input layout, which corresponds to the vertex stream declaration in Direct3D 9. The per-vertex data structure needs to match what the vertex shader uses; in Direct3D 11 we have more control over the input layout; we can define the array size and bit length of floating-point vectors and specify semantics for the vertex shader. We create a [**D3D11\\_INPUT\\_ELEMENT\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476180) structure and use it to inform Direct3D what the per-vertex data will look like. We waited until after we loaded the vertex shader to define the input layout because the API validates the input layout against the vertex shader resource. If the input layout isn't compatible then Direct3D throws an exception.\n\nPer-vertex data has to be stored in compatible types in system memory. DirectXMath data types can help; for example, DXGI\\_FORMAT\\_R32G32B32\\_FLOAT corresponds to [**XMFLOAT3**](https://msdn.microsoft.com/library/windows/desktop/ee419475).\n\n> **Note**   Constant buffers use a fixed input layout that aligns to four floating-point numbers at a time. [**XMFLOAT4**](https://msdn.microsoft.com/library/windows/desktop/ee419608) (and its derivatives) are recommended for constant buffer data.\n\n \n\nSetting the input layout in Direct3D 11\n\n```cpp\n// Create input layout:\nconst D3D11_INPUT_ELEMENT_DESC vertexDesc[] = \n{\n    { \"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT,\n        0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },\n\n    { \"COLOR\",    0, DXGI_FORMAT_R32G32B32_FLOAT, \n        0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },\n};\n```\n\n## Create geometry resources\n\n\nIn Direct3D 9 we stored geometry resources by creating buffers on the Direct3D device, locking the memory, and copying data from CPU memory to GPU memory.\n\nDirect3D 9\n\n```cpp\n// Create vertex buffer:\nVOID* pVertices;\n\n// In Direct3D 9 we create the buffer, lock it, and copy the data from \n// system memory to graphics memory.\nm_pd3dDevice->CreateVertexBuffer(\n    sizeof(CubeVertices),\n    0,\n    D3DFVF_XYZ | D3DFVF_DIFFUSE,\n    D3DPOOL_MANAGED,\n    &pVertexBuffer,\n    NULL);\n\npVertexBuffer->Lock(\n    0,\n    sizeof(CubeVertices),\n    &pVertices,\n    0);\n\nmemcpy(pVertices, CubeVertices, sizeof(CubeVertices));\npVertexBuffer->Unlock();\n```\n\nDirectX 11 follows a simpler process. The API automatically copies the data from system memory to the GPU. We can use COM smart pointers to help make programming easier.\n\nDirectX 11\n\n```cpp\nD3D11_SUBRESOURCE_DATA vertexBufferData = {0};\nvertexBufferData.pSysMem = CubeVertices;\nvertexBufferData.SysMemPitch = 0;\nvertexBufferData.SysMemSlicePitch = 0;\nCD3D11_BUFFER_DESC vertexBufferDesc(\n    sizeof(CubeVertices),\n    D3D11_BIND_VERTEX_BUFFER);\n  \n// This call allocates a device resource for the vertex buffer and copies\n// in the data.\nm_d3dDevice->CreateBuffer(\n    &vertexBufferDesc,\n    &vertexBufferData,\n    &m_vertexBuffer\n    );\n```\n\n## Implement the rendering chain\n\n\nDirect3D 9 games often used an effect-based rendering chain. This type of rendering chain sets up the effect object, provides it with the resources it needs, and lets it render each pass.\n\nDirect3D 9 rendering chain\n\n```cpp\n// Clear the render target and the z-buffer.\nm_pd3dDevice->Clear(\n    0, NULL,\n    D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,\n    D3DCOLOR_ARGB(0, 45, 50, 170),\n    1.0f, 0\n    );\n\n// Set the effect technique\nm_pEffect->SetTechnique(\"RenderSceneSimple\");\n\n// Rotate the cube 1 degree per frame.\nD3DXMATRIX world;\nD3DXMatrixRotationY(&world, D3DXToRadian(m_frameCount++));\n\n\n// Set the matrices up using traditional functions.\nm_pEffect->SetMatrix(\"g_mWorld\", &world);\nm_pEffect->SetMatrix(\"g_View\", &m_view);\nm_pEffect->SetMatrix(\"g_Projection\", &m_projection);\n\n// Render the scene using the Effects library.\nif(SUCCEEDED(m_pd3dDevice->BeginScene()))\n{\n    // Begin rendering effect passes.\n    UINT passes = 0;\n    m_pEffect->Begin(&passes, 0);\n    \n    for (UINT i = 0; i < passes; i++)\n    {\n        m_pEffect->BeginPass(i);\n        \n        // Send vertex data to the pipeline.\n        m_pd3dDevice->SetFVF(D3DFVF_XYZ | D3DFVF_DIFFUSE);\n        m_pd3dDevice->SetStreamSource(\n            0, pVertexBuffer,\n            0, sizeof(VertexPositionColor)\n            );\n        m_pd3dDevice->SetIndices(pIndexBuffer);\n        \n        // Draw the cube.\n        m_pd3dDevice->DrawIndexedPrimitive(\n            D3DPT_TRIANGLELIST,\n            0, 0, 8, 0, 12\n            );\n        m_pEffect->EndPass();\n    }\n    m_pEffect->End();\n    \n    // End drawing.\n    m_pd3dDevice->EndScene();\n}\n\n// Present frame:\n// Show the frame on the primary surface.\nm_pd3dDevice->Present(NULL, NULL, NULL, NULL);\n```\n\nThe DirectX 11 rendering chain will still do the same tasks, but the rendering passes need to be implemented differently. Instead of putting the specifics in FX files and letting the rendering techniques be more-or-less opaque to our C++ code, we'll set up all our rendering in C++.\n\nHere's how our rendering chain will look. We need to supply the input layout we created after loading the vertex shader, supply each of the shader objects, and specify the constant buffers for each shader to use. This example doesn't include multiple rendering passes, but if it did we'd do a similar rendering chain for each pass, changing the setup as needed.\n\nDirect3D 11 rendering chain\n\n```cpp\n// Clear the back buffer.\nconst float midnightBlue[] = { 0.098f, 0.098f, 0.439f, 1.000f };\nm_d3dContext->ClearRenderTargetView(\n    m_renderTargetView.Get(),\n    midnightBlue\n    );\n\n// Set the render target. This starts the drawing operation.\nm_d3dContext->OMSetRenderTargets(\n    1,  // number of render target views for this drawing operation.\n    m_renderTargetView.GetAddressOf(),\n    nullptr\n    );\n\n\n// Rotate the cube 1 degree per frame.\nXMStoreFloat4x4(\n    &m_constantBufferData.model, \n    XMMatrixTranspose(XMMatrixRotationY(m_frameCount++ * XM_PI / 180.f))\n    );\n\n// Copy the updated constant buffer from system memory to video memory.\nm_d3dContext->UpdateSubresource(\n    m_constantBuffer.Get(),\n    0,      // update the 0th subresource\n    NULL,   // use the whole destination\n    &m_constantBufferData,\n    0,      // default pitch\n    0       // default pitch\n    );\n\n\n// Send vertex data to the Input Assembler stage.\nUINT stride = sizeof(VertexPositionColor);\nUINT offset = 0;\n\nm_d3dContext->IASetVertexBuffers(\n    0,  // start with the first vertex buffer\n    1,  // one vertex buffer\n    m_vertexBuffer.GetAddressOf(),\n    &stride,\n    &offset\n    );\n\nm_d3dContext->IASetIndexBuffer(\n    m_indexBuffer.Get(),\n    DXGI_FORMAT_R16_UINT,\n    0   // no offset\n    );\n\nm_d3dContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\nm_d3dContext->IASetInputLayout(m_inputLayout.Get());\n\n\n// Set the vertex shader.\nm_d3dContext->VSSetShader(\n    m_vertexShader.Get(),\n    nullptr,\n    0\n    );\n\n// Set the vertex shader constant buffer data.\nm_d3dContext->VSSetConstantBuffers(\n    0,  // register 0\n    1,  // one constant buffer\n    m_constantBuffer.GetAddressOf()\n    );\n\n\n// Set the pixel shader.\nm_d3dContext->PSSetShader(\n    m_pixelShader.Get(),\n    nullptr,\n    0\n    );\n\n\n// Draw the cube.\nm_d3dContext->DrawIndexed(\n    m_indexCount,\n    0,  // start with index 0\n    0   // start with vertex 0\n    );\n```\n\nThe swap chain is part of graphics infrastructure, so we use our DXGI swap chain to present the completed frame. DXGI blocks the call until the next vsync; then it returns, and our game loop can continue to the next iteration.\n\nPresenting a frame to the screen using DirectX 11\n\n```cpp\nm_swapChain->Present(1, 0);\n```\n\nThe rendering chain we just created will be called from a game loop implemented in the [**IFrameworkView::Run**](https://msdn.microsoft.com/library/windows/apps/hh700505) method. This is shown in [Part 3: Viewport and game loop](simple-port-from-direct3d-9-to-11-1-part-3--viewport-and-game-loop.md).\n\n \n\n \n\n\n\n\n"}