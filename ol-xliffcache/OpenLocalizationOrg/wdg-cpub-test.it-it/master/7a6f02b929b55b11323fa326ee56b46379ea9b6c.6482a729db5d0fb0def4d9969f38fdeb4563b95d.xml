{"nodes":[{"content":"Optimize file access","pos":[2,22]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[24,62]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[63,158],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Create Universal Windows Platform (UWP) apps that access the file system efficiently, avoiding performance issues due to disk latency and memory/CPU cycles.","pos":[160,316]},{"content":"When you want to access a large collection of files and you want to access property values other than the typical Name, FileType, and Path properties, access them by creating <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>QueryOptions<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR207995)</ept> and calling <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>SetPropertyPrefetch<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR207995-setpropertyprefetch)</ept>.","pos":[318,686],"source":"When you want to access a large collection of files and you want to access property values other than the typical Name, FileType, and Path properties, access them by creating [**QueryOptions**](https://msdn.microsoft.com/library/windows/apps/BR207995) and calling [**SetPropertyPrefetch**](https://msdn.microsoft.com/library/windows/apps/BR207995-setpropertyprefetch)."},{"content":"The <bpt id=\"p1\">**</bpt>SetPropertyPrefetch<ept id=\"p1\">**</ept> method can dramatically improve the performance of apps that display a collection of items obtained from the file system, such as a collection of images.","pos":[687,868],"source":" The **SetPropertyPrefetch** method can dramatically improve the performance of apps that display a collection of items obtained from the file system, such as a collection of images."},{"content":"The next set of examples shows a few ways to access multiple files.","pos":[869,936]},{"content":"The first example uses <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.Storage.StorageFolder.GetFilesAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR227273)</ept> to retrieve the name info for a set of files.","pos":[938,1114],"source":"The first example uses [**Windows.Storage.StorageFolder.GetFilesAsync**](https://msdn.microsoft.com/library/windows/apps/BR227273) to retrieve the name info for a set of files."},{"content":"This approach provides good performance, because the example accesses only the name property.","pos":[1115,1208]},{"content":"The second example uses <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.Storage.StorageFolder.GetFilesAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR227273)</ept> and then retrieves the image properties for each file.","pos":[1928,2114],"source":"The second example uses [**Windows.Storage.StorageFolder.GetFilesAsync**](https://msdn.microsoft.com/library/windows/apps/BR227273) and then retrieves the image properties for each file."},{"content":"This approach provides poor performance.","pos":[2115,2155]},{"content":"The third example uses <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>QueryOptions<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR207995)</ept> to get info about a set of files.","pos":[3091,3224],"source":"The third example uses [**QueryOptions**](https://msdn.microsoft.com/library/windows/apps/BR207995) to get info about a set of files."},{"content":"This approach provides much better performance than the previous example.","pos":[3225,3298]},{"pos":[5678,5938],"content":"If you're performing multiple operations on Windows.Storage objects such as <ph id=\"ph1\">`Windows.Storage.ApplicationData.Current.LocalFolder`</ph>, create a local variable to reference that storage source so that you don't recreate intermediate objects each time you access it.","source":"If you're performing multiple operations on Windows.Storage objects such as `Windows.Storage.ApplicationData.Current.LocalFolder`, create a local variable to reference that storage source so that you don't recreate intermediate objects each time you access it."},{"content":"Stream performance in C\\# and Visual Basic","pos":[5943,5985]},{"content":"Buffering between UWP and .NET streams","pos":[5991,6029]},{"content":"There are many scenarios when you might want to convert a UWP stream (such as a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.Storage.Streams.IInputStream<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR241718)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>IOutputStream<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR241728)</ept>) to a .NET stream (<bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>System.IO.Stream<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.aspx)</ept>).","pos":[6031,6418],"source":"There are many scenarios when you might want to convert a UWP stream (such as a [**Windows.Storage.Streams.IInputStream**](https://msdn.microsoft.com/library/windows/apps/BR241718) or [**IOutputStream**](https://msdn.microsoft.com/library/windows/apps/BR241728)) to a .NET stream ([**System.IO.Stream**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.aspx))."},{"content":"For example, this is useful when you are writing a UWP app and want to use existing .NET code that works on streams with the UWP file system.","pos":[6419,6560]},{"content":"In order to enable this, .NET APIs for Windows Store apps provides extension methods that allow you to convert between .NET and UWP stream types.","pos":[6561,6706]},{"content":"For more info, see <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>WindowsRuntimeStreamExtensions<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.windowsruntimestreamextensions.aspx)</ept>.","pos":[6707,6869],"source":" For more info, see [**WindowsRuntimeStreamExtensions**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.windowsruntimestreamextensions.aspx)."},{"content":"When you convert a UWP stream to a .NET stream, you effectively create an adapter for the underlying UWP stream.","pos":[6871,6983]},{"content":"Under some circumstances, there is a runtime cost associated with invoking methods on UWP streams.","pos":[6984,7082]},{"content":"This may affect the speed of your app, especially in scenarios where you perform many small, frequent read or write operations.","pos":[7083,7210]},{"content":"In order to speed up apps, the UWP stream adapters contain a data buffer.","pos":[7212,7285]},{"content":"The following code sample demonstrates small consecutive reads using a UWP stream adapter with a default buffer size.","pos":[7286,7403]},{"content":"This default buffering behavior is desirable in most scenarios where you convert a UWP stream to a .NET stream.","pos":[9256,9367]},{"content":"However, in some scenarios you may want to tweak the buffering behavior in order to increase performance.","pos":[9368,9473]},{"content":"Working with large data sets","pos":[9479,9507]},{"content":"When reading or writing larger sets of data you may be able to increase your read or write throughput by providing a large buffer size to the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>AsStreamForRead<ept id=\"p2\">**</ept><ept id=\"p1\">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>AsStreamForWrite<ept id=\"p4\">**</ept><ept id=\"p3\">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite)</ept>, and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>AsStream<ept id=\"p6\">**</ept><ept id=\"p5\">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStream)</ept> extension methods.","pos":[9509,9930],"source":"When reading or writing larger sets of data you may be able to increase your read or write throughput by providing a large buffer size to the [**AsStreamForRead**](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead), [**AsStreamForWrite**](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite), and [**AsStream**](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStream) extension methods."},{"content":"This gives the stream adapter a larger internal buffer size.","pos":[9931,9991]},{"content":"For instance, when passing a stream that comes from a large file to an XML parser, the parser can make many sequential small reads from the stream.","pos":[9992,10139]},{"content":"A large buffer can reduce the number of calls to the underlying UWP stream and boost performance.","pos":[10140,10237]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   You should be careful when setting a buffer size that is larger than approximately 80 KB, as this may cause fragmentation on the garbage collector heap (see <bpt id=\"p2\">[</bpt>Improve garbage collection performance<ept id=\"p2\">](improve-garbage-collection-performance.md)</ept>).","pos":[10239,10492],"source":"**Note**   You should be careful when setting a buffer size that is larger than approximately 80 KB, as this may cause fragmentation on the garbage collector heap (see [Improve garbage collection performance](improve-garbage-collection-performance.md))."},{"content":"The following code example creates a managed stream adapter with an 81,920 byte buffer.","pos":[10493,10580]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Stream.CopyTo<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.copyto.aspx)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>CopyToAsync<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.copytoasync.aspx)</ept> methods also allocate a local buffer for copying between streams.","pos":[10893,11187],"source":"The [**Stream.CopyTo**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.copyto.aspx) and [**CopyToAsync**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.copytoasync.aspx) methods also allocate a local buffer for copying between streams."},{"content":"As with the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>AsStreamForRead<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.windowsruntimestreamextensions.asstreamforread.aspx)</ept> extension method, you may be able to get better performance for large stream copies by overriding the default buffer size.","pos":[11188,11466],"source":" As with the [**AsStreamForRead**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.windowsruntimestreamextensions.asstreamforread.aspx) extension method, you may be able to get better performance for large stream copies by overriding the default buffer size."},{"content":"The following code example demonstrates changing the default buffer size of a <bpt id=\"p1\">**</bpt>CopyToAsync<ept id=\"p1\">**</ept> call.","pos":[11467,11566],"source":" The following code example demonstrates changing the default buffer size of a **CopyToAsync** call."},{"content":"This example uses a buffer size of 1 MB, which is greater than the 80 KB previously recommended.","pos":[12204,12300]},{"content":"Using such a large buffer can improve throughput of the copy operation for very large data sets (that is, several hundred megabytes).","pos":[12301,12434]},{"content":"However, this buffer is allocated on the large object heap and could potentially degrade garbage collection performance.","pos":[12435,12555]},{"content":"You should only use large buffer sizes if it will noticeably improve the performance of your app.","pos":[12556,12653]},{"content":"When you are working with a large number of streams simultaneously, you might want to reduce or eliminate the memory overhead of the buffer.","pos":[12655,12795]},{"content":"You can specify a smaller buffer, or set the <bpt id=\"p1\">*</bpt>bufferSize<ept id=\"p1\">*</ept> parameter to 0 to turn off buffering entirely for that stream adapter.","pos":[12796,12924],"source":" You can specify a smaller buffer, or set the *bufferSize* parameter to 0 to turn off buffering entirely for that stream adapter."},{"content":"You can still achieve good throughput performance without buffering if you perform large reads and writes to the managed stream.","pos":[12925,13053]},{"content":"Performing latency-sensitive operations","pos":[13059,13098]},{"content":"You might also want to avoid buffering if you want low-latency reads and writes and do not want to read in large blocks out of the underlying UWP stream.","pos":[13100,13253]},{"content":"For example, you might want low-latency reads and writes if you are using the stream for network communications.","pos":[13254,13366]},{"content":"In a chat app you might use a stream over a network interface to send messages back in forth.","pos":[13368,13461]},{"content":"In this case you want to send messages as soon as they are ready and not wait for the buffer to fill up.","pos":[13462,13566]},{"content":"If you set the buffer size to 0 when calling the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>AsStreamForRead<ept id=\"p2\">**</ept><ept id=\"p1\">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>AsStreamForWrite<ept id=\"p4\">**</ept><ept id=\"p3\">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite)</ept>, and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>AsStream<ept id=\"p6\">**</ept><ept id=\"p5\">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStream)</ept> extension methods, then the resulting adapter will not allocate a buffer, and all calls will manipulate the underlying UWP stream directly.","pos":[13567,14016],"source":" If you set the buffer size to 0 when calling the [**AsStreamForRead**](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead), [**AsStreamForWrite**](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite), and [**AsStream**](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStream) extension methods, then the resulting adapter will not allocate a buffer, and all calls will manipulate the underlying UWP stream directly."}],"content":"# Optimize file access\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nCreate Universal Windows Platform (UWP) apps that access the file system efficiently, avoiding performance issues due to disk latency and memory/CPU cycles.\n\nWhen you want to access a large collection of files and you want to access property values other than the typical Name, FileType, and Path properties, access them by creating [**QueryOptions**](https://msdn.microsoft.com/library/windows/apps/BR207995) and calling [**SetPropertyPrefetch**](https://msdn.microsoft.com/library/windows/apps/BR207995-setpropertyprefetch). The **SetPropertyPrefetch** method can dramatically improve the performance of apps that display a collection of items obtained from the file system, such as a collection of images. The next set of examples shows a few ways to access multiple files.\n\nThe first example uses [**Windows.Storage.StorageFolder.GetFilesAsync**](https://msdn.microsoft.com/library/windows/apps/BR227273) to retrieve the name info for a set of files. This approach provides good performance, because the example accesses only the name property.\n\n> [!div class=\"tabbedCodeSnippets\"]\n```csharp\nStorageFolder library = Windows.Storage.KnownFolders.PicturesLibrary;\nIReadOnlyList<StorageFile> files = await library.GetFilesAsync(Windows.Storage.Search.CommonFileQuery.OrderByDate);\nfor (int i = 0; i < files.Count; i++)\n{\n    // do something with the name of each file\n    string fileName = files[i].Name;\n}\n```\n```vbnet\nDim library As StorageFolder = Windows.Storage.KnownFolders.PicturesLibrary\nDim files As IReadOnlyList(Of StorageFile) =\n    Await library.GetFilesAsync(Windows.Storage.Search.CommonFileQuery.OrderByDate)\n\nFor i As Integer = 0 To files.Count - 1\n    ' do something with the name of each file\n    Dim fileName As String = files(i).Name\nNext i\n```\n\nThe second example uses [**Windows.Storage.StorageFolder.GetFilesAsync**](https://msdn.microsoft.com/library/windows/apps/BR227273) and then retrieves the image properties for each file. This approach provides poor performance.\n\n> [!div class=\"tabbedCodeSnippets\"]\n```csharp\nStorageFolder library = Windows.Storage.KnownFolders.PicturesLibrary;\nIReadOnlyList<StorageFile> files = await library.GetFilesAsync(Windows.Storage.Search.CommonFileQuery.OrderByDate);\nfor (int i = 0; i < files.Count; i++)\n{\n    ImageProperties imgProps = await files[i].Properties.GetImagePropertiesAsync();\n\n    // do something with the date the image was taken\n    DateTimeOffset date = imgProps.DateTaken;\n}\n```\n```vbnet\nDim library As StorageFolder = Windows.Storage.KnownFolders.PicturesLibrary\nDim files As IReadOnlyList(Of StorageFile) = Await library.GetFilesAsync(Windows.Storage.Search.CommonFileQuery.OrderByDate)\nFor i As Integer = 0 To files.Count - 1\n    Dim imgProps As ImageProperties =\n        Await files(i).Properties.GetImagePropertiesAsync()\n\n    ' do something with the date the image was taken\n    Dim dateTaken As DateTimeOffset = imgProps.DateTaken\nNext i\n```\n\nThe third example uses [**QueryOptions**](https://msdn.microsoft.com/library/windows/apps/BR207995) to get info about a set of files. This approach provides much better performance than the previous example.\n\n> [!div class=\"tabbedCodeSnippets\"]\n```csharp\n// Set QueryOptions to prefetch our specific properties\nvar queryOptions = new Windows.Storage.Search.QueryOptions(CommonFileQuery.OrderByDate, null);\nqueryOptions.SetThumbnailPrefetch(ThumbnailMode.PicturesView, 100,\n        ThumbnailOptions.ReturnOnlyIfCached);\nqueryOptions.SetPropertyPrefetch(PropertyPrefetchOptions.ImageProperties, \n       new string[] {\"System.Size\"});\n\nStorageFileQueryResult queryResults = KnownFolders.PicturesLibrary.CreateFileQueryWithOptions(queryOptions);\nIReadOnlyList<StorageFile> files = await queryResults.GetFilesAsync();\n\nforeach (var file in files)\n{\n    ImageProperties imageProperties = await file.Properties.GetImagePropertiesAsync();\n\n    // Do something with the date the image was taken.\n    DateTimeOffset dateTaken = imageProperties.DateTaken;\n\n    // Performance gains increase with the number of properties that are accessed.\n    IDictionary<String, object> propertyResults =\n        await file.Properties.RetrievePropertiesAsync(\n              new string[] {\"System.Size\" });\n\n    // Get/Set extra properties here\n    var systemSize = propertyResults[\"System.Size\"];\n\n}\n```\n```vbnet\n' Set QueryOptions to prefetch our specific properties\nDim queryOptions = New Windows.Storage.Search.QueryOptions(CommonFileQuery.OrderByDate, Nothing)\nqueryOptions.SetThumbnailPrefetch(ThumbnailMode.PicturesView,\n            100, Windows.Storage.FileProperties.ThumbnailOptions.ReturnOnlyIfCached)\nqueryOptions.SetPropertyPrefetch(PropertyPrefetchOptions.ImageProperties,\n                                 New String() {\"System.Size\"})\n\nDim queryResults As StorageFileQueryResult = KnownFolders.PicturesLibrary.CreateFileQueryWithOptions(queryOptions)\nDim files As IReadOnlyList(Of StorageFile) = Await queryResults.GetFilesAsync()\n\n\nFor Each file In files\n    Dim imageProperties As ImageProperties = Await file.Properties.GetImagePropertiesAsync()\n\n    ' Do something with the date the image was taken.\n    Dim dateTaken As DateTimeOffset = imageProperties.DateTaken\n\n    ' Performance gains increase with the number of properties that are accessed.\n    Dim propertyResults As IDictionary(Of String, Object) =\n        Await file.Properties.RetrievePropertiesAsync(New String() {\"System.Size\"})\n\n    ' Get/Set extra properties here\n    Dim systemSize = propertyResults(\"System.Size\")\n\nNext file\n```\nIf you're performing multiple operations on Windows.Storage objects such as `Windows.Storage.ApplicationData.Current.LocalFolder`, create a local variable to reference that storage source so that you don't recreate intermediate objects each time you access it.\n\n## Stream performance in C\\# and Visual Basic\n\n### Buffering between UWP and .NET streams\n\nThere are many scenarios when you might want to convert a UWP stream (such as a [**Windows.Storage.Streams.IInputStream**](https://msdn.microsoft.com/library/windows/apps/BR241718) or [**IOutputStream**](https://msdn.microsoft.com/library/windows/apps/BR241728)) to a .NET stream ([**System.IO.Stream**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.aspx)). For example, this is useful when you are writing a UWP app and want to use existing .NET code that works on streams with the UWP file system. In order to enable this, .NET APIs for Windows Store apps provides extension methods that allow you to convert between .NET and UWP stream types. For more info, see [**WindowsRuntimeStreamExtensions**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.windowsruntimestreamextensions.aspx).\n\nWhen you convert a UWP stream to a .NET stream, you effectively create an adapter for the underlying UWP stream. Under some circumstances, there is a runtime cost associated with invoking methods on UWP streams. This may affect the speed of your app, especially in scenarios where you perform many small, frequent read or write operations.\n\nIn order to speed up apps, the UWP stream adapters contain a data buffer. The following code sample demonstrates small consecutive reads using a UWP stream adapter with a default buffer size.\n\n> [!div class=\"tabbedCodeSnippets\"]\n```csharp\nStorageFile file = await Windows.Storage.ApplicationData.Current\n    .LocalFolder.GetFileAsync(\"example.txt\");\nWindows.Storage.Streams.IInputStream windowsRuntimeStream = \n    await file.OpenReadAsync();\n\nbyte[] destinationArray = new byte[8];\n\n// Create an adapter with the default buffer size.\nusing (var managedStream = windowsRuntimeStream.AsStreamForRead())\n{\n\n    // Read 8 bytes into destinationArray.\n    // A larger block is actually read from the underlying \n    // windowsRuntimeStream and buffered within the adapter.\n    await managedStream.ReadAsync(destinationArray, 0, 8);\n\n    // Read 8 more bytes into destinationArray.\n    // This call may complete much faster than the first call\n    // because the data is buffered and no call to the \n    // underlying windowsRuntimeStream needs to be made.\n    await managedStream.ReadAsync(destinationArray, 0, 8);\n}\n```\n```vbnet\nDim file As StorageFile = Await Windows.Storage.ApplicationData.Current -\n.LocalFolder.GetFileAsync(\"example.txt\")\nDim windowsRuntimeStream As Windows.Storage.Streams.IInputStream =\n    Await file.OpenReadAsync()\n\nDim destinationArray() As Byte = New Byte(8) {}\n\n' Create an adapter with the default buffer size.\nDim managedStream As Stream = windowsRuntimeStream.AsStreamForRead()\nUsing (managedStream)\n\n    ' Read 8 bytes into destinationArray.\n    ' A larger block is actually read from the underlying \n    ' windowsRuntimeStream and buffered within the adapter.\n    Await managedStream.ReadAsync(destinationArray, 0, 8)\n\n    ' Read 8 more bytes into destinationArray.\n    ' This call may complete much faster than the first call\n    ' because the data is buffered and no call to the \n    ' underlying windowsRuntimeStream needs to be made.\n    Await managedStream.ReadAsync(destinationArray, 0, 8)\n\nEnd Using\n```\n\nThis default buffering behavior is desirable in most scenarios where you convert a UWP stream to a .NET stream. However, in some scenarios you may want to tweak the buffering behavior in order to increase performance.\n\n### Working with large data sets\n\nWhen reading or writing larger sets of data you may be able to increase your read or write throughput by providing a large buffer size to the [**AsStreamForRead**](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead), [**AsStreamForWrite**](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite), and [**AsStream**](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStream) extension methods. This gives the stream adapter a larger internal buffer size. For instance, when passing a stream that comes from a large file to an XML parser, the parser can make many sequential small reads from the stream. A large buffer can reduce the number of calls to the underlying UWP stream and boost performance.\n\n**Note**   You should be careful when setting a buffer size that is larger than approximately 80 KB, as this may cause fragmentation on the garbage collector heap (see [Improve garbage collection performance](improve-garbage-collection-performance.md)). The following code example creates a managed stream adapter with an 81,920 byte buffer.\n\n> [!div class=\"tabbedCodeSnippets\"]\n```csharp\n// Create a stream adapter with an 80 KB buffer.\nStream managedStream = nativeStream.AsStreamForRead(bufferSize: 81920);\n```\n```vbnet\n' Create a stream adapter with an 80 KB buffer.\nDim managedStream As Stream = nativeStream.AsStreamForRead(bufferSize:=81920)\n```\n\nThe [**Stream.CopyTo**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.copyto.aspx) and [**CopyToAsync**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.copytoasync.aspx) methods also allocate a local buffer for copying between streams. As with the [**AsStreamForRead**](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.windowsruntimestreamextensions.asstreamforread.aspx) extension method, you may be able to get better performance for large stream copies by overriding the default buffer size. The following code example demonstrates changing the default buffer size of a **CopyToAsync** call.\n\n> [!div class=\"tabbedCodeSnippets\"]\n```csharp\nMemoryStream destination = new MemoryStream();\n// copies the buffer into memory using the default copy buffer\nawait managedStream.CopyToAsync(destination);\n\n// Copy the buffer into memory using a 1 MB copy buffer.\nawait managedStream.CopyToAsync(destination, bufferSize: 1024 * 1024);\n```\n```vbnet\nDim destination As MemoryStream = New MemoryStream()\n' copies the buffer into memory using the default copy buffer\nAwait managedStream.CopyToAsync(destination)\n\n' Copy the buffer into memory using a 1 MB copy buffer.\nAwait managedStream.CopyToAsync(destination, bufferSize:=1024 * 1024)\n```\n\nThis example uses a buffer size of 1 MB, which is greater than the 80 KB previously recommended. Using such a large buffer can improve throughput of the copy operation for very large data sets (that is, several hundred megabytes). However, this buffer is allocated on the large object heap and could potentially degrade garbage collection performance. You should only use large buffer sizes if it will noticeably improve the performance of your app.\n\nWhen you are working with a large number of streams simultaneously, you might want to reduce or eliminate the memory overhead of the buffer. You can specify a smaller buffer, or set the *bufferSize* parameter to 0 to turn off buffering entirely for that stream adapter. You can still achieve good throughput performance without buffering if you perform large reads and writes to the managed stream.\n\n### Performing latency-sensitive operations\n\nYou might also want to avoid buffering if you want low-latency reads and writes and do not want to read in large blocks out of the underlying UWP stream. For example, you might want low-latency reads and writes if you are using the stream for network communications.\n\nIn a chat app you might use a stream over a network interface to send messages back in forth. In this case you want to send messages as soon as they are ready and not wait for the buffer to fill up. If you set the buffer size to 0 when calling the [**AsStreamForRead**](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead), [**AsStreamForWrite**](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite), and [**AsStream**](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStream) extension methods, then the resulting adapter will not allocate a buffer, and all calls will manipulate the underlying UWP stream directly.\n\n"}