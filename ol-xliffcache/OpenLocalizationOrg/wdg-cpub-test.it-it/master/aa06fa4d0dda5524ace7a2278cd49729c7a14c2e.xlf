<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="it-it" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-00ddeee</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">aa06fa4d0dda5524ace7a2278cd49729c7a14c2e</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci1\graphics\composition-native-interop.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">0642abf198b46b93147a88d01af75aaea8f08175</mda:meta><mda:meta type="olxliffhash">b346ee3166a60227fda9e5e68d0db52251799442</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Composition native DirectX and Direct2D interoperation with BeginDraw and EndDraw</source>
					<target>Composition native DirectX and Direct2D interoperation with BeginDraw and EndDraw</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>The Windows.UI.Composition API provides native interoperation interfaces allowing content to be moved directly into the compositor.</source>
					<target>The Windows.UI.Composition API provides native interoperation interfaces allowing content to be moved directly into the compositor.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Composition native DirectX and Direct2D interoperation with BeginDraw and EndDraw</source>
					<target>Composition native DirectX and Direct2D interoperation with BeginDraw and EndDraw</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt620068)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/Mt620058)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/Mt620065)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>The Windows.UI.Composition API provides the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ICompositorInterop</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ICompositionDrawingSurfaceInterop</pc></pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ICompositionGraphicsDeviceInterop</pc></pc> native interoperation interfaces allowing content to be moved directly into the compositor.</source>
					<target>The Windows.UI.Composition API provides the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ICompositorInterop</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ICompositionDrawingSurfaceInterop</pc></pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ICompositionGraphicsDeviceInterop</pc></pc> native interoperation interfaces allowing content to be moved directly into the compositor.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Native interoperation is structured around surface objects that are backed by DirectX textures.</source>
					<target>Native interoperation is structured around surface objects that are backed by DirectX textures.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn706749)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The surfaces are created from a factory object called <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionGraphicsDevice</pc></pc>.</source>
					<target>The surfaces are created from a factory object called <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionGraphicsDevice</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>This object is backed by an underlying Direct2D or Direct3D device object, which it uses to allocate video memory for surfaces.</source>
					<target>This object is backed by an underlying Direct2D or Direct3D device object, which it uses to allocate video memory for surfaces.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>The composition API never creates the underlying DirectX device.</source>
					<target>The composition API never creates the underlying DirectX device.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>It is the responsibility of the application to create one and pass it to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CompositionGraphicsDevice</pc> object.</source>
					<target>It is the responsibility of the application to create one and pass it to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CompositionGraphicsDevice</pc> object.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>An application may create more than one <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CompositionGraphicsDevice</pc> object at a time, and it may use the same DirectX device as the rendering device for multiple <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionGraphicsDevice</pc> objects.</source>
					<target>An application may create more than one <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CompositionGraphicsDevice</pc> object at a time, and it may use the same DirectX device as the rendering device for multiple <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionGraphicsDevice</pc> objects.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Creating a surface</source>
					<target>Creating a surface</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn706749)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Each <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionGraphicsDevice</pc></pc> serves as a surface factory.</source>
					<target>Each <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionGraphicsDevice</pc></pc> serves as a surface factory.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>Each surface is created with an initial size (which may be 0,0), but no valid pixels.</source>
					<target>Each surface is created with an initial size (which may be 0,0), but no valid pixels.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt589415)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/Mt589433)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>A surface in its initial state may be immediately consumed in a visual tree, for example, via a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionSurfaceBrush</pc></pc> and a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SpriteVisual</pc></pc>, but in its initial state the surface has no effect on screen output.</source>
					<target>A surface in its initial state may be immediately consumed in a visual tree, for example, via a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionSurfaceBrush</pc></pc> and a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SpriteVisual</pc></pc>, but in its initial state the surface has no effect on screen output.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>It is, for all purposes, entirely transparent, even if the specified alpha mode is “opaque”.</source>
					<target>It is, for all purposes, entirely transparent, even if the specified alpha mode is “opaque”.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Occasionally, DirectX devices may be rendered unusable.</source>
					<target>Occasionally, DirectX devices may be rendered unusable.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>This may happen, amongst other reasons, if the application passes invalid arguments to certain DirectX APIs, or if the graphics adapter is reset by the system, or if the driver is updated.</source>
					<target>This may happen, amongst other reasons, if the application passes invalid arguments to certain DirectX APIs, or if the graphics adapter is reset by the system, or if the driver is updated.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Direct3D has an API that an application may use to discover, asynchronously, if the device is lost for any reason.</source>
					<target>Direct3D has an API that an application may use to discover, asynchronously, if the device is lost for any reason.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn706749)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When a DirectX device is lost, the application must discard it, create a new one, and pass it to any <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionGraphicsDevice</pc></pc> objects previously associated with the bad DirectX device.</source>
					<target>When a DirectX device is lost, the application must discard it, create a new one, and pass it to any <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionGraphicsDevice</pc></pc> objects previously associated with the bad DirectX device.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>Loading pixels into a surface</source>
					<target>Loading pixels into a surface</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/mt620059.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To load pixels into the surface, the application must call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BeginDraw</pc></pc> method, which returns a DirectX interface representing a texture or Direct2D context, depending on what the application requests.</source>
					<target>To load pixels into the surface, the application must call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BeginDraw</pc></pc> method, which returns a DirectX interface representing a texture or Direct2D context, depending on what the application requests.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>The application must then render or upload pixels into that texture.</source>
					<target>The application must then render or upload pixels into that texture.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt620060)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When the application is done, it must call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">EndDraw</pc></pc> method.</source>
					<target>When the application is done, it must call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">EndDraw</pc></pc> method.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Only at that point are the new pixels available for composition, but they still don't show up on screen until the next time all changes to the visual tree are committed.</source>
					<target>Only at that point are the new pixels available for composition, but they still don't show up on screen until the next time all changes to the visual tree are committed.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If the visual tree is committed before <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EndDraw</pc> is called, then the update that is in progress is not visible on screen and the surface continues to display the contents it had prior to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">BeginDraw</pc>.</source>
					<target>If the visual tree is committed before <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EndDraw</pc> is called, then the update that is in progress is not visible on screen and the surface continues to display the contents it had prior to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">BeginDraw</pc>.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EndDraw</pc> is called, the texture or Direct2D context pointer returned by BeginDraw is invalidated.</source>
					<target>When <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EndDraw</pc> is called, the texture or Direct2D context pointer returned by BeginDraw is invalidated.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>An application should never cache that pointer beyond the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EndDraw</pc> call.</source>
					<target>An application should never cache that pointer beyond the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EndDraw</pc> call.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn706749)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The application may only call BeginDraw on one surface at a time, for any given <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionGraphicsDevice</pc></pc>.</source>
					<target>The application may only call BeginDraw on one surface at a time, for any given <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionGraphicsDevice</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/mt620059.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/mt620060)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>After calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BeginDraw</pc></pc>, the application must call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">EndDraw</pc></pc> on that surface before calling <pc dataRefEnd="id10" dataRefStart="id9" id="p5">BeginDraw</pc> on another.</source>
					<target>After calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BeginDraw</pc></pc>, the application must call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">EndDraw</pc></pc> on that surface before calling <pc dataRefEnd="id10" dataRefStart="id9" id="p5">BeginDraw</pc> on another.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>As the API is agile, the application is responsible for synchronizing these calls if it wishes to perform rendering from multiple worker threads.</source>
					<target>As the API is agile, the application is responsible for synchronizing these calls if it wishes to perform rendering from multiple worker threads.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/mt620064.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If an application wants to interrupt rendering one surface and switch to another temporarily, the application may use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SuspendDraw</pc></pc> method.</source>
					<target>If an application wants to interrupt rendering one surface and switch to another temporarily, the application may use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SuspendDraw</pc></pc> method.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This allows another <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BeginDraw</pc> to succeed, but does not make the first surface update available for on-screen composition.</source>
					<target>This allows another <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BeginDraw</pc> to succeed, but does not make the first surface update available for on-screen composition.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>This allows the application to perform multiple updates in a transactional manner.</source>
					<target>This allows the application to perform multiple updates in a transactional manner.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt620062)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Once a surface is suspended, the application may continue the update by calling the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResumeDraw</pc></pc> method, or it may declare that the update is done by calling <pc dataRefEnd="id6" dataRefStart="id5" id="p3">EndDraw</pc>.</source>
					<target>Once a surface is suspended, the application may continue the update by calling the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResumeDraw</pc></pc> method, or it may declare that the update is done by calling <pc dataRefEnd="id6" dataRefStart="id5" id="p3">EndDraw</pc>.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This means only one surface can be actively updated at a time for any given <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CompositionGraphicsDevice</pc>.</source>
					<target>This means only one surface can be actively updated at a time for any given <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CompositionGraphicsDevice</pc>.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Each graphics device keeps this state independently of the others, so an application may render to two surfaces simultaneously if they belong to different graphics devices.</source>
					<target>Each graphics device keeps this state independently of the others, so an application may render to two surfaces simultaneously if they belong to different graphics devices.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>However, this precludes the video memory for those two surfaces from being pooled together and, as such, is less memory efficient.</source>
					<target>However, this precludes the video memory for those two surfaces from being pooled together and, as such, is less memory efficient.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/mt620059.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/en-us/library/windows/apps/mt620064.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/mt620062)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/mt620060)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
					<data id="id17">**</data>
					<data id="id18">**</data>
					<data id="id19">**</data>
					<data id="id20">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BeginDraw</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SuspendDraw</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ResumeDraw</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">EndDraw</pc></pc> methods return failures if the application performs an incorrect operation (such as passing invalid arguments, or calling <pc dataRefEnd="id18" dataRefStart="id17" id="p9">BeginDraw</pc> on a surface before calling <pc dataRefEnd="id20" dataRefStart="id19" id="p10">EndDraw</pc> on another).</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BeginDraw</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SuspendDraw</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ResumeDraw</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">EndDraw</pc></pc> methods return failures if the application performs an incorrect operation (such as passing invalid arguments, or calling <pc dataRefEnd="id18" dataRefStart="id17" id="p9">BeginDraw</pc> on a surface before calling <pc dataRefEnd="id20" dataRefStart="id19" id="p10">EndDraw</pc> on another).</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>These types of failures represent application bugs and, as such, the expectation is that they are handled with a fail fast.</source>
					<target>These types of failures represent application bugs and, as such, the expectation is that they are handled with a fail fast.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">BeginDraw</pc> may also return a failure if the underlying DirectX device is lost.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">BeginDraw</pc> may also return a failure if the underlying DirectX device is lost.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>This failure is not fatal as the application can recreate its DirectX device and try again.</source>
					<target>This failure is not fatal as the application can recreate its DirectX device and try again.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>As such, the application is expected to handle device loss by simply skipping rendering.</source>
					<target>As such, the application is expected to handle device loss by simply skipping rendering.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BeginDraw</pc> fails for any reason, the application should also not call <pc dataRefEnd="id4" dataRefStart="id3" id="p2">EndDraw</pc>, as the begin never succeeded in the first place.</source>
					<target>If <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BeginDraw</pc> fails for any reason, the application should also not call <pc dataRefEnd="id4" dataRefStart="id3" id="p2">EndDraw</pc>, as the begin never succeeded in the first place.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>Scrolling</source>
					<target>Scrolling</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/mt620059.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For performance reasons, when an application calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BeginDraw</pc></pc> the contents of the returned texture are not guaranteed to be the previous contents of the surface.</source>
					<target>For performance reasons, when an application calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BeginDraw</pc></pc> the contents of the returned texture are not guaranteed to be the previous contents of the surface.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>The application must assume that the contents are random and, as such, the application must ensure that all pixels are touched, either by clearing the surface before rendering or by drawing enough opaque contents to cover the entire updated rectangle.</source>
					<target>The application must assume that the contents are random and, as such, the application must ensure that all pixels are touched, either by clearing the surface before rendering or by drawing enough opaque contents to cover the entire updated rectangle.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/mt620060)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>This, combined with the fact that the texture pointer is only valid between <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BeginDraw</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">EndDraw</pc></pc> calls, makes it impossible for the application to copy previous contents out of the surface.</source>
					<target>This, combined with the fact that the texture pointer is only valid between <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BeginDraw</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">EndDraw</pc></pc> calls, makes it impossible for the application to copy previous contents out of the surface.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt620063)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For this reason, we offer a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Scroll</pc></pc> method, which allows the application to perform a same-surface pixel copy.</source>
					<target>For this reason, we offer a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Scroll</pc></pc> method, which allows the application to perform a same-surface pixel copy.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Usage Example</source>
					<target>Usage Example</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/mt620059.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/mt620060)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The following sample illustrates a very simple scenario where an application creates drawing surfaces, and uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BeginDraw</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">EndDraw</pc></pc> to populate the surfaces with text.</source>
					<target>The following sample illustrates a very simple scenario where an application creates drawing surfaces, and uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BeginDraw</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">EndDraw</pc></pc> to populate the surfaces with text.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>The application uses DirectWrite to layout the text (details not shown) and then uses Direct2D to render it.</source>
					<target>The application uses DirectWrite to layout the text (details not shown) and then uses Direct2D to render it.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>The composition graphics device accepts the Direct2D device directly at initialization time.</source>
					<target>The composition graphics device accepts the Direct2D device directly at initialization time.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This allows <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BeginDraw</pc> to return an ID2D1DeviceContext interface pointer, which is considerably more efficient than having the application create a Direct2D context to wrap a returned ID3D11Texture2D interface at each drawing operation.</source>
					<target>This allows <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BeginDraw</pc> to return an ID2D1DeviceContext interface pointer, which is considerably more efficient than having the application create a Direct2D context to wrap a returned ID3D11Texture2D interface at each drawing operation.</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>