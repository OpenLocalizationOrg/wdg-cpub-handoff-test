{"nodes":[{"pos":[11,52],"content":"Render the shadow map to the depth buffer","needQuote":true,"needEscape":true,"nodes":[{"content":"Render the shadow map to the depth buffer","pos":[0,41]}]},{"pos":[66,178],"content":"Render from the point of view of the light to create a two-dimensional depth map representing the shadow volume.","needQuote":true,"needEscape":true,"nodes":[{"content":"Render from the point of view of the light to create a two-dimensional depth map representing the shadow volume.","pos":[0,112]}]},{"content":"Render the shadow map to the depth buffer","pos":[235,276]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[279,317]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[318,413],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Render from the point of view of the light to create a two-dimensional depth map representing the shadow volume.","pos":[416,528]},{"content":"The depth map masks the space that will be rendered in shadow.","pos":[529,591]},{"content":"Part 2 of <bpt id=\"p1\">[</bpt>Walkthrough: Implement shadow volumes using depth buffers in Direct3D 11<ept id=\"p1\">](implementing-depth-buffers-for-shadow-mapping.md)</ept>.","pos":[592,727],"source":" Part 2 of [Walkthrough: Implement shadow volumes using depth buffers in Direct3D 11](implementing-depth-buffers-for-shadow-mapping.md)."},{"content":"Clear the depth buffer","pos":[732,754]},{"content":"Always clear the depth buffer before rendering to it.","pos":[757,810]},{"content":"Render the shadow map to the depth buffer","pos":[1051,1092]},{"content":"For the shadow rendering pass, specify a depth buffer but do not specify a render target.","pos":[1095,1184]},{"content":"Specify the light viewport, a vertex shader, and set the light space constant buffers.","pos":[1186,1272]},{"content":"Use front face culling for this pass to optimize the depth values placed in the shadow buffer.","pos":[1273,1367]},{"content":"Note that on most devices, you can specify nullptr for the pixel shader (or skip specifying a pixel shader entirely).","pos":[1369,1486]},{"content":"But some drivers may throw an exception when you call draw on the Direct3D device with a null pixel shader set.","pos":[1487,1598]},{"content":"To avoid this exception, you can set a minimal pixel shader for the shadow rendering pass.","pos":[1599,1689]},{"content":"The output of this shader is thrown away; it can call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>discard<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb943995)</ept> on every pixel.","pos":[1690,1834],"source":" The output of this shader is thrown away; it can call [**discard**](https://msdn.microsoft.com/library/windows/desktop/bb943995) on every pixel."},{"content":"Render the objects that can cast shadows, but don't bother rendering geometry that can't cast a shadow (like a floor in a room, or objects removed from the shadow pass for optimization reasons).","pos":[1836,2030]},{"content":"<bpt id=\"p1\">**</bpt>Optimize the view frustum:<ept id=\"p1\">**</ept>  Make sure your implementation computes a tight view frustum so that you get the most precision out of your depth buffer.","pos":[4348,4500],"source":"**Optimize the view frustum:**  Make sure your implementation computes a tight view frustum so that you get the most precision out of your depth buffer."},{"content":"See <bpt id=\"p1\">[</bpt>Common Techniques to Improve Shadow Depth Maps<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ee416324)</ept> for more tips on shadow technique.","pos":[4501,4649],"source":" See [Common Techniques to Improve Shadow Depth Maps](https://msdn.microsoft.com/library/windows/desktop/ee416324) for more tips on shadow technique."},{"content":"Vertex shader for shadow pass","pos":[4654,4683]},{"content":"Use a simplified version of your vertex shader to render just the vertex position in light space.","pos":[4686,4783]},{"content":"Don't include any lighting normals, secondary transformations, and so on.","pos":[4784,4857]},{"pos":[5180,5317],"content":"In the next part of this walkthrough, learn how to add shadows by <bpt id=\"p1\">[</bpt>rendering with depth testing<ept id=\"p1\">](render-the-scene-with-depth-testing.md)</ept>.","source":"In the next part of this walkthrough, learn how to add shadows by [rendering with depth testing](render-the-scene-with-depth-testing.md)."}],"content":"---\ntitle: Render the shadow map to the depth buffer\ndescription: Render from the point of view of the light to create a two-dimensional depth map representing the shadow volume.\nms.assetid: 7f3d0208-c379-8871-cc48-027047c6c2d0\n---\n\n# Render the shadow map to the depth buffer\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\nRender from the point of view of the light to create a two-dimensional depth map representing the shadow volume. The depth map masks the space that will be rendered in shadow. Part 2 of [Walkthrough: Implement shadow volumes using depth buffers in Direct3D 11](implementing-depth-buffers-for-shadow-mapping.md).\n\n## Clear the depth buffer\n\n\nAlways clear the depth buffer before rendering to it.\n\n```cpp\ncontext->ClearRenderTargetView(m_deviceResources->GetBackBufferRenderTargetView(), DirectX::Colors::CornflowerBlue);\ncontext->ClearDepthStencilView(m_shadowDepthView.Get(), D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);\n```\n\n## Render the shadow map to the depth buffer\n\n\nFor the shadow rendering pass, specify a depth buffer but do not specify a render target.\n\nSpecify the light viewport, a vertex shader, and set the light space constant buffers. Use front face culling for this pass to optimize the depth values placed in the shadow buffer.\n\nNote that on most devices, you can specify nullptr for the pixel shader (or skip specifying a pixel shader entirely). But some drivers may throw an exception when you call draw on the Direct3D device with a null pixel shader set. To avoid this exception, you can set a minimal pixel shader for the shadow rendering pass. The output of this shader is thrown away; it can call [**discard**](https://msdn.microsoft.com/library/windows/desktop/bb943995) on every pixel.\n\nRender the objects that can cast shadows, but don't bother rendering geometry that can't cast a shadow (like a floor in a room, or objects removed from the shadow pass for optimization reasons).\n\n```cpp\nvoid ShadowSceneRenderer::RenderShadowMap()\n{\n    auto context = m_deviceResources->GetD3DDeviceContext();\n\n    // Render all the objects in the scene that can cast shadows onto themselves or onto other objects.\n\n    // Only bind the ID3D11DepthStencilView for output.\n    context->OMSetRenderTargets(\n        0,\n        nullptr,\n        m_shadowDepthView.Get()\n        );\n\n    // Note that starting with the second frame, the previous call will display\n    // warnings in VS debug output about forcing an unbind of the pixel shader\n    // resource. This warning can be safely ignored when using shadow buffers\n    // as demonstrated in this sample.\n\n    // Set rendering state.\n    context->RSSetState(m_shadowRenderState.Get());\n    context->RSSetViewports(1, &m_shadowViewport);\n\n    // Each vertex is one instance of the VertexPositionTexNormColor struct.\n    UINT stride = sizeof(VertexPositionTexNormColor);\n    UINT offset = 0;\n    context->IASetVertexBuffers(\n        0,\n        1,\n        m_vertexBuffer.GetAddressOf(),\n        &stride,\n        &offset\n        );\n\n    context->IASetIndexBuffer(\n        m_indexBuffer.Get(),\n        DXGI_FORMAT_R16_UINT, // Each index is one 16-bit unsigned integer (short).\n        0\n        );\n\n    context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n    context->IASetInputLayout(m_inputLayout.Get());\n\n    // Attach our vertex shader.\n    context->VSSetShader(\n        m_simpleVertexShader.Get(),\n        nullptr,\n        0\n        );\n\n    // Send the constant buffers to the Graphics device.\n    context->VSSetConstantBuffers(\n        0,\n        1,\n        m_lightViewProjectionBuffer.GetAddressOf()\n        );\n\n    context->VSSetConstantBuffers(\n        1,\n        1,\n        m_rotatedModelBuffer.GetAddressOf()\n        );\n\n    // In some configurations, it's possible to avoid setting a pixel shader\n    // (or set PS to nullptr). Not all drivers are tolerant of this, so to be\n    // safe set a minimal shader here.\n    //\n    // Direct3D will discard output from this shader because the render target\n    // view is unbound.\n    context->PSSetShader(\n        m_textureShader.Get(),\n        nullptr,\n        0\n        );\n\n    // Draw the objects.\n    context->DrawIndexed(\n        m_indexCountCube,\n        0,\n        0\n        );\n}\n```\n\n**Optimize the view frustum:**  Make sure your implementation computes a tight view frustum so that you get the most precision out of your depth buffer. See [Common Techniques to Improve Shadow Depth Maps](https://msdn.microsoft.com/library/windows/desktop/ee416324) for more tips on shadow technique.\n\n## Vertex shader for shadow pass\n\n\nUse a simplified version of your vertex shader to render just the vertex position in light space. Don't include any lighting normals, secondary transformations, and so on.\n\n```cpp\nPixelShaderInput main(VertexShaderInput input)\n{\n    PixelShaderInput output;\n    float4 pos = float4(input.pos, 1.0f);\n\n    // Transform the vertex position into projected space.\n    pos = mul(pos, model);\n    pos = mul(pos, view);\n    pos = mul(pos, projection);\n    output.pos = pos;\n\n    return output;\n}\n```\n\nIn the next part of this walkthrough, learn how to add shadows by [rendering with depth testing](render-the-scene-with-depth-testing.md).\n\n \n\n \n\n\n\n\n"}