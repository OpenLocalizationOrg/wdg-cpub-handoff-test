{"nodes":[{"pos":[11,58],"content":"Adding visual content to the Marble Maze sample","needQuote":true,"needEscape":true,"nodes":[{"content":"Adding visual content to the Marble Maze sample","pos":[0,47]}]},{"pos":[72,295],"content":"This document describes how the Marble Maze game uses Direct3D and Direct2D in the Universal Windows Platform (UWP) app environment so that you can learn the patterns and adapt them when you work with your own game content.","needQuote":true,"needEscape":true,"nodes":[{"content":"This document describes how the Marble Maze game uses Direct3D and Direct2D in the Universal Windows Platform (UWP) app environment so that you can learn the patterns and adapt them when you work with your own game content.","pos":[0,223]}]},{"content":"Adding visual content to the Marble Maze sample","pos":[352,399]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[402,440]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[441,536],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"This document describes how the Marble Maze game uses Direct3D and Direct2D in the Universal Windows Platform (UWP) app environment so that you can learn the patterns and adapt them when you work with your own game content.","pos":[539,762]},{"content":"To learn how visual game components fit in the overall application structure of Marble Maze, see <bpt id=\"p1\">[</bpt>Marble Maze application structure<ept id=\"p1\">](marble-maze-application-structure.md)</ept>.","pos":[763,934],"source":" To learn how visual game components fit in the overall application structure of Marble Maze, see [Marble Maze application structure](marble-maze-application-structure.md)."},{"content":"We followed these basic steps as we developed the visual aspects of Marble Maze:","pos":[936,1016]},{"content":"Create a basic framework that initializes the Direct3D and Direct2D environments.","pos":[1022,1103]},{"content":"Use image and model editing programs to design the 2-D and 3-D assets that appear in the game.","pos":[1108,1202]},{"content":"Ensure that 2-D and 3-D assets properly load and appear in the game.","pos":[1207,1275]},{"content":"Integrate vertex and pixel shaders that enhance the visual quality of the game assets.","pos":[1280,1366]},{"content":"Integrate game logic, such as animation and user input.","pos":[1371,1426]},{"content":"We also focused first on adding 3-D assets and then on 2-D assets.","pos":[1428,1494]},{"content":"For example, we focused on core game logic before we added the menu system and timer.","pos":[1495,1580]},{"content":"We also needed to iterate through some of these steps multiple times during the development process.","pos":[1582,1682]},{"content":"For example, as we make changes to the mesh and marble models, we had to also change some of the shader code that supports those models.","pos":[1683,1819]},{"pos":[1823,1981],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   The sample code that corresponds to this document is found in the <bpt id=\"p2\">[</bpt>DirectX Marble Maze game sample<ept id=\"p2\">](http://go.microsoft.com/fwlink/?LinkId=624011)</ept>.","source":"**Note**   The sample code that corresponds to this document is found in the [DirectX Marble Maze game sample](http://go.microsoft.com/fwlink/?LinkId=624011)."},{"content":"Here are some of the key points that this document discusses for when you work with DirectX and visual game content, namely, when you initialize the DirectX graphics libraries, load scene resources, and update and render the scene:","pos":[1985,2216]},{"content":"Adding game content typically involves many steps.","pos":[2222,2272]},{"content":"These steps also often require iteration.","pos":[2273,2314]},{"content":"Game developers often focus first on adding 3-D game content and then on adding 2-D content.","pos":[2315,2407]},{"content":"Reach more customers and give them all a great experience by supporting the greatest range of graphics hardware as possible.","pos":[2412,2536]},{"content":"Cleanly separate design-time and run-time formats.","pos":[2541,2591]},{"content":"Structure your design-time assets to maximize flexibility and enable rapid iterations on content.","pos":[2592,2689]},{"content":"Format and compress your assets to load and render as efficiently as possible at run time.","pos":[2690,2780]},{"content":"You create the Direct3D and Direct2D devices in a UWP app much like you do in a classic Windows desktop app.","pos":[2785,2893]},{"content":"One important difference is how the swap chain is associated with the output window.","pos":[2894,2978]},{"content":"When you design your game, ensure that the mesh format that you choose supports your key scenarios.","pos":[2983,3082]},{"content":"For example, if your game requires collision, make sure that you can obtain collision data from your meshes.","pos":[3083,3191]},{"content":"Separate game logic from rendering logic by first updating all scene objects before you render them.","pos":[3196,3296]},{"content":"You typically draw your 3-D scene objects, and then any 2-D objects that appear in front of the scene.","pos":[3301,3403]},{"content":"Synchronize drawing to the vertical blank to ensure that your game does not spend time drawing frames that will never be actually shown on the display.","pos":[3408,3559]},{"content":"Getting started with DirectX graphics","pos":[3564,3601]},{"content":"When we planned the Marble Maze Universal Windows Platform (UWP) game, we chose C++ and Direct3D 11.1 because they are the best choices for creating 3-D games that require maximum control over rendering and high performance.","pos":[3604,3828]},{"content":"DirectX 11.1 supports hardware from DirectX 9 to DirectX 11, and therefore can help you reach more customers more efficiently because you don't have to rewrite code for each of the earlier DirectX versions.","pos":[3829,4035]},{"content":"Marble Maze uses Direct3D 11.1 to render the 3-D game assets, namely the marble and the maze.","pos":[4037,4130]},{"content":"Marble Maze also uses Direct2D, DirectWrite, and Windows Imaging Component (WIC) to draw the 2-D game assets, such as the menus and the timer.","pos":[4131,4273]},{"content":"Finally, Marble Maze uses XAML to provide an app bar and allows you to add XAML controls.","pos":[4274,4363]},{"content":"Game development requires planning.","pos":[4365,4400]},{"content":"If you are new to DirectX graphics, we recommend that you read Creating a DirectX game to familiarize yourself with the basic concepts of creating a UWP DirectX game.","pos":[4401,4567]},{"content":"As you read this document and work through the Marble Maze source code, you can refer to the following resources for more in-depth information about DirectX graphics.","pos":[4568,4734]},{"pos":[4740,4948],"content":"<bpt id=\"p1\">[</bpt>Direct3D 11 Graphics<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476080)</ept> Describes Direct3D 11, a powerful, hardware-accelerated 3-D graphics API for rendering 3-D geometry on the Windows platform.","source":"[Direct3D 11 Graphics](https://msdn.microsoft.com/library/windows/desktop/ff476080) Describes Direct3D 11, a powerful, hardware-accelerated 3-D graphics API for rendering 3-D geometry on the Windows platform."},{"pos":[4953,5180],"content":"<bpt id=\"p1\">[</bpt>Direct2D<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/dd370990)</ept> Describes Direct2D, a hardware-accelerated, 2-D graphics API that provides high performance and high-quality rendering for 2-D geometry, bitmaps, and text.","source":"[Direct2D](https://msdn.microsoft.com/library/windows/desktop/dd370990) Describes Direct2D, a hardware-accelerated, 2-D graphics API that provides high performance and high-quality rendering for 2-D geometry, bitmaps, and text."},{"pos":[5185,5326],"content":"<bpt id=\"p1\">[</bpt>DirectWrite<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/dd368038)</ept> Describes DirectWrite, which supports high-quality text rendering.","source":"[DirectWrite](https://msdn.microsoft.com/library/windows/desktop/dd368038) Describes DirectWrite, which supports high-quality text rendering."},{"pos":[5331,5505],"content":"<bpt id=\"p1\">[</bpt>Windows Imaging Component<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ee719902)</ept> Describes WIC, an extensible platform that provides low-level API for digital images.","source":"[Windows Imaging Component](https://msdn.microsoft.com/library/windows/desktop/ee719902) Describes WIC, an extensible platform that provides low-level API for digital images."},{"content":"Feature levels","pos":[5511,5525]},{"content":"Direct3D 11 introduces a paradigm named feature levels.","pos":[5527,5582]},{"content":"A feature level is a well-defined set of GPU functionality.","pos":[5583,5642]},{"content":"Use feature levels to target your game to run on earlier versions of Direct3D hardware.","pos":[5643,5730]},{"content":"Marble Maze supports feature level 9.1 because it requires no advanced features from the higher levels.","pos":[5731,5834]},{"content":"We recommend that you support the greatest range of hardware possible and scale your game content so that your customers that have either high or low-end computers all have a great experience.","pos":[5835,6027]},{"content":"For more information about feature levels, see <bpt id=\"p1\">[</bpt>Direct3D 11 on Downlevel Hardware<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476872)</ept>.","pos":[6028,6172],"source":" For more information about feature levels, see [Direct3D 11 on Downlevel Hardware](https://msdn.microsoft.com/library/windows/desktop/ff476872)."},{"content":"Initializing Direct3D and Direct2D","pos":[6177,6211]},{"content":"A device represents the display adapter.","pos":[6214,6254]},{"content":"You create the Direct3D and Direct2D devices in a UWP app much like you do in a classic Windows desktop app.","pos":[6255,6363]},{"content":"The main difference is how you connect the Direct3D swap chain to the windowing system.","pos":[6364,6451]},{"content":"The <bpt id=\"p1\">*</bpt>DirectX 11 and XAML App (Universal Windows)<ept id=\"p1\">*</ept> factors out some generic operating system and 3-D rendering functions from the game-specific functions.","pos":[6453,6606],"source":"The *DirectX 11 and XAML App (Universal Windows)* factors out some generic operating system and 3-D rendering functions from the game-specific functions."},{"content":"The <bpt id=\"p1\">**</bpt>DeviceResources<ept id=\"p1\">**</ept> class is a foundation for managing Direct3D and Direct2D.","pos":[6607,6688],"source":" The **DeviceResources** class is a foundation for managing Direct3D and Direct2D."},{"content":"This class handles general infrastructure, and not game-specific assets.","pos":[6689,6761]},{"content":"Marble Maze defines the <bpt id=\"p1\">**</bpt>MarbleMaze<ept id=\"p1\">**</ept> class to handle game-specific assets, which has a reference to a <bpt id=\"p2\">**</bpt>DeviceResources<ept id=\"p2\">**</ept> object to give it access to Direct3D and Direct2D.","pos":[6762,6936],"source":" Marble Maze defines the **MarbleMaze** class to handle game-specific assets, which has a reference to a **DeviceResources** object to give it access to Direct3D and Direct2D."},{"pos":[6938,7079],"content":"During initialization, the <bpt id=\"p1\">**</bpt>DeviceResources::Initialize<ept id=\"p1\">**</ept> method creates device-independent resources and the Direct3D and Direct2D devices.","source":"During initialization, the **DeviceResources::Initialize** method creates device-independent resources and the Direct3D and Direct2D devices."},{"content":"The <bpt id=\"p1\">**</bpt>DeviceResources<ept id=\"p1\">**</ept> class separates this functionality so that it can more easily respond when the environment changes.","pos":[7373,7496],"source":"The **DeviceResources** class separates this functionality so that it can more easily respond when the environment changes."},{"content":"For example, it calls the <bpt id=\"p1\">**</bpt>CreateWindowSizeDependentResources<ept id=\"p1\">**</ept> method when the window size changes.","pos":[7497,7598],"source":" For example, it calls the **CreateWindowSizeDependentResources** method when the window size changes."},{"content":"Initializing the Direct2D, DirectWrite, and WIC factories","pos":[7605,7662]},{"content":"The <bpt id=\"p1\">**</bpt>DeviceResources::CreateDeviceIndependentResources<ept id=\"p1\">**</ept> method creates the factories for Direct2D, DirectWrite, and WIC.","pos":[7664,7786],"source":"The **DeviceResources::CreateDeviceIndependentResources** method creates the factories for Direct2D, DirectWrite, and WIC."},{"content":"In DirectX graphics, factories are the starting points for creating graphics resources.","pos":[7787,7874]},{"content":"Marble Maze specifies <bpt id=\"p1\">**</bpt>D2D1\\_FACTORY\\_TYPE\\_SINGLE\\_THREADED<ept id=\"p1\">**</ept> because it performs all drawing on the main thread.","pos":[7875,7990],"source":" Marble Maze specifies **D2D1\\_FACTORY\\_TYPE\\_SINGLE\\_THREADED** because it performs all drawing on the main thread."},{"content":"Creating the Direct3D and Direct2D devices","pos":[8991,9033]},{"content":"The <bpt id=\"p1\">**</bpt>DeviceResources::CreateDeviceResources<ept id=\"p1\">**</ept> method calls <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>D3D11CreateDevice<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</ept> to create the device object that represents the Direct3D display adapter.","pos":[9035,9253],"source":"The **DeviceResources::CreateDeviceResources** method calls [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) to create the device object that represents the Direct3D display adapter."},{"content":"Because Marble Maze supports feature level 9.1 and above, the <bpt id=\"p1\">**</bpt>DeviceResources::CreateDeviceResources<ept id=\"p1\">**</ept> method specifies levels 9.1 through 11.1 in the array of <bpt id=\"p2\">**</bpt><ph id=\"ph1\">\\\\</ph><ept id=\"p2\">**</ept> values.","pos":[9254,9430],"source":" Because Marble Maze supports feature level 9.1 and above, the **DeviceResources::CreateDeviceResources** method specifies levels 9.1 through 11.1 in the array of **\\\\** values."},{"content":"Direct3D walks the list in order and gives the app the first feature level that is available.","pos":[9431,9524]},{"content":"Therefore the <bpt id=\"p1\">**</bpt>D3D\\_FEATURE\\_LEVEL<ept id=\"p1\">**</ept> array entries are listed from highest to lowest so that the app will get the highest level feature level available.","pos":[9525,9678],"source":" Therefore the **D3D\\_FEATURE\\_LEVEL** array entries are listed from highest to lowest so that the app will get the highest level feature level available."},{"content":"The <bpt id=\"p1\">**</bpt>DeviceResources::CreateDeviceResources<ept id=\"p1\">**</ept> method obtains the Direct3D 11.1 device by querying the Direct3D 11 device that's returned from <bpt id=\"p2\">**</bpt>D3D11CreateDevice<ept id=\"p2\">**</ept>.","pos":[9679,9844],"source":" The **DeviceResources::CreateDeviceResources** method obtains the Direct3D 11.1 device by querying the Direct3D 11 device that's returned from **D3D11CreateDevice**."},{"content":"The <bpt id=\"p1\">**</bpt>DeviceResources::CreateDeviceResources<ept id=\"p1\">**</ept> method then creates the Direct2D device.","pos":[11510,11597],"source":"The **DeviceResources::CreateDeviceResources** method then creates the Direct2D device."},{"content":"Direct2D uses Microsoft DirectX Graphics Infrastructure (DXGI) to interoperate with Direct3D.","pos":[11598,11691]},{"content":"DXGI enables video memory surfaces to be shared between graphics runtimes.","pos":[11692,11766]},{"content":"Marble Maze uses the underlying DXGI device from the Direct3D device to create the Direct2D device from the Direct2D factory.","pos":[11767,11892]},{"pos":[12826,13106],"content":"For more information about DXGI and interoperability between Direct2D and Direct3D, see <bpt id=\"p1\">[</bpt>DXGI Overview<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb205075)</ept> and <bpt id=\"p2\">[</bpt>Direct2D and Direct3D Interoperability Overview<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/dd370966)</ept>.","source":"For more information about DXGI and interoperability between Direct2D and Direct3D, see [DXGI Overview](https://msdn.microsoft.com/library/windows/desktop/bb205075) and [Direct2D and Direct3D Interoperability Overview](https://msdn.microsoft.com/library/windows/desktop/dd370966)."},{"content":"Associating Direct3D with the view","pos":[13112,13146]},{"content":"The <bpt id=\"p1\">**</bpt>DeviceResources::CreateWindowSizeDependentResources<ept id=\"p1\">**</ept> method creates the graphics resources that depend on a given window size such as the swap chain and Direct3D and Direct2D render targets.","pos":[13148,13345],"source":"The **DeviceResources::CreateWindowSizeDependentResources** method creates the graphics resources that depend on a given window size such as the swap chain and Direct3D and Direct2D render targets."},{"content":"One important way that a DirectX UWP app differs from a desktop app is how the swap chain is associated with the output window.","pos":[13346,13473]},{"content":"A swap chain is responsible for displaying the buffer to which the device renders on the monitor.","pos":[13474,13571]},{"content":"The document Marble Maze application structure describes how the windowing system for a UWP app differs from a desktop app.","pos":[13572,13695]},{"content":"Because a Windows Store app does not work with <bpt id=\"p1\">**</bpt>HWND<ept id=\"p1\">**</ept> objects, Marble Maze must use the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>IDXGIFactory2::CreateSwapChainForCoreWindow<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/hh404559)</ept> method to associate the device output to the view.","pos":[13696,13947],"source":" Because a Windows Store app does not work with **HWND** objects, Marble Maze must use the [**IDXGIFactory2::CreateSwapChainForCoreWindow**](https://msdn.microsoft.com/library/windows/desktop/hh404559) method to associate the device output to the view."},{"content":"The following example shows the part of the <bpt id=\"p1\">**</bpt>DeviceResources::CreateWindowSizeDependentResources<ept id=\"p1\">**</ept> method that creates the swap chain.","pos":[13948,14083],"source":" The following example shows the part of the **DeviceResources::CreateWindowSizeDependentResources** method that creates the swap chain."},{"content":"To minimize power consumption, which is important to do on battery-powered devices such as laptops and tablets, the <bpt id=\"p1\">**</bpt>DeviceResources::CreateWindowSizeDependentResources<ept id=\"p1\">**</ept> method calls the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>IDXGIDevice1::SetMaximumFrameLatency<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff471334)</ept> method to ensure that the game is rendered only after the vertical blank.","pos":[14415,14781],"source":"To minimize power consumption, which is important to do on battery-powered devices such as laptops and tablets, the **DeviceResources::CreateWindowSizeDependentResources** method calls the [**IDXGIDevice1::SetMaximumFrameLatency**](https://msdn.microsoft.com/library/windows/desktop/ff471334) method to ensure that the game is rendered only after the vertical blank."},{"content":"Synchronizing with the vertical blank is described in greater detail in the section Presenting the scene in this document.","pos":[14782,14904]},{"pos":[15186,15319],"content":"The <bpt id=\"p1\">**</bpt>DeviceResources::CreateWindowSizeDependentResources<ept id=\"p1\">**</ept> method initializes graphics resources in a way that works for most games.","source":"The **DeviceResources::CreateWindowSizeDependentResources** method initializes graphics resources in a way that works for most games."},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   The term <bpt id=\"p2\">*</bpt>view<ept id=\"p2\">*</ept> has a different meaning in the Windows Runtime than it has in Direct3D.","pos":[15323,15421],"source":"**Note**   The term *view* has a different meaning in the Windows Runtime than it has in Direct3D."},{"content":"In the Windows Runtime, a view refers to the collection of user interface settings for an app, including the display area and the input behaviors, plus the thread it uses for processing.","pos":[15422,15608]},{"content":"You specify the configuration and settings you need when you create a view.","pos":[15609,15684]},{"content":"The process of setting up the app view is described in <bpt id=\"p1\">[</bpt>Marble Maze application structure<ept id=\"p1\">](marble-maze-application-structure.md)</ept>.","pos":[15685,15814],"source":" The process of setting up the app view is described in [Marble Maze application structure](marble-maze-application-structure.md)."},{"content":"In Direct3D, the term view has multiple meanings.","pos":[15815,15864]},{"content":"First, a resource view defines the subresources that a resource can access.","pos":[15865,15940]},{"content":"For example, when a texture object is associated with a shader resource view, that shader can later access the texture.","pos":[15941,16060]},{"content":"One advantage of a resource view is that you can interpret data in different ways at different stages in the rendering pipeline.","pos":[16061,16189]},{"content":"For more information about resource views, see <bpt id=\"p1\">[</bpt>Texture Views (Direct3D 10)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb205128)</ept>.","pos":[16190,16328],"source":" For more information about resource views, see [Texture Views (Direct3D 10)](https://msdn.microsoft.com/library/windows/desktop/bb205128)."},{"content":"When used in the context of a view transform or view transform matrix, view refers to the location and orientation of the camera.","pos":[16329,16458]},{"content":"A view transform relocates objects in the world around the camera’s position and orientation.","pos":[16459,16552]},{"content":"For more information about view transforms, see <bpt id=\"p1\">[</bpt>View Transform (Direct3D 9)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb206342)</ept>.","pos":[16553,16692],"source":" For more information about view transforms, see [View Transform (Direct3D 9)](https://msdn.microsoft.com/library/windows/desktop/bb206342)."},{"content":"How Marble Maze uses resource and matrix views is described in greater detail in this topic.","pos":[16693,16785]},{"content":"Loading scene resources","pos":[16793,16816]},{"content":"Marble Maze uses the <bpt id=\"p1\">**</bpt>BasicLoader<ept id=\"p1\">**</ept> class, which is declared in BasicLoader.h, to load textures and shaders.","pos":[16819,16928],"source":"Marble Maze uses the **BasicLoader** class, which is declared in BasicLoader.h, to load textures and shaders."},{"content":"Marble Maze uses the <bpt id=\"p1\">**</bpt>SDKMesh<ept id=\"p1\">**</ept> class to load the 3-D meshes for the maze and the marble.","pos":[16929,17019],"source":" Marble Maze uses the **SDKMesh** class to load the 3-D meshes for the maze and the marble."},{"content":"To ensure a responsive app, Marble Maze loads scene resources asynchronously, or in the background.","pos":[17021,17120]},{"content":"As assets load in the background, your game can respond to window events.","pos":[17121,17194]},{"content":"This process is explained in greater detail in <bpt id=\"p1\">[</bpt>Loading game assets in the background<ept id=\"p1\">](marble-maze-application-structure.md#loading_game_assets)</ept> in this guide.","pos":[17195,17354],"source":" This process is explained in greater detail in [Loading game assets in the background](marble-maze-application-structure.md#loading_game_assets) in this guide."},{"content":"Loading the 2-D overlay and user interface","pos":[17361,17403]},{"content":"In Marble Maze, the overlay is the image that appears at the top of the screen.","pos":[17405,17484]},{"content":"The overlay always appears in front of the scene.","pos":[17485,17534]},{"content":"In Marble Maze, the overlay contains the Windows logo and the text string \"DirectX Marble Maze game sample\".","pos":[17535,17643]},{"content":"The management of the overlay is performed by the <bpt id=\"p1\">**</bpt>SampleOverlay<ept id=\"p1\">**</ept> class, which is defined in SampleOverlay.h.","pos":[17644,17755],"source":" The management of the overlay is performed by the **SampleOverlay** class, which is defined in SampleOverlay.h."},{"content":"Although we use the overlay as part of the Direct3D samples, you can adapt this code to display any image that appears in front of your scene.","pos":[17756,17898]},{"content":"One important aspect of the overlay is that, because its contents do not change, the <bpt id=\"p1\">**</bpt>SampleOverlay<ept id=\"p1\">**</ept> class draws, or caches, its contents to an <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID2D1Bitmap1<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/hh404349)</ept> object during initialization.","pos":[17900,18155],"source":"One important aspect of the overlay is that, because its contents do not change, the **SampleOverlay** class draws, or caches, its contents to an [**ID2D1Bitmap1**](https://msdn.microsoft.com/library/windows/desktop/hh404349) object during initialization."},{"content":"At draw time, the <bpt id=\"p1\">**</bpt>SampleOverlay<ept id=\"p1\">**</ept> class only has to draw the bitmap to the screen.","pos":[18156,18240],"source":" At draw time, the **SampleOverlay** class only has to draw the bitmap to the screen."},{"content":"In this way, expensive routines such as text drawing do not have to be performed for every frame.","pos":[18241,18338]},{"content":"The user interface (UI) consists of 2-D components, such as menus and heads-up displays (HUDs), which appear in front of your scene.","pos":[18340,18472]},{"content":"Marble Maze defines the following UI elements:","pos":[18473,18519]},{"content":"Menu items that enable the user to start the game or view high scores.","pos":[18525,18595]},{"content":"A timer that counts down for three seconds before play begins.","pos":[18600,18662]},{"content":"A timer that tracks the elapsed play time.","pos":[18667,18709]},{"content":"A table that lists the fastest finish times.","pos":[18714,18758]},{"content":"Text that reads \"Paused\" when the game is paused.","pos":[18763,18812]},{"content":"Marble Maze defines game-specific UI elements in UserInterface.h.","pos":[18814,18879]},{"content":"Marble Maze defines the <bpt id=\"p1\">**</bpt>ElementBase<ept id=\"p1\">**</ept> class as a base type for all UI elements.","pos":[18880,18961],"source":" Marble Maze defines the **ElementBase** class as a base type for all UI elements."},{"content":"The <bpt id=\"p1\">**</bpt>ElementBase<ept id=\"p1\">**</ept> class defines attributes such as the size, position, alignment, and visibility of a UI element.","pos":[18962,19077],"source":" The **ElementBase** class defines attributes such as the size, position, alignment, and visibility of a UI element."},{"content":"It also controls how elements are updated and rendered.","pos":[19078,19133]},{"content":"By providing a common base class for UI elements, the <bpt id=\"p1\">**</bpt>UserInterface<ept id=\"p1\">**</ept> class, which manages the user interface, need only hold a collection of <bpt id=\"p2\">**</bpt>ElementBase<ept id=\"p2\">**</ept> objects, which simplifies UI management and provides a user interface manager that is reusable.","pos":[19741,19996],"source":"By providing a common base class for UI elements, the **UserInterface** class, which manages the user interface, need only hold a collection of **ElementBase** objects, which simplifies UI management and provides a user interface manager that is reusable."},{"content":"Marble Maze defines types that derive from <bpt id=\"p1\">**</bpt>ElementBase<ept id=\"p1\">**</ept> that implement game-specific behaviors.","pos":[19997,20095],"source":" Marble Maze defines types that derive from **ElementBase** that implement game-specific behaviors."},{"content":"For example, <bpt id=\"p1\">**</bpt>HighScoreTable<ept id=\"p1\">**</ept> defines the behavior for the high score table.","pos":[20096,20174],"source":" For example, **HighScoreTable** defines the behavior for the high score table."},{"content":"For more info about these types, refer to the source code.","pos":[20175,20233]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   Because XAML enables you to more easily create complex user interfaces, like those found in simulation and strategy games, consider whether to use XAML to define your UI.","pos":[20237,20418],"source":"**Note**   Because XAML enables you to more easily create complex user interfaces, like those found in simulation and strategy games, consider whether to use XAML to define your UI."},{"content":"For info about how to develop a user interface in XAML in a DirectX UWP game, see <bpt id=\"p1\">[</bpt>Extend the game sample (Windows)<ept id=\"p1\">](tutorial-resources.md)</ept>.","pos":[20419,20559],"source":" For info about how to develop a user interface in XAML in a DirectX UWP game, see [Extend the game sample (Windows)](tutorial-resources.md)."},{"content":"This document refers to the DirectX 3-D shooting game sample.","pos":[20560,20621]},{"content":"Loading shaders","pos":[20631,20646]},{"pos":[20648,20733],"content":"Marble Maze uses the <bpt id=\"p1\">**</bpt>BasicLoader::LoadShader<ept id=\"p1\">**</ept> method to load a shader from a file.","source":"Marble Maze uses the **BasicLoader::LoadShader** method to load a shader from a file."},{"content":"Shaders are the fundamental unit of GPU programming in games today.","pos":[20735,20802]},{"content":"Nearly all 3-D graphics processing is driven through shaders, whether it is model transformation and scene lighting, or more complex geometry processing, from character skinning to tessellation.","pos":[20803,20997]},{"content":"For more information about the shader programming model, see <bpt id=\"p1\">[</bpt>HLSL<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509561)</ept>.","pos":[20998,21127],"source":" For more information about the shader programming model, see [HLSL](https://msdn.microsoft.com/library/windows/desktop/bb509561)."},{"content":"Marble Maze uses vertex and pixel shaders.","pos":[21129,21171]},{"content":"A vertex shader always operates on one input vertex and produces one vertex as output.","pos":[21172,21258]},{"content":"A pixel shader takes numeric values, texture data, interpolated per-vertex values, and other data to produce a pixel color as output.","pos":[21259,21392]},{"content":"Because a shader transforms one element at a time, graphics hardware that provides multiple shader pipelines can process sets of elements in parallel.","pos":[21393,21543]},{"content":"The number of parallel pipelines that are available to the GPU can be vastly greater than the number that is available to the CPU.","pos":[21544,21674]},{"content":"Therefore, even basic shaders can greatly improve throughput.","pos":[21675,21736]},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::LoadDeferredResources<ept id=\"p1\">**</ept> method loads one vertex shader and one pixel shader after it loads the overlay.","pos":[21738,21859],"source":"The **MarbleMaze::LoadDeferredResources** method loads one vertex shader and one pixel shader after it loads the overlay."},{"content":"The design-time versions of these shaders are defined in BasicVertexShader.hlsl and BasicPixelShader.hlsl, respectively.","pos":[21860,21980]},{"content":"Marble Maze applies these shaders to both the ball and the maze during the rendering phase.","pos":[21981,22072]},{"content":"The Marble Maze project includes both .hlsl (the design-time format) and .cso (the run-time format) versions of the shader files.","pos":[22074,22203]},{"content":"At build time, Visual Studio uses the fxc.exe effect-compiler to compile your .hlsl source file into a .cso binary shader.","pos":[22204,22326]},{"content":"For more information about the effect-compiler tool, see <bpt id=\"p1\">[</bpt>Effect-Compiler Tool<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb232919)</ept>.","pos":[22327,22468],"source":" For more information about the effect-compiler tool, see [Effect-Compiler Tool](https://msdn.microsoft.com/library/windows/desktop/bb232919)."},{"content":"The vertex shader uses the supplied model, view and projection matrices to transform the input geometry.","pos":[22470,22574]},{"content":"Position data from the input geometry is transformed and output twice: once in screen space, which is necessary for rendering, and again in world space to enable the pixel shader to perform lighting calculations.","pos":[22575,22787]},{"content":"The surface normal vector is transformed to world space, which is also used by the pixel shader for lighting.","pos":[22788,22897]},{"content":"The texture coordinates are passed through unchanged to the pixel shader.","pos":[22898,22971]},{"content":"The pixel shader receives the output of the vertex shader as input.","pos":[23346,23413]},{"content":"This shader performs lighting calculations to mimic a soft-edged spotlight that hovers over the maze and is aligned with the position of the marble.","pos":[23414,23562]},{"content":"Lighting is strongest for surfaces that point directly toward the light.","pos":[23563,23635]},{"content":"The diffuse component tapers off to zero as the surface normal becomes perpendicular to the light, and the ambient term diminishes as the normal points away from the light.","pos":[23636,23808]},{"content":"Points closer to the marble (and therefore closer to the center of the spotlight) are lit more strongly.","pos":[23809,23913]},{"content":"However, lighting is modulated for points underneath the marble to simulate a soft shadow.","pos":[23914,24004]},{"content":"In a real environment, an object like the white marble would diffusely reflect the spotlight onto other objects in the scene.","pos":[24005,24130]},{"content":"This is approximated for the surfaces that are in view of the bright half of the marble.","pos":[24131,24219]},{"content":"The additional illumination factors are in relative angle and distance to the marble.","pos":[24220,24305]},{"content":"The resulting pixel color is a composition of the sampled texture with the result of the lighting calculations.","pos":[24306,24417]},{"content":"<bpt id=\"p1\">**</bpt>Caution<ept id=\"p1\">**</ept>  The compiled pixel shader contains 32 arithmetic instructions and 1 texture instruction.","pos":[25609,25710],"source":"**Caution**  The compiled pixel shader contains 32 arithmetic instructions and 1 texture instruction."},{"content":"This shader should perform well on desktop computers and higher-end tablets.","pos":[25711,25787]},{"content":"However, a lower-end computer might not be able to process this shader and still provide an interactive frame rate.","pos":[25788,25903]},{"content":"Consider the typical hardware of your target audience and design your shaders to meet the capabilities of that hardware.","pos":[25904,26024]},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::LoadDeferredResources<ept id=\"p1\">**</ept> method uses the <bpt id=\"p2\">**</bpt>BasicLoader::LoadShader<ept id=\"p2\">**</ept> method to load the shaders.","pos":[26029,26142],"source":"The **MarbleMaze::LoadDeferredResources** method uses the **BasicLoader::LoadShader** method to load the shaders."},{"content":"The following example loads the vertex shader.","pos":[26143,26189]},{"content":"The run-time format for this shader is BasicVertexShader.cso.","pos":[26190,26251]},{"content":"The <bpt id=\"p1\">**</bpt>m\\_vertexShader<ept id=\"p1\">**</ept> member variable is an <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID3D11VertexShader<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476641)</ept> object.","pos":[26252,26391],"source":" The **m\\_vertexShader** member variable is an [**ID3D11VertexShader**](https://msdn.microsoft.com/library/windows/desktop/ff476641) object."},{"content":"The <bpt id=\"p1\">**</bpt>m\\_inputLayout<ept id=\"p1\">**</ept> member variable is an <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID3D11InputLayout<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476575)</ept> object.","pos":[26546,26683],"source":"The **m\\_inputLayout** member variable is an [**ID3D11InputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476575) object."},{"content":"The input-layout object encapsulates the input state of the input assembler (IA) stage.","pos":[26684,26771]},{"content":"One job of the IA stage is to make shaders more efficient by using system-generated values, also known as <bpt id=\"p1\">*</bpt>semantics<ept id=\"p1\">*</ept>, to process only those primitives or vertices that have not already been processed.","pos":[26772,26973],"source":" One job of the IA stage is to make shaders more efficient by using system-generated values, also known as *semantics*, to process only those primitives or vertices that have not already been processed."},{"content":"Use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device::CreateInputLayout<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476512)</ept> method to create an input-layout from an array of input-element descriptions.","pos":[26974,27158],"source":" Use the [**ID3D11Device::CreateInputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476512) method to create an input-layout from an array of input-element descriptions."},{"content":"The array contains one or more input elements; each input element describes one vertex-data element from one vertex buffer.","pos":[27159,27282]},{"content":"The entire set of input-element descriptions describes all of the vertex-data elements from all of the vertex buffers that will be bound to the IA stage.","pos":[27283,27436]},{"content":"The following example shows the layout description that Marble Maze uses.","pos":[27437,27510]},{"content":"The layout description describes a vertex buffer that contains four vertex-data elements.","pos":[27511,27600]},{"content":"The important parts of each entry in the array are the semantic name, data format, and byte offset .","pos":[27601,27701]},{"content":"For example, the <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> element specifies the vertex position in object space.","pos":[27702,27786],"source":" For example, the **POSITION** element specifies the vertex position in object space."},{"content":"It starts at byte offset 0 and contains three floating-point components (for a total of 12 bytes).","pos":[27787,27885]},{"content":"The <bpt id=\"p1\">**</bpt>NORMAL<ept id=\"p1\">**</ept> element specifies the normal vector.","pos":[27886,27937],"source":" The **NORMAL** element specifies the normal vector."},{"content":"It starts at byte offset 12 because it appears directly after <bpt id=\"p1\">**</bpt>POSITION<ept id=\"p1\">**</ept> in the layout, which requires 12 bytes.","pos":[27938,28052],"source":" It starts at byte offset 12 because it appears directly after **POSITION** in the layout, which requires 12 bytes."},{"content":"The <bpt id=\"p1\">**</bpt>NORMAL<ept id=\"p1\">**</ept> element contains a four-component, 32-bit unsigned-integer.","pos":[28053,28127],"source":" The **NORMAL** element contains a four-component, 32-bit unsigned-integer."},{"content":"Compare the input layout with the <bpt id=\"p1\">**</bpt>sVSInput<ept id=\"p1\">**</ept> structure that is defined by the vertex shader, as shown in the following example.","pos":[28633,28762],"source":"Compare the input layout with the **sVSInput** structure that is defined by the vertex shader, as shown in the following example."},{"content":"The <bpt id=\"p1\">**</bpt>sVSInput<ept id=\"p1\">**</ept> structure defines the <bpt id=\"p2\">**</bpt>POSITION<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>NORMAL<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>TEXCOORD0<ept id=\"p4\">**</ept> elements.","pos":[28763,28855],"source":" The **sVSInput** structure defines the **POSITION**, **NORMAL**, and **TEXCOORD0** elements."},{"content":"The DirectX runtime maps each element in the layout to the input structure that is defined by the shader.","pos":[28856,28961]},{"pos":[29578,29724],"content":"The document <bpt id=\"p1\">[</bpt>Semantics<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509647)</ept> describes each of the available semantics in greater detail.","source":"The document [Semantics](https://msdn.microsoft.com/library/windows/desktop/bb509647) describes each of the available semantics in greater detail."},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   In a layout, you can specify additional components that are not used to enable multiple shaders to share the same layout.","pos":[29728,29860],"source":"**Note**   In a layout, you can specify additional components that are not used to enable multiple shaders to share the same layout."},{"content":"For example, the <bpt id=\"p1\">**</bpt>TANGENT<ept id=\"p1\">**</ept> element is not used by the shader.","pos":[29861,29924],"source":" For example, the **TANGENT** element is not used by the shader."},{"content":"You can use the <bpt id=\"p1\">**</bpt>TANGENT<ept id=\"p1\">**</ept> element if you want to experiment with techniques such as normal mapping.","pos":[29925,30026],"source":" You can use the **TANGENT** element if you want to experiment with techniques such as normal mapping."},{"content":"By using normal mapping, also known as bump mapping, you can create the effect of bumps on the surfaces of objects.","pos":[30027,30142]},{"content":"For more information about bump mapping, see <bpt id=\"p1\">[</bpt>Bump Mapping (Direct3D 9)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb172379)</ept>.","pos":[30143,30277],"source":" For more information about bump mapping, see [Bump Mapping (Direct3D 9)](https://msdn.microsoft.com/library/windows/desktop/bb172379)."},{"pos":[30282,30544],"content":"For more information about the input assembly stage state, see <bpt id=\"p1\">[</bpt>Input-Assembler Stage<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb205116)</ept> and <bpt id=\"p2\">[</bpt>Getting Started with the Input-Assembler Stage<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/bb205117)</ept>.","source":"For more information about the input assembly stage state, see [Input-Assembler Stage](https://msdn.microsoft.com/library/windows/desktop/bb205116) and [Getting Started with the Input-Assembler Stage](https://msdn.microsoft.com/library/windows/desktop/bb205117)."},{"pos":[30546,30712],"content":"The process of using the vertex and pixel shaders to render the scene are described in the section <bpt id=\"p1\">[</bpt>Rendering the scene<ept id=\"p1\">](#rendering_the_scene)</ept> later in this document.","source":"The process of using the vertex and pixel shaders to render the scene are described in the section [Rendering the scene](#rendering_the_scene) later in this document."},{"content":"Creating the constant buffer","pos":[30718,30746]},{"content":"Direct3D buffer groups a collection of data.","pos":[30748,30792]},{"content":"A constant buffer is a kind of buffer that you can use to pass data to shaders.","pos":[30793,30872]},{"content":"Marble Maze uses a constant buffer to hold the model (or world) view, and the projection matrices for the active scene object.","pos":[30873,30999]},{"content":"The following example shows how the <bpt id=\"p1\">**</bpt>MarbleMaze::LoadDeferredResources<ept id=\"p1\">**</ept> method creates a constant buffer that will later hold matrix data.","pos":[31001,31141],"source":"The following example shows how the **MarbleMaze::LoadDeferredResources** method creates a constant buffer that will later hold matrix data."},{"content":"The example creates a <bpt id=\"p1\">**</bpt>D3D11\\_BUFFER\\_DESC<ept id=\"p1\">**</ept> structure that uses the <bpt id=\"p2\">**</bpt>D3D11\\_BIND\\_CONSTANT\\_BUFFER<ept id=\"p2\">**</ept> flag to specify usage as a constant buffer.","pos":[31142,31289],"source":" The example creates a **D3D11\\_BUFFER\\_DESC** structure that uses the **D3D11\\_BIND\\_CONSTANT\\_BUFFER** flag to specify usage as a constant buffer."},{"content":"This example then passes that structure to the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device::CreateBuffer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept> method.","pos":[31290,31438],"source":" This example then passes that structure to the [**ID3D11Device::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501) method."},{"content":"The <bpt id=\"p1\">**</bpt>m\\_constantBuffer<ept id=\"p1\">**</ept> variable is an <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID3D11Buffer<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476351)</ept> object.","pos":[31439,31567],"source":" The **m\\_constantBuffer** variable is an [**ID3D11Buffer**](https://msdn.microsoft.com/library/windows/desktop/ff476351) object."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method later updates <bpt id=\"p2\">**</bpt>ConstantBuffer<ept id=\"p2\">**</ept> objects, one for the maze and one for the marble.","pos":[32328,32444],"source":"The **MarbleMaze::Update** method later updates **ConstantBuffer** objects, one for the maze and one for the marble."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Render<ept id=\"p1\">**</ept> method then binds each <bpt id=\"p2\">**</bpt>ConstantBuffer<ept id=\"p2\">**</ept> object to the constant buffer before each object is rendered.","pos":[32445,32575],"source":" The **MarbleMaze::Render** method then binds each **ConstantBuffer** object to the constant buffer before each object is rendered."},{"content":"The following example shows the <bpt id=\"p1\">**</bpt>ConstantBuffer<ept id=\"p1\">**</ept> structure, which is in MarbleMaze.h.","pos":[32576,32663],"source":" The following example shows the **ConstantBuffer** structure, which is in MarbleMaze.h."},{"pos":[32901,33115],"content":"To better understand how constant buffers map to shader code, compare the <bpt id=\"p1\">**</bpt>ConstantBuffer<ept id=\"p1\">**</ept> structure to the <bpt id=\"p2\">**</bpt>SimpleConstantBuffer<ept id=\"p2\">**</ept> constant buffer that is defined by the vertex shader in BasicVertexShader.hlsl:","source":"To better understand how constant buffers map to shader code, compare the **ConstantBuffer** structure to the **SimpleConstantBuffer** constant buffer that is defined by the vertex shader in BasicVertexShader.hlsl:"},{"content":"The layout of the <bpt id=\"p1\">**</bpt>ConstantBuffer<ept id=\"p1\">**</ept> structure matches the <bpt id=\"p2\">**</bpt>cbuffer<ept id=\"p2\">**</ept> object.","pos":[33307,33385],"source":"The layout of the **ConstantBuffer** structure matches the **cbuffer** object."},{"content":"The <bpt id=\"p1\">**</bpt>cbuffer<ept id=\"p1\">**</ept> variable specifies register b0, which means that the constant buffer data is stored in register 0.","pos":[33386,33500],"source":" The **cbuffer** variable specifies register b0, which means that the constant buffer data is stored in register 0."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Render<ept id=\"p1\">**</ept> method specifies register 0 when it activates the constant buffer.","pos":[33501,33594],"source":" The **MarbleMaze::Render** method specifies register 0 when it activates the constant buffer."},{"content":"This process is described in greater detail later in this document.","pos":[33595,33662]},{"content":"For more information about constant buffers, see <bpt id=\"p1\">[</bpt>Introduction to Buffers in Direct3D 11<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476898)</ept>.","pos":[33664,33815],"source":"For more information about constant buffers, see [Introduction to Buffers in Direct3D 11](https://msdn.microsoft.com/library/windows/desktop/ff476898)."},{"content":"For more information about the register keyword, see <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/dd607359)</ept>.","pos":[33816,33945],"source":" For more information about the register keyword, see [**register**](https://msdn.microsoft.com/library/windows/desktop/dd607359)."},{"content":"Loading meshes","pos":[33952,33966]},{"content":"Marble Maze uses SDK-Mesh as the run-time format because this format provides a basic way to load mesh data for sample applications.","pos":[33968,34100]},{"content":"For production use, you should use a mesh format that meets the specific requirements of your game.","pos":[34101,34200]},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::LoadDeferredResources<ept id=\"p1\">**</ept> method loads mesh data after it loads the vertex and pixel shaders.","pos":[34202,34311],"source":"The **MarbleMaze::LoadDeferredResources** method loads mesh data after it loads the vertex and pixel shaders."},{"content":"A mesh is a collection of vertex data that often includes information such as positions, normal data, colors, materials, and texture coordinates.","pos":[34312,34457]},{"content":"Meshes are typically created in 3-D authoring software and maintained in files that are separate from application code.","pos":[34458,34577]},{"content":"The marble and the maze are two examples of meshes that the game uses.","pos":[34578,34648]},{"content":"Marble Maze uses the <bpt id=\"p1\">**</bpt>SDKMesh<ept id=\"p1\">**</ept> class to manage meshes.","pos":[34650,34706],"source":"Marble Maze uses the **SDKMesh** class to manage meshes."},{"content":"This class is declared in SDKMesh.h.","pos":[34707,34743]},{"content":"<bpt id=\"p1\">**</bpt>SDKMesh<ept id=\"p1\">**</ept> provides methods to load, render, and destroy mesh data.","pos":[34744,34812],"source":"**SDKMesh** provides methods to load, render, and destroy mesh data."},{"content":"<bpt id=\"p1\">**</bpt>Important<ept id=\"p1\">**</ept>   Marble Maze uses the SDK-Mesh format and provides the <bpt id=\"p2\">**</bpt>SDKMesh<ept id=\"p2\">**</ept> class for illustration only.","pos":[34816,34926],"source":"**Important**   Marble Maze uses the SDK-Mesh format and provides the **SDKMesh** class for illustration only."},{"content":"Although the SDK-Mesh format is useful for learning, and for creating prototypes, it is a very basic format that might not meet the requirements of most game development.","pos":[34927,35097]},{"content":"We recommend that you use a mesh format that meets the specific requirements of your game.","pos":[35098,35188]},{"pos":[35193,35358],"content":"The following example shows how the <bpt id=\"p1\">**</bpt>MarbleMaze::LoadDeferredResources<ept id=\"p1\">**</ept> method uses the <bpt id=\"p2\">**</bpt>SDKMesh::Create<ept id=\"p2\">**</ept> method to load mesh data for the maze and for the ball.","source":"The following example shows how the **MarbleMaze::LoadDeferredResources** method uses the **SDKMesh::Create** method to load mesh data for the maze and for the ball."},{"content":"Loading collision data","pos":[35684,35706]},{"content":"Although this section does not focus on how Marble Maze implements the physics simulation between the marble and the maze, note that mesh geometry for the physics system is read when the meshes are loaded.","pos":[35708,35913]},{"content":"The way that you load collision data large depends on the run-time format that you use.","pos":[36544,36631]},{"content":"For more information about how Marble Maze loads the collision geometry from an SDK-Mesh file, see the <bpt id=\"p1\">**</bpt>MarbleMaze::ExtractTrianglesFromMesh<ept id=\"p1\">**</ept> method in the source code.","pos":[36632,36802],"source":" For more information about how Marble Maze loads the collision geometry from an SDK-Mesh file, see the **MarbleMaze::ExtractTrianglesFromMesh** method in the source code."},{"content":"Updating game state","pos":[36807,36826]},{"content":"Marble Maze separates game logic from rendering logic by first updating all scene objects before rendering them.","pos":[36829,36941]},{"content":"The document Marble Maze application structure describes the main game loop.","pos":[36943,37019]},{"content":"Updating the scene, which is part of the game loop, happens after Windows events and input are processed and before the scene is rendered.","pos":[37020,37158]},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method handles the update of the UI and the game.","pos":[37159,37235],"source":" The **MarbleMaze::Update** method handles the update of the UI and the game."},{"content":"Updating the user interface","pos":[37241,37268]},{"pos":[37270,37377],"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method calls the <bpt id=\"p2\">**</bpt>UserInterface::Update<ept id=\"p2\">**</ept> method to update the state of the UI.","source":"The **MarbleMaze::Update** method calls the **UserInterface::Update** method to update the state of the UI."},{"pos":[37450,37529],"content":"The <bpt id=\"p1\">**</bpt>UserInterface::Update<ept id=\"p1\">**</ept> method updates each element in the UI collection.","source":"The **UserInterface::Update** method updates each element in the UI collection."},{"content":"Classes that derive from <bpt id=\"p1\">**</bpt>ElementBase<ept id=\"p1\">**</ept> implement the <bpt id=\"p2\">**</bpt>Update<ept id=\"p2\">**</ept> method to perform specific behaviors.","pos":[37742,37845],"source":"Classes that derive from **ElementBase** implement the **Update** method to perform specific behaviors."},{"content":"For example, the <bpt id=\"p1\">**</bpt>StopwatchTimer::Update<ept id=\"p1\">**</ept> method updates the elapsed time by the provided amount and updates the text that it later displays.","pos":[37846,37989],"source":" For example, the **StopwatchTimer::Update** method updates the elapsed time by the provided amount and updates the text that it later displays."},{"content":"Updating the scene","pos":[38274,38292]},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method updates the game based on the current state machine state.","pos":[38294,38386],"source":"The **MarbleMaze::Update** method updates the game based on the current state machine state."},{"content":"When the game is in the active state, Marble Maze updates the camera to follow the marble, updates the view matrix part of the constant buffers, and updates the physics simulation.","pos":[38387,38567]},{"content":"The following example shows how the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method updates the position of the camera.","pos":[38569,38670],"source":"The following example shows how the **MarbleMaze::Update** method updates the position of the camera."},{"content":"Marble Maze uses the <bpt id=\"p1\">**</bpt>m\\_resetCamera<ept id=\"p1\">**</ept> variable to flag that the camera must be reset to be located directly above the marble.","pos":[38671,38798],"source":" Marble Maze uses the **m\\_resetCamera** variable to flag that the camera must be reset to be located directly above the marble."},{"content":"The camera is reset when the game starts or the marble falls through the maze.","pos":[38799,38877]},{"content":"When the main menu or high score display screen is active, the camera is set at a constant location.","pos":[38878,38978]},{"content":"Otherwise, Marble Maze uses the <bpt id=\"p1\">*</bpt>timeDelta<ept id=\"p1\">*</ept> parameter to interpolate the position of the camera between its current and target positions.","pos":[38979,39116],"source":" Otherwise, Marble Maze uses the *timeDelta* parameter to interpolate the position of the camera between its current and target positions."},{"content":"The target position is slightly above and in front of the marble.","pos":[39117,39182]},{"content":"Using the elapsed frame time enables the camera to gradually follow, or chase, the marble.","pos":[39183,39273]},{"content":"The following example shows how the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method updates the constant buffers for the marble and the maze.","pos":[40102,40225],"source":"The following example shows how the **MarbleMaze::Update** method updates the constant buffers for the marble and the maze."},{"content":"The maze’s model, or world, matrix always remains the identity matrix.","pos":[40226,40296]},{"content":"Except for the main diagonal, whose elements are all ones, the identity matrix is a square matrix composed of zeros.","pos":[40297,40413]},{"content":"The marble’s model matrix is based on its position matrix times its rotation matrix.","pos":[40414,40498]},{"content":"The <bpt id=\"p1\">**</bpt>mul<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>translation<ept id=\"p2\">**</ept> functions are defined in BasicMath.h.","pos":[40499,40568],"source":" The **mul** and **translation** functions are defined in BasicMath.h."},{"pos":[40997,41238],"content":"For information about how the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method reads user input and simulates the motion of the marble, see <bpt id=\"p2\">[</bpt>Adding input and interactivity to the Marble Maze sample<ept id=\"p2\">](adding-input-and-interactivity-to-the-marble-maze-sample.md)</ept>.","source":"For information about how the **MarbleMaze::Update** method reads user input and simulates the motion of the marble, see [Adding input and interactivity to the Marble Maze sample](adding-input-and-interactivity-to-the-marble-maze-sample.md)."},{"content":"Rendering the scene","pos":[41243,41262]},{"content":"When a scene is rendered, these steps are typically included.","pos":[41265,41326]},{"content":"Set the current render target depth-stencil buffer.","pos":[41332,41383]},{"content":"Clear the render and stencil views.","pos":[41388,41423]},{"content":"Prepare the vertex and pixel shaders for drawing.","pos":[41428,41477]},{"content":"Render the 3-D objects in the scene.","pos":[41482,41518]},{"content":"Render any 2-D object that you want to appear in front of the scene.","pos":[41523,41591]},{"content":"Present the rendered image to the monitor.","pos":[41596,41638]},{"pos":[41640,41787],"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Render<ept id=\"p1\">**</ept> method binds the render target and depth stencil views, clears those views, draws the scene, and then draws the overlay.","source":"The **MarbleMaze::Render** method binds the render target and depth stencil views, clears those views, draws the scene, and then draws the overlay."},{"content":"Preparing the render targets","pos":[41794,41822]},{"content":"Before you render your scene, you must set the current render target depth-stencil buffer.","pos":[41824,41914]},{"content":"If your scene is not guaranteed to draw over every pixel on the screen, also clear the render and stencil views.","pos":[41915,42027]},{"content":"Marble Maze clears the render and stencil views on every frame to ensure that there are no visible artifacts from the previous frame.","pos":[42028,42161]},{"content":"The following example shows how the <bpt id=\"p1\">**</bpt>MarbleMaze::Render<ept id=\"p1\">**</ept> method calls the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID3D11DeviceContext::OMSetRenderTargets<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476464)</ept> method to set the render target and the depth-stencil buffer as the current ones.","pos":[42163,42427],"source":"The following example shows how the **MarbleMaze::Render** method calls the [**ID3D11DeviceContext::OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464) method to set the render target and the depth-stencil buffer as the current ones."},{"content":"The <bpt id=\"p1\">**</bpt>m\\_renderTargetView<ept id=\"p1\">**</ept> member variable, an <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID3D11RenderTargetView<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</ept> object, and the <bpt id=\"p4\">**</bpt>m\\_depthStencilView<ept id=\"p4\">**</ept> member variable, an <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ID3D11DepthStencilView<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ff476377)</ept> object, are defined and initialized by the <bpt id=\"p7\">**</bpt>DirectXBase<ept id=\"p7\">**</ept> class.","pos":[42428,42781],"source":" The **m\\_renderTargetView** member variable, an [**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582) object, and the **m\\_depthStencilView** member variable, an [**ID3D11DepthStencilView**](https://msdn.microsoft.com/library/windows/desktop/ff476377) object, are defined and initialized by the **DirectXBase** class."},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11RenderTargetView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DepthStencilView<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476377)</ept> interfaces support the texture view mechanism that is provided by Direct3D 10 and later.","pos":[43265,43541],"source":"The [**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582) and [**ID3D11DepthStencilView**](https://msdn.microsoft.com/library/windows/desktop/ff476377) interfaces support the texture view mechanism that is provided by Direct3D 10 and later."},{"content":"For more information about texture views, see <bpt id=\"p1\">[</bpt>Texture Views (Direct3D 10)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb205128)</ept>.","pos":[43542,43679],"source":" For more information about texture views, see [Texture Views (Direct3D 10)](https://msdn.microsoft.com/library/windows/desktop/bb205128)."},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>OMSetRenderTargets<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476464)</ept> method prepares the output-merger stage of the Direct3D pipeline.","pos":[43680,43835],"source":" The [**OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464) method prepares the output-merger stage of the Direct3D pipeline."},{"content":"For more information about the output-merger stage, see <bpt id=\"p1\">[</bpt>Output-Merger Stage<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb205120)</ept>.","pos":[43836,43975],"source":" For more information about the output-merger stage, see [Output-Merger Stage](https://msdn.microsoft.com/library/windows/desktop/bb205120)."},{"content":"Preparing the vertex and pixel shaders","pos":[43981,44019]},{"content":"Before you render the scene objects, perform the following steps to prepare the vertex and pixel shaders for drawing:","pos":[44021,44138]},{"content":"Set the shader input layout as the current layout.","pos":[44144,44194]},{"content":"Set the vertex and pixel shaders as the current shaders.","pos":[44199,44255]},{"content":"Update any constant buffers with data that you have to pass to the shaders.","pos":[44260,44335]},{"content":"<bpt id=\"p1\">**</bpt>Important<ept id=\"p1\">**</ept>  Marble Maze uses one pair of vertex and pixel shaders for all 3-D objects.","pos":[44339,44428],"source":"**Important**  Marble Maze uses one pair of vertex and pixel shaders for all 3-D objects."},{"content":"If your game uses more than one pair of shaders, you must perform these steps each time you draw objects that use different shaders.","pos":[44429,44561]},{"content":"To reduce the overhead that is associated with changing the shader state, we recommend that you group render calls for all objects that use the same shaders.","pos":[44562,44719]},{"content":"The section <bpt id=\"p1\">[</bpt>Loading shaders<ept id=\"p1\">](#loading_shaders)</ept> in this document describes how the input layout is created when the vertex shader is created.","pos":[44724,44865],"source":"The section [Loading shaders](#loading_shaders) in this document describes how the input layout is created when the vertex shader is created."},{"content":"The following example shows how the <bpt id=\"p1\">**</bpt>MarbleMaze::Render<ept id=\"p1\">**</ept> method uses the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID3D11DeviceContext::IASetInputLayout<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476454)</ept> method to set this layout as the current layout.","pos":[44866,45094],"source":" The following example shows how the **MarbleMaze::Render** method uses the [**ID3D11DeviceContext::IASetInputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476454) method to set this layout as the current layout."},{"pos":[45161,45521],"content":"The following example shows how the <bpt id=\"p1\">**</bpt>MarbleMaze::Render<ept id=\"p1\">**</ept> method uses the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID3D11DeviceContext::VSSetShader<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</ept> and <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>ID3D11DeviceContext::PSSetShader<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</ept> methods to set the vertex and pixel shaders as the current shaders, respectively.","source":"The following example shows how the **MarbleMaze::Render** method uses the [**ID3D11DeviceContext::VSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476493) and [**ID3D11DeviceContext::PSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476472) methods to set the vertex and pixel shaders as the current shaders, respectively."},{"content":"After the <bpt id=\"p1\">**</bpt>MarbleMaze::Render<ept id=\"p1\">**</ept> sets the shaders and their input layout, it uses the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID3D11DeviceContext::UpdateSubresource<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476486)</ept> method to update the constant buffer with the model, view, and projection matrices for the maze.","pos":[46231,46519],"source":"After the **MarbleMaze::Render** sets the shaders and their input layout, it uses the [**ID3D11DeviceContext::UpdateSubresource**](https://msdn.microsoft.com/library/windows/desktop/ff476486) method to update the constant buffer with the model, view, and projection matrices for the maze."},{"content":"The <bpt id=\"p1\">**</bpt>UpdateSubresource<ept id=\"p1\">**</ept> method copies the matrix data from CPU memory to GPU memory.","pos":[46520,46606],"source":" The **UpdateSubresource** method copies the matrix data from CPU memory to GPU memory."},{"content":"Recall that the model and view components of the <bpt id=\"p1\">**</bpt>ConstantBuffer<ept id=\"p1\">**</ept> structure are updated in the <bpt id=\"p2\">**</bpt>MarbleMaze::Update<ept id=\"p2\">**</ept> method.","pos":[46607,46734],"source":" Recall that the model and view components of the **ConstantBuffer** structure are updated in the **MarbleMaze::Update** method."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Render<ept id=\"p1\">**</ept> method then calls the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID3D11DeviceContext::VSSetConstantBuffers<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476491)</ept> and <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>ID3D11DeviceContext::PSSetConstantBuffers<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/desktop/ff476470)</ept> methods to set this constant buffer as the current one.","pos":[46735,47061],"source":" The **MarbleMaze::Render** method then calls the [**ID3D11DeviceContext::VSSetConstantBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476491) and [**ID3D11DeviceContext::PSSetConstantBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476470) methods to set this constant buffer as the current one."},{"pos":[47712,47806],"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Render<ept id=\"p1\">**</ept> method performs similar steps to prepare the marble to be rendered.","source":"The **MarbleMaze::Render** method performs similar steps to prepare the marble to be rendered."},{"content":"Rendering the maze and the marble","pos":[47812,47845]},{"content":"After you activate the current shaders, you can draw your scene objects.","pos":[47847,47919]},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Render<ept id=\"p1\">**</ept> method calls the <bpt id=\"p2\">**</bpt>SDKMesh::Render<ept id=\"p2\">**</ept> method to render the maze mesh.","pos":[47920,48015],"source":" The **MarbleMaze::Render** method calls the **SDKMesh::Render** method to render the maze mesh."},{"pos":[48115,48193],"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Render<ept id=\"p1\">**</ept> method performs similar steps to render the marble.","source":"The **MarbleMaze::Render** method performs similar steps to render the marble."},{"content":"As mentioned earlier in this document, the <bpt id=\"p1\">**</bpt>SDKMesh<ept id=\"p1\">**</ept> class is provided for demonstration purposes, but we do not recommend it for use in a production-quality game.","pos":[48195,48360],"source":"As mentioned earlier in this document, the **SDKMesh** class is provided for demonstration purposes, but we do not recommend it for use in a production-quality game."},{"content":"However, notice that the <bpt id=\"p1\">**</bpt>SDKMesh::RenderMesh<ept id=\"p1\">**</ept> method, which is called by <bpt id=\"p2\">**</bpt>SDKMesh::Render<ept id=\"p2\">**</ept>, uses the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext::IASetVertexBuffers<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476456)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ID3D11DeviceContext::IASetIndexBuffer<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ff476453)</ept> methods to set the current vertex and index buffers that define the mesh, and the <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>ID3D11DeviceContext::DrawIndexed<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/desktop/ff476410)</ept> method to draw the buffers.","pos":[48361,48892],"source":" However, notice that the **SDKMesh::RenderMesh** method, which is called by **SDKMesh::Render**, uses the [**ID3D11DeviceContext::IASetVertexBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476456) and [**ID3D11DeviceContext::IASetIndexBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476453) methods to set the current vertex and index buffers that define the mesh, and the [**ID3D11DeviceContext::DrawIndexed**](https://msdn.microsoft.com/library/windows/desktop/ff476410) method to draw the buffers."},{"content":"For more information about how to work with vertex and index buffers, see <bpt id=\"p1\">[</bpt>Introduction to Buffers in Direct3D 11<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476898)</ept>.","pos":[48893,49069],"source":" For more information about how to work with vertex and index buffers, see [Introduction to Buffers in Direct3D 11](https://msdn.microsoft.com/library/windows/desktop/ff476898)."},{"content":"Drawing the user interface and overlay","pos":[49075,49113]},{"content":"After drawing 3-D scene objects, Marble Maze draws the 2-D UI elements that appear in front of the scene.","pos":[49115,49220]},{"pos":[49222,49307],"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Render<ept id=\"p1\">**</ept> method ends by drawing the user interface and the overlay.","source":"The **MarbleMaze::Render** method ends by drawing the user interface and the overlay."},{"content":"The <bpt id=\"p1\">**</bpt>UserInterface::Render<ept id=\"p1\">**</ept> method uses an <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID2D1DeviceContext<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/hh404479)</ept> object to draw the UI elements.","pos":[49432,49594],"source":"The **UserInterface::Render** method uses an [**ID2D1DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/hh404479) object to draw the UI elements."},{"content":"This method sets the drawing state, draws all active UI elements, and then restores the previous drawing state.","pos":[49595,49706]},{"pos":[50220,50309],"content":"The <bpt id=\"p1\">**</bpt>SampleOverlay::Render<ept id=\"p1\">**</ept> method uses a similar technique to draw the overlay bitmap.","source":"The **SampleOverlay::Render** method uses a similar technique to draw the overlay bitmap."},{"content":"Presenting the scene","pos":[50316,50336]},{"content":"After drawing all 2-D and 3-D scene objects, Marble Maze presents the rendered image to the monitor.","pos":[50338,50438]},{"content":"It synchronizes drawing to the vertical blank to ensure that time is not spent time drawing frames that will never be actually shown on the display.","pos":[50439,50587]},{"content":"Marble Maze also handles device changes when it presents the scene.","pos":[50588,50655]},{"content":"After the <bpt id=\"p1\">**</bpt>MarbleMaze::Render<ept id=\"p1\">**</ept> method returns, the game loop calls the <bpt id=\"p2\">**</bpt>MarbleMaze::Present<ept id=\"p2\">**</ept> method to send the rendered image to the monitor or display.","pos":[50657,50814],"source":"After the **MarbleMaze::Render** method returns, the game loop calls the **MarbleMaze::Present** method to send the rendered image to the monitor or display."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze<ept id=\"p1\">**</ept> class does not override the <bpt id=\"p2\">**</bpt>DirectXBase::Present<ept id=\"p2\">**</ept> method.","pos":[50815,50894],"source":" The **MarbleMaze** class does not override the **DirectXBase::Present** method."},{"content":"The <bpt id=\"p1\">**</bpt>DirectXBase::Present<ept id=\"p1\">**</ept> method calls <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>IDXGISwapChain1::Present<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</ept> to perform the present operation, as shown in the following example:","pos":[50895,51097],"source":" The **DirectXBase::Present** method calls [**IDXGISwapChain1::Present**](https://msdn.microsoft.com/library/windows/desktop/hh446797) to perform the present operation, as shown in the following example:"},{"content":"In this example, <bpt id=\"p1\">**</bpt>m\\_swapChain<ept id=\"p1\">**</ept> is an <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>IDXGISwapChain1<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/hh404631)</ept> object.","pos":[51753,51883],"source":"In this example, **m\\_swapChain** is an [**IDXGISwapChain1**](https://msdn.microsoft.com/library/windows/desktop/hh404631) object."},{"content":"The initialization of this object is described in the section <bpt id=\"p1\">[</bpt>Initializing Direct3D and Direct2D<ept id=\"p1\">](#initializing)</ept> in this document.","pos":[51884,52015],"source":" The initialization of this object is described in the section [Initializing Direct3D and Direct2D](#initializing) in this document."},{"content":"The first parameter to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1::Present<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</ept>, <bpt id=\"p3\">*</bpt>SyncInterval<ept id=\"p3\">*</ept>, specifies the number of vertical blanks to wait before presenting the frame.","pos":[52017,52225],"source":"The first parameter to [**IDXGISwapChain1::Present**](https://msdn.microsoft.com/library/windows/desktop/hh446797), *SyncInterval*, specifies the number of vertical blanks to wait before presenting the frame."},{"content":"Marble Maze specifies 1 so that it waits until the next vertical blank.","pos":[52226,52297]},{"content":"A vertical blank is the time between when one frame finishes drawing to the monitor and the next frame begins.","pos":[52298,52408]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1::Present1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</ept> method returns an error code that indicates that the device was removed or otherwise failed.","pos":[52410,52599],"source":"The [**IDXGISwapChain1::Present1**](https://msdn.microsoft.com/library/windows/desktop/hh446797) method returns an error code that indicates that the device was removed or otherwise failed."},{"content":"In this case, Marble Maze reinitializes the device.","pos":[52600,52651]},{"content":"Next steps","pos":[52905,52915]},{"content":"Read <bpt id=\"p1\">[</bpt>Adding input and interactivity to the Marble Maze sample<ept id=\"p1\">](adding-input-and-interactivity-to-the-marble-maze-sample.md)</ept> for information about some of the key practices to keep in mind when you work with input devices.","pos":[52918,53140],"source":"Read [Adding input and interactivity to the Marble Maze sample](adding-input-and-interactivity-to-the-marble-maze-sample.md) for information about some of the key practices to keep in mind when you work with input devices."},{"content":"This document discusses how Marble Maze supports touch, accelerometer, Xbox 360 controller, and mouse input.","pos":[53141,53249]},{"content":"Related topics","pos":[53254,53268]},{"content":"Adding input and interactivity to the Marble Maze sample","pos":[53274,53330]},{"content":"Marble Maze application structure","pos":[53396,53429]},{"content":"Developing Marble Maze, a UWP game in C++ and DirectX","pos":[53472,53525]}],"content":"---\ntitle: Adding visual content to the Marble Maze sample\ndescription: This document describes how the Marble Maze game uses Direct3D and Direct2D in the Universal Windows Platform (UWP) app environment so that you can learn the patterns and adapt them when you work with your own game content.\nms.assetid: 6e43422e-e1a1-b79e-2c4b-7d5b4fa88647\n---\n\n# Adding visual content to the Marble Maze sample\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\nThis document describes how the Marble Maze game uses Direct3D and Direct2D in the Universal Windows Platform (UWP) app environment so that you can learn the patterns and adapt them when you work with your own game content. To learn how visual game components fit in the overall application structure of Marble Maze, see [Marble Maze application structure](marble-maze-application-structure.md).\n\nWe followed these basic steps as we developed the visual aspects of Marble Maze:\n\n1.  Create a basic framework that initializes the Direct3D and Direct2D environments.\n2.  Use image and model editing programs to design the 2-D and 3-D assets that appear in the game.\n3.  Ensure that 2-D and 3-D assets properly load and appear in the game.\n4.  Integrate vertex and pixel shaders that enhance the visual quality of the game assets.\n5.  Integrate game logic, such as animation and user input.\n\nWe also focused first on adding 3-D assets and then on 2-D assets. For example, we focused on core game logic before we added the menu system and timer.\n\nWe also needed to iterate through some of these steps multiple times during the development process. For example, as we make changes to the mesh and marble models, we had to also change some of the shader code that supports those models.\n\n> **Note**   The sample code that corresponds to this document is found in the [DirectX Marble Maze game sample](http://go.microsoft.com/fwlink/?LinkId=624011).\n\n \nHere are some of the key points that this document discusses for when you work with DirectX and visual game content, namely, when you initialize the DirectX graphics libraries, load scene resources, and update and render the scene:\n\n-   Adding game content typically involves many steps. These steps also often require iteration. Game developers often focus first on adding 3-D game content and then on adding 2-D content.\n-   Reach more customers and give them all a great experience by supporting the greatest range of graphics hardware as possible.\n-   Cleanly separate design-time and run-time formats. Structure your design-time assets to maximize flexibility and enable rapid iterations on content. Format and compress your assets to load and render as efficiently as possible at run time.\n-   You create the Direct3D and Direct2D devices in a UWP app much like you do in a classic Windows desktop app. One important difference is how the swap chain is associated with the output window.\n-   When you design your game, ensure that the mesh format that you choose supports your key scenarios. For example, if your game requires collision, make sure that you can obtain collision data from your meshes.\n-   Separate game logic from rendering logic by first updating all scene objects before you render them.\n-   You typically draw your 3-D scene objects, and then any 2-D objects that appear in front of the scene.\n-   Synchronize drawing to the vertical blank to ensure that your game does not spend time drawing frames that will never be actually shown on the display.\n\n## Getting started with DirectX graphics\n\n\nWhen we planned the Marble Maze Universal Windows Platform (UWP) game, we chose C++ and Direct3D 11.1 because they are the best choices for creating 3-D games that require maximum control over rendering and high performance. DirectX 11.1 supports hardware from DirectX 9 to DirectX 11, and therefore can help you reach more customers more efficiently because you don't have to rewrite code for each of the earlier DirectX versions.\n\nMarble Maze uses Direct3D 11.1 to render the 3-D game assets, namely the marble and the maze. Marble Maze also uses Direct2D, DirectWrite, and Windows Imaging Component (WIC) to draw the 2-D game assets, such as the menus and the timer. Finally, Marble Maze uses XAML to provide an app bar and allows you to add XAML controls.\n\nGame development requires planning. If you are new to DirectX graphics, we recommend that you read Creating a DirectX game to familiarize yourself with the basic concepts of creating a UWP DirectX game. As you read this document and work through the Marble Maze source code, you can refer to the following resources for more in-depth information about DirectX graphics.\n\n-   [Direct3D 11 Graphics](https://msdn.microsoft.com/library/windows/desktop/ff476080) Describes Direct3D 11, a powerful, hardware-accelerated 3-D graphics API for rendering 3-D geometry on the Windows platform.\n-   [Direct2D](https://msdn.microsoft.com/library/windows/desktop/dd370990) Describes Direct2D, a hardware-accelerated, 2-D graphics API that provides high performance and high-quality rendering for 2-D geometry, bitmaps, and text.\n-   [DirectWrite](https://msdn.microsoft.com/library/windows/desktop/dd368038) Describes DirectWrite, which supports high-quality text rendering.\n-   [Windows Imaging Component](https://msdn.microsoft.com/library/windows/desktop/ee719902) Describes WIC, an extensible platform that provides low-level API for digital images.\n\n### Feature levels\n\nDirect3D 11 introduces a paradigm named feature levels. A feature level is a well-defined set of GPU functionality. Use feature levels to target your game to run on earlier versions of Direct3D hardware. Marble Maze supports feature level 9.1 because it requires no advanced features from the higher levels. We recommend that you support the greatest range of hardware possible and scale your game content so that your customers that have either high or low-end computers all have a great experience. For more information about feature levels, see [Direct3D 11 on Downlevel Hardware](https://msdn.microsoft.com/library/windows/desktop/ff476872).\n\n## Initializing Direct3D and Direct2D\n\n\nA device represents the display adapter. You create the Direct3D and Direct2D devices in a UWP app much like you do in a classic Windows desktop app. The main difference is how you connect the Direct3D swap chain to the windowing system.\n\nThe *DirectX 11 and XAML App (Universal Windows)* factors out some generic operating system and 3-D rendering functions from the game-specific functions. The **DeviceResources** class is a foundation for managing Direct3D and Direct2D. This class handles general infrastructure, and not game-specific assets. Marble Maze defines the **MarbleMaze** class to handle game-specific assets, which has a reference to a **DeviceResources** object to give it access to Direct3D and Direct2D.\n\nDuring initialization, the **DeviceResources::Initialize** method creates device-independent resources and the Direct3D and Direct2D devices.\n\n```cpp\n// Initialize the Direct3D resources required to run. \nvoid DeviceResources::DeviceResources(CoreWindow^ window, float dpi)\n{\n    m_window = window;\n\n    CreateDeviceIndependentResources();\n    CreateDeviceResources();\n    CreateWindowSizeDependentResources();\n    SetDpi(dpi);\n}\n```\n\nThe **DeviceResources** class separates this functionality so that it can more easily respond when the environment changes. For example, it calls the **CreateWindowSizeDependentResources** method when the window size changes.\n\n###  Initializing the Direct2D, DirectWrite, and WIC factories\n\nThe **DeviceResources::CreateDeviceIndependentResources** method creates the factories for Direct2D, DirectWrite, and WIC. In DirectX graphics, factories are the starting points for creating graphics resources. Marble Maze specifies **D2D1\\_FACTORY\\_TYPE\\_SINGLE\\_THREADED** because it performs all drawing on the main thread.\n\n```cpp\n// These are the resources required independent of hardware. \nvoid DeviceResources::CreateDeviceIndependentResources()\n{\n    D2D1_FACTORY_OPTIONS options;\n    ZeroMemory(&options, sizeof(D2D1_FACTORY_OPTIONS));\n\n#if defined(_DEBUG)\n     // If the project is in a debug build, enable Direct2D debugging via SDK Layers.\n    options.debugLevel = D2D1_DEBUG_LEVEL_INFORMATION;\n#endif\n\n    DX::ThrowIfFailed(\n        D2D1CreateFactory(\n            D2D1_FACTORY_TYPE_SINGLE_THREADED,\n            __uuidof(ID2D1Factory1),\n            &options,\n            &m_d2dFactory\n            )\n        );\n\n    DX::ThrowIfFailed(\n        DWriteCreateFactory(\n            DWRITE_FACTORY_TYPE_SHARED,\n            __uuidof(IDWriteFactory),\n            &m_dwriteFactory\n            )\n        );\n\n    DX::ThrowIfFailed(\n        CoCreateInstance(\n            CLSID_WICImagingFactory,\n            nullptr,\n            CLSCTX_INPROC_SERVER,\n            IID_PPV_ARGS(&m_wicFactory)\n            )\n        );\n}\n```\n\n###  Creating the Direct3D and Direct2D devices\n\nThe **DeviceResources::CreateDeviceResources** method calls [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) to create the device object that represents the Direct3D display adapter. Because Marble Maze supports feature level 9.1 and above, the **DeviceResources::CreateDeviceResources** method specifies levels 9.1 through 11.1 in the array of **\\\\** values. Direct3D walks the list in order and gives the app the first feature level that is available. Therefore the **D3D\\_FEATURE\\_LEVEL** array entries are listed from highest to lowest so that the app will get the highest level feature level available. The **DeviceResources::CreateDeviceResources** method obtains the Direct3D 11.1 device by querying the Direct3D 11 device that's returned from **D3D11CreateDevice**.\n\n```cpp\n// This array defines the set of DirectX hardware feature levels this app will support. \n// Note the ordering should be preserved. \n// Don't forget to declare your application's minimum required feature level in its \n// description.  All applications are assumed to support 9.1 unless otherwise stated.\nD3D_FEATURE_LEVEL featureLevels[] = \n{\n    D3D_FEATURE_LEVEL_11_1,\n    D3D_FEATURE_LEVEL_11_0,\n    D3D_FEATURE_LEVEL_10_1,\n    D3D_FEATURE_LEVEL_10_0,\n    D3D_FEATURE_LEVEL_9_3,\n    D3D_FEATURE_LEVEL_9_2,\n    D3D_FEATURE_LEVEL_9_1\n};\n\n// Create the DX11 API device object, and get a corresponding context.\nComPtr<ID3D11Device> device;\nComPtr<ID3D11DeviceContext> context;\nDX::ThrowIfFailed(\n    D3D11CreateDevice(\n        nullptr,                    // Specify null to use the default adapter.\n        D3D_DRIVER_TYPE_HARDWARE,\n        0,                          // Leave as 0 unless it is a software device.\n        creationFlags,              // Optionally, set debug and Direct2D compatibility flags.\n        featureLevels,              // A list of feature levels that this app can support.\n        ARRAYSIZE(featureLevels),   // The number of entries in the above list.\n        D3D11_SDK_VERSION,          // Always set this to D3D11_SDK_VERSION for modern.\n        &device,                    // Returns the Direct3D device created.\n        &m_featureLevel,            // Returns the feature level of the device created.\n        &context                    // Returns the device immediate context.\n        )\n    );    \n\n// Get the Direct3D 11.1 device by querying the Direct3D 11 device.\nDX::ThrowIfFailed(\n    device.As(&m_d3dDevice)\n    );\n```\n\nThe **DeviceResources::CreateDeviceResources** method then creates the Direct2D device. Direct2D uses Microsoft DirectX Graphics Infrastructure (DXGI) to interoperate with Direct3D. DXGI enables video memory surfaces to be shared between graphics runtimes. Marble Maze uses the underlying DXGI device from the Direct3D device to create the Direct2D device from the Direct2D factory.\n\n```cpp\n// Obtain the underlying DXGI device of the Direct3D 11.1 device.\nDX::ThrowIfFailed(\n    m_d3dDevice.As(&dxgiDevice)\n    );\n\n// Obtain the Direct2D device for 2-D rendering.\nDX::ThrowIfFailed(\n    m_d2dFactory->CreateDevice(dxgiDevice.Get(), &m_d2dDevice)\n    );\n\n// And get its corresponding device context object.\nDX::ThrowIfFailed(\n    m_d2dDevice->CreateDeviceContext(\n        D2D1_DEVICE_CONTEXT_OPTIONS_NONE,\n        &m_d2dContext\n        )\n    );\n```\n\n```cpp\n// Obtain the underlying DXGI device of the Direct3D 11.1 device.\nDX::ThrowIfFailed(\n    m_d3dDevice.As(&dxgiDevice)\n    );\n\n// Obtain the Direct2D device for 2-D rendering.\nDX::ThrowIfFailed(\n    m_d2dFactory->CreateDevice(dxgiDevice.Get(), &m_d2dDevice)\n    );\n\n// And get its corresponding device context object.\nDX::ThrowIfFailed(\n    m_d2dDevice->CreateDeviceContext(\n        D2D1_DEVICE_CONTEXT_OPTIONS_NONE,\n        &m_d2dContext\n        )\n    );\n```\n\nFor more information about DXGI and interoperability between Direct2D and Direct3D, see [DXGI Overview](https://msdn.microsoft.com/library/windows/desktop/bb205075) and [Direct2D and Direct3D Interoperability Overview](https://msdn.microsoft.com/library/windows/desktop/dd370966).\n\n### Associating Direct3D with the view\n\nThe **DeviceResources::CreateWindowSizeDependentResources** method creates the graphics resources that depend on a given window size such as the swap chain and Direct3D and Direct2D render targets. One important way that a DirectX UWP app differs from a desktop app is how the swap chain is associated with the output window. A swap chain is responsible for displaying the buffer to which the device renders on the monitor. The document Marble Maze application structure describes how the windowing system for a UWP app differs from a desktop app. Because a Windows Store app does not work with **HWND** objects, Marble Maze must use the [**IDXGIFactory2::CreateSwapChainForCoreWindow**](https://msdn.microsoft.com/library/windows/desktop/hh404559) method to associate the device output to the view. The following example shows the part of the **DeviceResources::CreateWindowSizeDependentResources** method that creates the swap chain.\n\n```cpp\n// Obtain the final swap chain for this window from the DXGI factory.\nDX::ThrowIfFailed(\n    dxgiFactory->CreateSwapChainForCoreWindow(\n        m_d3dDevice.Get(),\n        reinterpret_cast<IUnknown*>(m_window),\n        &swapChainDesc,\n        nullptr,    // Allow on all displays.\n        &m_swapChain\n        )\n    );\n```\n\nTo minimize power consumption, which is important to do on battery-powered devices such as laptops and tablets, the **DeviceResources::CreateWindowSizeDependentResources** method calls the [**IDXGIDevice1::SetMaximumFrameLatency**](https://msdn.microsoft.com/library/windows/desktop/ff471334) method to ensure that the game is rendered only after the vertical blank. Synchronizing with the vertical blank is described in greater detail in the section Presenting the scene in this document.\n\n```cpp\n// Ensure that DXGI does not queue more than one frame at a time. This both reduces  \n// latency and ensures that the application will only render after each VSync, minimizing  \n// power consumption.\nDX::ThrowIfFailed(\n    dxgiDevice->SetMaximumFrameLatency(1)\n    );\n```\n\nThe **DeviceResources::CreateWindowSizeDependentResources** method initializes graphics resources in a way that works for most games.\n\n> **Note**   The term *view* has a different meaning in the Windows Runtime than it has in Direct3D. In the Windows Runtime, a view refers to the collection of user interface settings for an app, including the display area and the input behaviors, plus the thread it uses for processing. You specify the configuration and settings you need when you create a view. The process of setting up the app view is described in [Marble Maze application structure](marble-maze-application-structure.md). In Direct3D, the term view has multiple meanings. First, a resource view defines the subresources that a resource can access. For example, when a texture object is associated with a shader resource view, that shader can later access the texture. One advantage of a resource view is that you can interpret data in different ways at different stages in the rendering pipeline. For more information about resource views, see [Texture Views (Direct3D 10)](https://msdn.microsoft.com/library/windows/desktop/bb205128). When used in the context of a view transform or view transform matrix, view refers to the location and orientation of the camera. A view transform relocates objects in the world around the camera’s position and orientation. For more information about view transforms, see [View Transform (Direct3D 9)](https://msdn.microsoft.com/library/windows/desktop/bb206342). How Marble Maze uses resource and matrix views is described in greater detail in this topic.\n\n \n\n## Loading scene resources\n\n\nMarble Maze uses the **BasicLoader** class, which is declared in BasicLoader.h, to load textures and shaders. Marble Maze uses the **SDKMesh** class to load the 3-D meshes for the maze and the marble.\n\nTo ensure a responsive app, Marble Maze loads scene resources asynchronously, or in the background. As assets load in the background, your game can respond to window events. This process is explained in greater detail in [Loading game assets in the background](marble-maze-application-structure.md#loading_game_assets) in this guide.\n\n###  Loading the 2-D overlay and user interface\n\nIn Marble Maze, the overlay is the image that appears at the top of the screen. The overlay always appears in front of the scene. In Marble Maze, the overlay contains the Windows logo and the text string \"DirectX Marble Maze game sample\". The management of the overlay is performed by the **SampleOverlay** class, which is defined in SampleOverlay.h. Although we use the overlay as part of the Direct3D samples, you can adapt this code to display any image that appears in front of your scene.\n\nOne important aspect of the overlay is that, because its contents do not change, the **SampleOverlay** class draws, or caches, its contents to an [**ID2D1Bitmap1**](https://msdn.microsoft.com/library/windows/desktop/hh404349) object during initialization. At draw time, the **SampleOverlay** class only has to draw the bitmap to the screen. In this way, expensive routines such as text drawing do not have to be performed for every frame.\n\nThe user interface (UI) consists of 2-D components, such as menus and heads-up displays (HUDs), which appear in front of your scene. Marble Maze defines the following UI elements:\n\n-   Menu items that enable the user to start the game or view high scores.\n-   A timer that counts down for three seconds before play begins.\n-   A timer that tracks the elapsed play time.\n-   A table that lists the fastest finish times.\n-   Text that reads \"Paused\" when the game is paused.\n\nMarble Maze defines game-specific UI elements in UserInterface.h. Marble Maze defines the **ElementBase** class as a base type for all UI elements. The **ElementBase** class defines attributes such as the size, position, alignment, and visibility of a UI element. It also controls how elements are updated and rendered.\n\n```cpp\nclass ElementBase\n{\npublic:\n    virtual void Initialize() { }\n    virtual void Update(float timeTotal, float timeDelta) { }\n    virtual void Render() { }\n\n    void SetAlignment(AlignType horizontal, AlignType vertical);\n    virtual void SetContainer(const D2D1_RECT_F& container);\n    void SetVisible(bool visible);\n\n    D2D1_RECT_F GetBounds();\n\n    bool IsVisible() const { return m_visible; }\n\nprotected:\n    ElementBase();\n\n    virtual void CalculateSize() { }\n\n    Alignment       m_alignment;\n    D2D1_RECT_F     m_container;\n    D2D1_SIZE_F     m_size;\n    bool            m_visible;\n};\n```\n\nBy providing a common base class for UI elements, the **UserInterface** class, which manages the user interface, need only hold a collection of **ElementBase** objects, which simplifies UI management and provides a user interface manager that is reusable. Marble Maze defines types that derive from **ElementBase** that implement game-specific behaviors. For example, **HighScoreTable** defines the behavior for the high score table. For more info about these types, refer to the source code.\n\n> **Note**   Because XAML enables you to more easily create complex user interfaces, like those found in simulation and strategy games, consider whether to use XAML to define your UI. For info about how to develop a user interface in XAML in a DirectX UWP game, see [Extend the game sample (Windows)](tutorial-resources.md). This document refers to the DirectX 3-D shooting game sample.\n\n \n\n###  Loading shaders\n\nMarble Maze uses the **BasicLoader::LoadShader** method to load a shader from a file.\n\nShaders are the fundamental unit of GPU programming in games today. Nearly all 3-D graphics processing is driven through shaders, whether it is model transformation and scene lighting, or more complex geometry processing, from character skinning to tessellation. For more information about the shader programming model, see [HLSL](https://msdn.microsoft.com/library/windows/desktop/bb509561).\n\nMarble Maze uses vertex and pixel shaders. A vertex shader always operates on one input vertex and produces one vertex as output. A pixel shader takes numeric values, texture data, interpolated per-vertex values, and other data to produce a pixel color as output. Because a shader transforms one element at a time, graphics hardware that provides multiple shader pipelines can process sets of elements in parallel. The number of parallel pipelines that are available to the GPU can be vastly greater than the number that is available to the CPU. Therefore, even basic shaders can greatly improve throughput.\n\nThe **MarbleMaze::LoadDeferredResources** method loads one vertex shader and one pixel shader after it loads the overlay. The design-time versions of these shaders are defined in BasicVertexShader.hlsl and BasicPixelShader.hlsl, respectively. Marble Maze applies these shaders to both the ball and the maze during the rendering phase.\n\nThe Marble Maze project includes both .hlsl (the design-time format) and .cso (the run-time format) versions of the shader files. At build time, Visual Studio uses the fxc.exe effect-compiler to compile your .hlsl source file into a .cso binary shader. For more information about the effect-compiler tool, see [Effect-Compiler Tool](https://msdn.microsoft.com/library/windows/desktop/bb232919).\n\nThe vertex shader uses the supplied model, view and projection matrices to transform the input geometry. Position data from the input geometry is transformed and output twice: once in screen space, which is necessary for rendering, and again in world space to enable the pixel shader to perform lighting calculations. The surface normal vector is transformed to world space, which is also used by the pixel shader for lighting. The texture coordinates are passed through unchanged to the pixel shader.\n\n```hlsl\nsPSInput main(sVSInput input)\n{\n    sPSInput output;\n    float4 temp = float4(input.pos, 1.0f);\n    temp = mul(temp, model);\n    output.worldPos = temp.xyz / temp.w;\n    temp = mul(temp, view);\n    temp = mul(temp, projection);\n    output.pos = temp;\n    output.tex = input.tex;\n    output.norm = mul(float4(input.norm, 0.0f), model).xyz;\n    return output;\n}\n```\n\nThe pixel shader receives the output of the vertex shader as input. This shader performs lighting calculations to mimic a soft-edged spotlight that hovers over the maze and is aligned with the position of the marble. Lighting is strongest for surfaces that point directly toward the light. The diffuse component tapers off to zero as the surface normal becomes perpendicular to the light, and the ambient term diminishes as the normal points away from the light. Points closer to the marble (and therefore closer to the center of the spotlight) are lit more strongly. However, lighting is modulated for points underneath the marble to simulate a soft shadow. In a real environment, an object like the white marble would diffusely reflect the spotlight onto other objects in the scene. This is approximated for the surfaces that are in view of the bright half of the marble. The additional illumination factors are in relative angle and distance to the marble. The resulting pixel color is a composition of the sampled texture with the result of the lighting calculations.\n\n```hlsl\nfloat4 main(sPSInput input) : SV_TARGET\n{\n    float3 lightDirection = float3(0, 0, -1);\n    float3 ambientColor = float3(0.43, 0.31, 0.24);\n    float3 lightColor = 1 - ambientColor;\n    float spotRadius = 50;\n\n    // Basic ambient (Ka) and diffuse (Kd) lighting from above.\n    float3 N = normalize(input.norm);\n    float NdotL = dot(N, lightDirection);\n    float Ka = saturate(NdotL + 1);\n    float Kd = saturate(NdotL);\n\n    // Spotlight.\n    float3 vec = input.worldPos - marblePosition;\n    float dist2D = sqrt(dot(vec.xy, vec.xy));\n    Kd = Kd * saturate(spotRadius / dist2D);\n\n    // Shadowing from ball.\n    if (input.worldPos.z > marblePosition.z)\n        Kd = Kd * saturate(dist2D / (marbleRadius * 1.5));\n\n    // Diffuse reflection of light off ball.\n    float dist3D = sqrt(dot(vec, vec));\n    float3 V = normalize(vec);\n    Kd += saturate(dot(-V, N)) * saturate(dot(V, lightDirection))\n        * saturate(marbleRadius / dist3D);\n\n    // Final composite.\n    float4 diffuseTexture = Texture.Sample(Sampler, input.tex);\n    float3 color = diffuseTexture.rgb * ((ambientColor * Ka) + (lightColor * Kd));\n    return float4(color * lightStrength, diffuseTexture.a);\n}\n```\n\n> **Caution**  The compiled pixel shader contains 32 arithmetic instructions and 1 texture instruction. This shader should perform well on desktop computers and higher-end tablets. However, a lower-end computer might not be able to process this shader and still provide an interactive frame rate. Consider the typical hardware of your target audience and design your shaders to meet the capabilities of that hardware.\n\n \n\nThe **MarbleMaze::LoadDeferredResources** method uses the **BasicLoader::LoadShader** method to load the shaders. The following example loads the vertex shader. The run-time format for this shader is BasicVertexShader.cso. The **m\\_vertexShader** member variable is an [**ID3D11VertexShader**](https://msdn.microsoft.com/library/windows/desktop/ff476641) object.\n\n```cpp\n\\loader->LoadShader(\n    L\"BasicVertexShader.cso\",\n    layoutDesc,\n    ARRAYSIZE(layoutDesc),\n    &m_vertexShader,\n    &m_inputLayout\n    );\n```\n\nThe **m\\_inputLayout** member variable is an [**ID3D11InputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476575) object. The input-layout object encapsulates the input state of the input assembler (IA) stage. One job of the IA stage is to make shaders more efficient by using system-generated values, also known as *semantics*, to process only those primitives or vertices that have not already been processed. Use the [**ID3D11Device::CreateInputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476512) method to create an input-layout from an array of input-element descriptions. The array contains one or more input elements; each input element describes one vertex-data element from one vertex buffer. The entire set of input-element descriptions describes all of the vertex-data elements from all of the vertex buffers that will be bound to the IA stage. The following example shows the layout description that Marble Maze uses. The layout description describes a vertex buffer that contains four vertex-data elements. The important parts of each entry in the array are the semantic name, data format, and byte offset . For example, the **POSITION** element specifies the vertex position in object space. It starts at byte offset 0 and contains three floating-point components (for a total of 12 bytes). The **NORMAL** element specifies the normal vector. It starts at byte offset 12 because it appears directly after **POSITION** in the layout, which requires 12 bytes. The **NORMAL** element contains a four-component, 32-bit unsigned-integer.\n\n```cpp\nD3D11_INPUT_ELEMENT_DESC layoutDesc[] = \n{\n    { \"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },\n    { \"NORMAL\",   0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },\n    { \"TEXCOORD\",  0, DXGI_FORMAT_R32G32_FLOAT,   0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 },\n    { \"TANGENT\", 0, DXGI_FORMAT_R32G32B32_FLOAT,  0, 32, D3D11_INPUT_PER_VERTEX_DATA, 0 }, \n};\nm_vertexStride = 44; // You must set this to match the size of layoutDesc above.\n```\n\nCompare the input layout with the **sVSInput** structure that is defined by the vertex shader, as shown in the following example. The **sVSInput** structure defines the **POSITION**, **NORMAL**, and **TEXCOORD0** elements. The DirectX runtime maps each element in the layout to the input structure that is defined by the shader.\n\n```hlsl\nstruct sVSInput\n{\n    float3 pos : POSITION;\n    float3 norm : NORMAL;\n    float2 tex : TEXCOORD0;\n};\n\nstruct sPSInput\n{\n    float4 pos : SV_POSITION;\n    float3 norm : NORMAL;\n    float2 tex : TEXCOORD0;\n    float3 worldPos : TEXCOORD1;\n};\n\nsPSInput main(sVSInput input)\n{\n    sPSInput output;\n    float4 temp = float4(input.pos, 1.0f);\n    temp = mul(temp, model);\n    output.worldPos = temp.xyz / temp.w;\n    temp = mul(temp, view);\n    temp = mul(temp, projection);\n    output.pos = temp;\n    output.tex = input.tex;\n    output.norm = mul(float4(input.norm, 0.0f), model).xyz;\n    return output;\n}\n```\n\nThe document [Semantics](https://msdn.microsoft.com/library/windows/desktop/bb509647) describes each of the available semantics in greater detail.\n\n> **Note**   In a layout, you can specify additional components that are not used to enable multiple shaders to share the same layout. For example, the **TANGENT** element is not used by the shader. You can use the **TANGENT** element if you want to experiment with techniques such as normal mapping. By using normal mapping, also known as bump mapping, you can create the effect of bumps on the surfaces of objects. For more information about bump mapping, see [Bump Mapping (Direct3D 9)](https://msdn.microsoft.com/library/windows/desktop/bb172379).\n\n \n\nFor more information about the input assembly stage state, see [Input-Assembler Stage](https://msdn.microsoft.com/library/windows/desktop/bb205116) and [Getting Started with the Input-Assembler Stage](https://msdn.microsoft.com/library/windows/desktop/bb205117).\n\nThe process of using the vertex and pixel shaders to render the scene are described in the section [Rendering the scene](#rendering_the_scene) later in this document.\n\n### Creating the constant buffer\n\nDirect3D buffer groups a collection of data. A constant buffer is a kind of buffer that you can use to pass data to shaders. Marble Maze uses a constant buffer to hold the model (or world) view, and the projection matrices for the active scene object.\n\nThe following example shows how the **MarbleMaze::LoadDeferredResources** method creates a constant buffer that will later hold matrix data. The example creates a **D3D11\\_BUFFER\\_DESC** structure that uses the **D3D11\\_BIND\\_CONSTANT\\_BUFFER** flag to specify usage as a constant buffer. This example then passes that structure to the [**ID3D11Device::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501) method. The **m\\_constantBuffer** variable is an [**ID3D11Buffer**](https://msdn.microsoft.com/library/windows/desktop/ff476351) object.\n\n```cpp\n// Create the constant buffer for updating model and camera data.\nD3D11_BUFFER_DESC constantBufferDesc = {0};\nconstantBufferDesc.ByteWidth           = ((sizeof(ConstantBuffer) + 15) / 16) * 16; // Multiple of 16 bytes\nconstantBufferDesc.Usage               = D3D11_USAGE_DEFAULT;\nconstantBufferDesc.BindFlags           = D3D11_BIND_CONSTANT_BUFFER;\nconstantBufferDesc.CPUAccessFlags      = 0;\nconstantBufferDesc.MiscFlags           = 0;\n// This will not be used as a structured buffer, so this parameter is ignored.\nconstantBufferDesc.StructureByteStride = 0;\n\nDX::ThrowIfFailed(\n    m_d3dDevice->CreateBuffer(\n        &constantBufferDesc,\n        nullptr,             // Leave the buffer uninitialized.\n        &m_constantBuffer\n        )\n    );\n```\n\nThe **MarbleMaze::Update** method later updates **ConstantBuffer** objects, one for the maze and one for the marble. The **MarbleMaze::Render** method then binds each **ConstantBuffer** object to the constant buffer before each object is rendered. The following example shows the **ConstantBuffer** structure, which is in MarbleMaze.h.\n\n```cpp\n// Describes the constant buffer that draws the meshes.\nstruct ConstantBuffer\n{\n    float4x4 model;\n    float4x4 view;\n    float4x4 projection;\n\n    float3 marblePosition;\n    float marbleRadius;\n    float lightStrength;\n};\n```\n\nTo better understand how constant buffers map to shader code, compare the **ConstantBuffer** structure to the **SimpleConstantBuffer** constant buffer that is defined by the vertex shader in BasicVertexShader.hlsl:\n\n```hlsl\ncbuffer ConstantBuffer : register(b0)\n{\n    matrix model;\n    matrix view;\n    matrix projection;\n    float3 marblePosition;\n    float marbleRadius;\n    float lightStrength;\n};\n```\n\nThe layout of the **ConstantBuffer** structure matches the **cbuffer** object. The **cbuffer** variable specifies register b0, which means that the constant buffer data is stored in register 0. The **MarbleMaze::Render** method specifies register 0 when it activates the constant buffer. This process is described in greater detail later in this document.\n\nFor more information about constant buffers, see [Introduction to Buffers in Direct3D 11](https://msdn.microsoft.com/library/windows/desktop/ff476898). For more information about the register keyword, see [**register**](https://msdn.microsoft.com/library/windows/desktop/dd607359).\n\n###  Loading meshes\n\nMarble Maze uses SDK-Mesh as the run-time format because this format provides a basic way to load mesh data for sample applications. For production use, you should use a mesh format that meets the specific requirements of your game.\n\nThe **MarbleMaze::LoadDeferredResources** method loads mesh data after it loads the vertex and pixel shaders. A mesh is a collection of vertex data that often includes information such as positions, normal data, colors, materials, and texture coordinates. Meshes are typically created in 3-D authoring software and maintained in files that are separate from application code. The marble and the maze are two examples of meshes that the game uses.\n\nMarble Maze uses the **SDKMesh** class to manage meshes. This class is declared in SDKMesh.h. **SDKMesh** provides methods to load, render, and destroy mesh data.\n\n> **Important**   Marble Maze uses the SDK-Mesh format and provides the **SDKMesh** class for illustration only. Although the SDK-Mesh format is useful for learning, and for creating prototypes, it is a very basic format that might not meet the requirements of most game development. We recommend that you use a mesh format that meets the specific requirements of your game.\n\n \n\nThe following example shows how the **MarbleMaze::LoadDeferredResources** method uses the **SDKMesh::Create** method to load mesh data for the maze and for the ball.\n\n```cpp\n// Load the meshes.\nDX::ThrowIfFailed(\n    m_mazeMesh.Create(\n        m_d3dDevice.Get(),\n        L\"Media\\\\Models\\\\maze1.sdkmesh\",\n        false\n        )\n    );\n\nDX::ThrowIfFailed(\n    m_marbleMesh.Create(\n        m_d3dDevice.Get(),\n        L\"Media\\\\Models\\\\marble2.sdkmesh\",\n        false\n        )\n    );\n```\n\n###  Loading collision data\n\nAlthough this section does not focus on how Marble Maze implements the physics simulation between the marble and the maze, note that mesh geometry for the physics system is read when the meshes are loaded.\n\n```cpp\n// Extract mesh geometry for the physics system.\nDX::ThrowIfFailed(\n    ExtractTrianglesFromMesh(\n        m_mazeMesh,\n        \"Mesh_walls\",\n        m_collision.m_wallTriList\n        )\n    );\n\nDX::ThrowIfFailed(\n    ExtractTrianglesFromMesh(\n        m_mazeMesh,\n        \"Mesh_Floor\",\n        m_collision.m_groundTriList\n        )\n    );\n\nDX::ThrowIfFailed(\n    ExtractTrianglesFromMesh(\n        m_mazeMesh,\n        \"Mesh_floorSides\",\n        m_collision.m_floorTriList\n        )\n    );\n\nm_physics.SetCollision(&m_collision);\nfloat radius = m_marbleMesh.GetMeshBoundingBoxExtents(0).x / 2;\nm_physics.SetRadius(radius);\n```\n\nThe way that you load collision data large depends on the run-time format that you use. For more information about how Marble Maze loads the collision geometry from an SDK-Mesh file, see the **MarbleMaze::ExtractTrianglesFromMesh** method in the source code.\n\n## Updating game state\n\n\nMarble Maze separates game logic from rendering logic by first updating all scene objects before rendering them.\n\nThe document Marble Maze application structure describes the main game loop. Updating the scene, which is part of the game loop, happens after Windows events and input are processed and before the scene is rendered. The **MarbleMaze::Update** method handles the update of the UI and the game.\n\n### Updating the user interface\n\nThe **MarbleMaze::Update** method calls the **UserInterface::Update** method to update the state of the UI.\n\n```cpp\nUserInterface::GetInstance().Update(timeTotal, timeDelta);\n```\n\nThe **UserInterface::Update** method updates each element in the UI collection.\n\n```cpp\nvoid UserInterface::Update(float timeTotal, float timeDelta)\n{\n    for (auto iter = m_elements.begin(); iter != m_elements.end(); ++iter)\n    {\n        (*iter)->Update(timeTotal, timeDelta);\n    }\n}\n```\n\nClasses that derive from **ElementBase** implement the **Update** method to perform specific behaviors. For example, the **StopwatchTimer::Update** method updates the elapsed time by the provided amount and updates the text that it later displays.\n\n```cpp\nvoid StopwatchTimer::Update(float timeTotal, float timeDelta)\n{\n    if (m_active)\n    {\n        m_elapsedTime += timeDelta;\n\n        WCHAR buffer[16];\n        GetFormattedTime(buffer);\n        SetText(buffer);\n    }\n\n    TextElement::Update(timeTotal, timeDelta);\n}\n```\n\n###  Updating the scene\n\nThe **MarbleMaze::Update** method updates the game based on the current state machine state. When the game is in the active state, Marble Maze updates the camera to follow the marble, updates the view matrix part of the constant buffers, and updates the physics simulation.\n\nThe following example shows how the **MarbleMaze::Update** method updates the position of the camera. Marble Maze uses the **m\\_resetCamera** variable to flag that the camera must be reset to be located directly above the marble. The camera is reset when the game starts or the marble falls through the maze. When the main menu or high score display screen is active, the camera is set at a constant location. Otherwise, Marble Maze uses the *timeDelta* parameter to interpolate the position of the camera between its current and target positions. The target position is slightly above and in front of the marble. Using the elapsed frame time enables the camera to gradually follow, or chase, the marble.\n\n```cpp\nstatic float eyeDistance = 200.0f;\nstatic float3 eyePosition = float3(0, 0, 0);\n\n// Gradually move the camera above the marble.\nfloat3 targetEyePosition = marblePosition - (eyeDistance * float3(g.x, g.y, g.z));\nif (m_resetCamera)\n{\n    eyePosition = targetEyePosition;\n    m_resetCamera = false;\n}\nelse\n{\n    eyePosition = eyePosition + ((targetEyePosition - eyePosition) * min(1, timeDelta * 8));\n}\n\n// Look at the marble. \nif ((m_gameState == GameState::MainMenu) || (m_gameState == GameState::HighScoreDisplay))\n{\n    // Override camera position for menus.\n    eyePosition = marblePosition + float3(75.0f, -150.0f, -75.0f);\n    m_camera->SetViewParameters(eyePosition, marblePosition, float3(0.0f, 0.0f, -1.0f));\n}\nelse\n{\n    m_camera->SetViewParameters(eyePosition, marblePosition, float3(0.0f, 1.0f, 0.0f));\n}\n```\n\nThe following example shows how the **MarbleMaze::Update** method updates the constant buffers for the marble and the maze. The maze’s model, or world, matrix always remains the identity matrix. Except for the main diagonal, whose elements are all ones, the identity matrix is a square matrix composed of zeros. The marble’s model matrix is based on its position matrix times its rotation matrix. The **mul** and **translation** functions are defined in BasicMath.h.\n\n```cpp\n// Update the model matrices based on the simulation.\nm_mazeConstantBufferData.model = identity();\nm_marbleConstantBufferData.model = mul(\n    translation(marblePosition.x, marblePosition.y, marblePosition.z),\n    marbleRotationMatrix\n    );\n\n// Update the view matrix based on the camera.\nfloat4x4 view;\nm_camera->GetViewMatrix(&view);\nm_mazeConstantBufferData.view = view;\nm_marbleConstantBufferData.view = view;\n```\n\nFor information about how the **MarbleMaze::Update** method reads user input and simulates the motion of the marble, see [Adding input and interactivity to the Marble Maze sample](adding-input-and-interactivity-to-the-marble-maze-sample.md).\n\n## Rendering the scene\n\n\nWhen a scene is rendered, these steps are typically included.\n\n1.  Set the current render target depth-stencil buffer.\n2.  Clear the render and stencil views.\n3.  Prepare the vertex and pixel shaders for drawing.\n4.  Render the 3-D objects in the scene.\n5.  Render any 2-D object that you want to appear in front of the scene.\n6.  Present the rendered image to the monitor.\n\nThe **MarbleMaze::Render** method binds the render target and depth stencil views, clears those views, draws the scene, and then draws the overlay.\n\n###  Preparing the render targets\n\nBefore you render your scene, you must set the current render target depth-stencil buffer. If your scene is not guaranteed to draw over every pixel on the screen, also clear the render and stencil views. Marble Maze clears the render and stencil views on every frame to ensure that there are no visible artifacts from the previous frame.\n\nThe following example shows how the **MarbleMaze::Render** method calls the [**ID3D11DeviceContext::OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464) method to set the render target and the depth-stencil buffer as the current ones. The **m\\_renderTargetView** member variable, an [**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582) object, and the **m\\_depthStencilView** member variable, an [**ID3D11DepthStencilView**](https://msdn.microsoft.com/library/windows/desktop/ff476377) object, are defined and initialized by the **DirectXBase** class.\n\n```cpp\n// Bind the render targets.\nm_d3dContext->OMSetRenderTargets(\n    1,\n    m_renderTargetView.GetAddressOf(),\n    m_depthStencilView.Get()\n    );\n\n// Clear the render target and depth stencil to default values. \nconst float clearColor[4] = { 0.0f, 0.0f, 0.0f, 1.0f };\n\nm_d3dContext->ClearRenderTargetView(\n    m_renderTargetView.Get(),\n    clearColor\n    );\n\nm_d3dContext->ClearDepthStencilView(\n    m_depthStencilView.Get(),\n    D3D11_CLEAR_DEPTH,\n    1.0f,\n    0\n    );\n```\n\nThe [**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582) and [**ID3D11DepthStencilView**](https://msdn.microsoft.com/library/windows/desktop/ff476377) interfaces support the texture view mechanism that is provided by Direct3D 10 and later. For more information about texture views, see [Texture Views (Direct3D 10)](https://msdn.microsoft.com/library/windows/desktop/bb205128). The [**OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464) method prepares the output-merger stage of the Direct3D pipeline. For more information about the output-merger stage, see [Output-Merger Stage](https://msdn.microsoft.com/library/windows/desktop/bb205120).\n\n### Preparing the vertex and pixel shaders\n\nBefore you render the scene objects, perform the following steps to prepare the vertex and pixel shaders for drawing:\n\n1.  Set the shader input layout as the current layout.\n2.  Set the vertex and pixel shaders as the current shaders.\n3.  Update any constant buffers with data that you have to pass to the shaders.\n\n> **Important**  Marble Maze uses one pair of vertex and pixel shaders for all 3-D objects. If your game uses more than one pair of shaders, you must perform these steps each time you draw objects that use different shaders. To reduce the overhead that is associated with changing the shader state, we recommend that you group render calls for all objects that use the same shaders.\n\n \n\nThe section [Loading shaders](#loading_shaders) in this document describes how the input layout is created when the vertex shader is created. The following example shows how the **MarbleMaze::Render** method uses the [**ID3D11DeviceContext::IASetInputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476454) method to set this layout as the current layout.\n\n```cpp\nm_d3dContext->IASetInputLayout(m_inputLayout.Get());\n```\n\nThe following example shows how the **MarbleMaze::Render** method uses the [**ID3D11DeviceContext::VSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476493) and [**ID3D11DeviceContext::PSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476472) methods to set the vertex and pixel shaders as the current shaders, respectively.\n\n```cpp\n// Set the vertex shader stage state.\nm_d3dContext->VSSetShader(\n    m_vertexShader.Get(),   // Use this vertex shader. \n    nullptr,                // Don't use shader linkage.\n    0                       // Don't use shader linkage.\n    );\n\n// Set the pixel shader stage state.\nm_d3dContext->PSSetShader(\n    m_pixelShader.Get(),    // Use this pixel shader. \n    nullptr,                // Don't use shader linkage.\n    0                       // Don't use shader linkage.\n    );\n\nm_d3dContext->PSSetSamplers(\n    0,                       // Starting at the first sampler slot\n    1,                       // set one sampler binding\n    m_sampler.GetAddressOf() // to use this sampler.\n    );\n```\n\nAfter the **MarbleMaze::Render** sets the shaders and their input layout, it uses the [**ID3D11DeviceContext::UpdateSubresource**](https://msdn.microsoft.com/library/windows/desktop/ff476486) method to update the constant buffer with the model, view, and projection matrices for the maze. The **UpdateSubresource** method copies the matrix data from CPU memory to GPU memory. Recall that the model and view components of the **ConstantBuffer** structure are updated in the **MarbleMaze::Update** method. The **MarbleMaze::Render** method then calls the [**ID3D11DeviceContext::VSSetConstantBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476491) and [**ID3D11DeviceContext::PSSetConstantBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476470) methods to set this constant buffer as the current one.\n\n```cpp\n// Update the constant buffer with the new data.\nm_d3dContext->UpdateSubresource(\n    m_constantBuffer.Get(),\n    0,\n    nullptr,\n    &m_mazeConstantBufferData,\n    0,\n    0\n    );\n\nm_d3dContext->VSSetConstantBuffers(\n    0,                // Starting at the first constant buffer slot\n    1,                // set one constant buffer binding\n    m_constantBuffer.GetAddressOf() // to use this buffer.\n    );\n\nm_d3dContext->PSSetConstantBuffers(\n    0,                // Starting at the first constant buffer slot\n    1,                // set one constant buffer binding\n    m_constantBuffer.GetAddressOf() // to use this buffer.\n    );\n```\n\nThe **MarbleMaze::Render** method performs similar steps to prepare the marble to be rendered.\n\n### Rendering the maze and the marble\n\nAfter you activate the current shaders, you can draw your scene objects. The **MarbleMaze::Render** method calls the **SDKMesh::Render** method to render the maze mesh.\n\n```cpp\nm_mazeMesh.Render(m_d3dContext.Get(), 0, INVALID_SAMPLER_SLOT, INVALID_SAMPLER_SLOT);\n```\n\nThe **MarbleMaze::Render** method performs similar steps to render the marble.\n\nAs mentioned earlier in this document, the **SDKMesh** class is provided for demonstration purposes, but we do not recommend it for use in a production-quality game. However, notice that the **SDKMesh::RenderMesh** method, which is called by **SDKMesh::Render**, uses the [**ID3D11DeviceContext::IASetVertexBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476456) and [**ID3D11DeviceContext::IASetIndexBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476453) methods to set the current vertex and index buffers that define the mesh, and the [**ID3D11DeviceContext::DrawIndexed**](https://msdn.microsoft.com/library/windows/desktop/ff476410) method to draw the buffers. For more information about how to work with vertex and index buffers, see [Introduction to Buffers in Direct3D 11](https://msdn.microsoft.com/library/windows/desktop/ff476898).\n\n### Drawing the user interface and overlay\n\nAfter drawing 3-D scene objects, Marble Maze draws the 2-D UI elements that appear in front of the scene.\n\nThe **MarbleMaze::Render** method ends by drawing the user interface and the overlay.\n\n```cpp\n// Draw the user interface and the overlay.\nUserInterface::GetInstance().Render();\n\nm_sampleOverlay->Render();\n```\n\nThe **UserInterface::Render** method uses an [**ID2D1DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/hh404479) object to draw the UI elements. This method sets the drawing state, draws all active UI elements, and then restores the previous drawing state.\n\n```cpp\nvoid UserInterface::Render()\n{\n    m_d2dContext->SaveDrawingState(m_stateBlock.Get());\n    m_d2dContext->BeginDraw();\n    m_d2dContext->SetTransform(D2D1::Matrix3x2F::Identity());\n    m_d2dContext->SetTextAntialiasMode(D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE);\n\n    for (auto iter = m_elements.begin(); iter != m_elements.end(); ++iter)\n    {\n        if ((*iter)->IsVisible())\n            (*iter)->Render();\n    }\n\n    m_d2dContext->EndDraw();\n    m_d2dContext->RestoreDrawingState(m_stateBlock.Get());\n}\n```\n\nThe **SampleOverlay::Render** method uses a similar technique to draw the overlay bitmap.\n\n###  Presenting the scene\n\nAfter drawing all 2-D and 3-D scene objects, Marble Maze presents the rendered image to the monitor. It synchronizes drawing to the vertical blank to ensure that time is not spent time drawing frames that will never be actually shown on the display. Marble Maze also handles device changes when it presents the scene.\n\nAfter the **MarbleMaze::Render** method returns, the game loop calls the **MarbleMaze::Present** method to send the rendered image to the monitor or display. The **MarbleMaze** class does not override the **DirectXBase::Present** method. The **DirectXBase::Present** method calls [**IDXGISwapChain1::Present**](https://msdn.microsoft.com/library/windows/desktop/hh446797) to perform the present operation, as shown in the following example:\n\n```cpp\n// The application may optionally specify \"dirty\" or \"scroll\" rects \n// to improve efficiency in certain scenarios. \n// In this sample, however, we do not utilize those features.\nDXGI_PRESENT_PARAMETERS parameters = {0};\nparameters.DirtyRectsCount = 0;\nparameters.pDirtyRects = nullptr;\nparameters.pScrollRect = nullptr;\nparameters.pScrollOffset = nullptr;\n\n// The first argument instructs DXGI to block until VSync, putting the  \n// application to sleep until the next VSync.  \n// This ensures we don't waste any cycles rendering frames that will  \n// never be displayed to the screen.\nHRESULT hr = m_swapChain->Present1(1, 0, &parameters);\n```\n\nIn this example, **m\\_swapChain** is an [**IDXGISwapChain1**](https://msdn.microsoft.com/library/windows/desktop/hh404631) object. The initialization of this object is described in the section [Initializing Direct3D and Direct2D](#initializing) in this document.\n\nThe first parameter to [**IDXGISwapChain1::Present**](https://msdn.microsoft.com/library/windows/desktop/hh446797), *SyncInterval*, specifies the number of vertical blanks to wait before presenting the frame. Marble Maze specifies 1 so that it waits until the next vertical blank. A vertical blank is the time between when one frame finishes drawing to the monitor and the next frame begins.\n\nThe [**IDXGISwapChain1::Present1**](https://msdn.microsoft.com/library/windows/desktop/hh446797) method returns an error code that indicates that the device was removed or otherwise failed. In this case, Marble Maze reinitializes the device.\n\n```cpp\n// Reinitialize the renderer if the device was disconnected  \n// or the driver was upgraded. \nif (hr == DXGI_ERROR_DEVICE_REMOVED || hr == DXGI_ERROR_DEVICE_RESET)\n{\n    Initialize(m_window, m_dpi);\n}\nelse\n{\n    DX::ThrowIfFailed(hr);\n}\n```\n\n## Next steps\n\n\nRead [Adding input and interactivity to the Marble Maze sample](adding-input-and-interactivity-to-the-marble-maze-sample.md) for information about some of the key practices to keep in mind when you work with input devices. This document discusses how Marble Maze supports touch, accelerometer, Xbox 360 controller, and mouse input.\n\n## Related topics\n\n\n* [Adding input and interactivity to the Marble Maze sample](adding-input-and-interactivity-to-the-marble-maze-sample.md)\n* [Marble Maze application structure](marble-maze-application-structure.md)\n* [Developing Marble Maze, a UWP game in C++ and DirectX](developing-marble-maze-a-windows-store-game-in-cpp-and-directx.md)\n\n \n\n \n\n\n\n\n"}