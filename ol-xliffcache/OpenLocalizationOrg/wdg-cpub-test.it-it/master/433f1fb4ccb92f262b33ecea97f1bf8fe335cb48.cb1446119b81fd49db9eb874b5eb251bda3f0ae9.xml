{"nodes":[{"pos":[32,198],"content":"If your app does not provide good keyboard access, users who are blind or have mobility issues can have difficulty using your app or may not be able to use it at all.","needQuote":true,"needEscape":true,"nodes":[{"content":"If your app does not provide good keyboard access, users who are blind or have mobility issues can have difficulty using your app or may not be able to use it at all.","pos":[0,166]}]},{"pos":[255,277],"content":"Keyboard accessibility","needQuote":true,"needEscape":true,"nodes":[{"content":"Keyboard accessibility","pos":[0,22]}]},{"content":"Keyboard accessibility","pos":[336,358]},{"content":"If your app does not provide good keyboard access, users who are blind or have mobility issues can have difficulty using your app or may not be able to use it at all.","pos":[364,530]},{"content":"Keyboard navigation among UI elements","pos":[688,725]},{"content":"To use the keyboard with a control, the control must have focus, and to receive focus (without using a pointer) the control must be accessible in a UI design via tab navigation.","pos":[728,905]},{"content":"By default, the tab order of controls is the same as the order in which they are added to a design surface, listed in XAML, or programmatically added to a container.","pos":[906,1071]},{"content":"In most cases, the default order based on how you defined controls in XAML is the best order, especially because that is the order in which the controls are read by screen readers.","pos":[1073,1253]},{"content":"However, the default order does not necessarily correspond to the visual order.","pos":[1254,1333]},{"content":"The actual display position might depend on the parent layout container and certain properties that you can set on the child elements to influence the layout.","pos":[1334,1492]},{"content":"To be sure your app has a good tab order, test this behavior yourself.","pos":[1493,1563]},{"content":"Especially if you have a grid metaphor or table metaphor for your layout, the order in which users might read versus the tab order could end up different.","pos":[1564,1718]},{"content":"That's not always a problem in and of itself.","pos":[1719,1764]},{"content":"But just make sure to test your app's functionality both as a touchable UI and as a keyboard-accessible UI and verify that your UI makes sense either way.","pos":[1765,1919]},{"content":"You can make the tab order match the visual order by adjusting the XAML.","pos":[1921,1993]},{"content":"Or you can override the default tab order by setting the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TabIndex<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209461)</ept> property, as shown in the following example of a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Grid<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept> layout that uses column-first tab navigation.","pos":[1994,2287],"source":" Or you can override the default tab order by setting the [**TabIndex**](https://msdn.microsoft.com/library/windows/apps/BR209461) property, as shown in the following example of a [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704) layout that uses column-first tab navigation."},{"content":"XAML","pos":[2289,2293]},{"content":"You may want to exclude a control from the tab order.","pos":[3016,3069]},{"content":"You typically do this only by making the control noninteractive, for example by setting its <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IsEnabled<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209419)</ept> property to <bpt id=\"p3\">**</bpt>false<ept id=\"p3\">**</ept>.","pos":[3070,3258],"source":" You typically do this only by making the control noninteractive, for example by setting its [**IsEnabled**](https://msdn.microsoft.com/library/windows/apps/BR209419) property to **false**."},{"content":"A disabled control is automatically excluded from the tab order.","pos":[3259,3323]},{"content":"But occasionally you might want to exclude a control from the tab order even if it is not disabled.","pos":[3324,3423]},{"content":"In this case, you can set the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IsTabStop<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209422)</ept> property to <bpt id=\"p3\">**</bpt>false<ept id=\"p3\">**</ept>.","pos":[3424,3550],"source":" In this case, you can set the [**IsTabStop**](https://msdn.microsoft.com/library/windows/apps/BR209422) property to **false**."},{"content":"Any elements that can have focus are usually in the tab order by default.","pos":[3552,3625]},{"content":"The exception to this is that certain text-display types such as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>RichTextBlock<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR227565)</ept> can have focus so that they can be accessed by the clipboard for text selection; however, they're not in the tab order because it is not expected for static text elements to be in the tab order.","pos":[3626,3963],"source":" The exception to this is that certain text-display types such as [**RichTextBlock**](https://msdn.microsoft.com/library/windows/apps/BR227565) can have focus so that they can be accessed by the clipboard for text selection; however, they're not in the tab order because it is not expected for static text elements to be in the tab order."},{"content":"They're not conventionally interactive (they can't be invoked, and don't require text input, but do support the <bpt id=\"p1\">[</bpt>Text control pattern<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/Ee671194)</ept> that supports finding and adjusting selection points in text).","pos":[3964,4222],"source":" They're not conventionally interactive (they can't be invoked, and don't require text input, but do support the [Text control pattern](https://msdn.microsoft.com/library/windows/desktop/Ee671194) that supports finding and adjusting selection points in text)."},{"content":"Text should not have the connotation that setting focus to it will enable some action that's possible.","pos":[4223,4325]},{"content":"Text elements will still be detected by assistive technologies, and read aloud in screen readers, but that relies on techniques other than finding those elements in the practical tab order.","pos":[4326,4515]},{"pos":[4517,4660],"content":"Whether you adjust <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TabIndex<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209461)</ept> values or use the default order, these rules apply:","source":"Whether you adjust [**TabIndex**](https://msdn.microsoft.com/library/windows/apps/BR209461) values or use the default order, these rules apply:"},{"pos":[4664,4848],"content":"UI elements with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TabIndex<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209461)</ept> equal to 0 are added to the tab order based on declaration order in XAML or child collections.","source":"UI elements with [**TabIndex**](https://msdn.microsoft.com/library/windows/apps/BR209461) equal to 0 are added to the tab order based on declaration order in XAML or child collections."},{"pos":[4851,5015],"content":"UI elements with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TabIndex<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209461)</ept> greater than 0 are added to the tab order based on the <bpt id=\"p3\">**</bpt>TabIndex<ept id=\"p3\">**</ept> value.","source":"UI elements with [**TabIndex**](https://msdn.microsoft.com/library/windows/apps/BR209461) greater than 0 are added to the tab order based on the **TabIndex** value."},{"content":"UI elements with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TabIndex<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209461)</ept> less than 0 are added to the tab order and appear before any zero value.","pos":[5018,5180],"source":"UI elements with [**TabIndex**](https://msdn.microsoft.com/library/windows/apps/BR209461) less than 0 are added to the tab order and appear before any zero value."},{"content":"This potentially differs from HTML's handling of its <bpt id=\"p1\">**</bpt>tabindex<ept id=\"p1\">**</ept> attribute (and negative <bpt id=\"p2\">**</bpt>tabindex<ept id=\"p2\">**</ept> was not supported in older HTML specifications).","pos":[5181,5332],"source":" This potentially differs from HTML's handling of its **tabindex** attribute (and negative **tabindex** was not supported in older HTML specifications)."},{"content":"Keyboard navigation within a UI element","pos":[5496,5535]},{"content":"For composite elements, it is important to ensure proper inner navigation among the contained elements.","pos":[5538,5641]},{"content":"A composite element can manage its current active child to reduce the overhead of having all child elements able to have focus.","pos":[5642,5769]},{"content":"Such a composite element is included in the tab order, and it handles keyboard navigation events itself.","pos":[5770,5874]},{"content":"Many of the composite controls already have some inner navigation logic built into the into control's event handling.","pos":[5875,5992]},{"content":"For example, arrow-key traversal of items is enabled by default on the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ListView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>GridView<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242704view)</ept>, <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ListBox<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR242868)</ept> and <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>FlipView<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/BR242678)</ept> controls.","pos":[5993,6374],"source":" For example, arrow-key traversal of items is enabled by default on the [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878), [**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242704view), [**ListBox**](https://msdn.microsoft.com/library/windows/apps/BR242868) and [**FlipView**](https://msdn.microsoft.com/library/windows/apps/BR242678) controls."},{"content":"Keyboard alternatives to pointer actions and events for specific control elements","pos":[6445,6526]},{"content":"Ensure that UI elements that can be clicked can also be invoked by using the keyboard.","pos":[6529,6615]},{"content":"To use the keyboard with a UI element, the element must have focus.","pos":[6616,6683]},{"content":"Only classes that derive from <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Control<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209390)</ept> support focus and tab navigation.","pos":[6684,6819],"source":" Only classes that derive from [**Control**](https://msdn.microsoft.com/library/windows/apps/BR209390) support focus and tab navigation."},{"content":"For UI elements that can be invoked, implement keyboard event handlers for the Spacebar and Enter keys.","pos":[6821,6924]},{"content":"This makes the basic keyboard accessibility support complete and enables users to accomplish basic app scenarios by using only the keyboard; that is, users can reach all interactive UI elements and activate the default functionality.","pos":[6925,7158]},{"content":"In cases where an element that you want to use in the UI cannot have focus, you could create your own custom control.","pos":[7160,7277]},{"content":"You must set the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IsTabStop<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209422)</ept> property to <bpt id=\"p3\">**</bpt>true<ept id=\"p3\">**</ept> to enable focus and you must provide a visual indication of the focused state by creating a visual state that decorates the UI with a focus indicator.","pos":[7278,7540],"source":" You must set the [**IsTabStop**](https://msdn.microsoft.com/library/windows/apps/BR209422) property to **true** to enable focus and you must provide a visual indication of the focused state by creating a visual state that decorates the UI with a focus indicator."},{"content":"However, it is often easier to use control composition so that the support for tab stops, focus, and Microsoft UI Automation peers and patterns are handled by the control within which you choose to compose your content.","pos":[7541,7760]},{"pos":[7762,8044],"content":"For example, instead of handling a pointer-pressed event on an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Image<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242752)</ept>, you could wrap that element in a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Button<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR209265)</ept> to get pointer, keyboard, and focus support.","source":"For example, instead of handling a pointer-pressed event on an [**Image**](https://msdn.microsoft.com/library/windows/apps/BR242752), you could wrap that element in a [**Button**](https://msdn.microsoft.com/library/windows/apps/BR209265) to get pointer, keyboard, and focus support."},{"content":"XAML","pos":[8046,8050]},{"content":"Keyboard shortcuts","pos":[8311,8329]},{"content":"In addition to implementing keyboard navigation and activation for your app, it is a good practice to implement shortcuts for your app's functionality.","pos":[8332,8483]},{"content":"Tab navigation provides a good, basic level of keyboard support, but with complex forms you may want to add support for shortcut keys as well.","pos":[8484,8626]},{"content":"This can make your application more efficient to use, even for people who use both a keyboard and pointing devices.","pos":[8627,8742]},{"content":"A <bpt id=\"p1\">*</bpt>shortcut<ept id=\"p1\">*</ept> is a keyboard combination that enhances productivity by providing an efficient way for the user to access app functionality.","pos":[8744,8881],"source":"A *shortcut* is a keyboard combination that enhances productivity by providing an efficient way for the user to access app functionality."},{"content":"There are two kinds of shortcut:","pos":[8882,8914]},{"content":"An <bpt id=\"p1\">*</bpt>access key<ept id=\"p1\">*</ept> is a shortcut to a piece of UI in your app.","pos":[8918,8977],"source":"An *access key* is a shortcut to a piece of UI in your app."},{"content":"Access keys consist of the Alt key plus a letter key.","pos":[8978,9031]},{"content":"An <bpt id=\"p1\">*</bpt>accelerator key<ept id=\"p1\">*</ept> is a shortcut to an app command.","pos":[9034,9087],"source":"An *accelerator key* is a shortcut to an app command."},{"content":"Your app may or may not have UI that corresponds exactly to the command.","pos":[9088,9160]},{"content":"Accelerator keys consist of the Ctrl key plus a letter key.","pos":[9161,9220]},{"content":"It is imperative that you provide an easy way for users who rely on screen readers and other assistive technology to discover your app's shortcut keys.","pos":[9222,9373]},{"content":"Communicate shortcut keys by using tooltips, accessible names, accessible descriptions, or some other form of on-screen communication.","pos":[9374,9508]},{"content":"At a minimum, shortcut keys should be well documented in your app's Help content.","pos":[9509,9590]},{"content":"You can document access keys through screen readers by setting the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>AutomationProperties.AccessKey<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Hh759763)</ept> attached property to a string that describes the shortcut key.","pos":[9592,9816],"source":"You can document access keys through screen readers by setting the [**AutomationProperties.AccessKey**](https://msdn.microsoft.com/library/windows/apps/Hh759763) attached property to a string that describes the shortcut key."},{"content":"There is also an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>AutomationProperties.AcceleratorKey<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Hh759762)</ept> attached property for documenting non-mnemonic shortcut keys, although screen readers generally treat both properties the same way.","pos":[9817,10065],"source":" There is also an [**AutomationProperties.AcceleratorKey**](https://msdn.microsoft.com/library/windows/apps/Hh759762) attached property for documenting non-mnemonic shortcut keys, although screen readers generally treat both properties the same way."},{"content":"Try to document shortcut keys in multiple ways, using tooltips, automation properties, and written Help documentation.","pos":[10066,10184]},{"content":"The following example demonstrates how to document shortcut keys for media play, pause, and stop buttons.","pos":[10186,10291]},{"content":"XAML","pos":[10293,10297]},{"pos":[11358,12445],"content":"[!IMPORTANT]\nSetting [**AutomationProperties.AcceleratorKey**](https://msdn.microsoft.com/library/windows/apps/Hh759762) or [**AutomationProperties.AccessKey**](https://msdn.microsoft.com/library/windows/apps/Hh759763) doesn't enable keyboard functionality. It only reports to the UI Automation framework what keys should be used, so that such information can be passed on to users via assistive technologies. The implementation for key handling still needs to be done in code, not XAML. You will still need to attach handlers for [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/BR208941) or [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/BR208942) events on the relevant control in order to actually implement the keyboard shortcut behavior in your app. Also, the underline text decoration for an access key is not provided automatically. You must explicitly underline the text for the specific key in your mnemonic as inline [**Underline**](https://msdn.microsoft.com/library/windows/apps/BR209982) formatting if you wish to show underlined text in the UI.","leadings":["","> "],"nodes":[{"content":"Setting [**AutomationProperties.AcceleratorKey**](https://msdn.microsoft.com/library/windows/apps/Hh759762) or [**AutomationProperties.AccessKey**](https://msdn.microsoft.com/library/windows/apps/Hh759763) doesn't enable keyboard functionality. It only reports to the UI Automation framework what keys should be used, so that such information can be passed on to users via assistive technologies. The implementation for key handling still needs to be done in code, not XAML. You will still need to attach handlers for [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/BR208941) or [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/BR208942) events on the relevant control in order to actually implement the keyboard shortcut behavior in your app. Also, the underline text decoration for an access key is not provided automatically. You must explicitly underline the text for the specific key in your mnemonic as inline [**Underline**](https://msdn.microsoft.com/library/windows/apps/BR209982) formatting if you wish to show underlined text in the UI.","pos":[13,1085],"nodes":[{"content":"Setting <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>AutomationProperties.AcceleratorKey<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Hh759762)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>AutomationProperties.AccessKey<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/Hh759763)</ept> doesn't enable keyboard functionality.","pos":[0,244],"source":"Setting [**AutomationProperties.AcceleratorKey**](https://msdn.microsoft.com/library/windows/apps/Hh759762) or [**AutomationProperties.AccessKey**](https://msdn.microsoft.com/library/windows/apps/Hh759763) doesn't enable keyboard functionality."},{"content":"It only reports to the UI Automation framework what keys should be used, so that such information can be passed on to users via assistive technologies.","pos":[245,396]},{"content":"The implementation for key handling still needs to be done in code, not XAML.","pos":[397,474]},{"content":"You will still need to attach handlers for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyDown<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208941)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>KeyUp<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR208942)</ept> events on the relevant control in order to actually implement the keyboard shortcut behavior in your app.","pos":[475,768],"source":" You will still need to attach handlers for [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/BR208941) or [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/BR208942) events on the relevant control in order to actually implement the keyboard shortcut behavior in your app."},{"content":"Also, the underline text decoration for an access key is not provided automatically.","pos":[769,853]},{"content":"You must explicitly underline the text for the specific key in your mnemonic as inline <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Underline<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209982)</ept> formatting if you wish to show underlined text in the UI.","pos":[854,1072],"source":" You must explicitly underline the text for the specific key in your mnemonic as inline [**Underline**](https://msdn.microsoft.com/library/windows/apps/BR209982) formatting if you wish to show underlined text in the UI."}]}]},{"content":"For simplicity, the preceding example omits the use of resources for strings such as \"Ctrl+A\".","pos":[12447,12541]},{"content":"However, you must also consider shortcut keys during localization.","pos":[12542,12608]},{"content":"Localizing shortcut keys is relevant because the choice of key to use as the shortcut key typically depends on the visible text label for the element.","pos":[12609,12759]},{"pos":[12761,12936],"content":"For more guidance about implementing shortcut keys, see <bpt id=\"p1\">[</bpt>Shortcut keys<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=221825)</ept> in the Windows User Experience Interaction Guidelines.","source":"For more guidance about implementing shortcut keys, see [Shortcut keys](http://go.microsoft.com/fwlink/p/?linkid=221825) in the Windows User Experience Interaction Guidelines."},{"content":"Implementing a key event handler","pos":[13080,13112]},{"content":"Input events such as the key events use an event concept called <bpt id=\"p1\">*</bpt>routed events<ept id=\"p1\">*</ept>.","pos":[13115,13195],"source":"Input events such as the key events use an event concept called *routed events*."},{"content":"A routed event can bubble up through the child elements of a composited control, such that a common control parent can handle events for multiple child elements.","pos":[13196,13357]},{"content":"This event model is convenient for defining shortcut key actions for a control that contains several composite parts that by design cannot have focus or be part of the tab order.","pos":[13358,13536]},{"pos":[13538,13744],"content":"For example code that shows how to write a key event handler that includes checking for modifiers such as the Ctrl key, see <bpt id=\"p1\">[</bpt>Keyboard interactions<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Mt185607)</ept>.","source":"For example code that shows how to write a key event handler that includes checking for modifiers such as the Ctrl key, see [Keyboard interactions](https://msdn.microsoft.com/library/windows/apps/Mt185607)."},{"content":"Keyboard navigation for custom controls","pos":[13908,13947]},{"content":"We recommend the use of arrow keys as keyboard shortcuts for navigating among child elements, in cases where the child elements have a spacial relationship to each other.","pos":[13950,14120]},{"content":"If tree-view nodes have separate sub-elements for handling expand-collapse and node activation, use the left and right arrow keys to provide keyboard expand-collapse functionality.","pos":[14121,14301]},{"content":"If you have an oriented control that supports directional traversal within the control content, use the appropriate arrow keys.","pos":[14302,14429]},{"pos":[14431,14726],"content":"Generally you implement custom key handling for custom controls by including an override of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>OnKeyDown<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209390_onkeydown)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>OnKeyUp<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR209390_onkeyup)</ept> methods as part of the class logic.","source":"Generally you implement custom key handling for custom controls by including an override of [**OnKeyDown**](https://msdn.microsoft.com/library/windows/apps/BR209390_onkeydown) and [**OnKeyUp**](https://msdn.microsoft.com/library/windows/apps/BR209390_onkeyup) methods as part of the class logic."},{"content":"An example of a visual state for a focus indicator","pos":[14923,14973]},{"content":"We mentioned earlier that any custom control that enables the user to focus it should have a visual focus indicator.","pos":[14976,15092]},{"content":"Usually that focus indicator is as simple as drawing a rectangle shape immediately around the control's normal bounding rectangle.","pos":[15093,15223]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Rectangle<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243371)</ept> for visual focus is a peer element to the rest of the control's composition in a control template, but is initially set with a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Visibility<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR208992)</ept> value of <bpt id=\"p5\">**</bpt>Collapsed<ept id=\"p5\">**</ept> because the control isn't focused yet.","pos":[15224,15565],"source":" The [**Rectangle**](https://msdn.microsoft.com/library/windows/apps/BR243371) for visual focus is a peer element to the rest of the control's composition in a control template, but is initially set with a [**Visibility**](https://msdn.microsoft.com/library/windows/apps/BR208992) value of **Collapsed** because the control isn't focused yet."},{"content":"Then, when the control does get focus, a visual state is invoked that specifically sets the <bpt id=\"p1\">**</bpt>Visibility<ept id=\"p1\">**</ept> of the focus visual to <bpt id=\"p2\">**</bpt>Visible<ept id=\"p2\">**</ept>.","pos":[15566,15708],"source":" Then, when the control does get focus, a visual state is invoked that specifically sets the **Visibility** of the focus visual to **Visible**."},{"content":"Once focus is moved elsewhere, another visual state is called, and the <bpt id=\"p1\">**</bpt>Visibility<ept id=\"p1\">**</ept> becomes <bpt id=\"p2\">**</bpt>Collapsed<ept id=\"p2\">**</ept>.","pos":[15709,15817],"source":" Once focus is moved elsewhere, another visual state is called, and the **Visibility** becomes **Collapsed**."},{"content":"All of the default XAML controls will display an appropriate visual focus indicator when focused (if they can be focused).","pos":[15819,15941]},{"content":"There are also potentially different looks depending on the user's selected theme (particularly if the user is using a high contrast mode.) If you're using the XAML controls in your UI and not replacing the control templates, you don't need to do anything extra to get visual focus indicators on controls that behave and display correctly.","pos":[15942,16281]},{"content":"But if you're intending to retemplate a control, or if you're curious about how XAML controls provide their visual focus indicators, the remainder of this section explains how this is done in XAML and in the control logic.","pos":[16282,16504]},{"pos":[16506,16650],"content":"Here's some example XAML that comes from the default XAML template for a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Button<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209265)</ept>.","source":"Here's some example XAML that comes from the default XAML template for a [**Button**](https://msdn.microsoft.com/library/windows/apps/BR209265)."},{"content":"XAML","pos":[16652,16656]},{"content":"So far this is just the composition.","pos":[17236,17272]},{"content":"To control the focus indicator's visibility, you define visual states that toggle the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Visibility<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208992)</ept> property.","pos":[17273,17443],"source":" To control the focus indicator's visibility, you define visual states that toggle the [**Visibility**](https://msdn.microsoft.com/library/windows/apps/BR208992) property."},{"content":"This is done using the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>VisualStateManager.VisualStateGroups<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Hh738505)</ept> attached property, as applied to the root element that defines the composition.","pos":[17444,17647],"source":" This is done using the [**VisualStateManager.VisualStateGroups**](https://msdn.microsoft.com/library/windows/apps/Hh738505) attached property, as applied to the root element that defines the composition."},{"content":"XAML","pos":[17649,17653]},{"content":"Note how only one of the named states adjusts <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Visibility<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208992)</ept> directly whereas the others are seemingly empty.","pos":[18505,18674],"source":"Note how only one of the named states adjusts [**Visibility**](https://msdn.microsoft.com/library/windows/apps/BR208992) directly whereas the others are seemingly empty."},{"content":"The way that visual states work is that as soon as the control uses another state from the same <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>VisualStateGroup<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209014)</ept>, any animations applied by the previous state are immediately canceled.","pos":[18675,18923],"source":" The way that visual states work is that as soon as the control uses another state from the same [**VisualStateGroup**](https://msdn.microsoft.com/library/windows/apps/BR209014), any animations applied by the previous state are immediately canceled."},{"content":"Because the default <bpt id=\"p1\">**</bpt>Visibility<ept id=\"p1\">**</ept> from composition is <bpt id=\"p2\">**</bpt>Collapsed<ept id=\"p2\">**</ept>, this means the rectangle will not appear.","pos":[18924,19035],"source":" Because the default **Visibility** from composition is **Collapsed**, this means the rectangle will not appear."},{"content":"The control logic controls this by listening for focus events like <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>GotFocus<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208927)</ept> and changing the states with <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>GoToState<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR209025)</ept>.","pos":[19036,19279],"source":" The control logic controls this by listening for focus events like [**GotFocus**](https://msdn.microsoft.com/library/windows/apps/BR208927) and changing the states with [**GoToState**](https://msdn.microsoft.com/library/windows/apps/BR209025)."},{"content":"Often this is already handled for you if you are using a default control or customizing based on a control that already has that behavior.","pos":[19280,19418]},{"content":"Keyboard accessibility and Windows Phone","pos":[19585,19625]},{"content":"A Windows Phone device typically doesn't have a dedicated, hardware keyboard.","pos":[19626,19703]},{"content":"However, a Soft Input Panel (SIP) can support several keyboard accessibility scenarios.","pos":[19704,19791]},{"content":"Screen readers can read text input from the <bpt id=\"p1\">**</bpt>Text<ept id=\"p1\">**</ept> SIP, including announcing deletions.","pos":[19792,19881],"source":" Screen readers can read text input from the **Text** SIP, including announcing deletions."},{"content":"Users can discover where their fingers are because the screen reader can detect that the user is scanning keys, and it reads the scanned key name aloud.","pos":[19882,20034]},{"content":"Also, some of the keyboard-oriented accessibility concepts can be mapped to related assistive technology behaviors that don't use a keyboard at all.","pos":[20035,20183]},{"content":"For example, even though a SIP won't include a Tab key, Narrator supports a touch gesture that's the equivalent of pressing the Tab key, so having a useful tab order through the controls in a UI is still an important accessibility principle.","pos":[20184,20425]},{"content":"Arrow keys as used for navigating the parts within complex controls are also supported through Narrator touch gestures.","pos":[20426,20545]},{"content":"Once focus has reached a control that's not for text input, Narrator supports a gesture that invokes that control's action.","pos":[20546,20669]},{"content":"Keyboard shortcuts aren't typically relevant for Windows Phone apps, because a SIP won't include Control or Alt keys.","pos":[20671,20788]},{"content":"Related topics","pos":[20821,20835]},{"content":"Accessibility","pos":[20841,20854]},{"content":"Keyboard interactions","pos":[20877,20898]},{"content":"Input: Touch keyboard sample","pos":[20961,20989]},{"content":"Responding to the appearance of the on-screen keyboard sample","pos":[21043,21104]},{"content":"XAML accessibility sample","pos":[21158,21183]}],"content":"---\nauthor: Xansky\nDescription: If your app does not provide good keyboard access, users who are blind or have mobility issues can have difficulty using your app or may not be able to use it at all.\nms.assetid: DDAE8C4B-7907-49FE-9645-F105F8DFAD8B\ntitle: Keyboard accessibility\nlabel: Keyboard accessibility\ntemplate: detail.hbs\n---\n\n# Keyboard accessibility  \n\n\n\nIf your app does not provide good keyboard access, users who are blind or have mobility issues can have difficulty using your app or may not be able to use it at all.\n\n<span id=\"keyboard_navigation_among_UI_elements\"/>\n<span id=\"keyboard_navigation_among_ui_elements\"/>\n<span id=\"KEYBOARD_NAVIGATION_AMONG_UI_ELEMENTS\"/>\n## Keyboard navigation among UI elements  \nTo use the keyboard with a control, the control must have focus, and to receive focus (without using a pointer) the control must be accessible in a UI design via tab navigation. By default, the tab order of controls is the same as the order in which they are added to a design surface, listed in XAML, or programmatically added to a container.\n\nIn most cases, the default order based on how you defined controls in XAML is the best order, especially because that is the order in which the controls are read by screen readers. However, the default order does not necessarily correspond to the visual order. The actual display position might depend on the parent layout container and certain properties that you can set on the child elements to influence the layout. To be sure your app has a good tab order, test this behavior yourself. Especially if you have a grid metaphor or table metaphor for your layout, the order in which users might read versus the tab order could end up different. That's not always a problem in and of itself. But just make sure to test your app's functionality both as a touchable UI and as a keyboard-accessible UI and verify that your UI makes sense either way.\n\nYou can make the tab order match the visual order by adjusting the XAML. Or you can override the default tab order by setting the [**TabIndex**](https://msdn.microsoft.com/library/windows/apps/BR209461) property, as shown in the following example of a [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704) layout that uses column-first tab navigation.\n\nXAML\n```xml\n<!--Custom tab order.-->\n<Grid>\n  <Grid.RowDefinitions>...</Grid.RowDefinitions>\n  <Grid.ColumnDefinitions>...</Grid.ColumnDefinitions>\n\n  <TextBlock Grid.Column=\"1\" HorizontalAlignment=\"Center\">Groom</TextBlock>\n  <TextBlock Grid.Column=\"2\" HorizontalAlignment=\"Center\">Bride</TextBlock>\n\n  <TextBlock Grid.Row=\"1\">First name</TextBlock>\n  <TextBox x:Name=\"GroomFirstName\" Grid.Row=\"1\" Grid.Column=\"1\" TabIndex=\"1\"/>\n  <TextBox x:Name=\"BrideFirstName\" Grid.Row=\"1\" Grid.Column=\"2\" TabIndex=\"3\"/>\n\n  <TextBlock Grid.Row=\"2\">Last name</TextBlock>\n  <TextBox x:Name=\"GroomLastName\" Grid.Row=\"2\" Grid.Column=\"1\" TabIndex=\"2\"/>\n  <TextBox x:Name=\"BrideLastName\" Grid.Row=\"2\" Grid.Column=\"2\" TabIndex=\"4\"/>\n</Grid>\n```\n\nYou may want to exclude a control from the tab order. You typically do this only by making the control noninteractive, for example by setting its [**IsEnabled**](https://msdn.microsoft.com/library/windows/apps/BR209419) property to **false**. A disabled control is automatically excluded from the tab order. But occasionally you might want to exclude a control from the tab order even if it is not disabled. In this case, you can set the [**IsTabStop**](https://msdn.microsoft.com/library/windows/apps/BR209422) property to **false**.\n\nAny elements that can have focus are usually in the tab order by default. The exception to this is that certain text-display types such as [**RichTextBlock**](https://msdn.microsoft.com/library/windows/apps/BR227565) can have focus so that they can be accessed by the clipboard for text selection; however, they're not in the tab order because it is not expected for static text elements to be in the tab order. They're not conventionally interactive (they can't be invoked, and don't require text input, but do support the [Text control pattern](https://msdn.microsoft.com/library/windows/desktop/Ee671194) that supports finding and adjusting selection points in text). Text should not have the connotation that setting focus to it will enable some action that's possible. Text elements will still be detected by assistive technologies, and read aloud in screen readers, but that relies on techniques other than finding those elements in the practical tab order.\n\nWhether you adjust [**TabIndex**](https://msdn.microsoft.com/library/windows/apps/BR209461) values or use the default order, these rules apply:\n\n* UI elements with [**TabIndex**](https://msdn.microsoft.com/library/windows/apps/BR209461) equal to 0 are added to the tab order based on declaration order in XAML or child collections.\n* UI elements with [**TabIndex**](https://msdn.microsoft.com/library/windows/apps/BR209461) greater than 0 are added to the tab order based on the **TabIndex** value.\n* UI elements with [**TabIndex**](https://msdn.microsoft.com/library/windows/apps/BR209461) less than 0 are added to the tab order and appear before any zero value. This potentially differs from HTML's handling of its **tabindex** attribute (and negative **tabindex** was not supported in older HTML specifications).\n\n<span id=\"keyboard_navigation_within_a_UI_element\"/>\n<span id=\"keyboard_navigation_within_a_ui_element\"/>\n<span id=\"KEYBOARD_NAVIGATION_WITHIN_A_UI_ELEMENT\"/>\n## Keyboard navigation within a UI element  \nFor composite elements, it is important to ensure proper inner navigation among the contained elements. A composite element can manage its current active child to reduce the overhead of having all child elements able to have focus. Such a composite element is included in the tab order, and it handles keyboard navigation events itself. Many of the composite controls already have some inner navigation logic built into the into control's event handling. For example, arrow-key traversal of items is enabled by default on the [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878), [**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242704view), [**ListBox**](https://msdn.microsoft.com/library/windows/apps/BR242868) and [**FlipView**](https://msdn.microsoft.com/library/windows/apps/BR242678) controls.\n\n<span id=\"keyboard_activation\"/>\n<span id=\"KEYBOARD_ACTIVATION\"/>\n## Keyboard alternatives to pointer actions and events for specific control elements  \nEnsure that UI elements that can be clicked can also be invoked by using the keyboard. To use the keyboard with a UI element, the element must have focus. Only classes that derive from [**Control**](https://msdn.microsoft.com/library/windows/apps/BR209390) support focus and tab navigation.\n\nFor UI elements that can be invoked, implement keyboard event handlers for the Spacebar and Enter keys. This makes the basic keyboard accessibility support complete and enables users to accomplish basic app scenarios by using only the keyboard; that is, users can reach all interactive UI elements and activate the default functionality.\n\nIn cases where an element that you want to use in the UI cannot have focus, you could create your own custom control. You must set the [**IsTabStop**](https://msdn.microsoft.com/library/windows/apps/BR209422) property to **true** to enable focus and you must provide a visual indication of the focused state by creating a visual state that decorates the UI with a focus indicator. However, it is often easier to use control composition so that the support for tab stops, focus, and Microsoft UI Automation peers and patterns are handled by the control within which you choose to compose your content.\n\nFor example, instead of handling a pointer-pressed event on an [**Image**](https://msdn.microsoft.com/library/windows/apps/BR242752), you could wrap that element in a [**Button**](https://msdn.microsoft.com/library/windows/apps/BR209265) to get pointer, keyboard, and focus support.\n\nXAML\n```xml\n<!--Don't do this.-->\n<Image Source=\"sample.jpg\" PointerPressed=\"Image_PointerPressed\"/>\n\n<!--Do this instead.-->\n<Button Click=\"Button_Click\"><Image Source=\"sample.jpg\"/></Button>\n```\n\n<span id=\"keyboard_shortcuts\"/>\n<span id=\"KEYBOARD_SHORTCUTS\"/>\n## Keyboard shortcuts  \nIn addition to implementing keyboard navigation and activation for your app, it is a good practice to implement shortcuts for your app's functionality. Tab navigation provides a good, basic level of keyboard support, but with complex forms you may want to add support for shortcut keys as well. This can make your application more efficient to use, even for people who use both a keyboard and pointing devices.\n\nA *shortcut* is a keyboard combination that enhances productivity by providing an efficient way for the user to access app functionality. There are two kinds of shortcut:\n\n* An *access key* is a shortcut to a piece of UI in your app. Access keys consist of the Alt key plus a letter key.\n* An *accelerator key* is a shortcut to an app command. Your app may or may not have UI that corresponds exactly to the command. Accelerator keys consist of the Ctrl key plus a letter key.\n\nIt is imperative that you provide an easy way for users who rely on screen readers and other assistive technology to discover your app's shortcut keys. Communicate shortcut keys by using tooltips, accessible names, accessible descriptions, or some other form of on-screen communication. At a minimum, shortcut keys should be well documented in your app's Help content.\n\nYou can document access keys through screen readers by setting the [**AutomationProperties.AccessKey**](https://msdn.microsoft.com/library/windows/apps/Hh759763) attached property to a string that describes the shortcut key. There is also an [**AutomationProperties.AcceleratorKey**](https://msdn.microsoft.com/library/windows/apps/Hh759762) attached property for documenting non-mnemonic shortcut keys, although screen readers generally treat both properties the same way. Try to document shortcut keys in multiple ways, using tooltips, automation properties, and written Help documentation.\n\nThe following example demonstrates how to document shortcut keys for media play, pause, and stop buttons.\n\nXAML\n```xml\n<Grid KeyDown=\"Grid_KeyDown\">\n\n  <Grid.RowDefinitions>\n    <RowDefinition Height=\"Auto\" />\n    <RowDefinition Height=\"Auto\" />\n  </Grid.RowDefinitions>\n\n  <MediaElement x:Name=\"DemoMovie\" Source=\"xbox.wmv\"\n    Width=\"500\" Height=\"500\" Margin=\"20\" HorizontalAlignment=\"Center\" />\n\n  <StackPanel Grid.Row=\"1\" Margin=\"10\"\n    Orientation=\"Horizontal\" HorizontalAlignment=\"Center\">\n\n    <Button x:Name=\"PlayButton\" Click=\"MediaButton_Click\"\n      ToolTipService.ToolTip=\"Shortcut key: Ctrl+P\"\n      AutomationProperties.AcceleratorKey=\"Control P\">\n      <TextBlock>Play</TextBlock>\n    </Button>\n\n    <Button x:Name=\"PauseButton\" Click=\"MediaButton_Click\"\n      ToolTipService.ToolTip=\"Shortcut key: Ctrl+A\"\n      AutomationProperties.AcceleratorKey=\"Control A\">\n      <TextBlock>Pause</TextBlock>\n    </Button>\n\n    <Button x:Name=\"StopButton\" Click=\"MediaButton_Click\"\n      ToolTipService.ToolTip=\"Shortcut key: Ctrl+S\"\n      AutomationProperties.AcceleratorKey=\"Control S\">\n      <TextBlock>Stop</TextBlock>\n    </Button>\n  </StackPanel>\n</Grid>\n```\n\n> [!IMPORTANT]\n> Setting [**AutomationProperties.AcceleratorKey**](https://msdn.microsoft.com/library/windows/apps/Hh759762) or [**AutomationProperties.AccessKey**](https://msdn.microsoft.com/library/windows/apps/Hh759763) doesn't enable keyboard functionality. It only reports to the UI Automation framework what keys should be used, so that such information can be passed on to users via assistive technologies. The implementation for key handling still needs to be done in code, not XAML. You will still need to attach handlers for [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/BR208941) or [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/BR208942) events on the relevant control in order to actually implement the keyboard shortcut behavior in your app. Also, the underline text decoration for an access key is not provided automatically. You must explicitly underline the text for the specific key in your mnemonic as inline [**Underline**](https://msdn.microsoft.com/library/windows/apps/BR209982) formatting if you wish to show underlined text in the UI.\n\nFor simplicity, the preceding example omits the use of resources for strings such as \"Ctrl+A\". However, you must also consider shortcut keys during localization. Localizing shortcut keys is relevant because the choice of key to use as the shortcut key typically depends on the visible text label for the element.\n\nFor more guidance about implementing shortcut keys, see [Shortcut keys](http://go.microsoft.com/fwlink/p/?linkid=221825) in the Windows User Experience Interaction Guidelines.\n\n<span id=\"Implementing_a_key_event_handler\"/>\n<span id=\"implementing_a_key_event_handler\"/>\n<span id=\"IMPLEMENTING_A_KEY_EVENT_HANDLER\"/>\n### Implementing a key event handler  \nInput events such as the key events use an event concept called *routed events*. A routed event can bubble up through the child elements of a composited control, such that a common control parent can handle events for multiple child elements. This event model is convenient for defining shortcut key actions for a control that contains several composite parts that by design cannot have focus or be part of the tab order.\n\nFor example code that shows how to write a key event handler that includes checking for modifiers such as the Ctrl key, see [Keyboard interactions](https://msdn.microsoft.com/library/windows/apps/Mt185607).\n\n<span id=\"Keyboard_navigation_for_custom_controls\"/>\n<span id=\"keyboard_navigation_for_custom_controls\"/>\n<span id=\"KEYBOARD_NAVIGATION_FOR_CUSTOM_CONTROLS\"/>\n## Keyboard navigation for custom controls  \nWe recommend the use of arrow keys as keyboard shortcuts for navigating among child elements, in cases where the child elements have a spacial relationship to each other. If tree-view nodes have separate sub-elements for handling expand-collapse and node activation, use the left and right arrow keys to provide keyboard expand-collapse functionality. If you have an oriented control that supports directional traversal within the control content, use the appropriate arrow keys.\n\nGenerally you implement custom key handling for custom controls by including an override of [**OnKeyDown**](https://msdn.microsoft.com/library/windows/apps/BR209390_onkeydown) and [**OnKeyUp**](https://msdn.microsoft.com/library/windows/apps/BR209390_onkeyup) methods as part of the class logic.\n\n<span id=\"An_example_of_a_visual_state_for_a_focus_indicator\"/>\n<span id=\"an_example_of_a_visual_state_for_a_focus_indicator\"/>\n<span id=\"AN_EXAMPLE_OF_A_VISUAL_STATE_FOR_A_FOCUS_INDICATOR\"/>\n## An example of a visual state for a focus indicator  \nWe mentioned earlier that any custom control that enables the user to focus it should have a visual focus indicator. Usually that focus indicator is as simple as drawing a rectangle shape immediately around the control's normal bounding rectangle. The [**Rectangle**](https://msdn.microsoft.com/library/windows/apps/BR243371) for visual focus is a peer element to the rest of the control's composition in a control template, but is initially set with a [**Visibility**](https://msdn.microsoft.com/library/windows/apps/BR208992) value of **Collapsed** because the control isn't focused yet. Then, when the control does get focus, a visual state is invoked that specifically sets the **Visibility** of the focus visual to **Visible**. Once focus is moved elsewhere, another visual state is called, and the **Visibility** becomes **Collapsed**.\n\nAll of the default XAML controls will display an appropriate visual focus indicator when focused (if they can be focused). There are also potentially different looks depending on the user's selected theme (particularly if the user is using a high contrast mode.) If you're using the XAML controls in your UI and not replacing the control templates, you don't need to do anything extra to get visual focus indicators on controls that behave and display correctly. But if you're intending to retemplate a control, or if you're curious about how XAML controls provide their visual focus indicators, the remainder of this section explains how this is done in XAML and in the control logic.\n\nHere's some example XAML that comes from the default XAML template for a [**Button**](https://msdn.microsoft.com/library/windows/apps/BR209265).\n\nXAML\n```xml\n<ControlTemplate TargetType=\"Button\">\n...\n    <Rectangle\n      x:Name=\"FocusVisualWhite\"\n      IsHitTestVisible=\"False\"\n      Stroke=\"{ThemeResource FocusVisualWhiteStrokeThemeBrush}\"\n      StrokeEndLineCap=\"Square\"\n      StrokeDashArray=\"1,1\"\n      Opacity=\"0\"\n      StrokeDashOffset=\"1.5\"/>\n    <Rectangle\n      x:Name=\"FocusVisualBlack\"\n      IsHitTestVisible=\"False\"\n      Stroke=\"{ThemeResource FocusVisualBlackStrokeThemeBrush}\"\n      StrokeEndLineCap=\"Square\"\n      StrokeDashArray=\"1,1\"\n      Opacity=\"0\"\n      StrokeDashOffset=\"0.5\"/>\n...\n</ControlTemplate>\n```\n\nSo far this is just the composition. To control the focus indicator's visibility, you define visual states that toggle the [**Visibility**](https://msdn.microsoft.com/library/windows/apps/BR208992) property. This is done using the [**VisualStateManager.VisualStateGroups**](https://msdn.microsoft.com/library/windows/apps/Hh738505) attached property, as applied to the root element that defines the composition.\n\nXAML\n```xml\n<ControlTemplate TargetType=\"Button\">\n  <Grid>\n    <VisualStateManager.VisualStateGroups>\n       <!--other visual state groups here-->\n       <VisualStateGroup x:Name=\"FocusStates\">\n         <VisualState x:Name=\"Focused\">\n           <Storyboard>\n             <DoubleAnimation\n               Storyboard.TargetName=\"FocusVisualWhite\"\n               Storyboard.TargetProperty=\"Opacity\"\n               To=\"1\" Duration=\"0\"/>\n             <DoubleAnimation\n               Storyboard.TargetName=\"FocusVisualBlack\"\n               Storyboard.TargetProperty=\"Opacity\"\n               To=\"1\" Duration=\"0\"/>\n         </VisualState>\n         <VisualState x:Name=\"Unfocused\" />\n         <VisualState x:Name=\"PointerFocused\" />\n       </VisualStateGroup>\n     <VisualStateManager.VisualStateGroups>\n<!--composition is here-->\n   </Grid>\n</ControlTemplate>\n```\n\nNote how only one of the named states adjusts [**Visibility**](https://msdn.microsoft.com/library/windows/apps/BR208992) directly whereas the others are seemingly empty. The way that visual states work is that as soon as the control uses another state from the same [**VisualStateGroup**](https://msdn.microsoft.com/library/windows/apps/BR209014), any animations applied by the previous state are immediately canceled. Because the default **Visibility** from composition is **Collapsed**, this means the rectangle will not appear. The control logic controls this by listening for focus events like [**GotFocus**](https://msdn.microsoft.com/library/windows/apps/BR208927) and changing the states with [**GoToState**](https://msdn.microsoft.com/library/windows/apps/BR209025). Often this is already handled for you if you are using a default control or customizing based on a control that already has that behavior.\n\n<span id=\"Keyboard_accessibility_and_Windows_Phone\"/>\n<span id=\"keyboard_accessibility_and_windows_phone\"/>\n<span id=\"KEYBOARD_ACCESSIBILITY_AND_WINDOWS_PHONE\"/>\n## Keyboard accessibility and Windows Phone\nA Windows Phone device typically doesn't have a dedicated, hardware keyboard. However, a Soft Input Panel (SIP) can support several keyboard accessibility scenarios. Screen readers can read text input from the **Text** SIP, including announcing deletions. Users can discover where their fingers are because the screen reader can detect that the user is scanning keys, and it reads the scanned key name aloud. Also, some of the keyboard-oriented accessibility concepts can be mapped to related assistive technology behaviors that don't use a keyboard at all. For example, even though a SIP won't include a Tab key, Narrator supports a touch gesture that's the equivalent of pressing the Tab key, so having a useful tab order through the controls in a UI is still an important accessibility principle. Arrow keys as used for navigating the parts within complex controls are also supported through Narrator touch gestures. Once focus has reached a control that's not for text input, Narrator supports a gesture that invokes that control's action.\n\nKeyboard shortcuts aren't typically relevant for Windows Phone apps, because a SIP won't include Control or Alt keys.\n\n<span id=\"related_topics\"/>\n## Related topics  \n* [Accessibility](accessibility.md)\n* [Keyboard interactions](https://msdn.microsoft.com/library/windows/apps/Mt185607)\n* [Input: Touch keyboard sample](http://go.microsoft.com/fwlink/p/?linkid=246019)\n* [Responding to the appearance of the on-screen keyboard sample](http://go.microsoft.com/fwlink/p/?linkid=231633)\n* [XAML accessibility sample](http://go.microsoft.com/fwlink/p/?linkid=238570)\n \n"}