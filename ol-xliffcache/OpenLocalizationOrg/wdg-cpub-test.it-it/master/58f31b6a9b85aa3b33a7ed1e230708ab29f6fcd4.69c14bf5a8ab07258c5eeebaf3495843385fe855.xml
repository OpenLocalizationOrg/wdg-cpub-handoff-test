{"nodes":[{"pos":[11,23],"content":"Add controls","needQuote":true,"needEscape":true,"nodes":[{"content":"Add controls","pos":[0,12]}]},{"pos":[37,193],"content":"Now, we take a look at how the game sample implements move-look controls in a 3-D game, and how to develop basic touch, mouse, and game controller controls.","needQuote":true,"needEscape":true,"nodes":[{"content":"Now, we take a look at how the game sample implements move-look controls in a 3-D game, and how to develop basic touch, mouse, and game controller controls.","pos":[0,156]}]},{"content":"Add controls","pos":[250,262]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[265,303]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[304,399],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Now, we take a look at how the game sample implements move-look controls in a 3-D game, and how to develop basic touch, mouse, and game controller controls.","pos":[401,557]},{"content":"Objective","pos":[562,571]},{"content":"To implement mouse/keyboard, touch, and Xbox controller controls in a Universal Windows Platform (UWP) game with DirectX.","pos":[578,699]},{"content":"UWP game apps and controls","pos":[704,730]},{"content":"A good UWP game supports a broad variety of interfaces.","pos":[733,788]},{"content":"A potential player might have Windows 10 on a tablet with no physical buttons, or a media PC with an Xbox controller attached, or the latest desktop gaming rig with a high-performance mouse and gaming keyboard.","pos":[789,999]},{"content":"Your game should support all of these devices if the game design allows it.","pos":[1000,1075]},{"content":"This sample supports all three.","pos":[1077,1108]},{"content":"It's a simple first-person shooting game, and the move-look controls that are standard for this genre are easily implemented for all three types of input.","pos":[1109,1263]},{"pos":[1265,1516],"content":"For more info about controls, and move-look controls specifically, see <bpt id=\"p1\">[</bpt>Move-look controls for games<ept id=\"p1\">](tutorial--adding-move-look-controls-to-your-directx-game.md)</ept> and <bpt id=\"p2\">[</bpt>Touch controls for games<ept id=\"p2\">](tutorial--adding-touch-controls-to-your-directx-game.md)</ept>.","source":"For more info about controls, and move-look controls specifically, see [Move-look controls for games](tutorial--adding-move-look-controls-to-your-directx-game.md) and [Touch controls for games](tutorial--adding-touch-controls-to-your-directx-game.md)."},{"content":"Common control behaviors","pos":[1521,1545]},{"content":"Touch controls and mouse/keyboard controls have a very similar core implementation.","pos":[1548,1631]},{"content":"In a UWP app, a pointer is simply a point on the screen.","pos":[1632,1688]},{"content":"You can move it by sliding the mouse or sliding your finger on the touch screen.","pos":[1689,1769]},{"content":"As a result, you can register for a single set of events, and not worry about whether the player is using a mouse or a touch screen to move and press the pointer.","pos":[1770,1932]},{"pos":[1934,2082],"content":"When the <bpt id=\"p1\">**</bpt>MoveLookController<ept id=\"p1\">**</ept> class in the game sample is initialized, it registers for four pointer-specific events and one mouse-specific event:","source":"When the **MoveLookController** class in the game sample is initialized, it registers for four pointer-specific events and one mouse-specific event:"},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow::PointerPressed<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208278)</ept>.","pos":[2088,2179],"source":"[**CoreWindow::PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208278)."},{"content":"The left or right mouse button was pressed (and held), or the touch surface was touched.","pos":[2180,2268]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow::PointerMoved<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208276)</ept>.","pos":[2273,2362],"source":"[**CoreWindow::PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208276)."},{"content":"The mouse moved, or a drag action was made on the touch surface.","pos":[2363,2427]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow::PointerReleased<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208279)</ept>.","pos":[2432,2524],"source":"[**CoreWindow::PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279)."},{"content":"The left mouse button was released, or the object contacting the touch surface was lifted.","pos":[2525,2615]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow::PointerExited<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208275)</ept>.","pos":[2620,2710],"source":"[**CoreWindow::PointerExited**](https://msdn.microsoft.com/library/windows/apps/br208275)."},{"content":"The pointer moved out of the main window.","pos":[2711,2752]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows::Devices::Input::MouseMoved<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh758356)</ept>.","pos":[2757,2857],"source":"[**Windows::Devices::Input::MouseMoved**](https://msdn.microsoft.com/library/windows/apps/hh758356)."},{"content":"The mouse moved a certain distance.","pos":[2858,2893]},{"content":"Be aware that we are only interested in mouse movement delta values, and not the current x-y position.","pos":[2894,2996]},{"content":"The Xbox controller is handled separately, using the <bpt id=\"p1\">[</bpt>XInput<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh405053)</ept> APIs.","pos":[4261,4389],"source":"The Xbox controller is handled separately, using the [XInput](https://msdn.microsoft.com/library/windows/desktop/hh405053) APIs."},{"content":"We talk about the implementation of game controller controls in a bit.","pos":[4390,4460]},{"pos":[4462,4584],"content":"In the game sample, the <bpt id=\"p1\">**</bpt>MoveLookController<ept id=\"p1\">**</ept> class has three controller-specific states, regardless of the control type:","source":"In the game sample, the **MoveLookController** class has three controller-specific states, regardless of the control type:"},{"content":"<bpt id=\"p1\">**</bpt>None<ept id=\"p1\">**</ept>.","pos":[4590,4599],"source":"**None**."},{"content":"This is the initialized state for the controller.","pos":[4600,4649]},{"content":"The game is not anticipating any controller input.","pos":[4650,4700]},{"content":"<bpt id=\"p1\">**</bpt>WaitForInput<ept id=\"p1\">**</ept>.","pos":[4705,4722],"source":"**WaitForInput**."},{"content":"The game is paused and is waiting for the player to continue.","pos":[4723,4784]},{"content":"<bpt id=\"p1\">**</bpt>Active<ept id=\"p1\">**</ept>.","pos":[4789,4800],"source":"**Active**."},{"content":"The game is running, processing player input.","pos":[4801,4846]},{"content":"The <bpt id=\"p1\">**</bpt>Active<ept id=\"p1\">**</ept> state is the state when the player is actively playing the game.","pos":[4848,4927],"source":"The **Active** state is the state when the player is actively playing the game."},{"content":"During this state, the <bpt id=\"p1\">**</bpt>MoveLookController<ept id=\"p1\">**</ept> instance is processing input events from all enabled input devices and interpreting the player's intentions based on the aggregated event data.","pos":[4928,5117],"source":" During this state, the **MoveLookController** instance is processing input events from all enabled input devices and interpreting the player's intentions based on the aggregated event data."},{"content":"As a result, it updates the velocity and look direction (the view plane normal) of the player's view and shares the updated data with the game after Update is called from the game loop.","pos":[5118,5303]},{"content":"Be aware that the player can take more than one action at the same time.","pos":[5305,5377]},{"content":"For example, he or she could be firing spheres while moving the camera.","pos":[5378,5449]},{"content":"All of these inputs are tracked in the <bpt id=\"p1\">**</bpt>Active<ept id=\"p1\">**</ept> state, with different pointer IDs corresponding to different pointer actions.","pos":[5450,5577],"source":" All of these inputs are tracked in the **Active** state, with different pointer IDs corresponding to different pointer actions."},{"content":"This is necessary because from a player's perspective, a pointer event in the firing rectangle is different from one in the move rectangle or in the rest of the screen.","pos":[5578,5746]},{"content":"When a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerPressed<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208278)</ept> event is received, the <bpt id=\"p3\">**</bpt>MoveLookController<ept id=\"p3\">**</ept> obtains the pointer ID value created by the window.","pos":[5748,5931],"source":"When a [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208278) event is received, the **MoveLookController** obtains the pointer ID value created by the window."},{"content":"The pointer ID represents a specific type of input.","pos":[5932,5983]},{"content":"For example, on a multi-touch device, there may be several different active inputs at the same time.","pos":[5984,6084]},{"content":"The IDs are used to keep track of which input the player is using.","pos":[6085,6151]},{"content":"If one event is in the move rectangle of the touch screen, a pointer ID is assigned to track any pointer events in move rectangle.","pos":[6152,6282]},{"content":"Other pointer events in the fire rectangle are tracked separately, with a separate pointer ID.","pos":[6283,6377]},{"content":"(We talk about this some more in the section on touch controls.)","pos":[6378,6442]},{"content":"Input from the mouse has yet another ID and is also handled separately.","pos":[6444,6515]},{"pos":[6517,6680],"content":"After the pointer events have been mapped to a specific game action, it's time to update the data the <bpt id=\"p1\">**</bpt>MoveLookController<ept id=\"p1\">**</ept> object shares with the main game loop.","source":"After the pointer events have been mapped to a specific game action, it's time to update the data the **MoveLookController** object shares with the main game loop."},{"pos":[6682,6993],"content":"When called, the <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> method in the game sample processes the input and updates the velocity and look direction variables (<bpt id=\"p2\">**</bpt>m\\_velocity<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>m\\_lookdirection<ept id=\"p3\">**</ept>), which the game loop then retrieves by calling the public <bpt id=\"p4\">**</bpt>Velocity<ept id=\"p4\">**</ept> and <bpt id=\"p5\">**</bpt>LookDirection<ept id=\"p5\">**</ept> methods on the <bpt id=\"p6\">**</bpt>MoveLookController<ept id=\"p6\">**</ept> instance.","source":"When called, the **Update** method in the game sample processes the input and updates the velocity and look direction variables (**m\\_velocity** and **m\\_lookdirection**), which the game loop then retrieves by calling the public **Velocity** and **LookDirection** methods on the **MoveLookController** instance."},{"content":"The game loop can test to see if the player is firing by calling the <bpt id=\"p1\">**</bpt>IsFiring<ept id=\"p1\">**</ept> method on the <bpt id=\"p2\">**</bpt>MoveLookController<ept id=\"p2\">**</ept> instance.","pos":[9064,9192],"source":"The game loop can test to see if the player is firing by calling the **IsFiring** method on the **MoveLookController** instance."},{"content":"The <bpt id=\"p1\">**</bpt>MoveLookController<ept id=\"p1\">**</ept> checks to see if the player has pressed the fire button on one of the three input types.","pos":[9193,9308],"source":" The **MoveLookController** checks to see if the player has pressed the fire button on one of the three input types."},{"content":"If the player moves the pointer outside the main window of the game, or presses the pause button (the P key or the Xbox controller start button), the game must be paused.","pos":[9744,9914]},{"content":"The <bpt id=\"p1\">**</bpt>MoveLookController<ept id=\"p1\">**</ept> registered the press, and informs the game loop when it calls the <bpt id=\"p2\">**</bpt>IsPauseRequested<ept id=\"p2\">**</ept> method.","pos":[9915,10036],"source":" The **MoveLookController** registered the press, and informs the game loop when it calls the **IsPauseRequested** method."},{"content":"At that point, if <bpt id=\"p1\">**</bpt>IsPauseRequested<ept id=\"p1\">**</ept> returns <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept>, the game loop then calls <bpt id=\"p3\">**</bpt>WaitForPress<ept id=\"p3\">**</ept> on the <bpt id=\"p4\">**</bpt>MoveLookController<ept id=\"p4\">**</ept> to move the controller into the <bpt id=\"p5\">**</bpt>WaitForInput<ept id=\"p5\">**</ept> state.","pos":[10037,10221],"source":" At that point, if **IsPauseRequested** returns **true**, the game loop then calls **WaitForPress** on the **MoveLookController** to move the controller into the **WaitForInput** state."},{"content":"Then, the <bpt id=\"p1\">**</bpt>MoveLookController<ept id=\"p1\">**</ept> waits for the player to select one of the menu items to load, continue, or exit the game, and stop processing gameplay input events until it returns to the <bpt id=\"p2\">**</bpt>Active<ept id=\"p2\">**</ept> state.","pos":[10222,10428],"source":" Then, the **MoveLookController** waits for the player to select one of the menu items to load, continue, or exit the game, and stop processing gameplay input events until it returns to the **Active** state."},{"pos":[10430,10492],"content":"See the <bpt id=\"p1\">[</bpt>complete code sample for this section<ept id=\"p1\">](#code_sample)</ept>.","source":"See the [complete code sample for this section](#code_sample)."},{"content":"Now, let's look at the implementation of each of the three control types in a little more detail.","pos":[10494,10591]},{"content":"Implementing relative mouse controls","pos":[10596,10632]},{"content":"If mouse movement is detected, we want use that movement to determine the new pitch and yaw of the camera.","pos":[10635,10741]},{"content":"We do that by implementing relative mouse controls, where we handle the relative distance the mouse has moved—the delta between the start of the movement and the stop—as opposed to recording the absolute x-y pixel coordinates of the motion.","pos":[10742,10982]},{"pos":[10984,11454],"content":"To do that, we obtain the changes in the X (the horizontal motion) and the Y (the vertical motion) coordinates by examining the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MouseDelta::X<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh758353)</ept> and <bpt id=\"p3\">**</bpt>MouseDelta::Y<ept id=\"p3\">**</ept> fields on the <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>Windows::Device::Input::MouseEventArgs::MouseDelta<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/hh758358)</ept> argument object returned by the <bpt id=\"p6\">[</bpt><bpt id=\"p7\">**</bpt>MouseMoved<ept id=\"p7\">**</ept><ept id=\"p6\">](https://msdn.microsoft.com/library/windows/apps/hh758356)</ept> event.","source":"To do that, we obtain the changes in the X (the horizontal motion) and the Y (the vertical motion) coordinates by examining the [**MouseDelta::X**](https://msdn.microsoft.com/library/windows/apps/hh758353) and **MouseDelta::Y** fields on the [**Windows::Device::Input::MouseEventArgs::MouseDelta**](https://msdn.microsoft.com/library/windows/apps/hh758358) argument object returned by the [**MouseMoved**](https://msdn.microsoft.com/library/windows/apps/hh758356) event."},{"content":"Implementing touch controls","pos":[12625,12652]},{"content":"Touch controls are the trickiest to develop, because they are the most complex and require the most fine-tuning to be effective.","pos":[12655,12783]},{"content":"In the game sample, a rectangle in the lower left quadrant of the screen is used as a directional pad, where sliding your thumb left and right in this space slides the camera left and right, and sliding your thumb up and down moves the camera forward and backward.","pos":[12784,13048]},{"content":"A rectangle in the lower right quadrant of the screen can be pressed to fire the spheres.","pos":[13049,13138]},{"content":"Aiming (pitch and yaw) are controlled by sliding your finger on the parts of the screen not reserved for moving and firing; as your finger moves, the camera (with fixed cross hairs) moves similarly.","pos":[13139,13337]},{"content":"The move and fire rectangles are created by two methods in the sample code:","pos":[13339,13414]},{"content":"We treat touch device pointer events for the other regions of the screen as look commands.","pos":[13655,13745]},{"content":"If the screen is resized, these rectangles must be computed again (and redrawn).","pos":[13746,13826]},{"pos":[13828,13987],"content":"If a touch device pointer event is raised in one of these regions and the game state is set to <bpt id=\"p1\">**</bpt>Active<ept id=\"p1\">**</ept>, it's assigned a pointer ID, as we discussed earlier.","source":"If a touch device pointer event is raised in one of these regions and the game state is set to **Active**, it's assigned a pointer ID, as we discussed earlier."},{"content":"If a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerPressed<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208278)</ept> event has occurred in one of the three control regions, the move rectangle, the fire rectangle, or the rest of the screen (the look control), the <bpt id=\"p3\">**</bpt>MoveLookController<ept id=\"p3\">**</ept> assigns the pointer ID for the pointer that fired the event to a specific variable that corresponds to the region of the screen the event was fired in.","pos":[16812,17216],"source":"If a [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208278) event has occurred in one of the three control regions, the move rectangle, the fire rectangle, or the rest of the screen (the look control), the **MoveLookController** assigns the pointer ID for the pointer that fired the event to a specific variable that corresponds to the region of the screen the event was fired in."},{"content":"For example, if the event occurred in the move rectangle, the <bpt id=\"p1\">**</bpt>m\\_movePointerID<ept id=\"p1\">**</ept> variable is set to the pointer ID that fired the event.","pos":[17217,17355],"source":" For example, if the event occurred in the move rectangle, the **m\\_movePointerID** variable is set to the pointer ID that fired the event."},{"content":"A Boolean \"in use\" variable (<bpt id=\"p1\">**</bpt>m\\_lookInUse<ept id=\"p1\">**</ept>, in the example) is also set to indicate that the control has not been released yet.","pos":[17356,17486],"source":" A Boolean \"in use\" variable (**m\\_lookInUse**, in the example) is also set to indicate that the control has not been released yet."},{"pos":[17488,17635],"content":"Now, let's look at how the game sample handles the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerMoved<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208276)</ept> touch screen event.","source":"Now, let's look at how the game sample handles the [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208276) touch screen event."},{"pos":[19629,19756],"content":"The <bpt id=\"p1\">**</bpt>MoveLookController<ept id=\"p1\">**</ept> checks the pointer ID to determine where the event occurred, and takes one of the following actions:","source":"The **MoveLookController** checks the pointer ID to determine where the event occurred, and takes one of the following actions:"},{"pos":[19762,19939],"content":"If the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerMoved<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208276)</ept> event occurred in the move or fire rectangle, update the pointer position for the controller.","source":"If the [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208276) event occurred in the move or fire rectangle, update the pointer position for the controller."},{"pos":[19944,20178],"content":"If the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerMoved<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208276)</ept> event occurred somewhere in the rest of the screen (defined as the look controls), calculate the change in pitch and yaw of the look direction vector.","source":"If the [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208276) event occurred somewhere in the rest of the screen (defined as the look controls), calculate the change in pitch and yaw of the look direction vector."},{"pos":[20180,20333],"content":"Lastly, let's look at how the game sample handles the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerReleased<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208279)</ept> touch screen event.","source":"Lastly, let's look at how the game sample handles the [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279) touch screen event."},{"content":"If the ID of the pointer that fired the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerReleased<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208279)</ept> event is the ID of the previously recorded move pointer, the <bpt id=\"p3\">**</bpt>MoveLookController<ept id=\"p3\">**</ept> sets the velocity to 0 because the player has stopped touching the move rectangle.","pos":[21620,21906],"source":"If the ID of the pointer that fired the [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279) event is the ID of the previously recorded move pointer, the **MoveLookController** sets the velocity to 0 because the player has stopped touching the move rectangle."},{"content":"If it didn't set the velocity to 0, the player would keep moving!","pos":[21907,21972]},{"content":"If you want to implement some form of inertia, this is where you add the method that begins returning the velocity to 0 over future calls to <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> from the game loop.","pos":[21973,22144],"source":" If you want to implement some form of inertia, this is where you add the method that begins returning the velocity to 0 over future calls to **Update** from the game loop."},{"pos":[22146,22357],"content":"Otherwise, if the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerReleased<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208279)</ept> event fired in the fire rectangle or the look region, the <bpt id=\"p3\">**</bpt>MoveLookController<ept id=\"p3\">**</ept> resets the specific pointer IDs.","source":"Otherwise, if the [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279) event fired in the fire rectangle or the look region, the **MoveLookController** resets the specific pointer IDs."},{"content":"That's the basics of how touch screen controls are implemented in the game sample.","pos":[22359,22441]},{"content":"Let's move on to mouse and keyboard controls.","pos":[22442,22487]},{"content":"Implementing mouse and keyboard controls","pos":[22492,22532]},{"content":"The game sample implements these mouse and keyboard controls:","pos":[22535,22596]},{"content":"The W, S, A, and D keys move the player view forward, backward, left, and right, respectively.","pos":[22602,22696]},{"content":"Pressing X and the space bar move the view up and down, respectively.","pos":[22697,22766]},{"content":"Pressing the P key pauses the game.","pos":[22771,22806]},{"content":"Moving the mouse puts the player in control of the rotation (the pitch and yaw) of the camera view.","pos":[22811,22910]},{"content":"Clicking the left button fires a sphere.","pos":[22915,22955]},{"pos":[22957,23259],"content":"To use the keyboard, the game sample registers for two extra events: <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow::KeyUp<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208271)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>CoreWindow::KeyDown<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208270)</ept>, which handle the press and the release of a key, respectively.","source":"To use the keyboard, the game sample registers for two extra events: [**CoreWindow::KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208271) and [**CoreWindow::KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208270), which handle the press and the release of a key, respectively."},{"content":"The mouse is treated a little differently from the touch controls, even though it uses a pointer.","pos":[23510,23607]},{"content":"Obviously, it doesn't use the move and fire rectangles, as that would be very cumbersome for the player: how could they press the move and fire controls at the same time?","pos":[23608,23778]},{"content":"As noted earlier, the <bpt id=\"p1\">**</bpt>MoveLookController<ept id=\"p1\">**</ept> controller engages the look controls whenever the mouse is moved, and engages the fire controls when the left mouse button is pressed, as shown here.","pos":[23779,23973],"source":" As noted earlier, the **MoveLookController** controller engages the look controls whenever the mouse is moved, and engages the fire controls when the left mouse button is pressed, as shown here."},{"pos":[27788,27931],"content":"Now, let's look at how the game sample handles the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerReleased<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208279)</ept> mouse event.","source":"Now, let's look at how the game sample handles the [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279) mouse event."},{"content":"When the player stops pressing one of the mouse buttons, the input is complete: the spheres stop firing.","pos":[29602,29706]},{"content":"But, because look is always enabled, the game continues to use the same mouse pointer to track the ongoing look events.","pos":[29707,29826]},{"content":"Now, let's look at the last of control types: the Xbox controller.","pos":[29828,29894]},{"content":"It's handled separately from the touch and mouse controls, because it doesn't use the pointer object.","pos":[29895,29996]},{"content":"Implementing Xbox controller controls","pos":[30001,30038]},{"content":"In the game sample, Xbox controller support is added by calls to the <bpt id=\"p1\">[</bpt>XInput<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh405053)</ept> APIs, which are set of APIs designed to simplify programming for game controllers.","pos":[30041,30262],"source":"In the game sample, Xbox controller support is added by calls to the [XInput](https://msdn.microsoft.com/library/windows/desktop/hh405053) APIs, which are set of APIs designed to simplify programming for game controllers."},{"content":"In the game sample, we use the Xbox controller's left analog stick for player movement, the right analog stick for the look controls, and the right trigger to fire.","pos":[30263,30427]},{"content":"We use the start button to pause and resume the game.","pos":[30428,30481]},{"pos":[30483,30642],"content":"The <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> method on the <bpt id=\"p2\">**</bpt>MoveLookController<ept id=\"p2\">**</ept> instance immediately checks to see if a game controller is connected, and then checks the controller state.","source":"The **Update** method on the **MoveLookController** instance immediately checks to see if a game controller is connected, and then checks the controller state."},{"content":"If the game controller is in the <bpt id=\"p1\">**</bpt>Active<ept id=\"p1\">**</ept> state, this method checks to see if a user moved the left analog stick in a specific direction.","pos":[35047,35186],"source":"If the game controller is in the **Active** state, this method checks to see if a user moved the left analog stick in a specific direction."},{"content":"But the movement on the stick in a specific direction must register as larger than the radius of the dead zone; otherwise, nothing will happen.","pos":[35187,35330]},{"content":"This dead zone radius is necessary to present \"drifting,\" which is when the controller picks up minute movements from the player's thumb as it rests on the stick.","pos":[35331,35493]},{"content":"If we don't have this dead zone, the player can get annoyed very quickly, as the controls feel very fidgety.","pos":[35494,35602]},{"pos":[35604,35822],"content":"The <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> method then performs the same check on the right stick, to see if the player has changed the direction the camera is looking, as long as the movement on the stick is longer than another dead zone radius.","source":"The **Update** method then performs the same check on the right stick, to see if the player has changed the direction the camera is looking, as long as the movement on the stick is longer than another dead zone radius."},{"pos":[35824,35952],"content":"<bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept> computes the new pitch and yaw, and then checks to see if the user pressed the right analog trigger, our fire button.","source":"**Update** computes the new pitch and yaw, and then checks to see if the user pressed the right analog trigger, our fire button."},{"content":"And that's how this sample implements a full set of control options.","pos":[35954,36022]},{"content":"Again, remember that a good UWP app supports a range of control options, so players with different form factors and devices can play in the way they prefer!","pos":[36023,36179]},{"content":"Next steps","pos":[36184,36194]},{"content":"We've reviewed every major component of a UWP DirectX game except one: audio!","pos":[36197,36274]},{"content":"Music and sound effects are important to any game, so let's discuss <bpt id=\"p1\">[</bpt>adding sound<ept id=\"p1\">](tutorial--adding-sound.md)</ept>!","pos":[36275,36385],"source":" Music and sound effects are important to any game, so let's discuss [adding sound](tutorial--adding-sound.md)!"},{"content":"Complete sample code for this section","pos":[36390,36427]},{"content":"MoveLookController.h","pos":[36430,36450]},{"content":"MoveLookController.cpp","pos":[42425,42447]},{"content":"Note","pos":[70355,70359]},{"content":"This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.","pos":[70364,70452]},{"content":"If you’re developing for Windows 8.x or Windows Phone 8.x, see the <bpt id=\"p1\">[</bpt>archived documentation<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>.","pos":[70453,70594],"source":" If you’re developing for Windows 8.x or Windows Phone 8.x, see the [archived documentation](http://go.microsoft.com/fwlink/p/?linkid=619132)."},{"content":"Related topics","pos":[70602,70616]},{"content":"Create a simple UWP game with DirectX","pos":[70620,70657]}],"content":"---\ntitle: Add controls\ndescription: Now, we take a look at how the game sample implements move-look controls in a 3-D game, and how to develop basic touch, mouse, and game controller controls.\nms.assetid: f9666abb-151a-74b4-ae0b-ef88f1f252f8\n---\n\n# Add controls\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nNow, we take a look at how the game sample implements move-look controls in a 3-D game, and how to develop basic touch, mouse, and game controller controls.\n\n## Objective\n\n\n-   To implement mouse/keyboard, touch, and Xbox controller controls in a Universal Windows Platform (UWP) game with DirectX.\n\n## UWP game apps and controls\n\n\nA good UWP game supports a broad variety of interfaces. A potential player might have Windows 10 on a tablet with no physical buttons, or a media PC with an Xbox controller attached, or the latest desktop gaming rig with a high-performance mouse and gaming keyboard. Your game should support all of these devices if the game design allows it.\n\nThis sample supports all three. It's a simple first-person shooting game, and the move-look controls that are standard for this genre are easily implemented for all three types of input.\n\nFor more info about controls, and move-look controls specifically, see [Move-look controls for games](tutorial--adding-move-look-controls-to-your-directx-game.md) and [Touch controls for games](tutorial--adding-touch-controls-to-your-directx-game.md).\n\n## Common control behaviors\n\n\nTouch controls and mouse/keyboard controls have a very similar core implementation. In a UWP app, a pointer is simply a point on the screen. You can move it by sliding the mouse or sliding your finger on the touch screen. As a result, you can register for a single set of events, and not worry about whether the player is using a mouse or a touch screen to move and press the pointer.\n\nWhen the **MoveLookController** class in the game sample is initialized, it registers for four pointer-specific events and one mouse-specific event:\n\n-   [**CoreWindow::PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208278). The left or right mouse button was pressed (and held), or the touch surface was touched.\n-   [**CoreWindow::PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208276). The mouse moved, or a drag action was made on the touch surface.\n-   [**CoreWindow::PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279). The left mouse button was released, or the object contacting the touch surface was lifted.\n-   [**CoreWindow::PointerExited**](https://msdn.microsoft.com/library/windows/apps/br208275). The pointer moved out of the main window.\n-   [**Windows::Devices::Input::MouseMoved**](https://msdn.microsoft.com/library/windows/apps/hh758356). The mouse moved a certain distance. Be aware that we are only interested in mouse movement delta values, and not the current x-y position.\n\n```cpp\nvoid MoveLookController::Initialize(\n    _In_ CoreWindow^ window\n    )\n{\n    window->PointerPressed +=\n        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerPressed);\n\n    window->PointerMoved +=\n        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerMoved);\n\n    window->PointerReleased +=\n        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerReleased);\n\n    window->PointerExited +=\n        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerExited);\n\n    window->KeyDown +=\n        ref new TypedEventHandler<CoreWindow^, KeyEventArgs^>(this, &MoveLookController::OnKeyDown);\n\n    window->KeyUp +=\n        ref new TypedEventHandler<CoreWindow^, KeyEventArgs^>(this, &MoveLookController::OnKeyUp);\n\n    // A separate handler for mouse only relative mouse movement events.\n    Windows::Devices::Input::MouseDevice::GetForCurrentView()->MouseMoved +=\n        ref new TypedEventHandler<MouseDevice^, MouseEventArgs^>(this, &MoveLookController::OnMouseMoved);\n\n    ResetState();\n    m_state = MoveLookControllerState::None;\n\n    m_pitch = 0.0f;\n    m_yaw   = 0.0f;\n}\n```\n\nThe Xbox controller is handled separately, using the [XInput](https://msdn.microsoft.com/library/windows/desktop/hh405053) APIs. We talk about the implementation of game controller controls in a bit.\n\nIn the game sample, the **MoveLookController** class has three controller-specific states, regardless of the control type:\n\n-   **None**. This is the initialized state for the controller. The game is not anticipating any controller input.\n-   **WaitForInput**. The game is paused and is waiting for the player to continue.\n-   **Active**. The game is running, processing player input.\n\nThe **Active** state is the state when the player is actively playing the game. During this state, the **MoveLookController** instance is processing input events from all enabled input devices and interpreting the player's intentions based on the aggregated event data. As a result, it updates the velocity and look direction (the view plane normal) of the player's view and shares the updated data with the game after Update is called from the game loop.\n\nBe aware that the player can take more than one action at the same time. For example, he or she could be firing spheres while moving the camera. All of these inputs are tracked in the **Active** state, with different pointer IDs corresponding to different pointer actions. This is necessary because from a player's perspective, a pointer event in the firing rectangle is different from one in the move rectangle or in the rest of the screen.\n\nWhen a [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208278) event is received, the **MoveLookController** obtains the pointer ID value created by the window. The pointer ID represents a specific type of input. For example, on a multi-touch device, there may be several different active inputs at the same time. The IDs are used to keep track of which input the player is using. If one event is in the move rectangle of the touch screen, a pointer ID is assigned to track any pointer events in move rectangle. Other pointer events in the fire rectangle are tracked separately, with a separate pointer ID. (We talk about this some more in the section on touch controls.)\n\nInput from the mouse has yet another ID and is also handled separately.\n\nAfter the pointer events have been mapped to a specific game action, it's time to update the data the **MoveLookController** object shares with the main game loop.\n\nWhen called, the **Update** method in the game sample processes the input and updates the velocity and look direction variables (**m\\_velocity** and **m\\_lookdirection**), which the game loop then retrieves by calling the public **Velocity** and **LookDirection** methods on the **MoveLookController** instance.\n\n```cpp\nvoid MoveLookController::Update()\n{\n    UpdateGameController();\n\n    if (m_moveInUse)\n    {\n        // Move control.\n        XMFLOAT2 pointerDelta;\n\n        pointerDelta.x = m_movePointerPosition.x - m_moveFirstDown.x;\n        pointerDelta.y = m_movePointerPosition.y - m_moveFirstDown.y;\n\n        // Figure out the command from the virtual joystick.\n        XMFLOAT3 commandDirection = XMFLOAT3(0.0f, 0.0f, 0.0f);\n        if (fabsf(pointerDelta.x) > 16.0f)         // Leave 32 pixel-wide dead spot for being still.\n            m_moveCommand.x -= pointerDelta.x/fabsf(pointerDelta.x);\n\n        if (fabsf(pointerDelta.y) > 16.0f)\n            m_moveCommand.y -= pointerDelta.y/fabsf(pointerDelta.y);\n    }\n\n    // Poll our state bits set by the keyboard input events.\n    if (m_forward)\n    {\n        m_moveCommand.y += 1.0f;\n    }\n    if (m_back)\n    {\n        m_moveCommand.y -= 1.0f;\n    }\n    if (m_left)\n    {\n        m_moveCommand.x += 1.0f;\n    }\n    if (m_right)\n    {\n        m_moveCommand.x -= 1.0f;\n    }\n    if (m_up)\n    {\n        m_moveCommand.z += 1.0f;\n    }\n    if (m_down)\n    {\n        m_moveCommand.z -= 1.0f;\n    }\n\n    // Make sure that 45deg cases are not faster.\n    if (fabsf(m_moveCommand.x) > 0.1f ||\n        fabsf(m_moveCommand.y) > 0.1f ||\n        fabsf(m_moveCommand.z) > 0.1f)\n    {\n        XMStoreFloat3(&m_moveCommand, XMVector3Normalize(XMLoadFloat3(&m_moveCommand)));\n    }\n\n    // Rotate command to align with our direction (world coordinates).\n    XMFLOAT3 wCommand;\n    wCommand.x =  m_moveCommand.x * cosf(m_yaw) - m_moveCommand.y * sinf(m_yaw);\n    wCommand.y =  m_moveCommand.x * sinf(m_yaw) + m_moveCommand.y * cosf(m_yaw);\n    wCommand.z =  m_moveCommand.z;\n\n    // Scale for sensitivity adjustment.\n    // Our velocity is based on the command, y is up.\n    m_velocity.x = -wCommand.x * MOVEMENT_GAIN;\n    m_velocity.z =  wCommand.y * MOVEMENT_GAIN;\n    m_velocity.y =  wCommand.z * MOVEMENT_GAIN;\n\n    // Clear movement input accumulator for use during next frame.\n    m_moveCommand = XMFLOAT3(0.0f, 0.0f, 0.0f);\n}\n```\n\nThe game loop can test to see if the player is firing by calling the **IsFiring** method on the **MoveLookController** instance. The **MoveLookController** checks to see if the player has pressed the fire button on one of the three input types.\n\n```cpp\nbool MoveLookController::IsFiring()\n{\n    if (m_state == MoveLookControllerState::Active)\n    {\n        if (m_autoFire)\n        {\n            return (m_fireInUse || (m_mouseInUse && m_mouseLeftInUse) || m_xinputTriggerInUse);\n        }\n        else\n        {\n            if (m_firePressed)\n            {\n                m_firePressed = false;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\nIf the player moves the pointer outside the main window of the game, or presses the pause button (the P key or the Xbox controller start button), the game must be paused. The **MoveLookController** registered the press, and informs the game loop when it calls the **IsPauseRequested** method. At that point, if **IsPauseRequested** returns **true**, the game loop then calls **WaitForPress** on the **MoveLookController** to move the controller into the **WaitForInput** state. Then, the **MoveLookController** waits for the player to select one of the menu items to load, continue, or exit the game, and stop processing gameplay input events until it returns to the **Active** state.\n\nSee the [complete code sample for this section](#code_sample).\n\nNow, let's look at the implementation of each of the three control types in a little more detail.\n\n## Implementing relative mouse controls\n\n\nIf mouse movement is detected, we want use that movement to determine the new pitch and yaw of the camera. We do that by implementing relative mouse controls, where we handle the relative distance the mouse has moved—the delta between the start of the movement and the stop—as opposed to recording the absolute x-y pixel coordinates of the motion.\n\nTo do that, we obtain the changes in the X (the horizontal motion) and the Y (the vertical motion) coordinates by examining the [**MouseDelta::X**](https://msdn.microsoft.com/library/windows/apps/hh758353) and **MouseDelta::Y** fields on the [**Windows::Device::Input::MouseEventArgs::MouseDelta**](https://msdn.microsoft.com/library/windows/apps/hh758358) argument object returned by the [**MouseMoved**](https://msdn.microsoft.com/library/windows/apps/hh758356) event.\n\n```cpp\nvoid MoveLookController::OnMouseMoved(\n    _In_ MouseDevice^ /* mouseDevice */,\n    _In_ MouseEventArgs^ args\n    )\n{\n    // Handle Mouse Input via dedicated relative movement handler.\n\n    switch (m_state)\n    {\n    case MoveLookControllerState::Active:\n        XMFLOAT2 mouseDelta;\n        mouseDelta.x = static_cast<float>(args->MouseDelta.X);\n        mouseDelta.y = static_cast<float>(args->MouseDelta.Y);\n\n        XMFLOAT2 rotationDelta;\n        rotationDelta.x  = mouseDelta.x * ROTATION_GAIN;   // scale for control sensitivity\n        rotationDelta.y  = mouseDelta.y * ROTATION_GAIN;\n\n        // Update our orientation based on the command.\n        m_pitch -= rotationDelta.y;\n        m_yaw   += rotationDelta.x;\n\n        // Limit pitch to straight up or straight down.\n        float limit = XM_PI / 2.0f - 0.01f;\n        m_pitch = __max(-limit, m_pitch);\n        m_pitch = __min(+limit, m_pitch);\n\n        // Keep longitude in same range by wrapping.\n        if (m_yaw >  XM_PI)\n        {\n            m_yaw -= XM_PI * 2.0f;\n        }\n        else if (m_yaw < -XM_PI)\n        {\n            m_yaw += XM_PI * 2.0f;\n        }\n        break;\n    }\n}\n```\n\n## Implementing touch controls\n\n\nTouch controls are the trickiest to develop, because they are the most complex and require the most fine-tuning to be effective. In the game sample, a rectangle in the lower left quadrant of the screen is used as a directional pad, where sliding your thumb left and right in this space slides the camera left and right, and sliding your thumb up and down moves the camera forward and backward. A rectangle in the lower right quadrant of the screen can be pressed to fire the spheres. Aiming (pitch and yaw) are controlled by sliding your finger on the parts of the screen not reserved for moving and firing; as your finger moves, the camera (with fixed cross hairs) moves similarly.\n\nThe move and fire rectangles are created by two methods in the sample code:\n\n```cpp\nvoid SetMoveRect(\n        _In_ DirectX::XMFLOAT2 upperLeft,\n        _In_ DirectX::XMFLOAT2 lowerRight\n        );\n void SetFireRect(\n        _In_ DirectX::XMFLOAT2 upperLeft,\n        _In_ DirectX::XMFLOAT2 lowerRight\n        );\n```\n\nWe treat touch device pointer events for the other regions of the screen as look commands. If the screen is resized, these rectangles must be computed again (and redrawn).\n\nIf a touch device pointer event is raised in one of these regions and the game state is set to **Active**, it's assigned a pointer ID, as we discussed earlier.\n\n```cpp\nvoid MoveLookController::OnPointerPressed(\n    _In_ CoreWindow^ sender,\n    _In_ PointerEventArgs^ args\n    )\n{\n    PointerPoint^ point = args->CurrentPoint;\n    UINT32 pointerID = point->PointerId;\n    Point pointerPosition = point->Position;\n    PointerPointProperties^ pointProperties = point->Properties;\n    auto pointerDevice = point->PointerDevice;\n    auto pointerDeviceType = pointerDevice->PointerDeviceType;\n\n    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // convert to allow math\n\n    switch (m_state)\n    {\n    case MoveLookControllerState::WaitForInput:\n        // ...\n        // Game is paused, wait for click inside the game window.\n        // ...\n        break;\n\n    case MoveLookControllerState::Active:\n        switch (pointerDeviceType)\n        {\n        case Windows::Devices::Input::PointerDeviceType::Touch:\n            // Check to see if this pointer is in the move control.\n            if (position.x > m_moveUpperLeft.x &&\n                position.x < m_moveLowerRight.x &&\n                position.y > m_moveUpperLeft.y &&\n                position.y < m_moveLowerRight.y)\n            {\n                if (!m_moveInUse)         // If no pointer is in this control yet:\n                {\n                    // Process a DPad touch down event.\n                    m_moveFirstDown = position;                 // Save the location of the initial contact.\n                    m_movePointerID = pointerID;                // Store the pointer using this control.\n                    m_moveInUse = true;\n                }\n            }\n            // Check to see if this pointer is in the fire control.\n            else if (position.x > m_fireUpperLeft.x &&\n                position.x < m_fireLowerRight.x &&\n                position.y > m_fireUpperLeft.y &&\n                position.y < m_fireLowerRight.y)\n            {\n                if (!m_fireInUse)\n                {\n                    m_fireLastPoint = position;\n                    m_firePointerID = pointerID;\n                    m_fireInUse = true;\n                }\n            }\n            else\n            {\n                if (!m_lookInUse)   // If no pointer is in this control yet:\n                {\n                    m_lookLastPoint = position;                   // Save the pointer for a later move.\n                    m_lookPointerID = pointerID;                  // Store the pointer using this control.\n                    m_lookLastDelta.x = m_lookLastDelta.y = 0;    // These are for smoothing.\n                    m_lookInUse = true;\n                }\n            }\n            break;\n\n        default:\n            // ...\n            // Handle mouse input here.\n                                                // ...\n            break;\n        }\n        break;\n    }\n    return;\n}\n```\n\nIf a [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208278) event has occurred in one of the three control regions, the move rectangle, the fire rectangle, or the rest of the screen (the look control), the **MoveLookController** assigns the pointer ID for the pointer that fired the event to a specific variable that corresponds to the region of the screen the event was fired in. For example, if the event occurred in the move rectangle, the **m\\_movePointerID** variable is set to the pointer ID that fired the event. A Boolean \"in use\" variable (**m\\_lookInUse**, in the example) is also set to indicate that the control has not been released yet.\n\nNow, let's look at how the game sample handles the [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208276) touch screen event.\n\n```cpp\nvoid MoveLookController::OnPointerMoved(\n    _In_ CoreWindow^ sender,\n    _In_ PointerEventArgs^ args\n    )\n{\n    PointerPoint^ point = args->CurrentPoint;\n    UINT32 pointerID = point->PointerId;\n    Point pointerPosition = point->Position;\n    PointerPointProperties^ pointProperties = point->Properties;\n    auto pointerDevice = point->PointerDevice;\n    auto pointerDeviceType = pointerDevice->PointerDeviceType;\n\n    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // Convert to allow math.\n\n    switch (m_state)\n    {\n    case MoveLookControllerState::Active:\n        // Decide which control this pointer is operating.\n        if (pointerID == m_movePointerID)     // This is the move pointer.\n        {\n            m_movePointerPosition = position;       // Save the current position.\n        }\n        else if (pointerID == m_lookPointerID)     // This is the look pointer.\n        {\n            // Look control\n            XMFLOAT2 pointerDelta;\n            pointerDelta.x = position.x - m_lookLastPoint.x;        // How far did the pointer move.\n            pointerDelta.y = position.y - m_lookLastPoint.y;\n\n            XMFLOAT2 rotationDelta;\n            rotationDelta.x = pointerDelta.x * ROTATION_GAIN;       // Scale for control sensitivity.\n            rotationDelta.y = pointerDelta.y * ROTATION_GAIN;\n            m_lookLastPoint = position;                             // Save for the next time through.\n\n            // Update our orientation based on the command.\n            m_pitch -= rotationDelta.y;\n            m_yaw   += rotationDelta.x;\n\n            // Limit pitch to straight up or straight down.\n            m_pitch = __max(-XM_PI / 2.0f, m_pitch);\n            m_pitch = __min(+XM_PI / 2.0f, m_pitch);\n        }\n        else if (pointerID == m_firePointerID)\n        {\n            m_fireLastPoint = position;\n        }\n        else if (pointerID == m_mousePointerID)\n        {\n            // ...\n        }\n        break;\n    }\n}\n```\n\nThe **MoveLookController** checks the pointer ID to determine where the event occurred, and takes one of the following actions:\n\n-   If the [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208276) event occurred in the move or fire rectangle, update the pointer position for the controller.\n-   If the [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208276) event occurred somewhere in the rest of the screen (defined as the look controls), calculate the change in pitch and yaw of the look direction vector.\n\nLastly, let's look at how the game sample handles the [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279) touch screen event.\n\n```cpp\nvoid MoveLookController::OnPointerReleased(\n    _In_ CoreWindow^ sender,\n    _In_ PointerEventArgs^ args\n    )\n{\n    PointerPoint^ point = args->CurrentPoint;\n    UINT32 pointerID = point->PointerId;\n    Point pointerPosition = point->Position;\n    PointerPointProperties^ pointProperties = point->Properties;\n\n    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // Convert to allow math.\n    switch (m_state)\n    {\n    case MoveLookControllerState::WaitForInput:\n        if (m_buttonInUse && (pointerID == m_buttonPointerID))\n        {\n            m_buttonInUse = false;\n            m_buttonPressed = true;\n        }\n        break;\n\n    case MoveLookControllerState::Active:\n        if (pointerID == m_movePointerID)\n        {\n            m_velocity = XMFLOAT3(0, 0, 0);      // Stop on release.\n            m_moveInUse = false;\n            m_movePointerID = 0;\n        }\n        else if (pointerID == m_lookPointerID)\n        {\n            m_lookInUse = false;\n            m_lookPointerID = 0;\n        }\n        else if (pointerID == m_firePointerID)\n        {\n            m_fireInUse = false;\n            m_firePointerID = 0;\n        }\n        else if (pointerID == m_mousePointerID)\n        {\n            // ...\n        }\n        break;\n    }\n}\n```\n\nIf the ID of the pointer that fired the [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279) event is the ID of the previously recorded move pointer, the **MoveLookController** sets the velocity to 0 because the player has stopped touching the move rectangle. If it didn't set the velocity to 0, the player would keep moving! If you want to implement some form of inertia, this is where you add the method that begins returning the velocity to 0 over future calls to **Update** from the game loop.\n\nOtherwise, if the [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279) event fired in the fire rectangle or the look region, the **MoveLookController** resets the specific pointer IDs.\n\nThat's the basics of how touch screen controls are implemented in the game sample. Let's move on to mouse and keyboard controls.\n\n## Implementing mouse and keyboard controls\n\n\nThe game sample implements these mouse and keyboard controls:\n\n-   The W, S, A, and D keys move the player view forward, backward, left, and right, respectively. Pressing X and the space bar move the view up and down, respectively.\n-   Pressing the P key pauses the game.\n-   Moving the mouse puts the player in control of the rotation (the pitch and yaw) of the camera view.\n-   Clicking the left button fires a sphere.\n\nTo use the keyboard, the game sample registers for two extra events: [**CoreWindow::KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208271) and [**CoreWindow::KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208270), which handle the press and the release of a key, respectively.\n\n```cpp\nwindow->KeyDown +=\n        ref new TypedEventHandler<CoreWindow^, KeyEventArgs^>(this, &MoveLookController::OnKeyDown);\n\nwindow->KeyUp +=\n        ref new TypedEventHandler<CoreWindow^, KeyEventArgs^>(this, &MoveLookController::OnKeyUp);\n```\n\nThe mouse is treated a little differently from the touch controls, even though it uses a pointer. Obviously, it doesn't use the move and fire rectangles, as that would be very cumbersome for the player: how could they press the move and fire controls at the same time? As noted earlier, the **MoveLookController** controller engages the look controls whenever the mouse is moved, and engages the fire controls when the left mouse button is pressed, as shown here.\n\n```cpp\nvoid MoveLookController::OnPointerPressed(\n    _In_ CoreWindow^ /* sender */,\n    _In_ PointerEventArgs^ args\n    )\n{\n    PointerPoint^ point = args->CurrentPoint;\n    uint32 pointerID = point->PointerId;\n    Point pointerPosition = point->Position;\n    PointerPointProperties^ pointProperties = point->Properties;\n    auto pointerDevice = point->PointerDevice;\n    auto pointerDeviceType = pointerDevice->PointerDeviceType;\n\n    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // convert to allow math\n\n    switch (m_state)\n    {\n    case MoveLookControllerState::WaitForInput:\n        if (position.x > m_buttonUpperLeft.x &&\n            position.x < m_buttonLowerRight.x &&\n            position.y > m_buttonUpperLeft.y &&\n            position.y < m_buttonLowerRight.y)\n        {\n            // Wait until the button is released before setting the variable.\n            m_buttonPointerID = pointerID;\n            m_buttonInUse = true;\n\n        }\n        break;\n\n    case MoveLookControllerState::Active:\n        switch (pointerDeviceType)\n        {\n        case Windows::Devices::Input::PointerDeviceType::Touch:\n            // Check to see if this pointer is in the move control.\n            if (position.x > m_moveUpperLeft.x &&\n                position.x < m_moveLowerRight.x &&\n                position.y > m_moveUpperLeft.y &&\n                position.y < m_moveLowerRight.y)\n            {\n                if (!m_moveInUse)         // If no pointer is in this control yet:\n                {\n                    // Process a DPad touch down event.\n                    m_moveFirstDown = position;                 // Save the location of the initial contact.\n                    m_movePointerID = pointerID;                // Store the pointer using this control.\n                    m_moveInUse = true;\n                }\n            }\n            // Check to see if this pointer is in the fire control.\n            else if (position.x > m_fireUpperLeft.x &&\n                position.x < m_fireLowerRight.x &&\n                position.y > m_fireUpperLeft.y &&\n                position.y < m_fireLowerRight.y)\n            {\n                if (!m_fireInUse)\n                {\n                    m_fireLastPoint = position;\n                    m_firePointerID = pointerID;\n                    m_fireInUse = true;\n                    if (!m_autoFire)\n                    {\n                        m_firePressed = true;\n                    }\n                }\n            }\n            else\n            {\n                if (!m_lookInUse)   // If no pointer is in this control yet:\n                {\n                    m_lookLastPoint = position;                   // Save the pointer for a later move.\n                    m_lookPointerID = pointerID;                  // Store the pointer using this control.\n                    m_lookLastDelta.x = m_lookLastDelta.y = 0;    // These are for smoothing.\n                    m_lookInUse = true;\n                }\n            }\n            break;\n\n        default:\n            bool rightButton = pointProperties->IsRightButtonPressed;\n            bool leftButton = pointProperties->IsLeftButtonPressed;\n\n            if (!m_autoFire && (!m_mouseLeftInUse && leftButton))\n            {\n                m_firePressed = true;\n            }\n\n            if (!m_mouseInUse)\n            {\n                m_mouseInUse = true;\n                m_mouseLastPoint = position;\n                m_mousePointerID = pointerID;\n                m_mouseLeftInUse = leftButton;\n                m_mouseRightInUse = rightButton;\n                m_lookLastDelta.x = m_lookLastDelta.y = 0;          // These are for smoothing.\n            }\n            else\n            {\n\n            }\n            break;\n        }\n\n        break;\n    }\n\n    return;\n}\n```\n\nNow, let's look at how the game sample handles the [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279) mouse event.\n\n```cpp\nvoid MoveLookController::OnPointerReleased(\n    _In_ CoreWindow^ /* sender */,\n    _In_ PointerEventArgs^ args\n    )\n{\n    PointerPoint^ point = args->CurrentPoint;\n    uint32 pointerID = point->PointerId;\n    Point pointerPosition = point->Position;\n    PointerPointProperties^ pointProperties = point->Properties;\n\n    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // Convert to allow math.\n    switch (m_state)\n    {\n    case MoveLookControllerState::WaitForInput:\n        if (m_buttonInUse && (pointerID == m_buttonPointerID))\n        {\n            m_buttonInUse = false;\n            m_buttonPressed = true;\n        }\n        break;\n\n    case MoveLookControllerState::Active:\n        if (pointerID == m_movePointerID)\n        {\n            m_velocity = XMFLOAT3(0, 0, 0);      // Stop on release.\n            m_moveInUse = false;\n            m_movePointerID = 0;\n        }\n        else if (pointerID == m_lookPointerID)\n        {\n            m_lookInUse = false;\n            m_lookPointerID = 0;\n        }\n        else if (pointerID == m_firePointerID)\n        {\n            m_fireInUse = false;\n            m_firePointerID = 0;\n        }\n        else if (pointerID == m_mousePointerID)\n        {\n            bool rightButton = pointProperties->IsRightButtonPressed;\n            bool leftButton = pointProperties->IsLeftButtonPressed;\n\n            m_mouseInUse = false;\n\n            // Don't clear the mouse pointer ID so that Move events still result in Look changes.\n            // m_mousePointerID = 0;\n            m_mouseLeftInUse = leftButton;\n            m_mouseRightInUse = rightButton;\n        }\n        break;\n    }\n}\n```\n\nWhen the player stops pressing one of the mouse buttons, the input is complete: the spheres stop firing. But, because look is always enabled, the game continues to use the same mouse pointer to track the ongoing look events.\n\nNow, let's look at the last of control types: the Xbox controller. It's handled separately from the touch and mouse controls, because it doesn't use the pointer object.\n\n## Implementing Xbox controller controls\n\n\nIn the game sample, Xbox controller support is added by calls to the [XInput](https://msdn.microsoft.com/library/windows/desktop/hh405053) APIs, which are set of APIs designed to simplify programming for game controllers. In the game sample, we use the Xbox controller's left analog stick for player movement, the right analog stick for the look controls, and the right trigger to fire. We use the start button to pause and resume the game.\n\nThe **Update** method on the **MoveLookController** instance immediately checks to see if a game controller is connected, and then checks the controller state.\n\n```cpp\nvoid MoveLookController::UpdateGameController()\n{\n    if (!m_isControllerConnected)\n    {\n        // Check for controller connection by trying to get the capabilties.\n        DWORD capsResult = XInputGetCapabilities(0, XINPUT_FLAG_GAMEPAD, &m_xinputCaps);\n        if (capsResult != ERROR_SUCCESS)\n        {\n            return;\n        }\n        // Device is connected.\n        m_isControllerConnected = true;\n        m_xinputStartButtonInUse = false;\n        m_xinputTriggerInUse = false;\n    }\n\n    DWORD stateResult = XInputGetState(0, &m_xinputState);\n    if (stateResult != ERROR_SUCCESS)\n    {\n        // Device is no longer connected.\n        m_isControllerConnected = false;\n    }\n\n    switch (m_state)\n    {\n    case MoveLookControllerState::WaitForInput:\n        if (m_xinputState.Gamepad.wButtons & XINPUT_GAMEPAD_START)\n        {\n            m_xinputStartButtonInUse = true;\n        }\n        else if (m_xinputStartButtonInUse)\n        {\n            // Trigger one time only on button release.\n            m_xinputStartButtonInUse = false;\n            m_buttonPressed = true;\n        }\n        break;\n\n    case MoveLookControllerState::Active:\n        if (m_xinputState.Gamepad.wButtons & XINPUT_GAMEPAD_START)\n        {\n            m_xinputStartButtonInUse = true;\n        }\n        else if (m_xinputStartButtonInUse)\n        {\n            // Trigger one time only on button release.\n            m_xinputStartButtonInUse = false;\n            m_pausePressed = true;\n        }\n        // Use the Right Thumb joystick on the XBox controller to control\n        // the eye point position control.\n        // The controller input goes from -32767 to 32767.   We will normalize\n        // this from -1 to 1 and keep a dead spot in the middle to avoid drift.\n\n        if (m_xinputState.Gamepad.sThumbLX > XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE ||\n            m_xinputState.Gamepad.sThumbLX < -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE)\n        {\n            float x = (float)m_xinputState.Gamepad.sThumbLX/32767.0f;\n            m_moveCommand.x -= x / fabsf(x);\n        }\n\n        if (m_xinputState.Gamepad.sThumbLY > XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE ||\n            m_xinputState.Gamepad.sThumbLY < -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE)\n        {\n            float y = (float)m_xinputState.Gamepad.sThumbLY/32767.0f;\n            m_moveCommand.y += y / fabsf(y);\n        }\n\n        // Use the Left Thumb Joystick on the XBox controller to control\n        // the look at control.\n        // The controller input goes from -32767 to 32767.   We will normalize\n        // this from -1 to 1 and keep a dead spot in the middle to avoid drift.\n        XMFLOAT2 pointerDelta;\n        if (m_xinputState.Gamepad.sThumbRX > XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE ||\n            m_xinputState.Gamepad.sThumbRX < -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE)\n        {\n            pointerDelta.x = (float)m_xinputState.Gamepad.sThumbRX/32767.0f;\n            pointerDelta.x = pointerDelta.x * pointerDelta.x * pointerDelta.x;\n        }\n        else\n        {\n            pointerDelta.x = 0.0f;\n        }\n        if (m_xinputState.Gamepad.sThumbRY > XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE ||\n            m_xinputState.Gamepad.sThumbRY < -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE)\n        {\n            pointerDelta.y = (float)m_xinputState.Gamepad.sThumbRY/32767.0f;\n            pointerDelta.y = pointerDelta.y * pointerDelta.y * pointerDelta.y;\n        }\n        else\n        {\n            pointerDelta.y = 0.0f;\n        }\n\n        XMFLOAT2 rotationDelta;\n        rotationDelta.x = pointerDelta.x *  0.08f;       // Scale for control sensitivity.\n        rotationDelta.y = pointerDelta.y *  0.08f;\n\n        // Update our orientation based on the command.\n        m_pitch += rotationDelta.y;\n        m_yaw   += rotationDelta.x;\n\n        // Limit pitch to straight up or straight down.\n        m_pitch = __max(-XM_PI / 2.0f, m_pitch);\n        m_pitch = __min(+XM_PI / 2.0f, m_pitch);\n\n        // Check the state of the A button.  This is used to indicate fire control.\n\n        if (m_xinputState.Gamepad.bRightTrigger > XINPUT_GAMEPAD_TRIGGER_THRESHOLD)\n        {\n            if (!m_autoFire && !m_xinputTriggerInUse)\n            {\n                m_firePressed = true;\n            }\n            m_xinputTriggerInUse = true;\n        }\n        else\n        {\n            m_xinputTriggerInUse = false;\n        }\n        break;\n    }\n}\n```\n\nIf the game controller is in the **Active** state, this method checks to see if a user moved the left analog stick in a specific direction. But the movement on the stick in a specific direction must register as larger than the radius of the dead zone; otherwise, nothing will happen. This dead zone radius is necessary to present \"drifting,\" which is when the controller picks up minute movements from the player's thumb as it rests on the stick. If we don't have this dead zone, the player can get annoyed very quickly, as the controls feel very fidgety.\n\nThe **Update** method then performs the same check on the right stick, to see if the player has changed the direction the camera is looking, as long as the movement on the stick is longer than another dead zone radius.\n\n**Update** computes the new pitch and yaw, and then checks to see if the user pressed the right analog trigger, our fire button.\n\nAnd that's how this sample implements a full set of control options. Again, remember that a good UWP app supports a range of control options, so players with different form factors and devices can play in the way they prefer!\n\n## Next steps\n\n\nWe've reviewed every major component of a UWP DirectX game except one: audio! Music and sound effects are important to any game, so let's discuss [adding sound](tutorial--adding-sound.md)!\n\n## Complete sample code for this section\n\n\nMoveLookController.h\n\n```cpp\n//// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF\n//// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n//// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A\n//// PARTICULAR PURPOSE.\n////\n//// Copyright (c) Microsoft Corporation. All rights reserved\n\n#pragma once\n\n// Uncomment to print debug tracing.\n// #define MOVELOOKCONTROLLER_TRACE 1\n\nenum class MoveLookControllerState\n{\n    None,\n    WaitForInput,\n    Active,\n};\n\nref class MoveLookController\n{\ninternal:\n    MoveLookController();\n\n    void Initialize(\n        _In_ Windows::UI::Core::CoreWindow^ window\n        );\n    void SetMoveRect(\n        _In_ DirectX::XMFLOAT2 upperLeft,\n        _In_ DirectX::XMFLOAT2 lowerRight\n        );\n    void SetFireRect(\n        _In_ DirectX::XMFLOAT2 upperLeft,\n        _In_ DirectX::XMFLOAT2 lowerRight\n        );\n    void WaitForPress(\n        _In_ DirectX::XMFLOAT2 UpperLeft,\n        _In_ DirectX::XMFLOAT2 LowerRight\n        );\n    void WaitForPress();\n\n    void Update();\n    bool IsFiring();\n    bool IsPressComplete();\n    bool IsPauseRequested();\n\n    DirectX::XMFLOAT3 Velocity();\n    DirectX::XMFLOAT3 LookDirection();\n    float Pitch();\n    void  Pitch(_In_ float pitch);\n    float Yaw();\n    void  Yaw(_In_ float yaw);\n    bool  Active();\n    void  Active(_In_ bool active);\n\n    bool AutoFire();\n    void AutoFire(_In_ bool AutoFire);\n\nprotected:\n    void OnPointerPressed(\n        _In_ Windows::UI::Core::CoreWindow^ sender,\n        _In_ Windows::UI::Core::PointerEventArgs^ args\n        );\n    void OnPointerMoved(\n        _In_ Windows::UI::Core::CoreWindow^ sender,\n        _In_ Windows::UI::Core::PointerEventArgs^ args\n        );\n    void OnPointerReleased(\n        _In_ Windows::UI::Core::CoreWindow^ sender,\n        _In_ Windows::UI::Core::PointerEventArgs^ args\n        );\n    void OnPointerExited(\n        _In_ Windows::UI::Core::CoreWindow^ sender,\n        _In_ Windows::UI::Core::PointerEventArgs^ args\n        );\n    void OnKeyDown(\n        _In_ Windows::UI::Core::CoreWindow^ sender,\n        _In_ Windows::UI::Core::KeyEventArgs^ args\n        );\n    void OnKeyUp(\n        _In_ Windows::UI::Core::CoreWindow^ sender,\n        _In_ Windows::UI::Core::KeyEventArgs^ args\n        );\n\n    void OnMouseMoved(\n        _In_ Windows::Devices::Input::MouseDevice^ mouseDevice,\n        _In_ Windows::Devices::Input::MouseEventArgs^ args\n        );\n\n#ifdef MOVELOOKCONTROLLER_TRACE\n    void DebugTrace(const wchar_t *format, ...);\n#endif\n\nprivate:\n    // Properties of the controller object\n    MoveLookControllerState     m_state;\n    DirectX::XMFLOAT3           m_velocity;             // How far we move it this frame\n    float                       m_pitch;\n    float                       m_yaw;                  // Orientation euler angles in radians\n\n    // Properties of the Move control\n    DirectX::XMFLOAT2           m_moveUpperLeft;        // Bounding box where this control will activate\n    DirectX::XMFLOAT2           m_moveLowerRight;\n    bool                        m_moveInUse;            // The move control is in use.\n    uint32                      m_movePointerID;        // The id of the pointer in this control.\n    DirectX::XMFLOAT2           m_moveFirstDown;        // The point where the initial contact occurred.\n    DirectX::XMFLOAT2           m_movePointerPosition;  // The point where the move pointer is currently located.\n    DirectX::XMFLOAT3           m_moveCommand;          // The net command from the move control.\n\n    // Properties of the Look control\n    bool                        m_lookInUse;            // The look control is in use.\n    uint32                      m_lookPointerID;        // The id of the pointer in this control.\n    DirectX::XMFLOAT2           m_lookLastPoint;        // The last point (from last frame)\n    DirectX::XMFLOAT2           m_lookLastDelta;        // for smoothing.\n\n    // Properties of the Fire control\n    bool                        m_autoFire;\n    bool                        m_firePressed;\n    DirectX::XMFLOAT2           m_fireUpperLeft;        // The bounding box where this control will activate.\n    DirectX::XMFLOAT2           m_fireLowerRight;\n    bool                        m_fireInUse;            // The fire control is in use.\n    UINT32                      m_firePointerID;        // The id of the pointer in this control.\n    DirectX::XMFLOAT2           m_fireLastPoint;        // The last fire position.\n\n    // Properties of the Mouse control. This is a combination of Look and Fire.\n    bool                        m_mouseInUse;\n    uint32                      m_mousePointerID;\n    DirectX::XMFLOAT2           m_mouseLastPoint;\n    bool                        m_mouseLeftInUse;\n    bool                        m_mouseRightInUse;\n\n    bool                        m_buttonInUse;\n    uint32                      m_buttonPointerID;\n    DirectX::XMFLOAT2           m_buttonUpperLeft;\n    DirectX::XMFLOAT2           m_buttonLowerRight;\n    bool                        m_buttonPressed;\n    bool                        m_pausePressed;\n\n    // XBox Input related members\n    bool                        m_isControllerConnected;  // Do we have a controller connected?\n    XINPUT_CAPABILITIES         m_xinputCaps;             // The capabilites of the controller.\n    XINPUT_STATE                m_xinputState;            // The current state of the controller.\n    bool                        m_xinputStartButtonInUse;\n    bool                        m_xinputTriggerInUse;\n\n    // Input states for Keyboard\n    bool                        m_forward;\n    bool                        m_back;                    // States for movement\n    bool                        m_left;\n    bool                        m_right;\n    bool                        m_up;\n    bool                        m_down;\n    bool                        m_pause;\n\nprivate:\n    void     ResetState();\n    void     UpdateGameController();\n};\n```\n\nMoveLookController.cpp\n\n```cpp\n//// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF\n//// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n//// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A\n//// PARTICULAR PURPOSE.\n////\n//// Copyright (c) Microsoft Corporation. All rights reserved\n\n#include \"pch.h\"\n#include \"MoveLookController.h\"\n#include \"DirectXSample.h\"\n\nusing namespace Windows::UI::Core;\nusing namespace Windows::UI::Input;\nusing namespace Windows::UI;\nusing namespace Windows::Foundation;\nusing namespace Microsoft::WRL;\nusing namespace DirectX;\nusing namespace Windows::Devices::Input;\nusing namespace Windows::System;\n\n#define ROTATION_GAIN 0.008f        // The sensitivity adjustment for the look controller.\n#define MOVEMENT_GAIN 2.f           // The sensitivity adjustment for the move controller.\n\n// A basic Move/Look Controller class such as in an FPS\n// horizontal (x-z-plane) movement on left virtual joystick\n// also supports WASD keyboard input\n// steering and orientation via left mouse down or touch drag.\n\n//----------------------------------------------------------------------\n\nMoveLookController::MoveLookController():\n    m_autoFire(true),\n    m_isControllerConnected(false)\n{\n}\n\n//----------------------------------------------------------------------\n// Set up the controls supported by this controller.\n\nvoid MoveLookController::Initialize(\n    _In_ CoreWindow^ window\n    )\n{\n    window->PointerPressed +=\n        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerPressed);\n\n    window->PointerMoved +=\n        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerMoved);\n\n    window->PointerReleased +=\n        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerReleased);\n\n    window->PointerExited +=\n        ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerExited);\n\n    window->KeyDown +=\n        ref new TypedEventHandler<CoreWindow^, KeyEventArgs^>(this, &MoveLookController::OnKeyDown);\n\n    window->KeyUp +=\n        ref new TypedEventHandler<CoreWindow^, KeyEventArgs^>(this, &MoveLookController::OnKeyUp);\n\n    // A separate handler for mouse only relative mouse movement events.\n    Windows::Devices::Input::MouseDevice::GetForCurrentView()->MouseMoved +=\n        ref new TypedEventHandler<MouseDevice^, MouseEventArgs^>(this, &MoveLookController::OnMouseMoved);\n\n    ResetState();\n    m_state = MoveLookControllerState::None;\n\n    m_pitch = 0.0f;\n    m_yaw   = 0.0f;\n}\n\n//----------------------------------------------------------------------\n\nbool MoveLookController::IsPauseRequested()\n{\n    switch (m_state)\n    {\n    case MoveLookControllerState::Active:\n        UpdateGameController();\n        if (m_pausePressed)\n        {\n\n            m_pausePressed = false;\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    return false;\n}\n\n//----------------------------------------------------------------------\n\nbool MoveLookController::IsFiring()\n{\n    if (m_state == MoveLookControllerState::Active)\n    {\n        if (m_autoFire)\n        {\n            return (m_fireInUse || (m_mouseInUse && m_mouseLeftInUse) || m_xinputTriggerInUse);\n        }\n        else\n        {\n            if (m_firePressed)\n            {\n                m_firePressed = false;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n//----------------------------------------------------------------------\n\nbool MoveLookController::IsPressComplete()\n{\n    switch (m_state)\n    {\n    case MoveLookControllerState::WaitForInput:\n        UpdateGameController();\n        if (m_buttonPressed)\n        {\n\n            m_buttonPressed = false;\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n        break;\n    }\n\n    return false;\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::OnPointerPressed(\n    _In_ CoreWindow^ /* sender */,\n    _In_ PointerEventArgs^ args\n    )\n{\n    PointerPoint^ point = args->CurrentPoint;\n    uint32 pointerID = point->PointerId;\n    Point pointerPosition = point->Position;\n    PointerPointProperties^ pointProperties = point->Properties;\n    auto pointerDevice = point->PointerDevice;\n    auto pointerDeviceType = pointerDevice->PointerDeviceType;\n\n    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // Convert to allow math.\n\n    switch (m_state)\n    {\n    case MoveLookControllerState::WaitForInput:\n        if (position.x > m_buttonUpperLeft.x &&\n            position.x < m_buttonLowerRight.x &&\n            position.y > m_buttonUpperLeft.y &&\n            position.y < m_buttonLowerRight.y)\n        {\n            // Wait until button released before setting variable.\n            m_buttonPointerID = pointerID;\n            m_buttonInUse = true;\n\n        }\n        break;\n\n    case MoveLookControllerState::Active:\n        switch (pointerDeviceType)\n        {\n        case Windows::Devices::Input::PointerDeviceType::Touch:\n            // Check to see if this pointer is in the move control.\n            if (position.x > m_moveUpperLeft.x &&\n                position.x < m_moveLowerRight.x &&\n                position.y > m_moveUpperLeft.y &&\n                position.y < m_moveLowerRight.y)\n            {\n                if (!m_moveInUse)         // If no pointer is in this control yet:\n                {\n                    // Process a DPad touch down event.\n                    m_moveFirstDown = position;                 // Save the location of the initial contact.\n                    m_movePointerID = pointerID;                // Store the pointer using this control.\n                    m_moveInUse = true;\n                }\n            }\n            // Check to see if this pointer is in the fire control.\n            else if (position.x > m_fireUpperLeft.x &&\n                position.x < m_fireLowerRight.x &&\n                position.y > m_fireUpperLeft.y &&\n                position.y < m_fireLowerRight.y)\n            {\n                if (!m_fireInUse)\n                {\n                    m_fireLastPoint = position;\n                    m_firePointerID = pointerID;\n                    m_fireInUse = true;\n                    if (!m_autoFire)\n                    {\n                        m_firePressed = true;\n                    }\n                }\n            }\n            else\n            {\n                if (!m_lookInUse)   // If no pointer is in this control yet:\n                {\n                    m_lookLastPoint = position;                   // Save the point for a later move.\n                    m_lookPointerID = pointerID;                  // Store the pointer using this control.\n                    m_lookLastDelta.x = m_lookLastDelta.y = 0;    // These are for smoothing.\n                    m_lookInUse = true;\n                }\n            }\n            break;\n\n        default:\n            bool rightButton = pointProperties->IsRightButtonPressed;\n            bool leftButton = pointProperties->IsLeftButtonPressed;\n\n            if (!m_autoFire && (!m_mouseLeftInUse && leftButton))\n            {\n                m_firePressed = true;\n            }\n\n            if (!m_mouseInUse)\n            {\n                m_mouseInUse = true;\n                m_mouseLastPoint = position;\n                m_mousePointerID = pointerID;\n                m_mouseLeftInUse = leftButton;\n                m_mouseRightInUse = rightButton;\n                m_lookLastDelta.x = m_lookLastDelta.y = 0;          // These are for smoothing.\n            }\n            else\n            {\n\n            }\n            break;\n        }\n\n        break;\n    }\n\n    return;\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::OnPointerMoved(\n    _In_ CoreWindow^ /* sender */,\n    _In_ PointerEventArgs^ args\n    )\n{\n    PointerPoint^ point = args->CurrentPoint;\n    uint32 pointerID = point->PointerId;\n    Point pointerPosition = point->Position;\n    PointerPointProperties^ pointProperties = point->Properties;\n    auto pointerDevice = point->PointerDevice;\n\n    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // Convert to allow math.\n\n    switch (m_state)\n    {\n    case MoveLookControllerState::Active:\n        // Decide which control this pointer is operating.\n        if (pointerID == m_movePointerID)     // This is the move pointer.\n        {\n            m_movePointerPosition = position;       // Save the current position.\n        }\n        else if (pointerID == m_lookPointerID)     // This is the look pointer.\n        {\n            // Look control\n            XMFLOAT2 pointerDelta;\n            pointerDelta.x = position.x - m_lookLastPoint.x;        // How far did the pointer move?\n            pointerDelta.y = position.y - m_lookLastPoint.y;\n\n            XMFLOAT2 rotationDelta;\n            rotationDelta.x = pointerDelta.x * ROTATION_GAIN;       // Scale for control sensitivity.\n            rotationDelta.y = pointerDelta.y * ROTATION_GAIN;\n            m_lookLastPoint = position;                             // Save for the next time through.\n\n            // Update our orientation based on the command.\n            m_pitch -= rotationDelta.y;\n            m_yaw   += rotationDelta.x;\n\n            // Limit pitch to straight up or straight down.\n            float limit = XM_PI / 2.0f - 0.01f;\n            m_pitch = __max(-limit, m_pitch);\n            m_pitch = __min(+limit, m_pitch);\n\n            // Keep longitude in the same range by wrapping.\n            if (m_yaw >  XM_PI)\n            {\n                m_yaw -= XM_PI * 2.0f;\n            }\n            else if (m_yaw < -XM_PI)\n            {\n                m_yaw += XM_PI * 2.0f;\n            }\n        }\n        else if (pointerID == m_firePointerID)\n        {\n            m_fireLastPoint = position;\n        }\n        else if (pointerID == m_mousePointerID)\n        {\n            m_mouseLeftInUse  = pointProperties->IsLeftButtonPressed;\n            m_mouseRightInUse = pointProperties->IsRightButtonPressed;;\n            m_mouseLastPoint = position;                            // save for next time through\n\n            // Handle mouse movement via a separate relative mouse movement handler (OnMouseMoved).\n        }\n        break;\n    }\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::OnMouseMoved(\n    _In_ MouseDevice^ /* mouseDevice */,\n    _In_ MouseEventArgs^ args\n    )\n{\n    // Handle Mouse Input via dedicated relative movement handler.\n\n    switch (m_state)\n    {\n    case MoveLookControllerState::Active:\n        XMFLOAT2 mouseDelta;\n        mouseDelta.x = static_cast<float>(args->MouseDelta.X);\n        mouseDelta.y = static_cast<float>(args->MouseDelta.Y);\n\n        XMFLOAT2 rotationDelta;\n        rotationDelta.x  = mouseDelta.x * ROTATION_GAIN;   // Scale for control sensitivity.\n        rotationDelta.y  = mouseDelta.y * ROTATION_GAIN;\n\n        // Update our orientation based on the command.\n        m_pitch -= rotationDelta.y;\n        m_yaw   += rotationDelta.x;\n\n        // Limit pitch to straight up or straight down.\n        float limit = XM_PI / 2.0f - 0.01f;\n        m_pitch = __max(-limit, m_pitch);\n        m_pitch = __min(+limit, m_pitch);\n\n        // Keep longitude in same range by wrapping.\n        if (m_yaw >  XM_PI)\n        {\n            m_yaw -= XM_PI * 2.0f;\n        }\n        else if (m_yaw < -XM_PI)\n        {\n            m_yaw += XM_PI * 2.0f;\n        }\n        break;\n    }\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::OnPointerReleased(\n    _In_ CoreWindow^ /* sender */,\n    _In_ PointerEventArgs^ args\n    )\n{\n    PointerPoint^ point = args->CurrentPoint;\n    uint32 pointerID = point->PointerId;\n    Point pointerPosition = point->Position;\n    PointerPointProperties^ pointProperties = point->Properties;\n\n    XMFLOAT2 position = XMFLOAT2(pointerPosition.X, pointerPosition.Y);     // Convert to allow math.\n    switch (m_state)\n    {\n    case MoveLookControllerState::WaitForInput:\n        if (m_buttonInUse && (pointerID == m_buttonPointerID))\n        {\n            m_buttonInUse = false;\n            m_buttonPressed = true;\n        }\n        break;\n\n    case MoveLookControllerState::Active:\n        if (pointerID == m_movePointerID)\n        {\n            m_velocity = XMFLOAT3(0, 0, 0);      // Stop on release.\n            m_moveInUse = false;\n            m_movePointerID = 0;\n        }\n        else if (pointerID == m_lookPointerID)\n        {\n            m_lookInUse = false;\n            m_lookPointerID = 0;\n        }\n        else if (pointerID == m_firePointerID)\n        {\n            m_fireInUse = false;\n            m_firePointerID = 0;\n        }\n        else if (pointerID == m_mousePointerID)\n        {\n            bool rightButton = pointProperties->IsRightButtonPressed;\n            bool leftButton = pointProperties->IsLeftButtonPressed;\n\n            m_mouseInUse = false;\n\n            // Don't clear the mouse pointer ID so that Move events still result in Look changes.\n            // m_mousePointerID = 0;\n            m_mouseLeftInUse = leftButton;\n            m_mouseRightInUse = rightButton;\n        }\n        break;\n    }\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::OnPointerExited(\n    _In_ CoreWindow^ /* sender */,\n    _In_ PointerEventArgs^ args\n    )\n{\n    PointerPoint^ point = args->CurrentPoint;\n    uint32 pointerID = point->PointerId;\n    Point pointerPosition = point->Position;\n    PointerPointProperties^ pointProperties = point->Properties;\n\n    XMFLOAT2 position  = XMFLOAT2(pointerPosition.X, pointerPosition.Y);        // Convert to allow math.\n\n    switch (m_state)\n    {\n    case MoveLookControllerState::WaitForInput:\n        if (m_buttonInUse && (pointerID == m_buttonPointerID))\n        {\n            m_buttonInUse = false;\n            m_buttonPressed = false;\n        }\n        break;\n\n    case MoveLookControllerState::Active:\n        if (pointerID == m_movePointerID)\n        {\n            m_velocity = XMFLOAT3(0, 0, 0);      // Stop on release.\n            m_moveInUse = false;\n            m_movePointerID = 0;\n        }\n        else if (pointerID == m_lookPointerID)\n        {\n            m_lookInUse = false;\n            m_lookPointerID = 0;\n        }\n        else if (pointerID == m_firePointerID)\n        {\n            m_fireInUse = false;\n            m_firePointerID = 0;\n        }\n        else if (pointerID == m_mousePointerID)\n        {\n            m_mouseInUse = false;\n            m_mousePointerID = 0;\n            m_mouseLeftInUse = false;\n            m_mouseRightInUse = false;\n        }\n        break;\n    }\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::OnKeyDown(\n    _In_ CoreWindow^ /* sender */,\n    _In_ KeyEventArgs^ args\n    )\n{\n    Windows::System::VirtualKey Key;\n    Key = args->VirtualKey;\n\n    // Figure out the command from the keyboard.\n    if (Key == VirtualKey::W)       // forward\n        m_forward = true;\n    if (Key == VirtualKey::S)       // back\n        m_back = true;\n    if (Key == VirtualKey::A)       // left\n        m_left = true;\n    if (Key == VirtualKey::D)       // right\n        m_right = true;\n    if (Key == VirtualKey::Space)   // up\n        m_up = true;\n    if (Key == VirtualKey::X)       // down\n        m_down = true;\n    if (Key == VirtualKey::P)       // Pause\n        m_pause = true;\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::OnKeyUp(\n    _In_ CoreWindow^ /* sender */,\n    _In_ KeyEventArgs^ args\n    )\n{\n    Windows::System::VirtualKey Key;\n    Key = args->VirtualKey;\n\n    // Figure out the command from the keyboard.\n    if (Key == VirtualKey::W)       // Forward\n        m_forward = false;\n    if (Key == VirtualKey::S)       // Back\n        m_back = false;\n    if (Key == VirtualKey::A)       // Left\n        m_left = false;\n    if (Key == VirtualKey::D)       // Right\n        m_right = false;\n    if (Key == VirtualKey::Space)   // Up\n        m_up = false;\n    if (Key == VirtualKey::X)       // Down\n        m_down = false;\n    if (Key == VirtualKey::P)\n    {\n        if (m_pause)\n        {\n            // Trigger pause only one time on button release.\n            m_pausePressed = true;\n            m_pause = false;\n        }\n    }\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::ResetState()\n{\n    // Reset the state of the controller.\n    // Disable any active pointer IDs to stop all interaction.\n    m_buttonPressed = false;\n    m_pausePressed = false;\n    m_buttonInUse = false;\n    m_moveInUse = false;\n    m_lookInUse = false;\n    m_fireInUse = false;\n    m_mouseInUse = false;\n    m_mouseLeftInUse = false;\n    m_mouseRightInUse = false;\n    m_movePointerID = 0;\n    m_lookPointerID = 0;\n    m_firePointerID = 0;\n    m_mousePointerID = 0;\n    m_velocity = XMFLOAT3(0.0f, 0.0f, 0.0f);\n\n    m_xinputStartButtonInUse = false;\n    m_xinputTriggerInUse = false;\n\n    m_moveCommand = XMFLOAT3(0.0f, 0.0f, 0.0f);\n    m_forward = false;\n    m_back = false;\n    m_left = false;\n    m_right = false;\n    m_up = false;\n    m_down = false;\n    m_pause = false;\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::SetMoveRect (\n    _In_ XMFLOAT2 upperLeft,\n    _In_ XMFLOAT2 lowerRight\n    )\n{\n    m_moveUpperLeft  = upperLeft;\n    m_moveLowerRight = lowerRight;\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::SetFireRect (\n    _In_ XMFLOAT2 upperLeft,\n    _In_ XMFLOAT2 lowerRight\n    )\n{\n    m_fireUpperLeft  = upperLeft;\n    m_fireLowerRight = lowerRight;\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::WaitForPress(\n    _In_ XMFLOAT2 upperLeft,\n    _In_ XMFLOAT2 lowerRight\n    )\n{\n\n    ResetState();\n    m_state = MoveLookControllerState::WaitForInput;\n    m_buttonUpperLeft  = upperLeft;\n    m_buttonLowerRight = lowerRight;\n\n    // Turn on the mouse cursor.\n    CoreWindow::GetForCurrentThread()->PointerCursor = ref new CoreCursor(CoreCursorType::Arrow, 0);\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::WaitForPress()\n{\n    ResetState();\n    m_state = MoveLookControllerState::WaitForInput;\n    m_buttonUpperLeft.x = 0.0f;\n    m_buttonUpperLeft.y = 0.0f;\n    m_buttonLowerRight.x = 0.0f;\n    m_buttonLowerRight.y = 0.0f;\n\n    // Turn on the mouse cursor.\n    CoreWindow::GetForCurrentThread()->PointerCursor = ref new CoreCursor(CoreCursorType::Arrow, 0);\n}\n\n//----------------------------------------------------------------------\n\nXMFLOAT3 MoveLookController::Velocity()\n{\n    return m_velocity;\n}\n\n//----------------------------------------------------------------------\n\nXMFLOAT3 MoveLookController::LookDirection()\n{\n    XMFLOAT3 lookDirection;\n\n    float r = cosf(m_pitch);              // In the plane\n    lookDirection.y = sinf(m_pitch);      // Vertical\n    lookDirection.z = r * cosf(m_yaw);    // Fwd-back\n    lookDirection.x = r * sinf(m_yaw);    // Left-right\n\n    return lookDirection;\n}\n\n//----------------------------------------------------------------------\n\nfloat MoveLookController::Pitch()\n{\n    return m_pitch;\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::Pitch(_In_ float pitch)\n{\n    m_pitch = pitch;\n}\n\n//----------------------------------------------------------------------\n\nfloat MoveLookController::Yaw()\n{\n    return m_yaw;\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::Yaw(_In_ float yaw)\n{\n    m_yaw = yaw;\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::Active(_In_ bool active)\n{\n    ResetState();\n\n    if (active)\n    {\n        m_state = MoveLookControllerState::Active;\n        // Turn the mouse cursor off (hidden).\n        CoreWindow::GetForCurrentThread()->PointerCursor = nullptr;\n    }\n    else\n    {\n        m_state = MoveLookControllerState::None;\n        // Turn the mouse cursor on.\n        auto window = CoreWindow::GetForCurrentThread();\n        if (window)\n        {\n            // Protect case where there isn't a window associated with the current thread.\n            // This happens on initialization.\n            window->PointerCursor = ref new CoreCursor(CoreCursorType::Arrow, 0);\n        }\n    }\n}\n\n//----------------------------------------------------------------------\n\nbool MoveLookController::Active()\n{\n    if (m_state == MoveLookControllerState::Active)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::AutoFire(_In_ bool autoFire)\n{\n    m_autoFire = autoFire;\n}\n\n//----------------------------------------------------------------------\n\nbool MoveLookController::AutoFire()\n{\n    return m_autoFire;\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::Update()\n{\n    UpdateGameController();\n\n    if (m_moveInUse)\n    {\n        // Move control.\n        XMFLOAT2 pointerDelta;\n\n        pointerDelta.x = m_movePointerPosition.x - m_moveFirstDown.x;\n        pointerDelta.y = m_movePointerPosition.y - m_moveFirstDown.y;\n\n        // Figure out the command from the virtual joystick.\n        XMFLOAT3 commandDirection = XMFLOAT3(0.0f, 0.0f, 0.0f);\n        if (fabsf(pointerDelta.x) > 16.0f)         // leave 32 pixel-wide dead spot for being still\n            m_moveCommand.x -= pointerDelta.x/fabsf(pointerDelta.x);\n\n        if (fabsf(pointerDelta.y) > 16.0f)\n            m_moveCommand.y -= pointerDelta.y/fabsf(pointerDelta.y);\n    }\n\n    // Poll our state bits set by the keyboard input events.\n    if (m_forward)\n    {\n        m_moveCommand.y += 1.0f;\n    }\n    if (m_back)\n    {\n        m_moveCommand.y -= 1.0f;\n    }\n    if (m_left)\n    {\n        m_moveCommand.x += 1.0f;\n    }\n    if (m_right)\n    {\n        m_moveCommand.x -= 1.0f;\n    }\n    if (m_up)\n    {\n        m_moveCommand.z += 1.0f;\n    }\n    if (m_down)\n    {\n        m_moveCommand.z -= 1.0f;\n    }\n\n    // Make sure that 45 deg cases are not faster.\n    if (fabsf(m_moveCommand.x) > 0.1f ||\n        fabsf(m_moveCommand.y) > 0.1f ||\n        fabsf(m_moveCommand.z) > 0.1f)\n    {\n        XMStoreFloat3(&m_moveCommand, XMVector3Normalize(XMLoadFloat3(&m_moveCommand)));\n    }\n\n    // Rotate command to align with our direction (world coordinates).\n    XMFLOAT3 wCommand;\n    wCommand.x =  m_moveCommand.x * cosf(m_yaw) - m_moveCommand.y * sinf(m_yaw);\n    wCommand.y =  m_moveCommand.x * sinf(m_yaw) + m_moveCommand.y * cosf(m_yaw);\n    wCommand.z =  m_moveCommand.z;\n\n    // Scale for sensitivity adjustment.\n    // Our velocity is based on the command, y is up.\n    m_velocity.x = -wCommand.x * MOVEMENT_GAIN;\n    m_velocity.z =  wCommand.y * MOVEMENT_GAIN;\n    m_velocity.y =  wCommand.z * MOVEMENT_GAIN;\n\n    // Clear the movement input accumulator for use during next frame.\n    m_moveCommand = XMFLOAT3(0.0f, 0.0f, 0.0f);\n}\n\n//----------------------------------------------------------------------\n\nvoid MoveLookController::UpdateGameController()\n{\n    if (!m_isControllerConnected)\n    {\n        // Check for controller connection by trying to get the capabilties.\n        DWORD capsResult = XInputGetCapabilities(0, XINPUT_FLAG_GAMEPAD, &m_xinputCaps);\n        if (capsResult != ERROR_SUCCESS)\n        {\n            return;\n        }\n        // The device is connected.\n        m_isControllerConnected = true;\n        m_xinputStartButtonInUse = false;\n        m_xinputTriggerInUse = false;\n    }\n\n    DWORD stateResult = XInputGetState(0, &m_xinputState);\n    if (stateResult != ERROR_SUCCESS)\n    {\n        // The device is no longer connected.\n        m_isControllerConnected = false;\n    }\n\n    switch (m_state)\n    {\n    case MoveLookControllerState::WaitForInput:\n        if (m_xinputState.Gamepad.wButtons & XINPUT_GAMEPAD_START)\n        {\n            m_xinputStartButtonInUse = true;\n        }\n        else if (m_xinputStartButtonInUse)\n        {\n            // Trigger one time only on button release.\n            m_xinputStartButtonInUse = false;\n            m_buttonPressed = true;\n        }\n        break;\n\n    case MoveLookControllerState::Active:\n        if (m_xinputState.Gamepad.wButtons & XINPUT_GAMEPAD_START)\n        {\n            m_xinputStartButtonInUse = true;\n        }\n        else if (m_xinputStartButtonInUse)\n        {\n            // Trigger one time only on button release.\n            m_xinputStartButtonInUse = false;\n            m_pausePressed = true;\n        }\n        // Use the Right Thumb joystick on the XBox controller to control\n        // the eye point position control.\n        // The controller input goes from -32767 to 32767.   We will normalize\n        // this from -1 to 1 and keep a dead spot in the middle to avoid drift.\n\n        if (m_xinputState.Gamepad.sThumbLX > XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE ||\n            m_xinputState.Gamepad.sThumbLX < -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE)\n        {\n            float x = (float)m_xinputState.Gamepad.sThumbLX/32767.0f;\n            m_moveCommand.x -= x / fabsf(x);\n        }\n\n        if (m_xinputState.Gamepad.sThumbLY > XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE ||\n            m_xinputState.Gamepad.sThumbLY < -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE)\n        {\n            float y = (float)m_xinputState.Gamepad.sThumbLY/32767.0f;\n            m_moveCommand.y += y / fabsf(y);\n        }\n\n        // Use the Left Thumb Joystick on the XBox controller to control\n        // the look at control.\n        // The controller input goes from -32767 to 32767.   We will normalize\n        // this from -1 to 1 and keep a dead spot in the middle to avoid drift.\n        XMFLOAT2 pointerDelta;\n        if (m_xinputState.Gamepad.sThumbRX > XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE ||\n            m_xinputState.Gamepad.sThumbRX < -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE)\n        {\n            pointerDelta.x = (float)m_xinputState.Gamepad.sThumbRX/32767.0f;\n            pointerDelta.x = pointerDelta.x * pointerDelta.x * pointerDelta.x;\n        }\n        else\n        {\n            pointerDelta.x = 0.0f;\n        }\n        if (m_xinputState.Gamepad.sThumbRY > XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE ||\n            m_xinputState.Gamepad.sThumbRY < -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE)\n        {\n            pointerDelta.y = (float)m_xinputState.Gamepad.sThumbRY/32767.0f;\n            pointerDelta.y = pointerDelta.y * pointerDelta.y * pointerDelta.y;\n        }\n        else\n        {\n            pointerDelta.y = 0.0f;\n        }\n\n        XMFLOAT2 rotationDelta;\n        rotationDelta.x = pointerDelta.x *  0.08f;       // scale for control sensitivity\n        rotationDelta.y = pointerDelta.y *  0.08f;\n\n        // Update our orientation based on the command.\n        m_pitch += rotationDelta.y;\n        m_yaw   += rotationDelta.x;\n\n        // Limit pitch to straight up or straight down.\n        m_pitch = __max(-XM_PI / 2.0f, m_pitch);\n        m_pitch = __min(+XM_PI / 2.0f, m_pitch);\n\n        // Check the state of the A button.  This is used to indicate fire control.\n\n        if (m_xinputState.Gamepad.bRightTrigger > XINPUT_GAMEPAD_TRIGGER_THRESHOLD)\n        {\n            if (!m_autoFire && !m_xinputTriggerInUse)\n            {\n                m_firePressed = true;\n            }\n            m_xinputTriggerInUse = true;\n        }\n        else\n        {\n            m_xinputTriggerInUse = false;\n        }\n        break;\n    }\n}\n```\n\n> **Note**  \nThis article is for Windows 10 developers writing Universal Windows Platform (UWP) apps. If you’re developing for Windows 8.x or Windows Phone 8.x, see the [archived documentation](http://go.microsoft.com/fwlink/p/?linkid=619132).\n\n \n\n## Related topics\n\n\n[Create a simple UWP game with DirectX](tutorial--create-your-first-metro-style-directx-game.md)\n\n \n\n \n\n\n\n\n"}