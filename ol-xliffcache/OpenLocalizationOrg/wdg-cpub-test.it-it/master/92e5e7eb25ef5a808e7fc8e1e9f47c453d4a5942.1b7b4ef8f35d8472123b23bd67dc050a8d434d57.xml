{"nodes":[{"pos":[11,44],"content":"Marble Maze application structure","needQuote":true,"needEscape":true,"nodes":[{"content":"Marble Maze application structure","pos":[0,33]}]},{"pos":[58,177],"content":"The structure of a DirectX Universal Windows Platform (UWP) app differs from that of a traditional desktop application.","needQuote":true,"needEscape":true,"nodes":[{"content":"The structure of a DirectX Universal Windows Platform (UWP) app differs from that of a traditional desktop application.","pos":[0,119]}]},{"content":"Marble Maze application structure","pos":[234,267]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[270,308]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[309,404],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"The structure of a DirectX Universal Windows Platform (UWP) app differs from that of a traditional desktop application.","pos":[407,526]},{"content":"Instead of working with handle types such as <bpt id=\"p1\">**</bpt>HWND<ept id=\"p1\">**</ept> and functions such as <bpt id=\"p2\">**</bpt>CreateWindow<ept id=\"p2\">**</ept>, the Windows Runtime provides interfaces such as <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Windows::UI::Core::ICoreWindow<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208296)</ept> so that you can develop UWP apps in a more modern, object-oriented manner.","pos":[527,838],"source":" Instead of working with handle types such as **HWND** and functions such as **CreateWindow**, the Windows Runtime provides interfaces such as [**Windows::UI::Core::ICoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208296) so that you can develop UWP apps in a more modern, object-oriented manner."},{"content":"This section of the documentation shows how the Marble Maze application code is structured.","pos":[839,930]},{"pos":[934,1092],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   The sample code that corresponds to this document is found in the <bpt id=\"p2\">[</bpt>DirectX Marble Maze game sample<ept id=\"p2\">](http://go.microsoft.com/fwlink/?LinkId=624011)</ept>.","source":"**Note**   The sample code that corresponds to this document is found in the [DirectX Marble Maze game sample](http://go.microsoft.com/fwlink/?LinkId=624011)."},{"content":"Here are some of the key points that this document discusses for when you structure your game code:","pos":[1100,1199]},{"content":"In the initialization phase, set up runtime and library components that your game uses.","pos":[1205,1292]},{"content":"Also load game-specific resources.","pos":[1293,1327]},{"content":"UWP apps must start processing events within 5 seconds of launch.","pos":[1332,1397]},{"content":"Therefore, load only essential resources when you load your app.","pos":[1398,1462]},{"content":"Games should load large resources in the background and display a progress screen.","pos":[1463,1545]},{"content":"In the game loop, respond to Windows events, read user input, update scene objects, and render the scene.","pos":[1550,1655]},{"content":"Use event handlers to respond to window events.","pos":[1660,1707]},{"content":"(These replace the window messages from desktop Windows applications.)","pos":[1708,1778]},{"content":"Use a state machine to control the flow and order of the game logic.","pos":[1783,1851]},{"content":"File organization","pos":[1857,1874]},{"content":"Some of the components in Marble Maze can be reused with any game with little or no modification.","pos":[1877,1974]},{"content":"For your own game, you can adapt the organization and ideas that these files provide.","pos":[1975,2060]},{"content":"The following table briefly describes the important source code files.","pos":[2061,2131]},{"content":"Files","pos":[2135,2140]},{"content":"Description","pos":[2180,2191]},{"content":"Audio.h, Audio.cpp","pos":[2595,2613]},{"pos":[2640,2699],"content":"Defines the <bpt id=\"p1\">**</bpt>Audio<ept id=\"p1\">**</ept> class, which manages audio resources.","source":"Defines the **Audio** class, which manages audio resources."},{"content":"BasicLoader.h, BasicLoader.cpp","pos":[2825,2855]},{"pos":[2870,2985],"content":"Defines the <bpt id=\"p1\">**</bpt>BasicLoader<ept id=\"p1\">**</ept> class, which provides utility methods that help you load textures, meshes, and shaders.","source":"Defines the **BasicLoader** class, which provides utility methods that help you load textures, meshes, and shaders."},{"content":"BasicMath.h","pos":[3055,3066]},{"content":"Defines structures and functions that help you work with vector and matrix data and computations.","pos":[3100,3197]},{"content":"Many of these functions are compatible with HLSL shader types.","pos":[3198,3260]},{"content":"BasicReaderWriter.h, BasicReaderWriter.cpp","pos":[3285,3327]},{"pos":[3330,3443],"content":"Defines the <bpt id=\"p1\">**</bpt>BasicReaderWriter<ept id=\"p1\">**</ept> class, which uses the Windows Runtime to read and write file data in a UWP app.","source":"Defines the **BasicReaderWriter** class, which uses the Windows Runtime to read and write file data in a UWP app."},{"content":"BasicShapes.h, BasicShapes.cpp","pos":[3515,3545]},{"content":"Defines the <bpt id=\"p1\">**</bpt>BasicShapes<ept id=\"p1\">**</ept> class, which provides utility methods for creating basic shapes such as cubes and spheres.","pos":[3560,3678],"source":"Defines the **BasicShapes** class, which provides utility methods for creating basic shapes such as cubes and spheres."},{"content":"(These files are not used by the Marble Maze implementation).","pos":[3679,3740]},{"content":"BasicTimer.h, BasicTimer.cpp","pos":[3745,3773]},{"pos":[3790,3882],"content":"Defines the <bpt id=\"p1\">**</bpt>BasicTimer<ept id=\"p1\">**</ept> class, which provides an easy way to get total and elapsed times.","source":"Defines the **BasicTimer** class, which provides an easy way to get total and elapsed times."},{"content":"Camera.h, Camera.cpp","pos":[3975,3995]},{"pos":[4020,4106],"content":"Defines the <bpt id=\"p1\">**</bpt>Camera<ept id=\"p1\">**</ept> class, which provides the position and orientation of a camera.","source":"Defines the **Camera** class, which provides the position and orientation of a camera."},{"content":"Collision.h, Collision.cpp","pos":[4205,4231]},{"content":"Manages collision info between the marble and other objects, such as the maze.","pos":[4250,4328]},{"content":"DDSTextureLoader.h, DDSTextureLoader.cpp","pos":[4435,4475]},{"pos":[4480,4599],"content":"Defines the <bpt id=\"p1\">**</bpt>CreateDDSTextureFromMemory<ept id=\"p1\">**</ept> function, which loads textures that are in .dds format from a memory buffer.","source":"Defines the **CreateDDSTextureFromMemory** function, which loads textures that are in .dds format from a memory buffer."},{"content":"DirectXApp.h, DirectXApp.cpp","pos":[4665,4693]},{"pos":[4710,4838],"content":"Defines the <bpt id=\"p1\">**</bpt>DirectXApp<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>DirectXAppSource<ept id=\"p2\">**</ept> classes, which encapsulate the view (window, thread, and events) of the app.","source":"Defines the **DirectXApp** and **DirectXAppSource** classes, which encapsulate the view (window, thread, and events) of the app."},{"content":"DirectXBase.h, DirectXBase.cpp","pos":[4895,4925]},{"pos":[4940,5045],"content":"Defines the <bpt id=\"p1\">**</bpt>DirectXBase<ept id=\"p1\">**</ept> class, which provides infrastructure that is common to many DirectX UWP apps.","source":"Defines the **DirectXBase** class, which provides infrastructure that is common to many DirectX UWP apps."},{"content":"DirectXSample.h","pos":[5125,5140]},{"content":"Defines utility functions that can be used by DirectX UWP apps.","pos":[5170,5233]},{"content":"LoadScreen.h, LoadScreen.cpp","pos":[5355,5383]},{"pos":[5400,5492],"content":"Defines the <bpt id=\"p1\">**</bpt>LoadScreen<ept id=\"p1\">**</ept> class, which displays a loading screen during app initialization.","source":"Defines the **LoadScreen** class, which displays a loading screen during app initialization."},{"content":"MarbleMaze.h, MarbleMaze.cpp","pos":[5585,5613]},{"pos":[5630,5737],"content":"Defines the <bpt id=\"p1\">**</bpt>MarbleMaze<ept id=\"p1\">**</ept> class, which manages game-specific resources and defines much of the game logic.","source":"Defines the **MarbleMaze** class, which manages game-specific resources and defines much of the game logic."},{"content":"MediaStreamer.h, MediaStreamer.cpp","pos":[5815,5849]},{"pos":[5860,5965],"content":"Defines the <bpt id=\"p1\">**</bpt>MediaStreamer<ept id=\"p1\">**</ept> class, which uses Media Foundation to help the game manage audio resources.","source":"Defines the **MediaStreamer** class, which uses Media Foundation to help the game manage audio resources."},{"content":"PersistentState.h, PersistentState.cpp","pos":[6045,6083]},{"pos":[6090,6201],"content":"Defines the <bpt id=\"p1\">**</bpt>PersistentState<ept id=\"p1\">**</ept> class, which reads and writes primitive data types from and to a backing store.","source":"Defines the **PersistentState** class, which reads and writes primitive data types from and to a backing store."},{"content":"Physics.h, Physics.cpp","pos":[6275,6297]},{"pos":[6320,6423],"content":"Defines the <bpt id=\"p1\">**</bpt>Physics<ept id=\"p1\">**</ept> class, which implements the physics simulation between the marble and the maze.","source":"Defines the **Physics** class, which implements the physics simulation between the marble and the maze."},{"content":"Primitives.h","pos":[6505,6517]},{"content":"Defines geometric types that are used by the game.","pos":[6550,6600]},{"content":"SampleOverlay.h, SampleOverlay.cpp","pos":[6735,6769]},{"pos":[6780,6882],"content":"Defines the <bpt id=\"p1\">**</bpt>SampleOverlay<ept id=\"p1\">**</ept> class, which provides common 2-D and user-interface data and operations.","source":"Defines the **SampleOverlay** class, which provides common 2-D and user-interface data and operations."},{"content":"SDKMesh.h, SDKMesh.cpp","pos":[6965,6987]},{"pos":[7010,7111],"content":"Defines the <bpt id=\"p1\">**</bpt>SDKMesh<ept id=\"p1\">**</ept> class, which loads and renders meshes that are in SDK Mesh (.sdkmesh) format.","source":"Defines the **SDKMesh** class, which loads and renders meshes that are in SDK Mesh (.sdkmesh) format."},{"content":"UserInterface.h, UserInterface.cpp","pos":[7195,7229]},{"content":"Defines functionality that's related to the user interface, such as the menu system and the high score table.","pos":[7240,7349]},{"content":"Design-time versus run-time resource formats","pos":[7431,7475]},{"content":"When you can, use run-time formats instead of design-time formats to more efficiently load game resources.","pos":[7478,7584]},{"content":"A <bpt id=\"p1\">*</bpt>design-time<ept id=\"p1\">*</ept> format is the format you use when you design your resource.","pos":[7586,7661],"source":"A *design-time* format is the format you use when you design your resource."},{"content":"Typically, 3-D designers work with design-time formats.","pos":[7662,7717]},{"content":"Some design-time formats are also text-based so that you can modify them in any text-based editor.","pos":[7718,7816]},{"content":"Design-time formats can be verbose and contain more information than your game requires.","pos":[7817,7905]},{"content":"A <bpt id=\"p1\">*</bpt>run-time<ept id=\"p1\">*</ept> format is the binary format that is read by your game.","pos":[7906,7973],"source":" A *run-time* format is the binary format that is read by your game."},{"content":"Run-time formats are typically more compact and more efficient to load than the corresponding design-time formats.","pos":[7974,8088]},{"content":"This is why the majority of games use run-time assets at run time.","pos":[8089,8155]},{"content":"Although your game can directly read a design-time format, there are several benefits to using a separate run-time format.","pos":[8157,8279]},{"content":"Because run-time formats are often more compact, they require less disk space and require less time to transfer over a network.","pos":[8280,8407]},{"content":"Also, run-time formats are often represented as memory-mapped data structures.","pos":[8408,8486]},{"content":"Therefore, they can be loaded into memory much faster than, for example, an XML-based text file.","pos":[8487,8583]},{"content":"Finally, because separate run-time formats are typically binary-encoded, they are more difficult for the end-user to modify.","pos":[8584,8708]},{"content":"HLSL shaders are one example of resources that use different design-time and run-time formats.","pos":[8710,8804]},{"content":"Marble Maze uses .hlsl as the design-time format, and .cso as the run-time format.","pos":[8805,8887]},{"content":"A .hlsl file holds source code for the shader; a .cso file holds the corresponding shader byte code.","pos":[8888,8988]},{"content":"When you convert .hlsl files offline and provide .cso files with your game, you avoid the need to convert HLSL source files to byte code when your game loads.","pos":[8989,9147]},{"content":"For instructional reasons, the Marble Maze project includes both the design-time format and the run-time format for many resources, but you only have to maintain the design-time formats in the source project for your own game because you can convert them to run-time formats when you need them.","pos":[9149,9443]},{"content":"This documentation shows how to convert the design-time formats to the run-time formats.","pos":[9444,9532]},{"content":"Application life cycle","pos":[9538,9560]},{"content":"Marble Maze follows the life cycle of a typical UWP app.","pos":[9563,9619]},{"content":"For more info about the life cycle of a UWP app, see <bpt id=\"p1\">[</bpt>App lifecycle<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt243287)</ept>.","pos":[9620,9747],"source":" For more info about the life cycle of a UWP app, see [App lifecycle](https://msdn.microsoft.com/library/windows/apps/mt243287)."},{"content":"When a UWP game initializes, it typically initializes runtime components such as Direct3D, Direct2D, and any input, audio, or physics libraries that it uses.","pos":[9749,9906]},{"content":"It also loads game-specific resources that are required before the game begins.","pos":[9907,9986]},{"content":"This initialization occurs one time during a game session.","pos":[9987,10045]},{"content":"After initialization, games typically run the <bpt id=\"p1\">*</bpt>game loop<ept id=\"p1\">*</ept>.","pos":[10047,10105],"source":"After initialization, games typically run the *game loop*."},{"content":"In this loop, games typically perform four actions: process Windows events, collect input, update scene objects, and render the scene.","pos":[10106,10240]},{"content":"When the game updates the scene, it can apply the current input state to the scene objects and simulate physical events, such as object collisions.","pos":[10241,10388]},{"content":"The game can also perform other activities such as playing sound effects or sending data over the network.","pos":[10389,10495]},{"content":"When the game renders the scene, it captures the current state of the scene and draws it to the display device.","pos":[10496,10607]},{"content":"The following sections describe these activities in greater detail.","pos":[10608,10675]},{"content":"Adding to the template","pos":[10681,10703]},{"content":"The <bpt id=\"p1\">*</bpt>DirectX 11 App (Universal Windows)<ept id=\"p1\">*</ept> template creates a core window that you can render to with Direct3D.","pos":[10706,10815],"source":"The *DirectX 11 App (Universal Windows)* template creates a core window that you can render to with Direct3D."},{"content":"The template also includes the <bpt id=\"p1\">**</bpt>DeviceResources<ept id=\"p1\">**</ept> class that creates all of the Direct3D device resources needed for rendering 3D content in a UWP app.","pos":[10816,10968],"source":" The template also includes the **DeviceResources** class that creates all of the Direct3D device resources needed for rendering 3D content in a UWP app."},{"content":"The <bpt id=\"p1\">**</bpt>AppMain<ept id=\"p1\">**</ept> class creates the <bpt id=\"p2\">**</bpt>MarbleMaze<ept id=\"p2\">**</ept> class object, starts the loading of resources, loops to update the timer, and calls the <bpt id=\"p3\">**</bpt>MarbleMaze<ept id=\"p3\">**</ept> render method each frame.","pos":[10969,11146],"source":" The **AppMain** class creates the **MarbleMaze** class object, starts the loading of resources, loops to update the timer, and calls the **MarbleMaze** render method each frame."},{"content":"The <bpt id=\"p1\">**</bpt>CreateWindowSizeDependentResources<ept id=\"p1\">**</ept>, Update, and Render methods for this class call the corresponding methods in the <bpt id=\"p2\">**</bpt>MarbleMaze<ept id=\"p2\">**</ept> class.","pos":[11147,11292],"source":" The **CreateWindowSizeDependentResources**, Update, and Render methods for this class call the corresponding methods in the **MarbleMaze** class."},{"content":"The following example shows where the <bpt id=\"p1\">**</bpt>AppMain<ept id=\"p1\">**</ept> constructor creates the <bpt id=\"p2\">**</bpt>MarbleMaze<ept id=\"p2\">**</ept> class object.","pos":[11293,11395],"source":" The following example shows where the **AppMain** constructor creates the **MarbleMaze** class object."},{"content":"The device resources class is passed to the class so it can use the Direct3D objects for rendering.","pos":[11396,11495]},{"content":"The <bpt id=\"p1\">**</bpt>AppMain<ept id=\"p1\">**</ept> class also starts loading the deferred resources for the game.","pos":[11648,11726],"source":"The **AppMain** class also starts loading the deferred resources for the game."},{"content":"See the next section for more detail.","pos":[11727,11764]},{"content":"The <bpt id=\"p1\">**</bpt>DirectXPage<ept id=\"p1\">**</ept> constructor sets up the event handlers, creates the <bpt id=\"p2\">**</bpt>DeviceResources<ept id=\"p2\">**</ept> class, and creates the <bpt id=\"p3\">**</bpt>AppMain<ept id=\"p3\">**</ept> class.","pos":[11765,11898],"source":" The **DirectXPage** constructor sets up the event handlers, creates the **DeviceResources** class, and creates the **AppMain** class."},{"pos":[11900,11995],"content":"When the handlers for these events are called, they pass the input to the <bpt id=\"p1\">**</bpt>MarbleMaze<ept id=\"p1\">**</ept> class.","source":"When the handlers for these events are called, they pass the input to the **MarbleMaze** class."},{"content":"Loading game assets in the background","pos":[12000,12037]},{"content":"To ensure that your game can respond to window events within 5 seconds after it is launched, we recommend that you load your game assets asynchronously, or in the background.","pos":[12040,12214]},{"content":"As assets load in the background, your game can respond to window events.","pos":[12215,12288]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  You can also display the main menu when it is ready, and allow the remaining assets to continue loading in the background.","pos":[12292,12424],"source":"**Note**  You can also display the main menu when it is ready, and allow the remaining assets to continue loading in the background."},{"content":"If the user selects an option from the menu before all resources are loaded, you can indicate that scene resources are continuing to load by displaying a progress bar, for example.","pos":[12425,12605]},{"content":"Even if your game contains relatively few game assets, it is good practice to load them asynchronously for two reasons.","pos":[12610,12729]},{"content":"One reason is that it is difficult to guarantee that all of your resources will load quickly on all devices and all configurations.","pos":[12730,12861]},{"content":"Also, by incorporating asynchronous loading early, your code is ready to scale as you add functionality.","pos":[12862,12966]},{"content":"Asynchronous asset loading begins with the <bpt id=\"p1\">**</bpt>AppMain::Load<ept id=\"p1\">**</ept> method.","pos":[12968,13036],"source":"Asynchronous asset loading begins with the **AppMain::Load** method."},{"content":"This method uses the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>task Class (Concurrency Runtime)<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh750113.aspx)</ept> class to load game assets in the background.","pos":[13037,13204],"source":" This method uses the [**task Class (Concurrency Runtime)**](https://msdn.microsoft.com/library/windows/apps/hh750113.aspx) class to load game assets in the background."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze<ept id=\"p1\">**</ept> class defines the <bpt id=\"p2\">*</bpt>m\\_deferredResourcesReady<ept id=\"p2\">*</ept> flag to indicate that asynchronous loading is complete.","pos":[13301,13421],"source":"The **MarbleMaze** class defines the *m\\_deferredResourcesReady* flag to indicate that asynchronous loading is complete."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::LoadDeferredResources<ept id=\"p1\">**</ept> method loads the game resources and then sets this flag.","pos":[13422,13520],"source":" The **MarbleMaze::LoadDeferredResources** method loads the game resources and then sets this flag."},{"content":"The update (<bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept>) and render (<bpt id=\"p2\">**</bpt>MarbleMaze::Render<ept id=\"p2\">**</ept>) phases of the app check this flag.","pos":[13521,13627],"source":" The update (**MarbleMaze::Update**) and render (**MarbleMaze::Render**) phases of the app check this flag."},{"content":"When this flag is set, the game continues as normal.","pos":[13628,13680]},{"content":"If the flag is not yet set, the game shows the loading screen.","pos":[13681,13743]},{"pos":[13745,13907],"content":"For more information about asynchronous programming for UWP apps, see <bpt id=\"p1\">[</bpt>Asynchronous programming in C++<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt187334)</ept>.","source":"For more information about asynchronous programming for UWP apps, see [Asynchronous programming in C++](https://msdn.microsoft.com/library/windows/apps/mt187334)."},{"pos":[13914,14272],"content":"<bpt id=\"p1\">**</bpt>Tip<ept id=\"p1\">**</ept>   If you’re writing game code that is part of a Windows Runtime C++ Library (in other words, a DLL), consider whether to read <bpt id=\"p2\">[</bpt>Creating Asynchronous Operations in C++ for Windows Store Apps<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh750113.aspx)</ept> to learn how to create asynchronous operations that can be consumed by apps and other libraries.","source":"**Tip**   If you’re writing game code that is part of a Windows Runtime C++ Library (in other words, a DLL), consider whether to read [Creating Asynchronous Operations in C++ for Windows Store Apps](https://msdn.microsoft.com/library/windows/apps/hh750113.aspx) to learn how to create asynchronous operations that can be consumed by apps and other libraries."},{"content":"The game loop","pos":[14280,14293]},{"content":"The <bpt id=\"p1\">**</bpt>DirectPage::OnRendering<ept id=\"p1\">**</ept> method runs the main game loop.","pos":[14296,14359],"source":"The **DirectPage::OnRendering** method runs the main game loop."},{"content":"This method is called every frame.","pos":[14360,14394]},{"content":"To help separate view and window code from game-specific code, we implemented the <bpt id=\"p1\">**</bpt>DirectXApp::Run<ept id=\"p1\">**</ept> method to forward update and render calls to the <bpt id=\"p2\">**</bpt>MarbleMaze<ept id=\"p2\">**</ept> object.","pos":[14396,14569],"source":"To help separate view and window code from game-specific code, we implemented the **DirectXApp::Run** method to forward update and render calls to the **MarbleMaze** object."},{"content":"The <bpt id=\"p1\">**</bpt>DirectPage::OnRendering<ept id=\"p1\">**</ept> method also defines the game timer, which is used for animation and physics simulation.","pos":[14570,14689],"source":" The **DirectPage::OnRendering** method also defines the game timer, which is used for animation and physics simulation."},{"content":"The following example shows the <bpt id=\"p1\">**</bpt>DirectPage::OnRendering<ept id=\"p1\">**</ept> method, which includes the main game loop.","pos":[14691,14793],"source":"The following example shows the **DirectPage::OnRendering** method, which includes the main game loop."},{"content":"The game loop updates the total time and frame time variables, and then updates and renders the scene.","pos":[14794,14896]},{"content":"This also makes sure that content is only rendered when the window is visible.","pos":[14897,14975]},{"content":"The state machine","pos":[15213,15230]},{"content":"Games typically contain a <bpt id=\"p1\">*</bpt>state machine<ept id=\"p1\">*</ept> (also known as a <bpt id=\"p2\">*</bpt>finite state machine<ept id=\"p2\">*</ept>, or FSM) to control the flow and order of the game logic.","pos":[15233,15372],"source":"Games typically contain a *state machine* (also known as a *finite state machine*, or FSM) to control the flow and order of the game logic."},{"content":"A state machine contains a given number of states and the ability to transition among them.","pos":[15373,15464]},{"content":"A state machine typically starts from an <bpt id=\"p1\">*</bpt>initial<ept id=\"p1\">*</ept> state, transitions to one or more <bpt id=\"p2\">*</bpt>intermediate<ept id=\"p2\">*</ept> states, and possibly ends at a <bpt id=\"p3\">*</bpt>terminal<ept id=\"p3\">*</ept> state.","pos":[15465,15613],"source":" A state machine typically starts from an *initial* state, transitions to one or more *intermediate* states, and possibly ends at a *terminal* state."},{"content":"A game loop often uses a state machine so that it can perform the logic that is specific to the current game state.","pos":[15615,15730]},{"content":"Marble Maze defines the <bpt id=\"p1\">**</bpt>GameState<ept id=\"p1\">**</ept> enumeration, which defines each possible state of the game.","pos":[15731,15828],"source":" Marble Maze defines the **GameState** enumeration, which defines each possible state of the game."},{"content":"The <bpt id=\"p1\">**</bpt>MainMenu<ept id=\"p1\">**</ept> state, for example, defines that the main menu appears, and that the game is not active.","pos":[15996,16101],"source":"The **MainMenu** state, for example, defines that the main menu appears, and that the game is not active."},{"content":"Conversely, the <bpt id=\"p1\">**</bpt>InGameActive<ept id=\"p1\">**</ept> state defines that the game is active, and that the menu does not appear.","pos":[16102,16208],"source":" Conversely, the **InGameActive** state defines that the game is active, and that the menu does not appear."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze<ept id=\"p1\">**</ept> class defines the <bpt id=\"p2\">**</bpt>m\\_gameState<ept id=\"p2\">**</ept> member variable to hold the active game state.","pos":[16209,16309],"source":" The **MarbleMaze** class defines the **m\\_gameState** member variable to hold the active game state."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>MarbleMaze::Render<ept id=\"p2\">**</ept> methods use the switch statement to perform logic for the current state.","pos":[16311,16437],"source":"The **MarbleMaze::Update** and **MarbleMaze::Render** methods use the switch statement to perform logic for the current state."},{"content":"The following example shows what this switch statement might look like for the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method (details are removed to illustrate the structure).","pos":[16438,16597],"source":" The following example shows what this switch statement might look like for the **MarbleMaze::Update** method (details are removed to illustrate the structure)."},{"content":"When game logic or rendering depends on a specific game state, we emphasize it in this documentation.","pos":[16972,17073]},{"content":"Handling app and window events","pos":[17078,17108]},{"content":"The Windows Runtime provides an object-oriented event-handling system so that you can more easily manage Windows messages.","pos":[17111,17233]},{"content":"To consume an event in an application, you must provide an event handler, or event-handling method, that responds to the event.","pos":[17234,17361]},{"content":"You must also register the event handler with the event source.","pos":[17362,17425]},{"content":"This process is often referred to as event wiring.","pos":[17426,17476]},{"content":"Supporting suspend, resume, and restart","pos":[17482,17521]},{"content":"Marble Maze is suspended when the user switches away from it or when Windows enters a low power state.","pos":[17523,17625]},{"content":"The game is resumed when the user moves it to the foreground or when Windows comes out of a low power state.","pos":[17626,17734]},{"content":"Generally, you don't close apps.","pos":[17735,17767]},{"content":"Windows can terminate the app when it's in the suspended state and Windows requires the resources, such as memory, that the app is using.","pos":[17768,17905]},{"content":"Windows notifies an app when it is about to be suspended or resumed, but it doesn't notify the app when it's about to be terminated.","pos":[17906,18038]},{"content":"Therefore, your app must be able to save—at the point when Windows notifies your app that it is about to be suspended—any data that would be required to restore the current user state when the app is restarted.","pos":[18039,18249]},{"content":"If your app has significant user state that is expensive to save, you may also need to save state regularly, even before your app receives the suspend notification.","pos":[18250,18414]},{"content":"Marble Maze responds to suspend and resume notifications for two reasons:","pos":[18415,18488]},{"content":"When the app is suspended, the game saves the current game state and pauses audio playback.","pos":[18494,18585]},{"content":"When the app is resumed, the game resumes audio playback.","pos":[18586,18643]},{"content":"When the app is closed and later restarted, the game resumes from its previous state.","pos":[18648,18733]},{"content":"Marble Maze performs the following tasks to support suspend and resume:","pos":[18735,18806]},{"content":"It saves its state to persistent storage at key points in the game, such as when the user reaches a checkpoint.","pos":[18812,18923]},{"content":"It responds to suspend notifications by saving its state to persistent storage.","pos":[18928,19007]},{"content":"It responds to resume notifications by loading its state from persistent storage.","pos":[19012,19093]},{"content":"It also loads the previous state during startup.","pos":[19094,19142]},{"content":"To support suspend and resume, Marble Maze defines the <bpt id=\"p1\">**</bpt>PersistentState<ept id=\"p1\">**</ept> class.","pos":[19144,19225],"source":"To support suspend and resume, Marble Maze defines the **PersistentState** class."},{"content":"(See PersistentState.h and PersistentState.cpp).","pos":[19226,19274]},{"content":"This class uses the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows::Foundation::Collections::IPropertySet<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226054)</ept> interface to read and write properties.","pos":[19275,19445],"source":" This class uses the [**Windows::Foundation::Collections::IPropertySet**](https://msdn.microsoft.com/library/windows/apps/br226054) interface to read and write properties."},{"content":"The <bpt id=\"p1\">**</bpt>PersistentState<ept id=\"p1\">**</ept> class provides methods that read and write primitive data types (such as <bpt id=\"p2\">**</bpt>bool<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>int<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>float<ept id=\"p4\">**</ept>, <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>XMFLOAT3<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ee419475)</ept>, and <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>Platform::String<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/hh755812.aspx)</ept>), from and to a backing store.","pos":[19446,19770],"source":" The **PersistentState** class provides methods that read and write primitive data types (such as **bool**, **int**, **float**, [**XMFLOAT3**](https://msdn.microsoft.com/library/windows/desktop/ee419475), and [**Platform::String**](https://msdn.microsoft.com/library/windows/apps/hh755812.aspx)), from and to a backing store."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze<ept id=\"p1\">**</ept> class holds a <bpt id=\"p2\">**</bpt>PersistentState<ept id=\"p2\">**</ept> object.","pos":[20757,20817],"source":"The **MarbleMaze** class holds a **PersistentState** object."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze<ept id=\"p1\">**</ept> constructor initializes this object and provides the local application data store as the backing data store.","pos":[20818,20945],"source":" The **MarbleMaze** constructor initializes this object and provides the local application data store as the backing data store."},{"content":"Marble Maze saves its state when the marble passes over a checkpoint or the goal (in the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method), and when the window loses focus (in the <bpt id=\"p2\">**</bpt>MarbleMaze::OnFocusChange<ept id=\"p2\">**</ept> method).","pos":[21100,21299],"source":"Marble Maze saves its state when the marble passes over a checkpoint or the goal (in the **MarbleMaze::Update** method), and when the window loses focus (in the **MarbleMaze::OnFocusChange** method)."},{"content":"If your game holds a large amount of state data, we recommend that you occasionally save state to persistent storage in a similar manner because you only have a few seconds to respond to the suspend notification.","pos":[21300,21512]},{"content":"Therefore, when your app receives a suspend notification, it only has to save the state data that has changed.","pos":[21513,21623]},{"content":"To respond to suspend and resume notifications, the <bpt id=\"p1\">**</bpt>DirectXPage<ept id=\"p1\">**</ept> class defines the <bpt id=\"p2\">**</bpt>SaveInternalState<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>LoadInternalState<ept id=\"p3\">**</ept> methods that are called on suspend and resume.","pos":[21625,21805],"source":"To respond to suspend and resume notifications, the **DirectXPage** class defines the **SaveInternalState** and **LoadInternalState** methods that are called on suspend and resume."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::OnSuspending<ept id=\"p1\">**</ept> method handles the suspend event and the <bpt id=\"p2\">**</bpt>MarbleMaze::OnResuming<ept id=\"p2\">**</ept> method handles the resume event.","pos":[21806,21939],"source":" The **MarbleMaze::OnSuspending** method handles the suspend event and the **MarbleMaze::OnResuming** method handles the resume event."},{"pos":[21941,22017],"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::OnSuspending<ept id=\"p1\">**</ept> method saves game state and suspends audio.","source":"The **MarbleMaze::OnSuspending** method saves game state and suspends audio."},{"pos":[22112,22283],"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::SaveState<ept id=\"p1\">**</ept> method saves game state values such as the current position and velocity of the marble, the most recent checkpoint, and the high-score table.","source":"The **MarbleMaze::SaveState** method saves game state values such as the current position and velocity of the marble, the most recent checkpoint, and the high-score table."},{"content":"When the game resumes, it only has to resume audio.","pos":[23383,23434]},{"content":"It doesn't have to load state from persistent storage because the state is already loaded in memory.","pos":[23435,23535]},{"pos":[23537,23690],"content":"How the game suspends and resumes audio is explained in the document <bpt id=\"p1\">[</bpt>Adding audio to the Marble Maze sample<ept id=\"p1\">](adding-audio-to-the-marble-maze-sample.md)</ept>.","source":"How the game suspends and resumes audio is explained in the document [Adding audio to the Marble Maze sample](adding-audio-to-the-marble-maze-sample.md)."},{"content":"To support restart, the <bpt id=\"p1\">**</bpt>MarbleMaze::Initialize<ept id=\"p1\">**</ept> method, which is called during startup, calls the <bpt id=\"p2\">**</bpt>MarbleMaze::LoadState<ept id=\"p2\">**</ept> method.","pos":[23692,23826],"source":"To support restart, the **MarbleMaze::Initialize** method, which is called during startup, calls the **MarbleMaze::LoadState** method."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::LoadState<ept id=\"p1\">**</ept> method reads and applies the state to the game objects.","pos":[23827,23912],"source":" The **MarbleMaze::LoadState** method reads and applies the state to the game objects."},{"content":"This method also sets the current game state to paused if the game was paused or active when it was suspended.","pos":[23913,24023]},{"content":"We pause the game so that the user is not surprised by unexpected activity.","pos":[24024,24099]},{"content":"It also moves to the main menu if the game was not in a gameplay state when it was suspended.","pos":[24100,24193]},{"content":"<bpt id=\"p1\">**</bpt>Important<ept id=\"p1\">**</ept>  Marble Maze doesn't distinguish between cold starting—that is, starting for the first time without a prior suspend event—and resuming from a suspended state.","pos":[25998,26170],"source":"**Important**  Marble Maze doesn't distinguish between cold starting—that is, starting for the first time without a prior suspend event—and resuming from a suspended state."},{"content":"This is recommended design for all UWP apps.","pos":[26171,26215]},{"content":"For more examples that demonstrate how to store and retrieve settings and files from the local application data store, see <bpt id=\"p1\">[</bpt>Quickstart: Local application data<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh465118)</ept>.","pos":[26220,26438],"source":"For more examples that demonstrate how to store and retrieve settings and files from the local application data store, see [Quickstart: Local application data](https://msdn.microsoft.com/library/windows/apps/hh465118)."},{"content":"For more info about application data, see <bpt id=\"p1\">[</bpt>Store and retrieve settings and other app data<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt299098)</ept>.","pos":[26439,26588],"source":" For more info about application data, see [Store and retrieve settings and other app data](https://msdn.microsoft.com/library/windows/apps/mt299098)."},{"content":"Next steps","pos":[26594,26604]},{"pos":[26607,26814],"content":"Read <bpt id=\"p1\">[</bpt>Adding visual content to the Marble Maze sample<ept id=\"p1\">](adding-visual-content-to-the-marble-maze-sample.md)</ept> for information about some of the key practices to keep in mind when you work with visual resources.","source":"Read [Adding visual content to the Marble Maze sample](adding-visual-content-to-the-marble-maze-sample.md) for information about some of the key practices to keep in mind when you work with visual resources."},{"content":"Related topics","pos":[26819,26833]},{"content":"Adding visual content to the Marble Maze sample","pos":[26838,26885]},{"content":"Marble Maze sample fundamentals","pos":[26942,26973]},{"content":"Developing Marble Maze, a UWP game in C++ and DirectX","pos":[27014,27067]}],"content":"---\ntitle: Marble Maze application structure\ndescription: The structure of a DirectX Universal Windows Platform (UWP) app differs from that of a traditional desktop application.\nms.assetid: 6080f0d3-478a-8bbe-d064-73fd3d432074\n---\n\n# Marble Maze application structure\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\nThe structure of a DirectX Universal Windows Platform (UWP) app differs from that of a traditional desktop application. Instead of working with handle types such as **HWND** and functions such as **CreateWindow**, the Windows Runtime provides interfaces such as [**Windows::UI::Core::ICoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208296) so that you can develop UWP apps in a more modern, object-oriented manner. This section of the documentation shows how the Marble Maze application code is structured.\n\n> **Note**   The sample code that corresponds to this document is found in the [DirectX Marble Maze game sample](http://go.microsoft.com/fwlink/?LinkId=624011).\n\n \n## \nHere are some of the key points that this document discusses for when you structure your game code:\n\n-   In the initialization phase, set up runtime and library components that your game uses. Also load game-specific resources.\n-   UWP apps must start processing events within 5 seconds of launch. Therefore, load only essential resources when you load your app. Games should load large resources in the background and display a progress screen.\n-   In the game loop, respond to Windows events, read user input, update scene objects, and render the scene.\n-   Use event handlers to respond to window events. (These replace the window messages from desktop Windows applications.)\n-   Use a state machine to control the flow and order of the game logic.\n\n##  File organization\n\n\nSome of the components in Marble Maze can be reused with any game with little or no modification. For your own game, you can adapt the organization and ideas that these files provide. The following table briefly describes the important source code files.\n\n| Files                                      | Description                                                                                                                                                                          |\n|--------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Audio.h, Audio.cpp                         | Defines the **Audio** class, which manages audio resources.                                                                                                                          |\n| BasicLoader.h, BasicLoader.cpp             | Defines the **BasicLoader** class, which provides utility methods that help you load textures, meshes, and shaders.                                                                  |\n| BasicMath.h                                | Defines structures and functions that help you work with vector and matrix data and computations. Many of these functions are compatible with HLSL shader types.                     |\n| BasicReaderWriter.h, BasicReaderWriter.cpp | Defines the **BasicReaderWriter** class, which uses the Windows Runtime to read and write file data in a UWP app.                                                                    |\n| BasicShapes.h, BasicShapes.cpp             | Defines the **BasicShapes** class, which provides utility methods for creating basic shapes such as cubes and spheres. (These files are not used by the Marble Maze implementation). |\n| BasicTimer.h, BasicTimer.cpp               | Defines the **BasicTimer** class, which provides an easy way to get total and elapsed times.                                                                                         |\n| Camera.h, Camera.cpp                       | Defines the **Camera** class, which provides the position and orientation of a camera.                                                                                               |\n| Collision.h, Collision.cpp                 | Manages collision info between the marble and other objects, such as the maze.                                                                                                       |\n| DDSTextureLoader.h, DDSTextureLoader.cpp   | Defines the **CreateDDSTextureFromMemory** function, which loads textures that are in .dds format from a memory buffer.                                                              |\n| DirectXApp.h, DirectXApp.cpp               | Defines the **DirectXApp** and **DirectXAppSource** classes, which encapsulate the view (window, thread, and events) of the app.                                                     |\n| DirectXBase.h, DirectXBase.cpp             | Defines the **DirectXBase** class, which provides infrastructure that is common to many DirectX UWP apps.                                                                            |\n| DirectXSample.h                            | Defines utility functions that can be used by DirectX UWP apps.                                                                                                                      |\n| LoadScreen.h, LoadScreen.cpp               | Defines the **LoadScreen** class, which displays a loading screen during app initialization.                                                                                         |\n| MarbleMaze.h, MarbleMaze.cpp               | Defines the **MarbleMaze** class, which manages game-specific resources and defines much of the game logic.                                                                          |\n| MediaStreamer.h, MediaStreamer.cpp         | Defines the **MediaStreamer** class, which uses Media Foundation to help the game manage audio resources.                                                                            |\n| PersistentState.h, PersistentState.cpp     | Defines the **PersistentState** class, which reads and writes primitive data types from and to a backing store.                                                                      |\n| Physics.h, Physics.cpp                     | Defines the **Physics** class, which implements the physics simulation between the marble and the maze.                                                                              |\n| Primitives.h                               | Defines geometric types that are used by the game.                                                                                                                                   |\n| SampleOverlay.h, SampleOverlay.cpp         | Defines the **SampleOverlay** class, which provides common 2-D and user-interface data and operations.                                                                               |\n| SDKMesh.h, SDKMesh.cpp                     | Defines the **SDKMesh** class, which loads and renders meshes that are in SDK Mesh (.sdkmesh) format.                                                                                |\n| UserInterface.h, UserInterface.cpp         | Defines functionality that's related to the user interface, such as the menu system and the high score table.                                                                        |\n\n \n\n##  Design-time versus run-time resource formats\n\n\nWhen you can, use run-time formats instead of design-time formats to more efficiently load game resources.\n\nA *design-time* format is the format you use when you design your resource. Typically, 3-D designers work with design-time formats. Some design-time formats are also text-based so that you can modify them in any text-based editor. Design-time formats can be verbose and contain more information than your game requires. A *run-time* format is the binary format that is read by your game. Run-time formats are typically more compact and more efficient to load than the corresponding design-time formats. This is why the majority of games use run-time assets at run time.\n\nAlthough your game can directly read a design-time format, there are several benefits to using a separate run-time format. Because run-time formats are often more compact, they require less disk space and require less time to transfer over a network. Also, run-time formats are often represented as memory-mapped data structures. Therefore, they can be loaded into memory much faster than, for example, an XML-based text file. Finally, because separate run-time formats are typically binary-encoded, they are more difficult for the end-user to modify.\n\nHLSL shaders are one example of resources that use different design-time and run-time formats. Marble Maze uses .hlsl as the design-time format, and .cso as the run-time format. A .hlsl file holds source code for the shader; a .cso file holds the corresponding shader byte code. When you convert .hlsl files offline and provide .cso files with your game, you avoid the need to convert HLSL source files to byte code when your game loads.\n\nFor instructional reasons, the Marble Maze project includes both the design-time format and the run-time format for many resources, but you only have to maintain the design-time formats in the source project for your own game because you can convert them to run-time formats when you need them. This documentation shows how to convert the design-time formats to the run-time formats.\n\n##  Application life cycle\n\n\nMarble Maze follows the life cycle of a typical UWP app. For more info about the life cycle of a UWP app, see [App lifecycle](https://msdn.microsoft.com/library/windows/apps/mt243287).\n\nWhen a UWP game initializes, it typically initializes runtime components such as Direct3D, Direct2D, and any input, audio, or physics libraries that it uses. It also loads game-specific resources that are required before the game begins. This initialization occurs one time during a game session.\n\nAfter initialization, games typically run the *game loop*. In this loop, games typically perform four actions: process Windows events, collect input, update scene objects, and render the scene. When the game updates the scene, it can apply the current input state to the scene objects and simulate physical events, such as object collisions. The game can also perform other activities such as playing sound effects or sending data over the network. When the game renders the scene, it captures the current state of the scene and draws it to the display device. The following sections describe these activities in greater detail.\n\n##  Adding to the template\n\n\nThe *DirectX 11 App (Universal Windows)* template creates a core window that you can render to with Direct3D. The template also includes the **DeviceResources** class that creates all of the Direct3D device resources needed for rendering 3D content in a UWP app. The **AppMain** class creates the **MarbleMaze** class object, starts the loading of resources, loops to update the timer, and calls the **MarbleMaze** render method each frame. The **CreateWindowSizeDependentResources**, Update, and Render methods for this class call the corresponding methods in the **MarbleMaze** class. The following example shows where the **AppMain** constructor creates the **MarbleMaze** class object. The device resources class is passed to the class so it can use the Direct3D objects for rendering.\n\n```cpp\n    m_marbleMaze = std::unique_ptr<MarbleMaze>(new MarbleMaze(m_deviceResources));\n    m_marbleMaze->CreateWindowSizeDependentResources();\n```\n\nThe **AppMain** class also starts loading the deferred resources for the game. See the next section for more detail. The **DirectXPage** constructor sets up the event handlers, creates the **DeviceResources** class, and creates the **AppMain** class.\n\nWhen the handlers for these events are called, they pass the input to the **MarbleMaze** class.\n\n## Loading game assets in the background\n\n\nTo ensure that your game can respond to window events within 5 seconds after it is launched, we recommend that you load your game assets asynchronously, or in the background. As assets load in the background, your game can respond to window events.\n\n> **Note**  You can also display the main menu when it is ready, and allow the remaining assets to continue loading in the background. If the user selects an option from the menu before all resources are loaded, you can indicate that scene resources are continuing to load by displaying a progress bar, for example.\n\n \n\nEven if your game contains relatively few game assets, it is good practice to load them asynchronously for two reasons. One reason is that it is difficult to guarantee that all of your resources will load quickly on all devices and all configurations. Also, by incorporating asynchronous loading early, your code is ready to scale as you add functionality.\n\nAsynchronous asset loading begins with the **AppMain::Load** method. This method uses the [**task Class (Concurrency Runtime)**](https://msdn.microsoft.com/library/windows/apps/hh750113.aspx) class to load game assets in the background.\n\n```cpp\n    task<void>([=]()\n    {\n        m_marbleMaze->LoadDeferredResources();\n    });\n\n```\n\nThe **MarbleMaze** class defines the *m\\_deferredResourcesReady* flag to indicate that asynchronous loading is complete. The **MarbleMaze::LoadDeferredResources** method loads the game resources and then sets this flag. The update (**MarbleMaze::Update**) and render (**MarbleMaze::Render**) phases of the app check this flag. When this flag is set, the game continues as normal. If the flag is not yet set, the game shows the loading screen.\n\nFor more information about asynchronous programming for UWP apps, see [Asynchronous programming in C++](https://msdn.microsoft.com/library/windows/apps/mt187334).\n\n>> > **Tip**   If you’re writing game code that is part of a Windows Runtime C++ Library (in other words, a DLL), consider whether to read [Creating Asynchronous Operations in C++ for Windows Store Apps](https://msdn.microsoft.com/library/windows/apps/hh750113.aspx) to learn how to create asynchronous operations that can be consumed by apps and other libraries.\n\n \n\n## The game loop\n\n\nThe **DirectPage::OnRendering** method runs the main game loop. This method is called every frame.\n\nTo help separate view and window code from game-specific code, we implemented the **DirectXApp::Run** method to forward update and render calls to the **MarbleMaze** object. The **DirectPage::OnRendering** method also defines the game timer, which is used for animation and physics simulation.\n\nThe following example shows the **DirectPage::OnRendering** method, which includes the main game loop. The game loop updates the total time and frame time variables, and then updates and renders the scene. This also makes sure that content is only rendered when the window is visible.\n\n```cpp\n\nvoid DirectXPage::OnRendering(Object^ sender, Object^ args)\n{\n    if (m_windowVisible)\n    {\n        m_main->Update();\n\n        if (m_main->Render())\n        {\n            m_deviceResources->Present();\n        }\n    }\n}\n```\n\n## The state machine\n\n\nGames typically contain a *state machine* (also known as a *finite state machine*, or FSM) to control the flow and order of the game logic. A state machine contains a given number of states and the ability to transition among them. A state machine typically starts from an *initial* state, transitions to one or more *intermediate* states, and possibly ends at a *terminal* state.\n\nA game loop often uses a state machine so that it can perform the logic that is specific to the current game state. Marble Maze defines the **GameState** enumeration, which defines each possible state of the game.\n\n```cpp\nenum class GameState\n{\n    Initial,\n    MainMenu,\n    HighScoreDisplay,\n    PreGameCountdown,\n    InGameActive,\n    InGamePaused,\n    PostGameResults,\n};\n```\n\nThe **MainMenu** state, for example, defines that the main menu appears, and that the game is not active. Conversely, the **InGameActive** state defines that the game is active, and that the menu does not appear. The **MarbleMaze** class defines the **m\\_gameState** member variable to hold the active game state.\n\nThe **MarbleMaze::Update** and **MarbleMaze::Render** methods use the switch statement to perform logic for the current state. The following example shows what this switch statement might look like for the **MarbleMaze::Update** method (details are removed to illustrate the structure).\n\n```cpp\nswitch (m_gameState)\n{\ncase GameState::MainMenu:\n    // Do something with the main menu. \n    break;\n\ncase GameState::HighScoreDisplay:\n    // Do something with the high-score table. \n    break;\n\ncase GameState::PostGameResults:\n    // Do something with the game results. \n    break;\n\ncase GameState::InGamePaused:\n    // Handle the paused state. \n    break;\n}\n```\n\nWhen game logic or rendering depends on a specific game state, we emphasize it in this documentation.\n\n## Handling app and window events\n\n\nThe Windows Runtime provides an object-oriented event-handling system so that you can more easily manage Windows messages. To consume an event in an application, you must provide an event handler, or event-handling method, that responds to the event. You must also register the event handler with the event source. This process is often referred to as event wiring.\n\n### Supporting suspend, resume, and restart\n\nMarble Maze is suspended when the user switches away from it or when Windows enters a low power state. The game is resumed when the user moves it to the foreground or when Windows comes out of a low power state. Generally, you don't close apps. Windows can terminate the app when it's in the suspended state and Windows requires the resources, such as memory, that the app is using. Windows notifies an app when it is about to be suspended or resumed, but it doesn't notify the app when it's about to be terminated. Therefore, your app must be able to save—at the point when Windows notifies your app that it is about to be suspended—any data that would be required to restore the current user state when the app is restarted. If your app has significant user state that is expensive to save, you may also need to save state regularly, even before your app receives the suspend notification. Marble Maze responds to suspend and resume notifications for two reasons:\n\n1.  When the app is suspended, the game saves the current game state and pauses audio playback. When the app is resumed, the game resumes audio playback.\n2.  When the app is closed and later restarted, the game resumes from its previous state.\n\nMarble Maze performs the following tasks to support suspend and resume:\n\n-   It saves its state to persistent storage at key points in the game, such as when the user reaches a checkpoint.\n-   It responds to suspend notifications by saving its state to persistent storage.\n-   It responds to resume notifications by loading its state from persistent storage. It also loads the previous state during startup.\n\nTo support suspend and resume, Marble Maze defines the **PersistentState** class. (See PersistentState.h and PersistentState.cpp). This class uses the [**Windows::Foundation::Collections::IPropertySet**](https://msdn.microsoft.com/library/windows/apps/br226054) interface to read and write properties. The **PersistentState** class provides methods that read and write primitive data types (such as **bool**, **int**, **float**, [**XMFLOAT3**](https://msdn.microsoft.com/library/windows/desktop/ee419475), and [**Platform::String**](https://msdn.microsoft.com/library/windows/apps/hh755812.aspx)), from and to a backing store.\n\n```cpp\nref class PersistentState\n{\npublic:\n    void Initialize(\n        _In_ Windows::Foundation::Collections::IPropertySet^ m_settingsValues,\n        _In_ Platform::String^ key\n        );\n\n    void SaveBool(Platform::String^ key, bool value);\n    void SaveInt32(Platform::String^ key, int value);\n    void SaveSingle(Platform::String^ key, float value);\n    void SaveXMFLOAT3(Platform::String^ key, DirectX::XMFLOAT3 value);\n    void SaveString(Platform::String^ key, Platform::String^ string);\n\n    bool LoadBool(Platform::String^ key, bool defaultValue);\n    int  LoadInt32(Platform::String^ key, int defaultValue);\n    float LoadSingle(Platform::String^ key, float defaultValue);\n    DirectX::XMFLOAT3 LoadXMFLOAT3(Platform::String^ key, DirectX::XMFLOAT3 defaultValue);\n    Platform::String^ LoadString(Platform::String^ key, Platform::String^ defaultValue);\n\nprivate:\n    Platform::String^ m_keyName;\n    Windows::Foundation::Collections::IPropertySet^ m_settingsValues;\n};\n```\n\nThe **MarbleMaze** class holds a **PersistentState** object. The **MarbleMaze** constructor initializes this object and provides the local application data store as the backing data store.\n\n```cpp\nm_persistentState = ref new PersistentState();\nm_persistentState->Initialize(ApplicationData::Current->LocalSettings->Values, \"MarbleMaze\");\n```\n\nMarble Maze saves its state when the marble passes over a checkpoint or the goal (in the **MarbleMaze::Update** method), and when the window loses focus (in the **MarbleMaze::OnFocusChange** method). If your game holds a large amount of state data, we recommend that you occasionally save state to persistent storage in a similar manner because you only have a few seconds to respond to the suspend notification. Therefore, when your app receives a suspend notification, it only has to save the state data that has changed.\n\nTo respond to suspend and resume notifications, the **DirectXPage** class defines the **SaveInternalState** and **LoadInternalState** methods that are called on suspend and resume. The **MarbleMaze::OnSuspending** method handles the suspend event and the **MarbleMaze::OnResuming** method handles the resume event.\n\nThe **MarbleMaze::OnSuspending** method saves game state and suspends audio.\n\n```cpp\nvoid MarbleMaze::OnSuspending()\n{\n    SaveState();\n    m_audio.SuspendAudio();\n}\n```\n\nThe **MarbleMaze::SaveState** method saves game state values such as the current position and velocity of the marble, the most recent checkpoint, and the high-score table.\n\n```cpp\nvoid MarbleMaze::SaveState()\n{\n    m_persistentState->SaveXMFLOAT3(\":Position\", m_physics.GetPosition());\n    m_persistentState->SaveXMFLOAT3(\":Velocity\", m_physics.GetVelocity());\n    m_persistentState->SaveSingle(\":ElapsedTime\", m_inGameStopwatchTimer.GetElapsedTime());\n\n    m_persistentState->SaveInt32(\":GameState\", static_cast<int>(m_gameState));\n    m_persistentState->SaveInt32(\":Checkpoint\", static_cast<int>(m_currentCheckpoint));\n\n    int i = 0; \n    HighScoreEntries entries = m_highScoreTable.GetEntries();\n    const int bufferLength = 16;\n    char16 str[bufferLength];\n\n    m_persistentState->SaveInt32(\":ScoreCount\", static_cast<int>(entries.size()));\n    for (auto iter = entries.begin(); iter != entries.end(); ++iter)\n    {\n        int len = swprintf_s(str, bufferLength, L\"%d\", i++);\n        Platform::String^ string = ref new Platform::String(str, len);\n\n        m_persistentState->SaveSingle(Platform::String::Concat(\":ScoreTime\", string), iter->elapsedTime);\n        m_persistentState->SaveString(Platform::String::Concat(\":ScoreTag\", string), iter->tag);\n    }\n}\n```\n\nWhen the game resumes, it only has to resume audio. It doesn't have to load state from persistent storage because the state is already loaded in memory.\n\nHow the game suspends and resumes audio is explained in the document [Adding audio to the Marble Maze sample](adding-audio-to-the-marble-maze-sample.md).\n\nTo support restart, the **MarbleMaze::Initialize** method, which is called during startup, calls the **MarbleMaze::LoadState** method. The **MarbleMaze::LoadState** method reads and applies the state to the game objects. This method also sets the current game state to paused if the game was paused or active when it was suspended. We pause the game so that the user is not surprised by unexpected activity. It also moves to the main menu if the game was not in a gameplay state when it was suspended.\n\n```cpp\nvoid MarbleMaze::LoadState()\n{\n    XMFLOAT3 position = m_persistentState->LoadXMFLOAT3(\":Position\", m_physics.GetPosition());\n    XMFLOAT3 velocity = m_persistentState->LoadXMFLOAT3(\":Velocity\", m_physics.GetVelocity());\n    float elapsedTime = m_persistentState->LoadSingle(\":ElapsedTime\", 0.0f);\n\n    int gameState = m_persistentState->LoadInt32(\":GameState\", static_cast<int>(m_gameState));\n    int currentCheckpoint = m_persistentState->LoadInt32(\":Checkpoint\", static_cast<int>(m_currentCheckpoint));\n\n    switch (static_cast<GameState>(gameState))\n    {\n    case GameState::Initial:\n        break;\n\n    case GameState::MainMenu:\n    case GameState::HighScoreDisplay:\n    case GameState::PreGameCountdown:\n    case GameState::PostGameResults:\n        SetGameState(GameState::MainMenu);\n        break;\n\n    case GameState::InGameActive:\n    case GameState::InGamePaused:\n        m_inGameStopwatchTimer.SetVisible(true);\n        m_inGameStopwatchTimer.SetElapsedTime(elapsedTime);\n        m_physics.SetPosition(position);\n        m_physics.SetVelocity(velocity);\n        m_currentCheckpoint = currentCheckpoint;\n        SetGameState(GameState::InGamePaused);\n        break;\n    }\n\n    int count = m_persistentState->LoadInt32(\":ScoreCount\", 0);\n\n    const int bufferLength = 16;\n    char16 str[bufferLength];\n\n    for (int i = 0; i < count; i++)\n    {\n        HighScoreEntry entry;\n        int len = swprintf_s(str, bufferLength, L\"%d\", i);\n        Platform::String^ string = ref new Platform::String(str, len);\n\n        entry.elapsedTime = m_persistentState->LoadSingle(Platform::String::Concat(\":ScoreTime\", string), 0.0f);\n        entry.tag = m_persistentState->LoadString(Platform::String::Concat(\":ScoreTag\", string), L\"\");\n        m_highScoreTable.AddScoreToTable(entry);\n    }\n}\n```\n\n> **Important**  Marble Maze doesn't distinguish between cold starting—that is, starting for the first time without a prior suspend event—and resuming from a suspended state. This is recommended design for all UWP apps.\n\n \n\nFor more examples that demonstrate how to store and retrieve settings and files from the local application data store, see [Quickstart: Local application data](https://msdn.microsoft.com/library/windows/apps/hh465118). For more info about application data, see [Store and retrieve settings and other app data](https://msdn.microsoft.com/library/windows/apps/mt299098).\n\n##  Next steps\n\n\nRead [Adding visual content to the Marble Maze sample](adding-visual-content-to-the-marble-maze-sample.md) for information about some of the key practices to keep in mind when you work with visual resources.\n\n## Related topics\n\n* [Adding visual content to the Marble Maze sample](adding-visual-content-to-the-marble-maze-sample.md)\n* [Marble Maze sample fundamentals](marble-maze-sample-fundamentals.md)\n* [Developing Marble Maze, a UWP game in C++ and DirectX](developing-marble-maze-a-windows-store-game-in-cpp-and-directx.md)\n\n \n\n \n\n\n\n\n"}