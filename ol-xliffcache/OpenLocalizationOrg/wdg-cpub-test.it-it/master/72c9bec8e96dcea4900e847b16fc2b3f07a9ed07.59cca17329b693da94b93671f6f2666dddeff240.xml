{"nodes":[{"pos":[17,153],"content":"Learn to write code for a custom Panel class, implementing ArrangeOverride and MeasureOverride methods, and using the Children property.","needQuote":true,"needEscape":true,"nodes":[{"content":"Learn to write code for a custom Panel class, implementing ArrangeOverride and MeasureOverride methods, and using the Children property.","pos":[0,136]}]},{"pos":[161,194],"content":"BoxPanel, an example custom panel","needQuote":true,"needEscape":true,"nodes":[{"content":"BoxPanel, an example custom panel","pos":[0,33]}]},{"content":"BoxPanel, an example custom panel","pos":[313,346]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[349,387]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[388,483],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Important APIs","pos":[488,502]},{"content":"Panel","pos":[513,518]},{"content":"ArrangeOverride","pos":[587,602]},{"content":"MeasureOverride","pos":[671,686]},{"content":"Learn to write code for a custom <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Panel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept> class, implementing <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ArrangeOverride<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>MeasureOverride<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> methods, and using the <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>Children<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> property.","pos":[749,1141],"source":"Learn to write code for a custom [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) class, implementing [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) and [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) methods, and using the [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) property."},{"content":"The example code shows a custom panel implementation, but we don't devote a lot of time explaining the layout concepts that influence how you can customize a panel for different layout scenarios.","pos":[1142,1337]},{"content":"If you want more info about these layout concepts and how they might apply to your particular layout scenario, see <bpt id=\"p1\">[</bpt>XAML custom panels overview<ept id=\"p1\">](custom-panels-overview.md)</ept>.","pos":[1338,1510],"source":" If you want more info about these layout concepts and how they might apply to your particular layout scenario, see [XAML custom panels overview](custom-panels-overview.md)."},{"content":"A <bpt id=\"p1\">*</bpt>panel<ept id=\"p1\">*</ept> is an object that provides a layout behavior for child elements it contains, when the XAML layout system runs and your app UI is rendered.","pos":[1512,1660],"source":"A *panel* is an object that provides a layout behavior for child elements it contains, when the XAML layout system runs and your app UI is rendered."},{"content":"You can define custom panels for XAML layout by deriving a custom class from the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Panel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept> class.","pos":[1661,1818],"source":" You can define custom panels for XAML layout by deriving a custom class from the [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) class."},{"content":"You provide behavior for your panel by overriding the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ArrangeOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>MeasureOverride<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> methods, supplying logic that measures and arranges the child elements.","pos":[1819,2108],"source":" You provide behavior for your panel by overriding the [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) and [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) methods, supplying logic that measures and arranges the child elements."},{"content":"This example derives from <bpt id=\"p1\">**</bpt>Panel<ept id=\"p1\">**</ept>.","pos":[2109,2145],"source":" This example derives from **Panel**."},{"content":"When you start from <bpt id=\"p1\">**</bpt>Panel<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>ArrangeOverride<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>MeasureOverride<ept id=\"p3\">**</ept> methods don't have a starting behavior.","pos":[2146,2260],"source":" When you start from **Panel**, **ArrangeOverride** and **MeasureOverride** methods don't have a starting behavior."},{"content":"Your code is providing the gateway by which child elements become known to the XAML layout system and get rendered in the UI.","pos":[2261,2386]},{"content":"So, it's really important that your code accounts for all child elements and follows the patterns the layout system expects.","pos":[2387,2511]},{"content":"Your layout scenario","pos":[2516,2536]},{"content":"When you define a custom panel, you're defining a layout scenario.","pos":[2539,2605]},{"content":"A layout scenario is expressed through:","pos":[2607,2646]},{"content":"What the panel will do when it has child elements","pos":[2652,2701]},{"content":"When the panel has constraints on its own space","pos":[2706,2753]},{"content":"How the logic of the panel determines all the measurements, placement, positions, and sizings that eventually result in a rendered UI layout of children","pos":[2758,2910]},{"content":"With that in mind, the <ph id=\"ph1\">`BoxPanel`</ph> shown here is for a particular scenario.","pos":[2912,2986],"source":"With that in mind, the `BoxPanel` shown here is for a particular scenario."},{"content":"In the interest of keeping the code foremost in this example, we won't explain the scenario in detail yet, and instead concentrate on the steps needed and the coding patterns.","pos":[2987,3162]},{"content":"If you want to know more about the scenario first, skip ahead to <bpt id=\"p1\">[</bpt>\"The scenario for <ph id=\"ph1\">`BoxPanel`</ph>\"<ept id=\"p1\">](#scenario)</ept>, and then come back to the code.","pos":[3163,3303],"source":" If you want to know more about the scenario first, skip ahead to [\"The scenario for `BoxPanel`\"](#scenario), and then come back to the code."},{"pos":[3307,3339],"content":"Start by deriving from <bpt id=\"p1\">**</bpt>Panel<ept id=\"p1\">**</ept>","source":"Start by deriving from **Panel**"},{"content":"Start by deriving a custom class from <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Panel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept>.","pos":[3342,3450],"source":"Start by deriving a custom class from [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511)."},{"content":"Probably the easiest way to do this is to define a separate code file for this class, using the <bpt id=\"p1\">**</bpt>Add<ept id=\"p1\">**</ept><ph id=\"ph1\"> | </ph><bpt id=\"p2\">**</bpt>New Item<ept id=\"p2\">**</ept><ph id=\"ph2\"> | </ph><bpt id=\"p3\">**</bpt>Class<ept id=\"p3\">**</ept> context menu options for a project from the <bpt id=\"p4\">**</bpt>Solution Explorer<ept id=\"p4\">**</ept> in Microsoft Visual Studio.","pos":[3451,3675],"source":" Probably the easiest way to do this is to define a separate code file for this class, using the **Add** | **New Item** | **Class** context menu options for a project from the **Solution Explorer** in Microsoft Visual Studio."},{"content":"Name the class (and file) <ph id=\"ph1\">`BoxPanel`</ph>.","pos":[3676,3713],"source":" Name the class (and file) `BoxPanel`."},{"content":"The template file for a class doesn't start with many <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> statements because it's not specifically for Universal Windows Platform (UWP) apps.","pos":[3715,3862],"source":"The template file for a class doesn't start with many **using** statements because it's not specifically for Universal Windows Platform (UWP) apps."},{"content":"So first, add <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> statements.","pos":[3863,3898],"source":" So first, add **using** statements."},{"content":"The template file also starts with a few <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> statements that you probably don't need, and can be deleted.","pos":[3899,4010],"source":" The template file also starts with a few **using** statements that you probably don't need, and can be deleted."},{"content":"Here's a suggested list of <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> statements that can resolve types you'll need for typical custom panel code:","pos":[4011,4124],"source":" Here's a suggested list of **using** statements that can resolve types you'll need for typical custom panel code:"},{"content":"Now that you can resolve <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Panel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept>, make it the base class of <ph id=\"ph1\">`BoxPanel`</ph>.","pos":[4510,4643],"source":"Now that you can resolve [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511), make it the base class of `BoxPanel`."},{"content":"Also, make <ph id=\"ph1\">`BoxPanel`</ph> public:","pos":[4644,4673],"source":" Also, make `BoxPanel` public:"},{"content":"At the class level, define some <bpt id=\"p1\">**</bpt>int<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>double<ept id=\"p2\">**</ept> values that will be shared by several of your logic functions, but which won't need to be exposed as public API.","pos":[4724,4891],"source":"At the class level, define some **int** and **double** values that will be shared by several of your logic functions, but which won't need to be exposed as public API."},{"content":"In the example, these are named: <ph id=\"ph1\">`maxrc`</ph>, <ph id=\"ph2\">`rowcount`</ph>, <ph id=\"ph3\">`colcount`</ph>, <ph id=\"ph4\">`cellwidth`</ph>, <ph id=\"ph5\">`cellheight`</ph>, <ph id=\"ph6\">`maxcellheight`</ph>, <ph id=\"ph7\">`aspectratio`</ph>.","pos":[4892,5016],"source":" In the example, these are named: `maxrc`, `rowcount`, `colcount`, `cellwidth`, `cellheight`, `maxcellheight`, `aspectratio`."},{"pos":[5018,5150],"content":"After you've done this, the complete code file looks like this (removing comments on <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept>, now that you know why we have them):","source":"After you've done this, the complete code file looks like this (removing comments on **using**, now that you know why we have them):"},{"content":"From here on out, we'll be showing you one member definition at a time, be that a method override or something supporting such as a dependency property.","pos":[5458,5610]},{"content":"You can add these to the skeleton above in any order, and we won't be showing the <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> statements or the definition of the class scope again in the snippets until we show the final code.","pos":[5611,5802],"source":" You can add these to the skeleton above in any order, and we won't be showing the **using** statements or the definition of the class scope again in the snippets until we show the final code."},{"content":"MeasureOverride","pos":[5809,5824]},{"content":"The necessary pattern of a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> implementation is the loop through each element in <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Panel.Children<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept>.","pos":[7255,7492],"source":"The necessary pattern of a [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) implementation is the loop through each element in [**Panel.Children**](https://msdn.microsoft.com/library/windows/apps/br227514)."},{"content":"Always call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Measure<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> method on each of these elements.","pos":[7493,7614],"source":" Always call the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) method on each of these elements."},{"content":"<bpt id=\"p1\">**</bpt>Measure<ept id=\"p1\">**</ept> has a parameter of type <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Size<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept>.","pos":[7615,7720],"source":"**Measure** has a parameter of type [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995)."},{"content":"What you're passing here is the size that your panel is committing to have available for that particular child element.","pos":[7721,7840]},{"content":"So, before you can do the loop and start calling <bpt id=\"p1\">**</bpt>Measure<ept id=\"p1\">**</ept>, you need to know how much space each cell can devote.","pos":[7841,7956],"source":" So, before you can do the loop and start calling **Measure**, you need to know how much space each cell can devote."},{"content":"From the <bpt id=\"p1\">**</bpt>MeasureOverride<ept id=\"p1\">**</ept> method itself, you have the <bpt id=\"p2\">*</bpt>availableSize<ept id=\"p2\">*</ept> value.","pos":[7957,8036],"source":" From the **MeasureOverride** method itself, you have the *availableSize* value."},{"content":"That is the size that the panel's parent used when it called <bpt id=\"p1\">**</bpt>Measure<ept id=\"p1\">**</ept>, which was the trigger for this <bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept> being called in the first place.","pos":[8037,8194],"source":" That is the size that the panel's parent used when it called **Measure**, which was the trigger for this **MeasureOverride** being called in the first place."},{"content":"So a typical logic is to devise a scheme whereby each child element divides the space of the panel's overall <bpt id=\"p1\">*</bpt>availableSize<ept id=\"p1\">*</ept>.","pos":[8195,8320],"source":" So a typical logic is to devise a scheme whereby each child element divides the space of the panel's overall *availableSize*."},{"content":"You then pass each division of size to <bpt id=\"p1\">**</bpt>Measure<ept id=\"p1\">**</ept> of each child element.","pos":[8321,8394],"source":" You then pass each division of size to **Measure** of each child element."},{"content":"How <ph id=\"ph1\">`BoxPanel`</ph> divides size is fairly simple: it divides its space into a number of boxes that's largely controlled by the number of items.","pos":[8396,8535],"source":"How `BoxPanel` divides size is fairly simple: it divides its space into a number of boxes that's largely controlled by the number of items."},{"content":"Boxes are sized based on row and column count and the available size.","pos":[8536,8605]},{"content":"Sometimes one row or column from a square isn't needed, so it's dropped and the panel becomes a rectangle rather than square in terms of its row : column ratio.","pos":[8606,8766]},{"content":"For more info about how this logic was arrived at, skip ahead to <bpt id=\"p1\">[</bpt>\"The scenario for <ph id=\"ph1\">`BoxPanel`</ph>\"<ept id=\"p1\">](#scenario)</ept>.","pos":[8767,8875],"source":" For more info about how this logic was arrived at, skip ahead to [\"The scenario for `BoxPanel`\"](#scenario)."},{"content":"So what does the measure pass do?","pos":[8877,8910]},{"content":"It sets a value for the read-only <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DesiredSize<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> property on each element where <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Measure<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> was called.","pos":[8911,9135],"source":" It sets a value for the read-only [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) property on each element where [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) was called."},{"content":"Having a <bpt id=\"p1\">**</bpt>DesiredSize<ept id=\"p1\">**</ept> value is possibly important once you get to the arrange pass, because the <bpt id=\"p2\">**</bpt>DesiredSize<ept id=\"p2\">**</ept> communicates what the size can or should be when arranging and in the final rendering.","pos":[9136,9337],"source":" Having a **DesiredSize** value is possibly important once you get to the arrange pass, because the **DesiredSize** communicates what the size can or should be when arranging and in the final rendering."},{"content":"Even if you don't use <bpt id=\"p1\">**</bpt>DesiredSize<ept id=\"p1\">**</ept> in your own logic, the system still needs it.","pos":[9338,9421],"source":" Even if you don't use **DesiredSize** in your own logic, the system still needs it."},{"content":"It's possible for this panel to be used when the height component of <bpt id=\"p1\">*</bpt>availableSize<ept id=\"p1\">*</ept> is unbounded.","pos":[9423,9521],"source":"It's possible for this panel to be used when the height component of *availableSize* is unbounded."},{"content":"If that's true, the panel doesn't have a known height to divide.","pos":[9522,9586]},{"content":"In this case, the logic for the measure pass informs each child that it doesn't have a bounded height, yet.","pos":[9587,9694]},{"content":"It does so by passing a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Size<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> to the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Measure<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> call for children where <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Size.Height<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/hh763910)</ept> is infinite.","pos":[9695,9979],"source":" It does so by passing a [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) to the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) call for children where [**Size.Height**](https://msdn.microsoft.com/library/windows/apps/hh763910) is infinite."},{"content":"That's legal.","pos":[9980,9993]},{"content":"When <bpt id=\"p1\">**</bpt>Measure<ept id=\"p1\">**</ept> is called, the logic is that the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>DesiredSize<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> is set as the minimum of these: what was passed to <bpt id=\"p4\">**</bpt>Measure<ept id=\"p4\">**</ept>, or that element's natural size from factors such as explicitly-set <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Height<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208718)</ept> and <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>Width<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/br208751)</ept>.","pos":[9994,10396],"source":" When **Measure** is called, the logic is that the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) is set as the minimum of these: what was passed to **Measure**, or that element's natural size from factors such as explicitly-set [**Height**](https://msdn.microsoft.com/library/windows/apps/br208718) and [**Width**](https://msdn.microsoft.com/library/windows/apps/br208751)."},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>????The internal logic of <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>StackPanel<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br209635)</ept> also has this behavior: <bpt id=\"p4\">**</bpt>StackPanel<ept id=\"p4\">**</ept> passes an infinite dimension value to <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Measure<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> on children, indicating that there is no constraint on children in the orientation dimension.","pos":[10398,10749],"source":"**Note**????The internal logic of [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/br209635) also has this behavior: **StackPanel** passes an infinite dimension value to [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) on children, indicating that there is no constraint on children in the orientation dimension."},{"content":"<bpt id=\"p1\">**</bpt>StackPanel<ept id=\"p1\">**</ept> typically sizes itself dynamically, to accommodate all children in a stack that grows in that dimension.","pos":[10750,10869],"source":"**StackPanel** typically sizes itself dynamically, to accommodate all children in a stack that grows in that dimension."},{"content":"??","pos":[10871,10873]},{"content":"However, the panel itself can't return a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Size<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> with an infinite value from <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>MeasureOverride<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept>; that throws an exception during layout.","pos":[10875,11133],"source":"However, the panel itself can't return a [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) with an infinite value from [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730); that throws an exception during layout."},{"content":"So, part of the logic is to find out the maximum height that any child requests, and use that height as the cell height in case that isn't coming from the panel's own size constraints already.","pos":[11134,11326]},{"content":"Here's the helper function <ph id=\"ph1\">`LimitUnboundedSize`</ph> that was referenced in previous code, which then takes that maximum cell height and uses it to give the panel a finite height to return, as well as assuring that <ph id=\"ph2\">`cellheight`</ph> is a finite number before the arrange pass is initiated:","pos":[11327,11606],"source":" Here's the helper function `LimitUnboundedSize` that was referenced in previous code, which then takes that maximum cell height and uses it to give the panel a finite height to return, as well as assuring that `cellheight` is a finite number before the arrange pass is initiated:"},{"content":"ArrangeOverride","pos":[12148,12163]},{"content":"The necessary pattern of an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ArrangeOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> implementation is the loop through each element in <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Panel.Children<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept>.","pos":[12601,12839],"source":"The necessary pattern of an [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) implementation is the loop through each element in [**Panel.Children**](https://msdn.microsoft.com/library/windows/apps/br227514)."},{"content":"Always call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Arrange<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept> method on each of these elements.","pos":[12840,12961],"source":" Always call the [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) method on each of these elements."},{"content":"Note how there aren't as many calculations as in <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept>; that's typical.","pos":[12963,13108],"source":"Note how there aren't as many calculations as in [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730); that's typical."},{"content":"The size of children is already known from the panel's own <bpt id=\"p1\">**</bpt>MeasureOverride<ept id=\"p1\">**</ept> logic, or from the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>DesiredSize<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> value of each child set during the measure pass.","pos":[13109,13331],"source":" The size of children is already known from the panel's own **MeasureOverride** logic, or from the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) value of each child set during the measure pass."},{"content":"However, we still need to decide the location within the panel where each child will appear.","pos":[13332,13424]},{"content":"In a typical panel, each child should render at a different position.","pos":[13425,13494]},{"content":"A panel that creates overlapping elements isn't desirable for typical scenarios (although it's not out of the question to create panels that have purposeful overlaps, if that's really your intended scenario).","pos":[13495,13703]},{"content":"This panel arranges by the concept of rows and columns.","pos":[13705,13760]},{"content":"The number of rows and columns was already calculated (it was necessary for measurement).","pos":[13761,13850]},{"content":"So now the shape of the rows and columns plus the known sizes of each cell contribute to the logic of defining a rendering position (the <ph id=\"ph1\">`anchorPoint`</ph>) for each element that this panel contains.","pos":[13851,14045],"source":" So now the shape of the rows and columns plus the known sizes of each cell contribute to the logic of defining a rendering position (the `anchorPoint`) for each element that this panel contains."},{"content":"That <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Point<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br225870)</ept>, along with the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Size<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> already known from measure, are used as the two components that construct a <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Rect<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br225994)</ept>.","pos":[14046,14351],"source":" That [**Point**](https://msdn.microsoft.com/library/windows/apps/br225870), along with the [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) already known from measure, are used as the two components that construct a [**Rect**](https://msdn.microsoft.com/library/windows/apps/br225994)."},{"content":"<bpt id=\"p1\">**</bpt>Rect<ept id=\"p1\">**</ept> is the input type for <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Arrange<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept>.","pos":[14352,14455],"source":"**Rect** is the input type for [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914)."},{"content":"Panels sometimes need to clip their content.","pos":[14457,14501]},{"content":"If they do, the clipped size is the size that's present in <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DesiredSize<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept>, because the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Measure<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> logic sets it as the minimum of what was passed to <bpt id=\"p5\">**</bpt>Measure<ept id=\"p5\">**</ept>, or other natural size factors.","pos":[14502,14816],"source":" If they do, the clipped size is the size that's present in [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921), because the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) logic sets it as the minimum of what was passed to **Measure**, or other natural size factors."},{"content":"So you don't typically need to specifically check for clipping during <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Arrange<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept>; the clipping just happens based on passing the <bpt id=\"p3\">**</bpt>DesiredSize<ept id=\"p3\">**</ept> through to each <bpt id=\"p4\">**</bpt>Arrange<ept id=\"p4\">**</ept> call.","pos":[14817,15056],"source":" So you don't typically need to specifically check for clipping during [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914); the clipping just happens based on passing the **DesiredSize** through to each **Arrange** call."},{"content":"You don't always need a count while going through the loop if all the info you need for defining the rendering position is known by other means.","pos":[15058,15202]},{"content":"For example, in <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Canvas<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept> layout logic, the position in the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Children<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> collection doesn't matter.","pos":[15203,15423],"source":" For example, in [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267) layout logic, the position in the [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) collection doesn't matter."},{"content":"All the info needed to position each element in a <bpt id=\"p1\">**</bpt>Canvas<ept id=\"p1\">**</ept> is known by reading <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Canvas.Left<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh759771)</ept> and <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>Canvas.Top<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/hh759772)</ept> values of children as part of the arrange logic.","pos":[15424,15708],"source":" All the info needed to position each element in a **Canvas** is known by reading [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/hh759771) and [**Canvas.Top**](https://msdn.microsoft.com/library/windows/apps/hh759772) values of children as part of the arrange logic."},{"content":"The <ph id=\"ph1\">`BoxPanel`</ph> logic happens to need a count to compare to the <bpt id=\"p1\">*</bpt>colcount<ept id=\"p1\">*</ept> so it's known when to begin a new row and offset the <bpt id=\"p2\">*</bpt>y<ept id=\"p2\">*</ept> value.","pos":[15709,15846],"source":" The `BoxPanel` logic happens to need a count to compare to the *colcount* so it's known when to begin a new row and offset the *y* value."},{"content":"It's typical that the input <bpt id=\"p1\">*</bpt>finalSize<ept id=\"p1\">*</ept> and the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Size<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> you return from a <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>ArrangeOverride<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> implementation are the same.","pos":[15848,16091],"source":"It's typical that the input *finalSize* and the [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) you return from a [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) implementation are the same."},{"content":"For more info about why, see \"<bpt id=\"p1\">**</bpt>ArrangeOverride<ept id=\"p1\">**</ept>\" section of <bpt id=\"p2\">[</bpt>XAML custom panels overview<ept id=\"p2\">](custom-panels-overview.md)</ept>.","pos":[16092,16211],"source":" For more info about why, see \"**ArrangeOverride**\" section of [XAML custom panels overview](custom-panels-overview.md)."},{"content":"A refinement: controlling the row vs. column count","pos":[16216,16266]},{"content":"You could compile and use this panel just as it is now.","pos":[16269,16324]},{"content":"However, we'll add one more refinement.","pos":[16325,16364]},{"content":"In the code just shown, the logic puts the extra row or column on the side that's longest in aspect ratio.","pos":[16365,16471]},{"content":"But for greater control over the shapes of cells, it might be desirable to choose a 4??3 set of cells instead of 3??4 even if the panel's own aspect ratio is \"portrait.\"","pos":[16472,16641]},{"content":"So we'll add an optional dependency property that the panel consumer can set to control that behavior.","pos":[16642,16744]},{"content":"Here's the dependency property definition, which is very basic:","pos":[16745,16808]},{"content":"And here's how using <ph id=\"ph1\">`UseOppositeRCRatio`</ph> impacts the measure logic.","pos":[17140,17208],"source":"And here's how using `UseOppositeRCRatio` impacts the measure logic."},{"content":"Really all it's doing is changing how <ph id=\"ph1\">`rowcount`</ph> and <ph id=\"ph2\">`colcount`</ph> are derived from <ph id=\"ph3\">`maxrc`</ph> and the true aspect ratio, and there are corresponding size differences for each cell because of that.","pos":[17209,17400],"source":" Really all it's doing is changing how `rowcount` and `colcount` are derived from `maxrc` and the true aspect ratio, and there are corresponding size differences for each cell because of that."},{"content":"When <ph id=\"ph1\">`UseOppositeRCRatio`</ph> is <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept>, it inverts the value of the true aspect ratio before using it for row and column counts.","pos":[17401,17528],"source":" When `UseOppositeRCRatio` is **true**, it inverts the value of the true aspect ratio before using it for row and column counts."},{"pos":[17606,17622],"content":"The scenario for"},{"content":"The particular scenario for <ph id=\"ph1\">`BoxPanel`</ph> is that it's a panel where one of the main determinants of how to divide space is by knowing the number of child items, and dividing the known available space for the panel.","pos":[17636,17848],"source":"The particular scenario for `BoxPanel` is that it's a panel where one of the main determinants of how to divide space is by knowing the number of child items, and dividing the known available space for the panel."},{"content":"Panels are innately rectangle shapes.","pos":[17849,17886]},{"content":"Many panels operate by dividing that rectangle space into further rectangles; that's what <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Grid<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242704)</ept> does for its cells.","pos":[17887,18065],"source":" Many panels operate by dividing that rectangle space into further rectangles; that's what [**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) does for its cells."},{"content":"In <bpt id=\"p1\">**</bpt>Grid<ept id=\"p1\">**</ept>'s case, the size of the cells is set by <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ColumnDefinition<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br209324)</ept> and <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>RowDefinition<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br227606)</ept> values, and elements declare the exact cell they go into with <bpt id=\"p6\">[</bpt><bpt id=\"p7\">**</bpt>Grid.Row<ept id=\"p7\">**</ept><ept id=\"p6\">](https://msdn.microsoft.com/library/windows/apps/hh759795)</ept> and <bpt id=\"p8\">[</bpt><bpt id=\"p9\">**</bpt>Grid.Column<ept id=\"p9\">**</ept><ept id=\"p8\">](https://msdn.microsoft.com/library/windows/apps/hh759774)</ept> attached properties.","pos":[18066,18516],"source":" In **Grid**'s case, the size of the cells is set by [**ColumnDefinition**](https://msdn.microsoft.com/library/windows/apps/br209324) and [**RowDefinition**](https://msdn.microsoft.com/library/windows/apps/br227606) values, and elements declare the exact cell they go into with [**Grid.Row**](https://msdn.microsoft.com/library/windows/apps/hh759795) and [**Grid.Column**](https://msdn.microsoft.com/library/windows/apps/hh759774) attached properties."},{"content":"Getting good layout from a <bpt id=\"p1\">**</bpt>Grid<ept id=\"p1\">**</ept> usually requires knowing the number of child elements beforehand, so that there are enough cells and each child element sets its attached properties to fit into its own cell.","pos":[18517,18727],"source":" Getting good layout from a **Grid** usually requires knowing the number of child elements beforehand, so that there are enough cells and each child element sets its attached properties to fit into its own cell."},{"content":"But what if the number of children is dynamic?","pos":[18729,18775]},{"content":"That's certainly possible; your app code can add items to collections, in response to any dynamic run-time condition you consider to be important enough to be worth updating your UI.","pos":[18776,18958]},{"content":"If you're using data binding to backing collections/business objects, getting such updates and updating the UI is handled automatically, so that's often the preferred technique (see <bpt id=\"p1\">[</bpt>Data binding in depth<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt210946)</ept>).","pos":[18959,19224],"source":" If you're using data binding to backing collections/business objects, getting such updates and updating the UI is handled automatically, so that's often the preferred technique (see [Data binding in depth](https://msdn.microsoft.com/library/windows/apps/mt210946))."},{"content":"But not all app scenarios lend themselves to data binding.","pos":[19226,19284]},{"content":"Sometimes, you need to create new UI elements at runtime and make them visible.","pos":[19285,19364]},{"content":"is for this scenario.","pos":[19376,19397]},{"content":"A changing number of child items is no problem for <ph id=\"ph1\">`BoxPanel`</ph> because it's using the child count in calculations, and adjusts both the existing and new child elements into a new layout so they all fit.","pos":[19398,19599],"source":" A changing number of child items is no problem for `BoxPanel` because it's using the child count in calculations, and adjusts both the existing and new child elements into a new layout so they all fit."},{"content":"An advanced scenario for extending <ph id=\"ph1\">`BoxPanel`</ph> further (not shown here) could both accommodate dynamic children and use a child's <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DesiredSize<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> as a stronger factor for the sizing of individual cells.","pos":[19601,19862],"source":"An advanced scenario for extending `BoxPanel` further (not shown here) could both accommodate dynamic children and use a child's [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) as a stronger factor for the sizing of individual cells."},{"content":"This scenario might use varying row or column sizes or non-grid shapes so that there's less \"wasted\" space.","pos":[19863,19970]},{"content":"This requires a strategy for how multiple rectangles of various sizes and aspect ratios can all fit into a containing rectangle both for aesthetics and smallest size.","pos":[19971,20137]},{"content":"doesn't do that; it's using a simpler technique for dividing space.","pos":[20149,20216]},{"content":"'s technique is to determine the least square number that's greater than the child count.","pos":[20227,20316]},{"content":"For example, 9 items would fit in a 3??3 square.","pos":[20317,20365]},{"content":"10 items require a 4??4 square.","pos":[20366,20397]},{"content":"However, you can often fit items while still removing one row or column of the starting square, to save space.","pos":[20398,20508]},{"content":"In the count=10 example, that fits in a 4??3 or 3??4 rectangle.","pos":[20509,20572]},{"content":"You might wonder why the panel wouldn't instead choose 5??2 for 10 items, because that fits the item number neatly.","pos":[20574,20689]},{"content":"However, in practice, panels are sized as rectangles that seldom have a strongly oriented aspect ratio.","pos":[20690,20793]},{"content":"The least-squares technique is a way to bias the sizing logic to work well with typical layout shapes and not encourage sizing where the cell shapes get odd aspect ratios.","pos":[20794,20965]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>????","pos":[20967,20979],"source":"**Note**????"},{"content":"This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.","pos":[20980,21068],"source":"\nThis article is for Windows 10 developers writing Universal Windows Platform (UWP) apps."},{"content":"If you???re developing for Windows 8.x or Windows Phone 8.x, see the <bpt id=\"p1\">[</bpt>archived documentation<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>.","pos":[21069,21212],"source":" If you???re developing for Windows 8.x or Windows Phone 8.x, see the [archived documentation](http://go.microsoft.com/fwlink/p/?linkid=619132)."},{"content":"??","pos":[21214,21216]},{"content":"Related topics","pos":[21221,21235]},{"pos":[21238,21349],"content":"<bpt id=\"p1\">**</bpt>Reference<ept id=\"p1\">**</ept><ph id=\"ph1\">\n*</ph><bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>FrameworkElement.ArrangeOverride<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept>","source":"**Reference**\n*[**FrameworkElement.ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711)"},{"content":"FrameworkElement.MeasureOverride","pos":[21356,21388]},{"content":"Panel","pos":[21455,21460]},{"content":"Concepts","pos":[21525,21533]},{"content":"Alignment, margin, and padding","pos":[21539,21569]}],"content":"---\nDescription: Learn to write code for a custom Panel class, implementing ArrangeOverride and MeasureOverride methods, and using the Children property.\ntitle: BoxPanel, an example custom panel\nms.assetid: 981999DB-81B1-4B9C-A786-3025B62B74D6\nlabel: BoxPanel, an example custom panel\ntemplate: detail.hbs\n---\n\n# BoxPanel, an example custom panel\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\n**Important APIs**\n\n-   [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511)\n-   [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711)\n-   [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730)\n\nLearn to write code for a custom [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) class, implementing [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) and [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) methods, and using the [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) property. The example code shows a custom panel implementation, but we don't devote a lot of time explaining the layout concepts that influence how you can customize a panel for different layout scenarios. If you want more info about these layout concepts and how they might apply to your particular layout scenario, see [XAML custom panels overview](custom-panels-overview.md).\n\nA *panel* is an object that provides a layout behavior for child elements it contains, when the XAML layout system runs and your app UI is rendered. You can define custom panels for XAML layout by deriving a custom class from the [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) class. You provide behavior for your panel by overriding the [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) and [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) methods, supplying logic that measures and arranges the child elements. This example derives from **Panel**. When you start from **Panel**, **ArrangeOverride** and **MeasureOverride** methods don't have a starting behavior. Your code is providing the gateway by which child elements become known to the XAML layout system and get rendered in the UI. So, it's really important that your code accounts for all child elements and follows the patterns the layout system expects.\n\n## Your layout scenario\n\n\nWhen you define a custom panel, you're defining a layout scenario.\n\nA layout scenario is expressed through:\n\n-   What the panel will do when it has child elements\n-   When the panel has constraints on its own space\n-   How the logic of the panel determines all the measurements, placement, positions, and sizings that eventually result in a rendered UI layout of children\n\nWith that in mind, the `BoxPanel` shown here is for a particular scenario. In the interest of keeping the code foremost in this example, we won't explain the scenario in detail yet, and instead concentrate on the steps needed and the coding patterns. If you want to know more about the scenario first, skip ahead to [\"The scenario for `BoxPanel`\"](#scenario), and then come back to the code.\n## Start by deriving from **Panel**\n\n\nStart by deriving a custom class from [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511). Probably the easiest way to do this is to define a separate code file for this class, using the **Add** | **New Item** | **Class** context menu options for a project from the **Solution Explorer** in Microsoft Visual Studio. Name the class (and file) `BoxPanel`.\n\nThe template file for a class doesn't start with many **using** statements because it's not specifically for Universal Windows Platform (UWP) apps. So first, add **using** statements. The template file also starts with a few **using** statements that you probably don't need, and can be deleted. Here's a suggested list of **using** statements that can resolve types you'll need for typical custom panel code:\n\n```CSharp\nusing System;\nusing System.Collections.Generic; //if you need to cast IEnumerable for iteration, or define your own collection properties\nusing Windows.Foundation; //Point Size and Rect\nusing Windows.UI.Xaml; //DependencyObject UIElement and FrameworkElement\nusing Windows.UI.Xaml.Controls; //Panel\nusing Windows.UI.Xaml.Media; //if you need Brushes or other utilities\n```\n\nNow that you can resolve [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511), make it the base class of `BoxPanel`. Also, make `BoxPanel` public:\n\n```CSharp\npublic class BoxPanel : Panel\n{\n}\n```\n\nAt the class level, define some **int** and **double** values that will be shared by several of your logic functions, but which won't need to be exposed as public API. In the example, these are named: `maxrc`, `rowcount`, `colcount`, `cellwidth`, `cellheight`, `maxcellheight`, `aspectratio`.\n\nAfter you've done this, the complete code file looks like this (removing comments on **using**, now that you know why we have them):\n\n```CSharp\nusing System;\nusing System.Collections.Generic;\nusing Windows.Foundation;\nusing Windows.UI.Xaml;\nusing Windows.UI.Xaml.Controls;\nusing Windows.UI.Xaml.Media;\n\npublic class BoxPanel : Panel \n{\n    int maxrc, rowcount, colcount;\n    double cellwidth, cellheight, maxcellheight, aspectratio;\n}\n```\n\nFrom here on out, we'll be showing you one member definition at a time, be that a method override or something supporting such as a dependency property. You can add these to the skeleton above in any order, and we won't be showing the **using** statements or the definition of the class scope again in the snippets until we show the final code.\n\n## **MeasureOverride**\n\n\n```CSharp\nprotected override Size MeasureOverride(Size availableSize)\n{\n    Size returnSize;\n    // Determine the square that can contain this number of items.\n    maxrc = (int)Math.Ceiling(Math.Sqrt(Children.Count));\n    // Get an aspect ratio from availableSize, decides whether to trim row or column.\n    aspectratio = availableSize.Width / availableSize.Height;\n\n    // Now trim this square down to a rect, many times an entire row or column can be omitted.\n    if (aspectratio > 1)\n    {\n        rowcount = maxrc;\n        colcount = (maxrc > 2 &amp;&amp; Children.Count < maxrc * (maxrc - 1)) ? maxrc - 1 : maxrc;\n    } \n    else \n    {\n        rowcount = (maxrc > 2 &amp;&amp; Children.Count < maxrc * (maxrc - 1)) ? maxrc - 1 : maxrc;\n        colcount = maxrc;\n    }\n\n    // Now that we have a column count, divide available horizontal, that&#39;s our cell width.\n    cellwidth = (int)Math.Floor(availableSize.Width / colcount);\n    // Next get a cell height, same logic of dividing available vertical by rowcount.\n    cellheight = Double.IsInfinity(availableSize.Height) ? Double.PositiveInfinity : availableSize.Height / rowcount;\n           \n    foreach (UIElement child in Children)\n    {\n        child.Measure(new Size(cellwidth, cellheight));\n        maxcellheight = (child.DesiredSize.Height > maxcellheight) ? child.DesiredSize.Height : maxcellheight;\n    }\n    return LimitUnboundedSize(availableSize);\n}\n```\n\nThe necessary pattern of a [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) implementation is the loop through each element in [**Panel.Children**](https://msdn.microsoft.com/library/windows/apps/br227514). Always call the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) method on each of these elements. **Measure** has a parameter of type [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995). What you're passing here is the size that your panel is committing to have available for that particular child element. So, before you can do the loop and start calling **Measure**, you need to know how much space each cell can devote. From the **MeasureOverride** method itself, you have the *availableSize* value. That is the size that the panel's parent used when it called **Measure**, which was the trigger for this **MeasureOverride** being called in the first place. So a typical logic is to devise a scheme whereby each child element divides the space of the panel's overall *availableSize*. You then pass each division of size to **Measure** of each child element.\n\nHow `BoxPanel` divides size is fairly simple: it divides its space into a number of boxes that's largely controlled by the number of items. Boxes are sized based on row and column count and the available size. Sometimes one row or column from a square isn't needed, so it's dropped and the panel becomes a rectangle rather than square in terms of its row : column ratio. For more info about how this logic was arrived at, skip ahead to [\"The scenario for `BoxPanel`\"](#scenario).\n\nSo what does the measure pass do? It sets a value for the read-only [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) property on each element where [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) was called. Having a **DesiredSize** value is possibly important once you get to the arrange pass, because the **DesiredSize** communicates what the size can or should be when arranging and in the final rendering. Even if you don't use **DesiredSize** in your own logic, the system still needs it.\n\nIt's possible for this panel to be used when the height component of *availableSize* is unbounded. If that's true, the panel doesn't have a known height to divide. In this case, the logic for the measure pass informs each child that it doesn't have a bounded height, yet. It does so by passing a [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) to the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) call for children where [**Size.Height**](https://msdn.microsoft.com/library/windows/apps/hh763910) is infinite. That's legal. When **Measure** is called, the logic is that the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) is set as the minimum of these: what was passed to **Measure**, or that element's natural size from factors such as explicitly-set [**Height**](https://msdn.microsoft.com/library/windows/apps/br208718) and [**Width**](https://msdn.microsoft.com/library/windows/apps/br208751).\n\n**Note**????The internal logic of [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/br209635) also has this behavior: **StackPanel** passes an infinite dimension value to [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) on children, indicating that there is no constraint on children in the orientation dimension. **StackPanel** typically sizes itself dynamically, to accommodate all children in a stack that grows in that dimension.\n\n??\n\nHowever, the panel itself can't return a [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) with an infinite value from [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730); that throws an exception during layout. So, part of the logic is to find out the maximum height that any child requests, and use that height as the cell height in case that isn't coming from the panel's own size constraints already. Here's the helper function `LimitUnboundedSize` that was referenced in previous code, which then takes that maximum cell height and uses it to give the panel a finite height to return, as well as assuring that `cellheight` is a finite number before the arrange pass is initiated:\n\n```CSharp\n// This method is called only if one of the availableSize dimensions of measure is infinite.\n// That can happen to height if the panel is close to the root of main app window.\n// In this case, base the height of a cell on the max height from desired size\n// and base the height of the panel on that number times the #rows.\n\nSize LimitUnboundedSize(Size input)\n{\n    if (Double.IsInfinity(input.Height))\n    {\n        input.Height = maxcellheight * colcount;\n        cellheight = maxcellheight;\n    }\n    return input;\n}\n```\n\n## **ArrangeOverride**\n\n\n```CSharp\nprotected override Size ArrangeOverride(Size finalSize)\n{\n     int count = 1\n     double x, y;\n     foreach (UIElement child in Children)\n     {\n          x = (count - 1) % colcount * cellwidth;\n          y = ((int)(count - 1) / colcount) * cellheight;\n          Point anchorPoint = new Point(x, y);\n          child.Arrange(new Rect(anchorPoint, child.DesiredSize));\n          count++;\n     }\n     return finalSize;\n}\n```\n\nThe necessary pattern of an [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) implementation is the loop through each element in [**Panel.Children**](https://msdn.microsoft.com/library/windows/apps/br227514). Always call the [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) method on each of these elements.\n\nNote how there aren't as many calculations as in [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730); that's typical. The size of children is already known from the panel's own **MeasureOverride** logic, or from the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) value of each child set during the measure pass. However, we still need to decide the location within the panel where each child will appear. In a typical panel, each child should render at a different position. A panel that creates overlapping elements isn't desirable for typical scenarios (although it's not out of the question to create panels that have purposeful overlaps, if that's really your intended scenario).\n\nThis panel arranges by the concept of rows and columns. The number of rows and columns was already calculated (it was necessary for measurement). So now the shape of the rows and columns plus the known sizes of each cell contribute to the logic of defining a rendering position (the `anchorPoint`) for each element that this panel contains. That [**Point**](https://msdn.microsoft.com/library/windows/apps/br225870), along with the [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) already known from measure, are used as the two components that construct a [**Rect**](https://msdn.microsoft.com/library/windows/apps/br225994). **Rect** is the input type for [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914).\n\nPanels sometimes need to clip their content. If they do, the clipped size is the size that's present in [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921), because the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) logic sets it as the minimum of what was passed to **Measure**, or other natural size factors. So you don't typically need to specifically check for clipping during [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914); the clipping just happens based on passing the **DesiredSize** through to each **Arrange** call.\n\nYou don't always need a count while going through the loop if all the info you need for defining the rendering position is known by other means. For example, in [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267) layout logic, the position in the [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) collection doesn't matter. All the info needed to position each element in a **Canvas** is known by reading [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/hh759771) and [**Canvas.Top**](https://msdn.microsoft.com/library/windows/apps/hh759772) values of children as part of the arrange logic. The `BoxPanel` logic happens to need a count to compare to the *colcount* so it's known when to begin a new row and offset the *y* value.\n\nIt's typical that the input *finalSize* and the [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) you return from a [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) implementation are the same. For more info about why, see \"**ArrangeOverride**\" section of [XAML custom panels overview](custom-panels-overview.md).\n\n## A refinement: controlling the row vs. column count\n\n\nYou could compile and use this panel just as it is now. However, we'll add one more refinement. In the code just shown, the logic puts the extra row or column on the side that's longest in aspect ratio. But for greater control over the shapes of cells, it might be desirable to choose a 4??3 set of cells instead of 3??4 even if the panel's own aspect ratio is \"portrait.\" So we'll add an optional dependency property that the panel consumer can set to control that behavior. Here's the dependency property definition, which is very basic:\n\n```CSharp\npublic static readonly DependencyProperty UseOppositeRCRatioProperty =\n   DependencyProperty.Register(\"UseOppositeRCRatio\", typeof(bool), typeof(BoxPanel), null);\n\npublic bool UseSquareCells\n{\n    get { return (bool)GetValue(UseOppositeRCRatioProperty); }\n    set { SetValue(UseOppositeRCRatioProperty, value); }\n}\n```\n\nAnd here's how using `UseOppositeRCRatio` impacts the measure logic. Really all it's doing is changing how `rowcount` and `colcount` are derived from `maxrc` and the true aspect ratio, and there are corresponding size differences for each cell because of that. When `UseOppositeRCRatio` is **true**, it inverts the value of the true aspect ratio before using it for row and column counts.\n\n```CSharp\nif (UseOppositeRCRatio) { aspectratio = 1 / aspectratio;}\n```\n\n## The scenario for `BoxPanel`\n\n\nThe particular scenario for `BoxPanel` is that it's a panel where one of the main determinants of how to divide space is by knowing the number of child items, and dividing the known available space for the panel. Panels are innately rectangle shapes. Many panels operate by dividing that rectangle space into further rectangles; that's what [**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) does for its cells. In **Grid**'s case, the size of the cells is set by [**ColumnDefinition**](https://msdn.microsoft.com/library/windows/apps/br209324) and [**RowDefinition**](https://msdn.microsoft.com/library/windows/apps/br227606) values, and elements declare the exact cell they go into with [**Grid.Row**](https://msdn.microsoft.com/library/windows/apps/hh759795) and [**Grid.Column**](https://msdn.microsoft.com/library/windows/apps/hh759774) attached properties. Getting good layout from a **Grid** usually requires knowing the number of child elements beforehand, so that there are enough cells and each child element sets its attached properties to fit into its own cell.\n\nBut what if the number of children is dynamic? That's certainly possible; your app code can add items to collections, in response to any dynamic run-time condition you consider to be important enough to be worth updating your UI. If you're using data binding to backing collections/business objects, getting such updates and updating the UI is handled automatically, so that's often the preferred technique (see [Data binding in depth](https://msdn.microsoft.com/library/windows/apps/mt210946)).\n\nBut not all app scenarios lend themselves to data binding. Sometimes, you need to create new UI elements at runtime and make them visible. `BoxPanel` is for this scenario. A changing number of child items is no problem for `BoxPanel` because it's using the child count in calculations, and adjusts both the existing and new child elements into a new layout so they all fit.\n\nAn advanced scenario for extending `BoxPanel` further (not shown here) could both accommodate dynamic children and use a child's [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) as a stronger factor for the sizing of individual cells. This scenario might use varying row or column sizes or non-grid shapes so that there's less \"wasted\" space. This requires a strategy for how multiple rectangles of various sizes and aspect ratios can all fit into a containing rectangle both for aesthetics and smallest size. `BoxPanel` doesn't do that; it's using a simpler technique for dividing space. `BoxPanel`'s technique is to determine the least square number that's greater than the child count. For example, 9 items would fit in a 3??3 square. 10 items require a 4??4 square. However, you can often fit items while still removing one row or column of the starting square, to save space. In the count=10 example, that fits in a 4??3 or 3??4 rectangle.\n\nYou might wonder why the panel wouldn't instead choose 5??2 for 10 items, because that fits the item number neatly. However, in practice, panels are sized as rectangles that seldom have a strongly oriented aspect ratio. The least-squares technique is a way to bias the sizing logic to work well with typical layout shapes and not encourage sizing where the cell shapes get odd aspect ratios.\n\n**Note**????\nThis article is for Windows 10 developers writing Universal Windows Platform (UWP) apps. If you???re developing for Windows 8.x or Windows Phone 8.x, see the [archived documentation](http://go.microsoft.com/fwlink/p/?linkid=619132).\n\n??\n\n## Related topics\n\n\n**Reference**\n*[**FrameworkElement.ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711)\n\n* [**FrameworkElement.MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730)\n* [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511)\n\n**Concepts**\n* [Alignment, margin, and padding](alignment-margin-padding.md)\n\n"}