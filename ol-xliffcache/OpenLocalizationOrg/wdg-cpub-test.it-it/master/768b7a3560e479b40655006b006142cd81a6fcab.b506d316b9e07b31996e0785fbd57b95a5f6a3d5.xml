{"nodes":[{"content":"ListView and GridView UI optimization","pos":[2,39]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[41,79]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[80,175],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Note","pos":[179,183]},{"content":"For more details, see the //build/ session <bpt id=\"p1\">[</bpt>Dramatically Increase Performance when Users Interact with Large Amounts of Data in GridView and ListView<ept id=\"p1\">](https://channel9.msdn.com/events/build/2013/3-158)</ept>.","pos":[188,390],"source":"For more details, see the //build/ session [Dramatically Increase Performance when Users Interact with Large Amounts of Data in GridView and ListView](https://channel9.msdn.com/events/build/2013/3-158)."},{"content":"Improve <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ListView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>GridView<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242705)</ept> performance and startup time through UI virtualization, element reduction, and progressive updating of items.","pos":[392,659],"source":"Improve [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878) and [**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242705) performance and startup time through UI virtualization, element reduction, and progressive updating of items."},{"content":"For data virtualization techniques, see <bpt id=\"p1\">[</bpt>ListView and GridView data virtualization<ept id=\"p1\">](listview-and-gridview-data-optimization.md)</ept>.","pos":[660,788],"source":" For data virtualization techniques, see [ListView and GridView data virtualization](listview-and-gridview-data-optimization.md)."},{"content":"Two key factors in collection performance","pos":[793,834]},{"content":"Manipulating collections is a common scenario.","pos":[836,882]},{"content":"A photo viewer has collections of photos, a reader has collections of articles/books/stories, and a shopping app has collections of products.","pos":[883,1024]},{"content":"This topic shows what you can do to make your app efficient at manipulating collections.","pos":[1025,1113]},{"content":"There are two key factors in performance when it comes to collections: one is the time spent by the UI thread creating items; the other is the memory used by both the raw data set and the UI elements used to render that data.","pos":[1115,1340]},{"content":"For smooth panning/scrolling, it's vital that the UI thread do an efficient and smart job of instantiating, data-binding, and laying out items.","pos":[1342,1485]},{"content":"UI virtualization","pos":[1490,1507]},{"content":"UI virtualization is the most important improvement you can make.","pos":[1509,1574]},{"content":"This means that UI elements representing the items are created on demand.","pos":[1575,1648]},{"content":"For an items control bound to a 1000-item collection, it would be a waste of resources to create the UI for all the items at the same time, because they can't all be displayed at the same time.","pos":[1649,1842]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ListView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>GridView<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242705)</ept> (and other standard <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ItemsControl<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR242803)</ept>-derived controls) perform UI virtualization for you.","pos":[1843,2142],"source":"[**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878) and [**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242705) (and other standard [**ItemsControl**](https://msdn.microsoft.com/library/windows/apps/BR242803)-derived controls) perform UI virtualization for you."},{"content":"When items are close to being scrolled into view (a few pages away), the framework generates the UI for the items and caches them.","pos":[2143,2273]},{"content":"When it's unlikely that the items will be shown again, the framework re-claims the memory.","pos":[2274,2364]},{"content":"If you provide a custom items panel template (see <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ItemsPanel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242803-itemspanel)</ept>) then make sure you use a virtualizing panel such as <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ItemsWrapGrid<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/Dn298849)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ItemsStackPanel<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/Dn298795)</ept>.","pos":[2366,2717],"source":"If you provide a custom items panel template (see [**ItemsPanel**](https://msdn.microsoft.com/library/windows/apps/BR242803-itemspanel)) then make sure you use a virtualizing panel such as [**ItemsWrapGrid**](https://msdn.microsoft.com/library/windows/apps/Dn298849) and [**ItemsStackPanel**](https://msdn.microsoft.com/library/windows/apps/Dn298795)."},{"content":"If you use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>VariableSizedWrapGrid<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR227651)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>WrapGrid<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR227717)</ept>, or <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>StackPanel<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR209635)</ept>, then you will not get virtualization.","pos":[2718,3006],"source":" If you use [**VariableSizedWrapGrid**](https://msdn.microsoft.com/library/windows/apps/BR227651), [**WrapGrid**](https://msdn.microsoft.com/library/windows/apps/BR227717), or [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/BR209635), then you will not get virtualization."},{"content":"The concept of a viewport is critical to UI virtualization because the framework must create the elements that are likely to be shown.","pos":[3008,3142]},{"content":"In general, the viewport of an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ItemsControl<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242803)</ept> is the extent of the logical control.","pos":[3143,3288],"source":" In general, the viewport of an [**ItemsControl**](https://msdn.microsoft.com/library/windows/apps/BR242803) is the extent of the logical control."},{"content":"For example, the viewport of a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ListView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878)</ept> is the width and height of the <bpt id=\"p3\">**</bpt>ListView<ept id=\"p3\">**</ept> element.","pos":[3289,3445],"source":" For example, the viewport of a [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878) is the width and height of the **ListView** element."},{"content":"Some panels allow child elements unlimited space, examples being <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ScrollViewer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209527)</ept> and a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Grid<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept>, with auto-sized rows or columns.","pos":[3446,3696],"source":" Some panels allow child elements unlimited space, examples being [**ScrollViewer**](https://msdn.microsoft.com/library/windows/apps/BR209527) and a [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704), with auto-sized rows or columns."},{"content":"When a virtualized <bpt id=\"p1\">**</bpt>ItemsControl<ept id=\"p1\">**</ept> is placed in a panel like that, it takes enough room to display all of its items, which defeats virtualization.","pos":[3697,3844],"source":" When a virtualized **ItemsControl** is placed in a panel like that, it takes enough room to display all of its items, which defeats virtualization."},{"content":"Restore virtualization by setting a width and height on the <bpt id=\"p1\">**</bpt>ItemsControl<ept id=\"p1\">**</ept>.","pos":[3845,3922],"source":" Restore virtualization by setting a width and height on the **ItemsControl**."},{"content":"Element reduction per item","pos":[3927,3953]},{"content":"Keep the number of UI elements used to render your items to a reasonable minimum.","pos":[3955,4036]},{"content":"When an items control is first shown, all the elements needed to render a viewport full of items are created.","pos":[4038,4147]},{"content":"Also, as items approach the viewport, the framework updates the UI elements in cached item templates with the bound data objects.","pos":[4148,4277]},{"content":"Minimizing the complexity of the markup inside templates pays off in memory and in time spent on the UI thread, improving responsiveness especially while panning/scrolling.","pos":[4278,4450]},{"content":"The templates in question are the item template (see <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ItemTemplate<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242803-itemtemplate)</ept>) and the control template of a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ListViewItem<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242878item)</ept> or a <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>GridViewItem<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR242705item)</ept> (the item control template, or <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>ItemContainerStyle<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/BR242803-itemcontainerstyle)</ept>).","pos":[4451,4926],"source":" The templates in question are the item template (see [**ItemTemplate**](https://msdn.microsoft.com/library/windows/apps/BR242803-itemtemplate)) and the control template of a [**ListViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242878item) or a [**GridViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242705item) (the item control template, or [**ItemContainerStyle**](https://msdn.microsoft.com/library/windows/apps/BR242803-itemcontainerstyle))."},{"content":"The benefit of even a small reduction in element count is multiplied by the number of items displayed.","pos":[4927,5029]},{"pos":[5031,5124],"content":"For examples of element reduction, see <bpt id=\"p1\">[</bpt>Optimize your XAML markup<ept id=\"p1\">](optimize-xaml-loading.md)</ept>.","source":"For examples of element reduction, see [Optimize your XAML markup](optimize-xaml-loading.md)."},{"content":"The default control templates for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ListViewItem<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878item)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>GridViewItem<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242705item)</ept> contain a <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ListViewItemPresenter<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/Dn298500)</ept> and a <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>GridViewItemPresenter<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/Dn279298)</ept> element, respectively.","pos":[5126,5536],"source":"The default control templates for [**ListViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242878item) and [**GridViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242705item) contain a [**ListViewItemPresenter**](https://msdn.microsoft.com/library/windows/apps/Dn298500) and a [**GridViewItemPresenter**](https://msdn.microsoft.com/library/windows/apps/Dn279298) element, respectively."},{"content":"Each of these presenters is a single optimized element that displays complex visuals for focus, selection, and other visual states.","pos":[5537,5668]},{"content":"If you already have custom item control templates (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ItemContainerStyle<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242803-itemcontainerstyle)</ept>), or if in future you edit a copy of an item control template, then we recommend you use a <bpt id=\"p3\">**</bpt>ListViewItemPresenter<ept id=\"p3\">**</ept> or a <bpt id=\"p4\">**</bpt>GridViewItemPresenter<ept id=\"p4\">**</ept> because those elements will give you optimum balance between performance and customizability in the majority of cases.","pos":[5669,6088],"source":" If you already have custom item control templates ([**ItemContainerStyle**](https://msdn.microsoft.com/library/windows/apps/BR242803-itemcontainerstyle)), or if in future you edit a copy of an item control template, then we recommend you use a **ListViewItemPresenter** or a **GridViewItemPresenter** because those elements will give you optimum balance between performance and customizability in the majority of cases."},{"content":"You customize these presenters by setting properties on them.","pos":[6089,6150]},{"content":"For example, here's markup that removes the check mark that appears by default when an item is selected, and changes the background color of the selected item to orange.","pos":[6151,6320]},{"content":"There are about 25 properties with self-describing names similar to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SelectionCheckMarkVisualEnabled<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn298500-selectioncheckmarkvisualenabled)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>SelectedBackground<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/Dn298500-selectedbackground)</ept>.","pos":[6720,7022],"source":"There are about 25 properties with self-describing names similar to [**SelectionCheckMarkVisualEnabled**](https://msdn.microsoft.com/library/windows/apps/Dn298500-selectioncheckmarkvisualenabled) and [**SelectedBackground**](https://msdn.microsoft.com/library/windows/apps/Dn298500-selectedbackground)."},{"content":"Should the presenter types prove not to be customizable enough for your use case, you can edit a copy of the <ph id=\"ph1\">`ListViewItemExpanded`</ph> or <ph id=\"ph2\">`GridViewItemExpanded`</ph> control template instead.","pos":[7023,7206],"source":" Should the presenter types prove not to be customizable enough for your use case, you can edit a copy of the `ListViewItemExpanded` or `GridViewItemExpanded` control template instead."},{"content":"These can be found in <ph id=\"ph1\">`\\Program Files (x86)\\Windows Kits\\10\\DesignTime\\CommonConfiguration\\Neutral\\UAP\\&lt;version&gt;\\Generic\\generic.xaml`</ph>.","pos":[7207,7342],"source":" These can be found in `\\Program Files (x86)\\Windows Kits\\10\\DesignTime\\CommonConfiguration\\Neutral\\UAP\\<version>\\Generic\\generic.xaml`."},{"content":"Be aware that using these templates means trading some performance for the increase in customization.","pos":[7343,7444]},{"content":"Update ListView and GridView items progressively","pos":[7449,7497]},{"content":"If you're using data virtualization then you can keep <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ListView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>GridView<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242705)</ept> responsiveness high by configuring the control to render temporary UI elements for the items still being (down)loaded.","pos":[7499,7821],"source":"If you're using data virtualization then you can keep [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878) and [**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242705) responsiveness high by configuring the control to render temporary UI elements for the items still being (down)loaded."},{"content":"The temporary elements are then progressively replaced with actual UI as data loads.","pos":[7822,7906]},{"content":"Also—no matter where you're loading data from (local disk, network, or cloud)—a user can pan/scroll a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ListView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>GridView<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242705)</ept> so rapidly that it's not possible to render each item with full fidelity while preserving smooth panning/scrolling.","pos":[7908,8274],"source":"Also—no matter where you're loading data from (local disk, network, or cloud)—a user can pan/scroll a [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878) or [**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242705) so rapidly that it's not possible to render each item with full fidelity while preserving smooth panning/scrolling."},{"content":"To preserve smooth panning/scrolling you can choose to render an item in multiple phases in addition to using placeholders.","pos":[8275,8398]},{"content":"An example of these techniques is often seen in photo-viewing apps: even though not all of the images have been loaded and displayed, the user can still pan/scroll and interact with the collection.","pos":[8400,8597]},{"content":"Or, for a \"movie\" item, you could show the title in the first phase, the rating in the second phase, and an image of the poster in the third phase.","pos":[8598,8745]},{"content":"The user sees the most important data about each item as early as possible, and that means they're able to take action at once.","pos":[8746,8873]},{"content":"Then the less important info is filled-in as time allows.","pos":[8874,8931]},{"content":"Here are the platform features you can use to implement these techniques.","pos":[8932,9005]},{"content":"Placeholders","pos":[9011,9023]},{"content":"The temporary placeholder visuals feature is on by default, and it's controlled with the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ShowsScrollingPlaceholders<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878base-showsscrollingplaceholders)</ept> property.","pos":[9025,9245],"source":"The temporary placeholder visuals feature is on by default, and it's controlled with the [**ShowsScrollingPlaceholders**](https://msdn.microsoft.com/library/windows/apps/BR242878base-showsscrollingplaceholders) property."},{"content":"During fast panning/scrolling, this feature gives the user a visual hint that there are more items yet to fully display while also preserving smoothness.","pos":[9246,9399]},{"content":"If you use one of the techniques below then you can set <bpt id=\"p1\">**</bpt>ShowsScrollingPlaceholders<ept id=\"p1\">**</ept> to false if you prefer not to have the system render placeholders.","pos":[9400,9553],"source":" If you use one of the techniques below then you can set **ShowsScrollingPlaceholders** to false if you prefer not to have the system render placeholders."},{"content":"Progressive data template updates using x:Phase","pos":[9557,9604]},{"pos":[9608,9838],"content":"Here's how to use the <bpt id=\"p1\">[</bpt>x:Phase attribute<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Mt204790)</ept> with <bpt id=\"p2\">[</bpt>{x:Bind}<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</ept> bindings to implement progressive data template updates.","source":"Here's how to use the [x:Phase attribute](https://msdn.microsoft.com/library/windows/apps/Mt204790) with [{x:Bind}](https://msdn.microsoft.com/library/windows/apps/Mt204783) bindings to implement progressive data template updates."},{"content":"Here's what the binding source looks like (this is the data source that we'll bind to).","pos":[9844,9931]},{"content":"Here's the markup that <ph id=\"ph1\">`DeferMainPage.xaml`</ph> contains.","pos":[10883,10936],"source":"Here's the markup that `DeferMainPage.xaml` contains."},{"content":"The grid view contains an item template with elements bound to the <bpt id=\"p1\">**</bpt>Title<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Subtitle<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>Description<ept id=\"p3\">**</ept> properties of the <bpt id=\"p4\">**</bpt>MyItem<ept id=\"p4\">**</ept> class.","pos":[10937,11084],"source":" The grid view contains an item template with elements bound to the **Title**, **Subtitle**, and **Description** properties of the **MyItem** class."},{"content":"Note that <bpt id=\"p1\">**</bpt>x:Phase<ept id=\"p1\">**</ept> defaults to 0.","pos":[11085,11121],"source":" Note that **x:Phase** defaults to 0."},{"content":"Here, items will be initially rendered with just the title visible.","pos":[11122,11189]},{"content":"Then the subtitle element will be data bound and made visible for all the items and so on until all the phases have been processed.","pos":[11190,11321]},{"pos":[12486,12908],"content":"If you run the app now and pan/scroll quickly through the grid view then you'll notice that as each new item appears on the screen, at first it is rendered as a dark gray rectangle (thanks to the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ShowsScrollingPlaceholders<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878base-showsscrollingplaceholders)</ept> property defaulting to <bpt id=\"p3\">**</bpt>true<ept id=\"p3\">**</ept>), then the title appears, followed by subtitle, followed by description.","source":"If you run the app now and pan/scroll quickly through the grid view then you'll notice that as each new item appears on the screen, at first it is rendered as a dark gray rectangle (thanks to the [**ShowsScrollingPlaceholders**](https://msdn.microsoft.com/library/windows/apps/BR242878base-showsscrollingplaceholders) property defaulting to **true**), then the title appears, followed by subtitle, followed by description."},{"content":"Progressive data template updates using ContainerContentChanging","pos":[12912,12976]},{"content":"The general strategy for the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ContainerContentChanging<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging)</ept> event is to use <bpt id=\"p3\">**</bpt>Opacity<ept id=\"p3\">**</ept> to hide elements that don’t need to be immediately visible.","pos":[12980,13214],"source":"The general strategy for the [**ContainerContentChanging**](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging) event is to use **Opacity** to hide elements that don’t need to be immediately visible."},{"content":"When elements are recycled, they will retain their old values so we want to hide those elements until we've updated those values from the new data item.","pos":[13215,13367]},{"content":"We use the <bpt id=\"p1\">**</bpt>Phase<ept id=\"p1\">**</ept> property on the event arguments to determine which elements to update and show.","pos":[13368,13468],"source":" We use the **Phase** property on the event arguments to determine which elements to update and show."},{"content":"If additional phases are needed, we register a callback.","pos":[13469,13525]},{"pos":[13531,13584],"content":"We'll use the same binding source as for <bpt id=\"p1\">**</bpt>x:Phase<ept id=\"p1\">**</ept>.","source":"We'll use the same binding source as for **x:Phase**."},{"content":"Here's the markup that <ph id=\"ph1\">`MainPage.xaml`</ph> contains.","pos":[13590,13638],"source":"Here's the markup that `MainPage.xaml` contains."},{"content":"The grid view declares a handler to its <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ContainerContentChanging<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging)</ept> event, and it contains an item template with elements used to display the <bpt id=\"p3\">**</bpt>Title<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>Subtitle<ept id=\"p4\">**</ept>, and <bpt id=\"p5\">**</bpt>Description<ept id=\"p5\">**</ept> properties of the <bpt id=\"p6\">**</bpt>MyItem<ept id=\"p6\">**</ept> class.","pos":[13639,13951],"source":" The grid view declares a handler to its [**ContainerContentChanging**](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging) event, and it contains an item template with elements used to display the **Title**, **Subtitle**, and **Description** properties of the **MyItem** class."},{"content":"To get the maximum performance benefits of using <bpt id=\"p1\">**</bpt>ContainerContentChanging<ept id=\"p1\">**</ept>, we don't use bindings in the markup but we instead assign values programmatically.","pos":[13952,14113],"source":" To get the maximum performance benefits of using **ContainerContentChanging**, we don't use bindings in the markup but we instead assign values programmatically."},{"content":"The exception here is the element displaying the title, which we consider to be in phase 0.","pos":[14114,14205]},{"content":"Lastly, here's the implementation of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ContainerContentChanging<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging)</ept> event handler.","pos":[15373,15546],"source":"Lastly, here's the implementation of the [**ContainerContentChanging**](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging) event handler."},{"content":"This code also shows how we add a property of type <bpt id=\"p1\">**</bpt>RecordingViewModel<ept id=\"p1\">**</ept> to <bpt id=\"p2\">**</bpt>MainPage<ept id=\"p2\">**</ept> to expose the binding source class from the class that represents our page of markup.","pos":[15547,15722],"source":" This code also shows how we add a property of type **RecordingViewModel** to **MainPage** to expose the binding source class from the class that represents our page of markup."},{"content":"As long as you don't have any <bpt id=\"p1\">[</bpt>{Binding}<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</ept> bindings in your data template, then mark the event arguments object as handled in the first phase of the handler to hint to the item that it needn't set a data context.","pos":[15723,15992],"source":" As long as you don't have any [{Binding}](https://msdn.microsoft.com/library/windows/apps/Mt204782) bindings in your data template, then mark the event arguments object as handled in the first phase of the handler to hint to the item that it needn't set a data context."},{"pos":[18391,18519],"content":"If you run the app now and pan/scroll quickly through the grid view then you'll see the same behavior as for as for <bpt id=\"p1\">**</bpt>x:Phase<ept id=\"p1\">**</ept>.","source":"If you run the app now and pan/scroll quickly through the grid view then you'll see the same behavior as for as for **x:Phase**."},{"content":"Container-recycling with heterogeneous collections","pos":[18524,18574]},{"content":"In some applications, you need to have different UI for different types of item within a collection.","pos":[18576,18676]},{"content":"This can create a situation where it is impossible for virtualizing panels to reuse/recycle the visual elements used to display the items.","pos":[18677,18815]},{"content":"Recreating the visual elements for an item during panning undoes many of the performance wins provided by virtualization.","pos":[18816,18937]},{"content":"However, a little planning can allow virtualizing panels to reuse the elements.","pos":[18938,19017]},{"content":"Developers have a couple of options depending on their scenario: the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ChoosingItemContainer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer)</ept> event, or an item template selector.","pos":[19018,19235],"source":" Developers have a couple of options depending on their scenario: the [**ChoosingItemContainer**](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer) event, or an item template selector."},{"content":"The <bpt id=\"p1\">**</bpt>ChoosingItemContainer<ept id=\"p1\">**</ept> event is the most performant approach.","pos":[19236,19304],"source":" The **ChoosingItemContainer** event is the most performant approach."},{"content":"The ChoosingItemContainer event","pos":[19308,19339]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ChoosingItemContainer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer)</ept> is an event that allows you to provide an item (<bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ListViewItem<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242878item)</ept><ph id=\"ph1\">/</ph><bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>GridViewItem<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR242705item)</ept>) to the <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>ListView<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/BR242878)</ept><ph id=\"ph2\">/</ph><bpt id=\"p9\">[</bpt><bpt id=\"p10\">**</bpt>GridView<ept id=\"p10\">**</ept><ept id=\"p9\">](https://msdn.microsoft.com/library/windows/apps/BR242705)</ept> whenever a new item is needed during start-up or recycling.","pos":[19343,19878],"source":"[**ChoosingItemContainer**](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer) is an event that allows you to provide an item ([**ListViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242878item)/[**GridViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242705item)) to the [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878)/[**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242705) whenever a new item is needed during start-up or recycling."},{"content":"You can create a container based on the type of data item the container will display (shown in the example below).","pos":[19879,19993]},{"content":"<bpt id=\"p1\">**</bpt>ChoosingItemContainer<ept id=\"p1\">**</ept> is the most performant way to use different data templates for different items.","pos":[19994,20099],"source":"**ChoosingItemContainer** is the most performant way to use different data templates for different items."},{"content":"Container caching is something that can be achieved using <bpt id=\"p1\">**</bpt>ChoosingItemContainer<ept id=\"p1\">**</ept>.","pos":[20100,20184],"source":" Container caching is something that can be achieved using **ChoosingItemContainer**."},{"content":"For example, if you have five different template, with one template occurring an order of magnitude more often than the others, then ChoosingItemContainer allows you not only to create items at the ratios needed but also to keep an appropriate number of elements cached and available for recycling.","pos":[20185,20483]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ChoosingGroupHeaderContainer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosinggroupheadercontainer)</ept> provides the same functionality for group headers.","pos":[20484,20660],"source":"[**ChoosingGroupHeaderContainer**](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosinggroupheadercontainer) provides the same functionality for group headers."},{"content":"Item template selector","pos":[23040,23062]},{"content":"An item template selector (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DataTemplateSelector<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209469)</ept>) allows an app to return a different item template at runtime based on the type of the data item that will be displayed.","pos":[23066,23298],"source":"An item template selector ([**DataTemplateSelector**](https://msdn.microsoft.com/library/windows/apps/BR209469)) allows an app to return a different item template at runtime based on the type of the data item that will be displayed."},{"content":"This makes development more productive, but it makes UI virtualization more difficult because not every item template can be reused for every data item.","pos":[23299,23451]},{"content":"When recycling an item (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ListViewItem<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878item)</ept><ph id=\"ph1\">/</ph><bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>GridViewItem<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242705item)</ept>), the framework must decide whether the items that are available for use in the recycle queue (the recycle queue is a cache of items that are not currently being used to display data) have an item template that will match the one desired by the current data item.","pos":[23453,23902],"source":"When recycling an item ([**ListViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242878item)/[**GridViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242705item)), the framework must decide whether the items that are available for use in the recycle queue (the recycle queue is a cache of items that are not currently being used to display data) have an item template that will match the one desired by the current data item."},{"content":"If there are no items in the recycle queue with the appropriate item template then a new item is created, and the appropriate item template is instantiated for it.","pos":[23903,24066]},{"content":"If, on other hand, the recycle queue contains an item with the appropriate item template then that item is removed from the recycle queue and is used for the current data item.","pos":[24067,24243]},{"content":"An item template selector works in situations where only a small number of item templates are used and there is a flat distribution throughout the collection of items that use different item templates.","pos":[24244,24445]},{"content":"When there is an uneven distribution of items that use different item templates then new item templates will likely need to be created during panning, and this negates many of the gains provided by virtualization.","pos":[24447,24660]},{"content":"Additionally, an item template selector only considers five possible candidates when evaluating whether a particular container can be reused for the current data item.","pos":[24661,24828]},{"content":"So you should carefully consider whether your data is appropriate for use with an item template selector before using one in your app.","pos":[24829,24963]},{"content":"If your collection is mostly homogeneous then the selector is returning the same type most (possibly all) of the time.","pos":[24964,25082]},{"content":"Just be aware of the price you're paying for the rare exceptions to that homegeneity, and consider whether using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ChoosingItemContainer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer)</ept> (or two items controls) is preferable.","pos":[25083,25346],"source":" Just be aware of the price you're paying for the rare exceptions to that homegeneity, and consider whether using [**ChoosingItemContainer**](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer) (or two items controls) is preferable."}],"content":"# ListView and GridView UI optimization\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n**Note**  \nFor more details, see the //build/ session [Dramatically Increase Performance when Users Interact with Large Amounts of Data in GridView and ListView](https://channel9.msdn.com/events/build/2013/3-158).\n\nImprove [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878) and [**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242705) performance and startup time through UI virtualization, element reduction, and progressive updating of items. For data virtualization techniques, see [ListView and GridView data virtualization](listview-and-gridview-data-optimization.md).\n\n## Two key factors in collection performance\n\nManipulating collections is a common scenario. A photo viewer has collections of photos, a reader has collections of articles/books/stories, and a shopping app has collections of products. This topic shows what you can do to make your app efficient at manipulating collections.\n\nThere are two key factors in performance when it comes to collections: one is the time spent by the UI thread creating items; the other is the memory used by both the raw data set and the UI elements used to render that data.\n\nFor smooth panning/scrolling, it's vital that the UI thread do an efficient and smart job of instantiating, data-binding, and laying out items.\n\n## UI virtualization\n\nUI virtualization is the most important improvement you can make. This means that UI elements representing the items are created on demand. For an items control bound to a 1000-item collection, it would be a waste of resources to create the UI for all the items at the same time, because they can't all be displayed at the same time. [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878) and [**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242705) (and other standard [**ItemsControl**](https://msdn.microsoft.com/library/windows/apps/BR242803)-derived controls) perform UI virtualization for you. When items are close to being scrolled into view (a few pages away), the framework generates the UI for the items and caches them. When it's unlikely that the items will be shown again, the framework re-claims the memory.\n\nIf you provide a custom items panel template (see [**ItemsPanel**](https://msdn.microsoft.com/library/windows/apps/BR242803-itemspanel)) then make sure you use a virtualizing panel such as [**ItemsWrapGrid**](https://msdn.microsoft.com/library/windows/apps/Dn298849) and [**ItemsStackPanel**](https://msdn.microsoft.com/library/windows/apps/Dn298795). If you use [**VariableSizedWrapGrid**](https://msdn.microsoft.com/library/windows/apps/BR227651), [**WrapGrid**](https://msdn.microsoft.com/library/windows/apps/BR227717), or [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/BR209635), then you will not get virtualization.\n\nThe concept of a viewport is critical to UI virtualization because the framework must create the elements that are likely to be shown. In general, the viewport of an [**ItemsControl**](https://msdn.microsoft.com/library/windows/apps/BR242803) is the extent of the logical control. For example, the viewport of a [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878) is the width and height of the **ListView** element. Some panels allow child elements unlimited space, examples being [**ScrollViewer**](https://msdn.microsoft.com/library/windows/apps/BR209527) and a [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704), with auto-sized rows or columns. When a virtualized **ItemsControl** is placed in a panel like that, it takes enough room to display all of its items, which defeats virtualization. Restore virtualization by setting a width and height on the **ItemsControl**.\n\n## Element reduction per item\n\nKeep the number of UI elements used to render your items to a reasonable minimum.\n\nWhen an items control is first shown, all the elements needed to render a viewport full of items are created. Also, as items approach the viewport, the framework updates the UI elements in cached item templates with the bound data objects. Minimizing the complexity of the markup inside templates pays off in memory and in time spent on the UI thread, improving responsiveness especially while panning/scrolling. The templates in question are the item template (see [**ItemTemplate**](https://msdn.microsoft.com/library/windows/apps/BR242803-itemtemplate)) and the control template of a [**ListViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242878item) or a [**GridViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242705item) (the item control template, or [**ItemContainerStyle**](https://msdn.microsoft.com/library/windows/apps/BR242803-itemcontainerstyle)). The benefit of even a small reduction in element count is multiplied by the number of items displayed.\n\nFor examples of element reduction, see [Optimize your XAML markup](optimize-xaml-loading.md).\n\nThe default control templates for [**ListViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242878item) and [**GridViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242705item) contain a [**ListViewItemPresenter**](https://msdn.microsoft.com/library/windows/apps/Dn298500) and a [**GridViewItemPresenter**](https://msdn.microsoft.com/library/windows/apps/Dn279298) element, respectively. Each of these presenters is a single optimized element that displays complex visuals for focus, selection, and other visual states. If you already have custom item control templates ([**ItemContainerStyle**](https://msdn.microsoft.com/library/windows/apps/BR242803-itemcontainerstyle)), or if in future you edit a copy of an item control template, then we recommend you use a **ListViewItemPresenter** or a **GridViewItemPresenter** because those elements will give you optimum balance between performance and customizability in the majority of cases. You customize these presenters by setting properties on them. For example, here's markup that removes the check mark that appears by default when an item is selected, and changes the background color of the selected item to orange.\n\n```xml\n...\n<ListView>\n ...\n <ListView.ItemContainerStyle>\n <Style TargetType=\"ListViewItem\">\n <Setter Property=\"Template\">\n <Setter.Value>\n <ControlTemplate TargetType=\"ListViewItem\">\n <ListViewItemPresenter SelectionCheckMarkVisualEnabled=\"False\" SelectedBackground=\"Orange\"/>\n </ControlTemplate>\n </Setter.Value>\n </Setter>\n </Style>\n </ListView.ItemContainerStyle>\n</ListView>\n<!-- ... -->\n```\n\nThere are about 25 properties with self-describing names similar to [**SelectionCheckMarkVisualEnabled**](https://msdn.microsoft.com/library/windows/apps/Dn298500-selectioncheckmarkvisualenabled) and [**SelectedBackground**](https://msdn.microsoft.com/library/windows/apps/Dn298500-selectedbackground). Should the presenter types prove not to be customizable enough for your use case, you can edit a copy of the `ListViewItemExpanded` or `GridViewItemExpanded` control template instead. These can be found in `\\Program Files (x86)\\Windows Kits\\10\\DesignTime\\CommonConfiguration\\Neutral\\UAP\\<version>\\Generic\\generic.xaml`. Be aware that using these templates means trading some performance for the increase in customization.\n\n## Update ListView and GridView items progressively\n\nIf you're using data virtualization then you can keep [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878) and [**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242705) responsiveness high by configuring the control to render temporary UI elements for the items still being (down)loaded. The temporary elements are then progressively replaced with actual UI as data loads.\n\nAlso—no matter where you're loading data from (local disk, network, or cloud)—a user can pan/scroll a [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878) or [**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242705) so rapidly that it's not possible to render each item with full fidelity while preserving smooth panning/scrolling. To preserve smooth panning/scrolling you can choose to render an item in multiple phases in addition to using placeholders.\n\nAn example of these techniques is often seen in photo-viewing apps: even though not all of the images have been loaded and displayed, the user can still pan/scroll and interact with the collection. Or, for a \"movie\" item, you could show the title in the first phase, the rating in the second phase, and an image of the poster in the third phase. The user sees the most important data about each item as early as possible, and that means they're able to take action at once. Then the less important info is filled-in as time allows. Here are the platform features you can use to implement these techniques.\n\n### Placeholders\n\nThe temporary placeholder visuals feature is on by default, and it's controlled with the [**ShowsScrollingPlaceholders**](https://msdn.microsoft.com/library/windows/apps/BR242878base-showsscrollingplaceholders) property. During fast panning/scrolling, this feature gives the user a visual hint that there are more items yet to fully display while also preserving smoothness. If you use one of the techniques below then you can set **ShowsScrollingPlaceholders** to false if you prefer not to have the system render placeholders.\n\n**Progressive data template updates using x:Phase**\n\nHere's how to use the [x:Phase attribute](https://msdn.microsoft.com/library/windows/apps/Mt204790) with [{x:Bind}](https://msdn.microsoft.com/library/windows/apps/Mt204783) bindings to implement progressive data template updates.\n\n1.  Here's what the binding source looks like (this is the data source that we'll bind to).\n\n```csharp\nnamespace LotsOfItems\n    {\n        public class ExampleItem\n        {\n            public string Title { get; set; }\n            public string Subtitle { get; set; }\n            public string Description { get; set; }\n        }\n\n        public class ExampleItemViewModel\n        {\n            private ObservableCollection<ExampleItem> exampleItems = new ObservableCollection<ExampleItem>();\n            public ObservableCollection<ExampleItem> ExampleItems { get { return this.exampleItems; } }\n\n            public ExampleItemViewModel()\n            {\n                for (int i = 1; i < 150000; i++)\n                {\n                    this.exampleItems.Add(new ExampleItem(){\n                        Title = \"Title: \" + i.ToString(),\n                        Subtitle = \"Sub: \" + i.ToString(),\n                        Description = \"Desc: \" + i.ToString()\n                    });\n                }\n            }\n        }\n    }\n```\n\n2.  Here's the markup that `DeferMainPage.xaml` contains. The grid view contains an item template with elements bound to the **Title**, **Subtitle**, and **Description** properties of the **MyItem** class. Note that **x:Phase** defaults to 0. Here, items will be initially rendered with just the title visible. Then the subtitle element will be data bound and made visible for all the items and so on until all the phases have been processed.\n\n```xml\n    <Page\n        x:Class=\"LotsOfItems.DeferMainPage\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        xmlns:lotsOfItems=\"using:LotsOfItems\"\n        mc:Ignorable=\"d\">\n\n        <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n            <GridView ItemsSource=\"{x:Bind ViewModel.ExampleItems}\">\n                <GridView.ItemTemplate>\n                    <DataTemplate x:DataType=\"lotsOfItems:ExampleItem\">\n                        <StackPanel Height=\"100\" Width=\"100\" Background=\"OrangeRed\">\n                            <TextBlock Text=\"{x:Bind Title}\"/>\n                            <TextBlock Text=\"{x:Bind Subtitle}\" x:Phase=\"1\"/>\n                            <TextBlock Text=\"{x:Bind Description}\" x:Phase=\"2\"/>\n                        </StackPanel>\n                    </DataTemplate>\n                </GridView.ItemTemplate>\n            </GridView>\n        </Grid>\n    </Page>\n```\n\n3.  If you run the app now and pan/scroll quickly through the grid view then you'll notice that as each new item appears on the screen, at first it is rendered as a dark gray rectangle (thanks to the [**ShowsScrollingPlaceholders**](https://msdn.microsoft.com/library/windows/apps/BR242878base-showsscrollingplaceholders) property defaulting to **true**), then the title appears, followed by subtitle, followed by description.\n\n**Progressive data template updates using ContainerContentChanging**\n\nThe general strategy for the [**ContainerContentChanging**](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging) event is to use **Opacity** to hide elements that don’t need to be immediately visible. When elements are recycled, they will retain their old values so we want to hide those elements until we've updated those values from the new data item. We use the **Phase** property on the event arguments to determine which elements to update and show. If additional phases are needed, we register a callback.\n\n1.  We'll use the same binding source as for **x:Phase**.\n\n2.  Here's the markup that `MainPage.xaml` contains. The grid view declares a handler to its [**ContainerContentChanging**](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging) event, and it contains an item template with elements used to display the **Title**, **Subtitle**, and **Description** properties of the **MyItem** class. To get the maximum performance benefits of using **ContainerContentChanging**, we don't use bindings in the markup but we instead assign values programmatically. The exception here is the element displaying the title, which we consider to be in phase 0.\n\n```xml\n    <Page\n        x:Class=\"LotsOfItems.MainPage\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        xmlns:lotsOfItems=\"using:LotsOfItems\"\n        mc:Ignorable=\"d\">\n\n        <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n            <GridView ItemsSource=\"{x:Bind ViewModel.ExampleItems}\" ContainerContentChanging=\"GridView-ContainerContentChanging\">\n                <GridView.ItemTemplate>\n                    <DataTemplate x:DataType=\"lotsOfItems:ExampleItem\">\n                        <StackPanel Height=\"100\" Width=\"100\" Background=\"OrangeRed\">\n                            <TextBlock Text=\"{x:Bind Title}\"/>\n                            <TextBlock Opacity=\"0\"/>\n                            <TextBlock Opacity=\"0\"/>\n                        </StackPanel>\n                    </DataTemplate>\n                </GridView.ItemTemplate>\n            </GridView>\n        </Grid>\n    </Page>\n```\n\n3.  Lastly, here's the implementation of the [**ContainerContentChanging**](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging) event handler. This code also shows how we add a property of type **RecordingViewModel** to **MainPage** to expose the binding source class from the class that represents our page of markup. As long as you don't have any [{Binding}](https://msdn.microsoft.com/library/windows/apps/Mt204782) bindings in your data template, then mark the event arguments object as handled in the first phase of the handler to hint to the item that it needn't set a data context.\n\n```csharp\n    namespace LotsOfItems\n    {\n        /// <summary>\n        /// An empty page that can be used on its own or navigated to within a Frame.\n        /// </summary>\n        public sealed partial class MainPage : Page\n        {\n            public MainPage()\n            {\n                this.InitializeComponent();\n                this.ViewModel = new ExampleItemViewModel();\n            }\n\n            public ExampleItemViewModel ViewModel { get; set; }\n\n            // Display each item incrementally to improve performance.\n            private void GridView-ContainerContentChanging(ListViewBase sender, ContainerContentChangingEventArgs args)\n            {\n                if (args.Phase != 0)\n                {\n                    throw new System.Exception(\"We should be in phase 0, but we are not.\");\n                }\n\n                // It's phase 0, so this item's title will already be bound and displayed.\n\n                args.RegisterUpdateCallback(this.ShowSubtitle);\n\n                args.Handled = true;\n            }\n\n            private void ShowSubtitle(ListViewBase sender, ContainerContentChangingEventArgs args)\n            {\n                if (args.Phase != 1)\n                {\n                    throw new System.Exception(\"We should be in phase 1, but we are not.\");\n                }\n\n                // It's phase 1, so show this item's subtitle.\n                var templateRoot = args.ItemContainer.ContentTemplateRoot as StackPanel;\n                var textBlock = templateRoot.Children[1] as TextBlock;\n                textBlock.Text = (args.Item as ExampleItem).Subtitle;\n                textBlock.Opacity = 1;\n\n                args.RegisterUpdateCallback(this.ShowDescription);\n            }\n\n            private void ShowDescription(ListViewBase sender, ContainerContentChangingEventArgs args)\n            {\n                if (args.Phase != 2)\n                {\n                    throw new System.Exception(\"We should be in phase 2, but we are not.\");\n                }\n\n                // It's phase 2, so show this item's description.\n                var templateRoot = args.ItemContainer.ContentTemplateRoot as StackPanel;\n                var textBlock = templateRoot.Children[2] as TextBlock;\n                textBlock.Text = (args.Item as ExampleItem).Description;\n                textBlock.Opacity = 1;\n            }\n        }\n    }\n```\n\n4.  If you run the app now and pan/scroll quickly through the grid view then you'll see the same behavior as for as for **x:Phase**.\n\n## Container-recycling with heterogeneous collections\n\nIn some applications, you need to have different UI for different types of item within a collection. This can create a situation where it is impossible for virtualizing panels to reuse/recycle the visual elements used to display the items. Recreating the visual elements for an item during panning undoes many of the performance wins provided by virtualization. However, a little planning can allow virtualizing panels to reuse the elements. Developers have a couple of options depending on their scenario: the [**ChoosingItemContainer**](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer) event, or an item template selector. The **ChoosingItemContainer** event is the most performant approach.\n\n**The ChoosingItemContainer event**\n\n[**ChoosingItemContainer**](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer) is an event that allows you to provide an item ([**ListViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242878item)/[**GridViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242705item)) to the [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878)/[**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242705) whenever a new item is needed during start-up or recycling. You can create a container based on the type of data item the container will display (shown in the example below). **ChoosingItemContainer** is the most performant way to use different data templates for different items. Container caching is something that can be achieved using **ChoosingItemContainer**. For example, if you have five different template, with one template occurring an order of magnitude more often than the others, then ChoosingItemContainer allows you not only to create items at the ratios needed but also to keep an appropriate number of elements cached and available for recycling. [**ChoosingGroupHeaderContainer**](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosinggroupheadercontainer) provides the same functionality for group headers.\n\n```csharp\n// Example shows how to use ChoosingItemContainer to return the correct\n// DataTemplate when one is available. This example shows how to return different \n// data templates based on the type of FileItem. Available ListViewItems are kept\n// in two separate lists based on the type of DataTemplate needed.\nprivate void lst-ChoosingItemContainer\n    (ListViewBase sender, ChoosingItemContainerEventArgs args)\n{\n    // Determines type of FileItem from the item passed in.\n    bool special = args.Item is DifferentFileItem;\n\n    // Uses the Tag property to keep track of whether a particular ListViewItem's \n    // datatemplate should be a simple or a special one.\n    string tag = special ? \"specialFiles\" : \"simpleFiles\";\n\n    // Based on the type of datatemplate needed return the correct list of \n    // ListViewItems, this could have also been handled with a hash table. These \n    // two lists are being used to keep track of ItemContainers that can be reused.\n    List<UIElement> relevantStorage = special ? specialFileItemTrees : simpleFileItemTrees;\n\n    // args.ItemContainer is used to indicate whether the ListView is proposing an \n    // ItemContainer (ListViewItem) to use. If args.Itemcontainer, then there was a \n    // recycled ItemContainer available to be reused.\n    if (args.ItemContainer != null)\n    {\n        // The Tag is being used to determine whether this is a special file or \n        // a simple file.\n        if (args.ItemContainer.Tag.Equals(tag))\n        {\n            // Great: the system suggested a container that is actually going to \n            // work well.\n        }\n        else\n        {\n            // the ItemContainer's datatemplate does not match the needed \n            // datatemplate.\n            args.ItemContainer = null;\n        }\n    }\n\n    if (args.ItemContainer == null)\n    {\n        // see if we can fetch from the correct list.\n        if (relevantStorage.Count > 0)\n        {\n            args.ItemContainer = relevantStorage[0] as SelectorItem;\n        }\n        else\n        {\n            // there aren't any (recycled) ItemContainers available. So a new one \n            // needs to be created.\n            ListViewItem item = new ListViewItem();\n            item.ContentTemplate = this.Resources[tag] as DataTemplate;\n            item.Tag = tag;\n            args.ItemContainer = item;\n        }\n    }\n}\n```\n\n**Item template selector**\n\nAn item template selector ([**DataTemplateSelector**](https://msdn.microsoft.com/library/windows/apps/BR209469)) allows an app to return a different item template at runtime based on the type of the data item that will be displayed. This makes development more productive, but it makes UI virtualization more difficult because not every item template can be reused for every data item.\n\nWhen recycling an item ([**ListViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242878item)/[**GridViewItem**](https://msdn.microsoft.com/library/windows/apps/BR242705item)), the framework must decide whether the items that are available for use in the recycle queue (the recycle queue is a cache of items that are not currently being used to display data) have an item template that will match the one desired by the current data item. If there are no items in the recycle queue with the appropriate item template then a new item is created, and the appropriate item template is instantiated for it. If, on other hand, the recycle queue contains an item with the appropriate item template then that item is removed from the recycle queue and is used for the current data item. An item template selector works in situations where only a small number of item templates are used and there is a flat distribution throughout the collection of items that use different item templates.\n\nWhen there is an uneven distribution of items that use different item templates then new item templates will likely need to be created during panning, and this negates many of the gains provided by virtualization. Additionally, an item template selector only considers five possible candidates when evaluating whether a particular container can be reused for the current data item. So you should carefully consider whether your data is appropriate for use with an item template selector before using one in your app. If your collection is mostly homogeneous then the selector is returning the same type most (possibly all) of the time. Just be aware of the price you're paying for the rare exceptions to that homegeneity, and consider whether using [**ChoosingItemContainer**](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer) (or two items controls) is preferable.\n\n "}