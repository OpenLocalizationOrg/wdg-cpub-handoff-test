{"nodes":[{"pos":[11,43],"content":"Port the vertex buffers and data","needQuote":true,"needEscape":true,"nodes":[{"content":"Port the vertex buffers and data","pos":[0,32]}]},{"pos":[57,225],"content":"In this step, you'll define the vertex buffers that will contain your meshes and the index buffers that allow the shaders to traverse the vertices in a specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"In this step, you'll define the vertex buffers that will contain your meshes and the index buffers that allow the shaders to traverse the vertices in a specified order.","pos":[0,168]}]},{"content":"Port the vertex buffers and data","pos":[282,314]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[317,355]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[356,451],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Important APIs","pos":[456,470]},{"content":"ID3DDevice::CreateBuffer","pos":[481,505]},{"content":"ID3DDeviceContext::IASetVertexBuffers","pos":[577,614]},{"content":"ID3D11DeviceContext::IASetIndexBuffer","pos":[686,723]},{"content":"In this step, you'll define the vertex buffers that will contain your meshes and the index buffers that allow the shaders to traverse the vertices in a specified order.","pos":[789,957]},{"content":"At this point, let's examine the hardcoded model for the cube mesh we are using.","pos":[959,1039]},{"content":"Both representations have the vertices organized as a triangle list (as opposed to a strip or other more efficient triangle layout).","pos":[1040,1172]},{"content":"All vertices in both representations also have associated indices and color values.","pos":[1173,1256]},{"content":"Much of the Direct3D code in this topic refers to variables and objects defined in the Direct3D project.","pos":[1257,1361]},{"content":"Here's the cube for processing by OpenGL ES 2.0.","pos":[1363,1411]},{"content":"In the sample implementation, each vertex is 7 float values: 3 position coordinates followed by 4 RGBA color values.","pos":[1412,1528]},{"content":"And here's the same cube for processing by Direct3D 11.","pos":[2203,2258]},{"content":"Reviewing this code, you notice that the cube in the OpenGL ES 2.0 code is represented in a right-hand coordinate system, whereas the cube in the Direct3D-specific code is represented in a left-hand coordinate system.","pos":[3082,3299]},{"content":"When importing your own mesh data, you must reverse the z-axis coordinates for your model and change the indices for each mesh accordingly to traverse the triangles according to the change in the coordinate system.","pos":[3300,3514]},{"content":"Assuming that we have successfully moved the cube mesh from the right-handed OpenGL ES 2.0 coordinate system to the left-handed Direct3D one, let's see how to load the cube data for processing in both models.","pos":[3516,3724]},{"content":"Instructions","pos":[3729,3741]},{"content":"Step 1: Create an input layout","pos":[3747,3777]},{"content":"In OpenGL ES 2.0, your vertex data is supplied as attributes that will be supplied to and read by the shader objects.","pos":[3779,3896]},{"content":"You typically provide a string that contains the attribute name used in the shader's GLSL to the shader program object, and get a memory location back that you can supply to the shader.","pos":[3897,4082]},{"content":"In this example, a vertex buffer object contains a list of custom Vertex structures, defined and formatted as follows:","pos":[4083,4201]},{"content":"OpenGL ES 2.0: Configure the attributes that contain the per-vertex information.","pos":[4203,4283]},{"content":"In OpenGL ES 2.0, input layouts are implicit; you take a general purpose GL\\_ELEMENT\\_ARRAY\\_BUFFER and supply the stride and offset such that the vertex shader can interpret the data after uploading it.","pos":[4374,4577]},{"content":"You inform the shader before rendering which attributes map to which portions of each block of vertex data with <bpt id=\"p1\">**</bpt>glVertexAttribPointer<ept id=\"p1\">**</ept>.","pos":[4578,4716],"source":" You inform the shader before rendering which attributes map to which portions of each block of vertex data with **glVertexAttribPointer**."},{"content":"In Direct3D, you must provide an input layout to describe the structure of the vertex data in the vertex buffer when you create the buffer, instead of before you draw the geometry.","pos":[4718,4898]},{"content":"To do this, you use an input layout which corresponds to layout of the data for our individual vertices in memory.","pos":[4899,5013]},{"content":"It is very important to specify this accurately!","pos":[5014,5062]},{"pos":[5064,5223],"content":"Here, you create an input description as an array of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11\\_INPUT\\_ELEMENT\\_DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476180)</ept> structures.","source":"Here, you create an input description as an array of [**D3D11\\_INPUT\\_ELEMENT\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476180) structures."},{"content":"Direct3D: Define an input layout description.","pos":[5225,5270]},{"content":"This input description defines a vertex as a pair of 2 3-coordinate vectors: one 3D vector to store the position of the vertex in model coordinates, and another 3D vector to store the RGB color value associated with the vertex.","pos":[5612,5839]},{"content":"In this case, you use 3x32 bit floating point format, elements of which we represent in code as <ph id=\"ph1\">`XMFLOAT3(X.Xf, X.Xf, X.Xf)`</ph>.","pos":[5840,5965],"source":" In this case, you use 3x32 bit floating point format, elements of which we represent in code as `XMFLOAT3(X.Xf, X.Xf, X.Xf)`."},{"content":"You should use types from the <bpt id=\"p1\">[</bpt>DirectXMath<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ee415574)</ept> library whenever you are handling data that will be used by a shader, as it ensure the proper packing and alignment of that data.","pos":[5966,6200],"source":" You should use types from the [DirectXMath](https://msdn.microsoft.com/library/windows/desktop/ee415574) library whenever you are handling data that will be used by a shader, as it ensure the proper packing and alignment of that data."},{"content":"(For example, use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>XMFLOAT3<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ee419475)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>XMFLOAT4<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ee419608)</ept> for vector data, and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>XMFLOAT4X4<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ee419621)</ept> for matrices.)","pos":[6201,6487],"source":" (For example, use [**XMFLOAT3**](https://msdn.microsoft.com/library/windows/desktop/ee419475) or [**XMFLOAT4**](https://msdn.microsoft.com/library/windows/desktop/ee419608) for vector data, and [**XMFLOAT4X4**](https://msdn.microsoft.com/library/windows/desktop/ee419621) for matrices.)"},{"pos":[6489,6623],"content":"For a list of all the possible format types, refer to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DXGI\\_FORMAT<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb173059)</ept>.","source":"For a list of all the possible format types, refer to [**DXGI\\_FORMAT**](https://msdn.microsoft.com/library/windows/desktop/bb173059)."},{"content":"With the per-vertex input layout defined, you create the layout object.","pos":[6625,6696]},{"content":"In the following code, you write it to <bpt id=\"p1\">**</bpt>m\\_inputLayout<ept id=\"p1\">**</ept>, a variable of type <bpt id=\"p2\">**</bpt>ComPtr<ept id=\"p2\">**</ept> (which points to an object of type <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11InputLayout<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476575)</ept>).","pos":[6697,6907],"source":" In the following code, you write it to **m\\_inputLayout**, a variable of type **ComPtr** (which points to an object of type [**ID3D11InputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476575))."},{"content":"<bpt id=\"p1\">**</bpt>fileData<ept id=\"p1\">**</ept> contains the compiled vertex shader object from the previous step, <bpt id=\"p2\">[</bpt>Port the shaders<ept id=\"p2\">](port-the-shader-config.md)</ept>.","pos":[6908,7034],"source":"**fileData** contains the compiled vertex shader object from the previous step, [Port the shaders](port-the-shader-config.md)."},{"content":"Direct3D: Create the input layout used by the vertex buffer.","pos":[7036,7096]},{"content":"We've defined the input layout.","pos":[7320,7351]},{"content":"Now, let's create a buffer that uses this layout and load it with the cube mesh data.","pos":[7352,7437]},{"content":"Step 2: Create and load the vertex buffer(s)","pos":[7443,7487]},{"content":"In OpenGL ES 2.0, you create a pair of buffers, one for the position data and one for the color data.","pos":[7489,7590]},{"content":"(You could also create a struct that contains both and a single buffer.) You bind each buffer and write position and color data into them.","pos":[7591,7729]},{"content":"Later, during your render function, bind the buffers again and provide the shader with the format of the data in the buffer so it can correctly interpret it.","pos":[7730,7887]},{"content":"OpenGL ES 2.0: Bind the vertex buffers","pos":[7889,7927]},{"content":"In Direct3D, shader-accessible buffers are represented as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11\\_SUBRESOURCE\\_DATA<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structures.","pos":[8198,8359],"source":"In Direct3D, shader-accessible buffers are represented as [**D3D11\\_SUBRESOURCE\\_DATA**](https://msdn.microsoft.com/library/windows/desktop/ff476220) structures."},{"content":"To bind the location of this buffer to shader object, you need to create a CD3D11\\_BUFFER\\_DESC structure for each buffer with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3DDevice::CreateBuffer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept>, and then set the buffer of the Direct3D device context by calling a set method specific to the buffer type, such as <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3DDeviceContext::IASetVertexBuffers<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476456)</ept>.","pos":[8360,8801],"source":" To bind the location of this buffer to shader object, you need to create a CD3D11\\_BUFFER\\_DESC structure for each buffer with [**ID3DDevice::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501), and then set the buffer of the Direct3D device context by calling a set method specific to the buffer type, such as [**ID3DDeviceContext::IASetVertexBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476456)."},{"content":"When you set the buffer, you must set the stride (the size of the data element for an individual vertex) as well the offset (where the vertex data array actually starts) from the beginning of the buffer.","pos":[8803,9006]},{"content":"Notice that we assign the pointer to the <bpt id=\"p1\">**</bpt>vertexIndices<ept id=\"p1\">**</ept> array to the <bpt id=\"p2\">**</bpt>pSysMem<ept id=\"p2\">**</ept> field of the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>D3D11\\_SUBRESOURCE\\_DATA<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structure.","pos":[9008,9207],"source":"Notice that we assign the pointer to the **vertexIndices** array to the **pSysMem** field of the [**D3D11\\_SUBRESOURCE\\_DATA**](https://msdn.microsoft.com/library/windows/desktop/ff476220) structure."},{"content":"If this isn't correct, your mesh will be corrupt or empty!","pos":[9208,9266]},{"content":"Direct3D: Create and set the vertex buffer","pos":[9268,9310]},{"content":"Step 3: Create and load the index buffer","pos":[9853,9893]},{"content":"Index buffers are an efficient way to allow the vertex shader to look up individual vertices.","pos":[9895,9988]},{"content":"Although they are not required, we use them in this sample renderer.","pos":[9989,10057]},{"content":"As with vertex buffers in OpenGL ES 2.0, an index buffer is created and bound as a general purpose buffer and the vertex indices you created earlier are copied into it.","pos":[10058,10226]},{"pos":[10228,10336],"content":"When you're ready to draw, you bind both the vertex and the index buffer again, and call <bpt id=\"p1\">**</bpt>glDrawElements<ept id=\"p1\">**</ept>.","source":"When you're ready to draw, you bind both the vertex and the index buffer again, and call **glDrawElements**."},{"content":"OpenGL ES 2.0: Send the index order to the draw call.","pos":[10338,10391]},{"content":"With Direct3D, it's a bit very similar process, albeit a bit more didactic.","pos":[10857,10932]},{"content":"Supply the index buffer as a Direct3D subresource to the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept> you created when you configured Direct3D.","pos":[10933,11118],"source":" Supply the index buffer as a Direct3D subresource to the [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385) you created when you configured Direct3D."},{"content":"You do this by calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::IASetIndexBuffer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb173588)</ept> with the configured subresource for the index array, as follows.","pos":[11119,11311],"source":" You do this by calling [**ID3D11DeviceContext::IASetIndexBuffer**](https://msdn.microsoft.com/library/windows/desktop/bb173588) with the configured subresource for the index array, as follows."},{"content":"(Again, notice that you assign the pointer to the <bpt id=\"p1\">**</bpt>cubeIndices<ept id=\"p1\">**</ept> array to the <bpt id=\"p2\">**</bpt>pSysMem<ept id=\"p2\">**</ept> field of the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>D3D11\\_SUBRESOURCE\\_DATA<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structure.)","pos":[11312,11519],"source":" (Again, notice that you assign the pointer to the **cubeIndices** array to the **pSysMem** field of the [**D3D11\\_SUBRESOURCE\\_DATA**](https://msdn.microsoft.com/library/windows/desktop/ff476220) structure.)"},{"content":"Direct3D: Create the index buffer.","pos":[11521,11555]},{"content":"Later, you will draw the triangles with a call to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::DrawIndexed<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476409)</ept> (or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext::Draw<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476407)</ept> for unindexed vertices), as follows.","pos":[12032,12315],"source":"Later, you will draw the triangles with a call to [**ID3D11DeviceContext::DrawIndexed**](https://msdn.microsoft.com/library/windows/desktop/ff476409) (or [**ID3D11DeviceContext::Draw**](https://msdn.microsoft.com/library/windows/desktop/ff476407) for unindexed vertices), as follows."},{"content":"(For more details, jump ahead to <bpt id=\"p1\">[</bpt>Draw to the screen<ept id=\"p1\">](draw-to-the-screen.md)</ept>.)","pos":[12316,12394],"source":" (For more details, jump ahead to [Draw to the screen](draw-to-the-screen.md).)"},{"content":"Direct3D: Draw the indexed vertices.","pos":[12396,12432]},{"content":"Previous step","pos":[12646,12659]},{"content":"Port the shader objects","pos":[12663,12686]},{"content":"Next step","pos":[12719,12728]},{"content":"Port the GLSL","pos":[12731,12744]},{"content":"Remarks","pos":[12768,12775]},{"content":"When structuring your Direct3D, separate the code that calls methods on <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</ept> into a method that is called whenever the device resources need to be recreated.","pos":[12777,13009],"source":"When structuring your Direct3D, separate the code that calls methods on [**ID3D11Device**](https://msdn.microsoft.com/library/windows/desktop/ff476379) into a method that is called whenever the device resources need to be recreated."},{"content":"(In the Direct3D project template, this code is in the renderer object's <bpt id=\"p1\">**</bpt>CreateDeviceResource<ept id=\"p1\">**</ept> methods.","pos":[13010,13116],"source":" (In the Direct3D project template, this code is in the renderer object's **CreateDeviceResource** methods."},{"content":"The code that updates the device context (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept>), on the other hand, is placed in the <bpt id=\"p3\">**</bpt>Render<ept id=\"p3\">**</ept> method, since this is where you actually construct the shader stages and bind the data.","pos":[13117,13382],"source":" The code that updates the device context ([**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385)), on the other hand, is placed in the **Render** method, since this is where you actually construct the shader stages and bind the data."},{"content":"Related topics","pos":[13387,13401]},{"content":"How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11","pos":[13407,13466]},{"content":"Port the shader objects","pos":[13528,13551]},{"content":"Port the vertex buffers and data","pos":[13583,13615]},{"content":"Port the GLSL","pos":[13664,13677]}],"content":"---\ntitle: Port the vertex buffers and data\ndescription: In this step, you'll define the vertex buffers that will contain your meshes and the index buffers that allow the shaders to traverse the vertices in a specified order.\nms.assetid: 9a8138a5-0797-8532-6c00-58b907197a25\n---\n\n# Port the vertex buffers and data\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\n**Important APIs**\n\n-   [**ID3DDevice::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501)\n-   [**ID3DDeviceContext::IASetVertexBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476456)\n-   [**ID3D11DeviceContext::IASetIndexBuffer**](https://msdn.microsoft.com/library/windows/desktop/bb173588)\n\nIn this step, you'll define the vertex buffers that will contain your meshes and the index buffers that allow the shaders to traverse the vertices in a specified order.\n\nAt this point, let's examine the hardcoded model for the cube mesh we are using. Both representations have the vertices organized as a triangle list (as opposed to a strip or other more efficient triangle layout). All vertices in both representations also have associated indices and color values. Much of the Direct3D code in this topic refers to variables and objects defined in the Direct3D project.\n\nHere's the cube for processing by OpenGL ES 2.0. In the sample implementation, each vertex is 7 float values: 3 position coordinates followed by 4 RGBA color values.\n\n```cpp\n#define CUBE_INDICES 36\n#define CUBE_VERTICES 8\n\nGLfloat cubeVertsAndColors[] = \n{\n  -0.5f, -0.5f,  0.5f, 0.0f, 0.0f, 1.0f, 1.0f,\n  -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f,\n  -0.5f,  0.5f,  0.5f, 0.0f, 1.0f, 1.0f, 1.0f,\n  -0.5f,  0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 1.0f,\n  0.5f, -0.5f,  0.5f, 1.0f, 0.0f, 1.0f, 1.0f,\n  0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 1.0f,  \n  0.5f,  0.5f,  0.5f, 1.0f, 1.0f, 1.0f, 1.0f,\n  0.5f,  0.5f, -0.5f, 1.0f, 1.0f, 0.0f, 1.0f\n};\n\nGLuint cubeIndices[] = \n{\n  0, 1, 2, // -x\n  1, 3, 2,\n\n  4, 6, 5, // +x\n  6, 7, 5,\n\n  0, 5, 1, // -y\n  5, 6, 1,\n\n  2, 6, 3, // +y\n  6, 7, 3,\n\n  0, 4, 2, // +z\n  4, 6, 2,\n\n  1, 7, 3, // -z\n  5, 7, 1\n};\n```\n\nAnd here's the same cube for processing by Direct3D 11.\n\n```cpp\nVertexPositionColor cubeVerticesAndColors[] = \n// struct format is position, color\n{\n  {XMFLOAT3(-0.5f, -0.5f, -0.5f), XMFLOAT3(0.0f, 0.0f, 0.0f)},\n  {XMFLOAT3(-0.5f, -0.5f,  0.5f), XMFLOAT3(0.0f, 0.0f, 1.0f)},\n  {XMFLOAT3(-0.5f,  0.5f, -0.5f), XMFLOAT3(0.0f, 1.0f, 0.0f)},\n  {XMFLOAT3(-0.5f,  0.5f,  0.5f), XMFLOAT3(0.0f, 1.0f, 1.0f)},\n  {XMFLOAT3( 0.5f, -0.5f, -0.5f), XMFLOAT3(1.0f, 0.0f, 0.0f)},\n  {XMFLOAT3( 0.5f, -0.5f,  0.5f), XMFLOAT3(1.0f, 0.0f, 1.0f)},\n  {XMFLOAT3( 0.5f,  0.5f, -0.5f), XMFLOAT3(1.0f, 1.0f, 0.0f)},\n  {XMFLOAT3( 0.5f,  0.5f,  0.5f), XMFLOAT3(1.0f, 1.0f, 1.0f)},\n};\n        \nunsigned short cubeIndices[] = \n{\n  0, 2, 1, // -x\n  1, 2, 3,\n\n  4, 5, 6, // +x\n  5, 7, 6,\n\n  0, 1, 5, // -y\n  0, 5, 4,\n\n  2, 6, 7, // +y\n  2, 7, 3,\n\n  0, 4, 6, // -z\n  0, 6, 2,\n\n  1, 3, 7, // +z\n  1, 7, 5\n};\n```\n\nReviewing this code, you notice that the cube in the OpenGL ES 2.0 code is represented in a right-hand coordinate system, whereas the cube in the Direct3D-specific code is represented in a left-hand coordinate system. When importing your own mesh data, you must reverse the z-axis coordinates for your model and change the indices for each mesh accordingly to traverse the triangles according to the change in the coordinate system.\n\nAssuming that we have successfully moved the cube mesh from the right-handed OpenGL ES 2.0 coordinate system to the left-handed Direct3D one, let's see how to load the cube data for processing in both models.\n\n## Instructions\n\n### Step 1: Create an input layout\n\nIn OpenGL ES 2.0, your vertex data is supplied as attributes that will be supplied to and read by the shader objects. You typically provide a string that contains the attribute name used in the shader's GLSL to the shader program object, and get a memory location back that you can supply to the shader. In this example, a vertex buffer object contains a list of custom Vertex structures, defined and formatted as follows:\n\nOpenGL ES 2.0: Configure the attributes that contain the per-vertex information.\n\n``` syntax\ntypedef struct \n{\n  GLfloat pos[3];        \n  GLfloat rgba[4];\n} Vertex;\n```\n\nIn OpenGL ES 2.0, input layouts are implicit; you take a general purpose GL\\_ELEMENT\\_ARRAY\\_BUFFER and supply the stride and offset such that the vertex shader can interpret the data after uploading it. You inform the shader before rendering which attributes map to which portions of each block of vertex data with **glVertexAttribPointer**.\n\nIn Direct3D, you must provide an input layout to describe the structure of the vertex data in the vertex buffer when you create the buffer, instead of before you draw the geometry. To do this, you use an input layout which corresponds to layout of the data for our individual vertices in memory. It is very important to specify this accurately!\n\nHere, you create an input description as an array of [**D3D11\\_INPUT\\_ELEMENT\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476180) structures.\n\nDirect3D: Define an input layout description.\n\n``` syntax\nstruct VertexPositionColor\n{\n  DirectX::XMFLOAT3 pos;\n  DirectX::XMFLOAT3 color;\n};\n\n// ...\n\nconst D3D11_INPUT_ELEMENT_DESC vertexDesc[] = \n{\n  { \"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },\n  { \"COLOR\",    0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },\n};\n\n```\n\nThis input description defines a vertex as a pair of 2 3-coordinate vectors: one 3D vector to store the position of the vertex in model coordinates, and another 3D vector to store the RGB color value associated with the vertex. In this case, you use 3x32 bit floating point format, elements of which we represent in code as `XMFLOAT3(X.Xf, X.Xf, X.Xf)`. You should use types from the [DirectXMath](https://msdn.microsoft.com/library/windows/desktop/ee415574) library whenever you are handling data that will be used by a shader, as it ensure the proper packing and alignment of that data. (For example, use [**XMFLOAT3**](https://msdn.microsoft.com/library/windows/desktop/ee419475) or [**XMFLOAT4**](https://msdn.microsoft.com/library/windows/desktop/ee419608) for vector data, and [**XMFLOAT4X4**](https://msdn.microsoft.com/library/windows/desktop/ee419621) for matrices.)\n\nFor a list of all the possible format types, refer to [**DXGI\\_FORMAT**](https://msdn.microsoft.com/library/windows/desktop/bb173059).\n\nWith the per-vertex input layout defined, you create the layout object. In the following code, you write it to **m\\_inputLayout**, a variable of type **ComPtr** (which points to an object of type [**ID3D11InputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476575)). **fileData** contains the compiled vertex shader object from the previous step, [Port the shaders](port-the-shader-config.md).\n\nDirect3D: Create the input layout used by the vertex buffer.\n\n``` syntax\nMicrosoft::WRL::ComPtr<ID3D11InputLayout>      m_inputLayout;\n\n// ...\n\nm_d3dDevice->CreateInputLayout(\n  vertexDesc,\n  ARRAYSIZE(vertexDesc),\n  fileData->Data,\n  fileShaderData->Length,\n  &m_inputLayout\n);\n```\n\nWe've defined the input layout. Now, let's create a buffer that uses this layout and load it with the cube mesh data.\n\n### Step 2: Create and load the vertex buffer(s)\n\nIn OpenGL ES 2.0, you create a pair of buffers, one for the position data and one for the color data. (You could also create a struct that contains both and a single buffer.) You bind each buffer and write position and color data into them. Later, during your render function, bind the buffers again and provide the shader with the format of the data in the buffer so it can correctly interpret it.\n\nOpenGL ES 2.0: Bind the vertex buffers\n\n``` syntax\n// upload the data for the vertex position buffer\nglGenBuffers(1, &renderer->vertexBuffer);    \nglBindBuffer(GL_ARRAY_BUFFER, renderer->vertexBuffer);\nglBufferData(GL_ARRAY_BUFFER, sizeof(VERTEX) * CUBE_VERTICES, renderer->vertices, GL_STATIC_DRAW);   \n```\n\nIn Direct3D, shader-accessible buffers are represented as [**D3D11\\_SUBRESOURCE\\_DATA**](https://msdn.microsoft.com/library/windows/desktop/ff476220) structures. To bind the location of this buffer to shader object, you need to create a CD3D11\\_BUFFER\\_DESC structure for each buffer with [**ID3DDevice::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501), and then set the buffer of the Direct3D device context by calling a set method specific to the buffer type, such as [**ID3DDeviceContext::IASetVertexBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476456).\n\nWhen you set the buffer, you must set the stride (the size of the data element for an individual vertex) as well the offset (where the vertex data array actually starts) from the beginning of the buffer.\n\nNotice that we assign the pointer to the **vertexIndices** array to the **pSysMem** field of the [**D3D11\\_SUBRESOURCE\\_DATA**](https://msdn.microsoft.com/library/windows/desktop/ff476220) structure. If this isn't correct, your mesh will be corrupt or empty!\n\nDirect3D: Create and set the vertex buffer\n\n``` syntax\nD3D11_SUBRESOURCE_DATA vertexBufferData = {0};\nvertexBufferData.pSysMem = cubeVertices;\nvertexBufferData.SysMemPitch = 0;\nvertexBufferData.SysMemSlicePitch = 0;\nCD3D11_BUFFER_DESC vertexBufferDesc(sizeof(cubeVertices), D3D11_BIND_VERTEX_BUFFER);\n        \nm_d3dDevice->CreateBuffer(\n  &vertexBufferDesc,\n  &vertexBufferData,\n  &m_vertexBuffer);\n        \n// ...\n\nUINT stride = sizeof(VertexPositionColor);\nUINT offset = 0;\nm_d3dContext->IASetVertexBuffers(\n  0,\n  1,\n  m_vertexBuffer.GetAddressOf(),\n  &stride,\n  &offset);\n```\n\n### Step 3: Create and load the index buffer\n\nIndex buffers are an efficient way to allow the vertex shader to look up individual vertices. Although they are not required, we use them in this sample renderer. As with vertex buffers in OpenGL ES 2.0, an index buffer is created and bound as a general purpose buffer and the vertex indices you created earlier are copied into it.\n\nWhen you're ready to draw, you bind both the vertex and the index buffer again, and call **glDrawElements**.\n\nOpenGL ES 2.0: Send the index order to the draw call.\n\n``` syntax\nGLuint indexBuffer;\n\n// ...\n\nglGenBuffers(1, &renderer->indexBuffer);    \nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, renderer->indexBuffer);   \nglBufferData(GL_ELEMENT_ARRAY_BUFFER, \n  sizeof(GLuint) * CUBE_INDICES, \n  renderer->vertexIndices, \n  GL_STATIC_DRAW);\n\n// ...\n// Drawing function\n\n// Bind the index buffer\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, renderer->indexBuffer);\nglDrawElements (GL_TRIANGLES, renderer->numIndices, GL_UNSIGNED_INT, 0);\n```\n\nWith Direct3D, it's a bit very similar process, albeit a bit more didactic. Supply the index buffer as a Direct3D subresource to the [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385) you created when you configured Direct3D. You do this by calling [**ID3D11DeviceContext::IASetIndexBuffer**](https://msdn.microsoft.com/library/windows/desktop/bb173588) with the configured subresource for the index array, as follows. (Again, notice that you assign the pointer to the **cubeIndices** array to the **pSysMem** field of the [**D3D11\\_SUBRESOURCE\\_DATA**](https://msdn.microsoft.com/library/windows/desktop/ff476220) structure.)\n\nDirect3D: Create the index buffer.\n\n``` syntax\nm_indexCount = ARRAYSIZE(cubeIndices);\n\nD3D11_SUBRESOURCE_DATA indexBufferData = {0};\nindexBufferData.pSysMem = cubeIndices;\nindexBufferData.SysMemPitch = 0;\nindexBufferData.SysMemSlicePitch = 0;\nCD3D11_BUFFER_DESC indexBufferDesc(sizeof(cubeIndices), D3D11_BIND_INDEX_BUFFER);\n\nm_d3dDevice->CreateBuffer(\n  &indexBufferDesc,\n  &indexBufferData,\n  &m_indexBuffer);\n\n// ...\n\nm_d3dContext->IASetIndexBuffer(\n  m_indexBuffer.Get(),\n  DXGI_FORMAT_R16_UINT,\n  0);\n```\n\nLater, you will draw the triangles with a call to [**ID3D11DeviceContext::DrawIndexed**](https://msdn.microsoft.com/library/windows/desktop/ff476409) (or [**ID3D11DeviceContext::Draw**](https://msdn.microsoft.com/library/windows/desktop/ff476407) for unindexed vertices), as follows. (For more details, jump ahead to [Draw to the screen](draw-to-the-screen.md).)\n\nDirect3D: Draw the indexed vertices.\n\n``` syntax\nm_d3dContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\nm_d3dContext->IASetInputLayout(m_inputLayout.Get());\n\n// ...\n\nm_d3dContext->DrawIndexed(\n  m_indexCount,\n  0,\n  0);\n```\n\n## Previous step\n\n\n[Port the shader objects](port-the-shader-config.md)\n\n## Next step\n\n[Port the GLSL](port-the-glsl.md)\n\n## Remarks\n\nWhen structuring your Direct3D, separate the code that calls methods on [**ID3D11Device**](https://msdn.microsoft.com/library/windows/desktop/ff476379) into a method that is called whenever the device resources need to be recreated. (In the Direct3D project template, this code is in the renderer object's **CreateDeviceResource** methods. The code that updates the device context ([**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385)), on the other hand, is placed in the **Render** method, since this is where you actually construct the shader stages and bind the data.\n\n## Related topics\n\n\n* [How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11](port-a-simple-opengl-es-2-0-renderer-to-directx-11-1.md)\n* [Port the shader objects](port-the-shader-config.md)\n* [Port the vertex buffers and data](port-the-vertex-buffers-and-data-config.md)\n* [Port the GLSL](port-the-glsl.md)\n\n \n\n \n\n\n\n\n"}