{"nodes":[{"pos":[11,46],"content":"Complete code for BasicReaderWriter","needQuote":true,"needEscape":true,"nodes":[{"content":"Complete code for BasicReaderWriter","pos":[0,35]}]},{"pos":[60,151],"content":"Complete code for a class and methods for reading and writing binary data files in general.","needQuote":true,"needEscape":true,"nodes":[{"content":"Complete code for a class and methods for reading and writing binary data files in general.","pos":[0,91]}]},{"content":"Complete code for BasicReaderWriter","pos":[208,243]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[246,284]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[285,380],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Complete code for a class and methods for reading and writing binary data files in general.","pos":[382,473]},{"content":"Used by the <bpt id=\"p1\">[</bpt>BasicLoader<ept id=\"p1\">](complete-code-for-basicloader.md)</ept> class.","pos":[474,540],"source":" Used by the [BasicLoader](complete-code-for-basicloader.md) class."},{"content":"This topic contains these sections:","pos":[542,577]},{"content":"Technologies","pos":[584,596]},{"content":"Requirements","pos":[618,630]},{"content":"View the code (C++)","pos":[652,671]},{"content":"Download location","pos":[697,714]},{"content":"This sample is not available for download.","pos":[716,758]},{"content":"Technologies","pos":[764,776]},{"content":"Programming languages","pos":[868,889]},{"content":"C++","pos":[892,895]},{"content":"Programming models","pos":[912,930]},{"content":"Windows Runtime","pos":[936,951]},{"content":"Requirements","pos":[959,971]},{"content":"Minimum supported client","pos":[975,999]},{"content":"Windows 10","pos":[1002,1012]},{"content":"Minimum supported server","pos":[1113,1137]},{"content":"Windows Server 2016 Technical Preview","pos":[1140,1177]},{"content":"Minimum required SDK","pos":[1182,1202]},{"content":"View the code (C++)","pos":[1254,1273]},{"content":"BasicReaderWriter.h","pos":[1279,1298]},{"content":"BasicReaderWriter.cpp","pos":[2529,2550]}],"content":"---\ntitle: Complete code for BasicReaderWriter\ndescription: Complete code for a class and methods for reading and writing binary data files in general.\nms.assetid: af968edd-df5c-b8e6-479e-bfa9689380fc\n---\n\n# Complete code for BasicReaderWriter\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nComplete code for a class and methods for reading and writing binary data files in general. Used by the [BasicLoader](complete-code-for-basicloader.md) class.\n\nThis topic contains these sections:\n\n-   [Technologies](#technologies)\n-   [Requirements](#requirements)\n-   [View the code (C++)](#view-the-code-c-)\n\n\n## Download location\n\nThis sample is not available for download.\n\n\n## Technologies\n\n|                       |                 |\n|-----------------------|-----------------|\n| Programming languages | C++             |\n| Programming models    | Windows Runtime |\n\n\n## Requirements\n\n| Minimum supported client | Windows 10                            |\n|--------------------------|---------------------------------------|\n| Minimum supported server | Windows Server 2016 Technical Preview |\n| Minimum required SDK     |                                       |\n\n\n## View the code (C++)\n\n\n## BasicReaderWriter.h\n\n\n```cpp\n//// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF\n//// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n//// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A\n//// PARTICULAR PURPOSE.\n////\n//// Copyright (c) Microsoft Corporation. All rights reserved\n\n#pragma once\n\n#include <ppltasks.h>\n\n// A simple reader/writer class that provides support for reading and writing\n// files on disk. Provides synchronous and asynchronous methods.\nref class BasicReaderWriter\n{\nprivate:\n    Windows::Storage::StorageFolder^ m_location;\n    Platform::String^ m_locationPath;\n\ninternal:\n    BasicReaderWriter();\n    BasicReaderWriter(\n        _In_ Windows::Storage::StorageFolder^ folder\n        );\n\n    Platform::Array<byte>^ ReadData(\n        _In_ Platform::String^ filename\n        );\n\n    concurrency::task<Platform::Array<byte>^> ReadDataAsync(\n        _In_ Platform::String^ filename\n        );\n\n    uint32 WriteData(\n        _In_ Platform::String^ filename,\n        _In_ const Platform::Array<byte>^ fileData\n        );\n\n    concurrency::task<void> WriteDataAsync(\n        _In_ Platform::String^ filename,\n        _In_ const Platform::Array<byte>^ fileData\n        );\n};\n```\n\n## BasicReaderWriter.cpp\n\n\n```cpp\nusing namespace Microsoft::WRL;\nusing namespace Windows::Storage;\nusing namespace Windows::Storage::FileProperties;\nusing namespace Windows::Storage::Streams;\nusing namespace Windows::Foundation;\nusing namespace Windows::ApplicationModel;\nusing namespace concurrency;\n\nBasicReaderWriter::BasicReaderWriter()\n{\n    m_location = Package::Current->InstalledLocation;\n    m_locationPath = Platform::String::Concat(m_location->Path, \"\\\\\");\n}\n\nBasicReaderWriter::BasicReaderWriter(\n    _In_ Windows::Storage::StorageFolder^ folder\n    )\n{\n    m_location = folder;\n    Platform::String^ path = m_location->Path;\n    if (path->Length() == 0)\n    {\n        // Applications are not permitted to access certain\n        // folders, such as the Documents folder, using this\n        // code path.  In such cases, the Path property for\n        // the folder will be an empty string.\n        throw ref new Platform::FailureException();\n    }\n    m_locationPath = Platform::String::Concat(path, \"\\\\\");\n}\n\nPlatform::Array<byte>^ BasicReaderWriter::ReadData(\n    _In_ Platform::String^ filename\n    )\n{\n    CREATEFILE2_EXTENDED_PARAMETERS extendedParams = {0};\n    extendedParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);\n    extendedParams.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;\n    extendedParams.dwFileFlags = FILE_FLAG_SEQUENTIAL_SCAN;\n    extendedParams.dwSecurityQosFlags = SECURITY_ANONYMOUS;\n    extendedParams.lpSecurityAttributes = nullptr;\n    extendedParams.hTemplateFile = nullptr;\n\n    Wrappers::FileHandle file(\n        CreateFile2(\n            Platform::String::Concat(m_locationPath, filename)->Data(),\n            GENERIC_READ,\n            FILE_SHARE_READ,\n            OPEN_EXISTING,\n            &extendedParams\n            )\n        );\n    if (file.Get() == INVALID_HANDLE_VALUE)\n    {\n        throw ref new Platform::FailureException();\n    }\n\n    FILE_STANDARD_INFO fileInfo = {0};\n    if (!GetFileInformationByHandleEx(\n        file.Get(),\n        FileStandardInfo,\n        &fileInfo,\n        sizeof(fileInfo)\n        ))\n    {\n        throw ref new Platform::FailureException();\n    }\n\n    if (fileInfo.EndOfFile.HighPart != 0)\n    {\n        throw ref new Platform::OutOfMemoryException();\n    }\n\n    Platform::Array<byte>^ fileData = ref new Platform::Array<byte>(fileInfo.EndOfFile.LowPart);\n\n    if (!ReadFile(\n        file.Get(),\n        fileData->Data,\n        fileData->Length,\n        nullptr,\n        nullptr\n        ))\n    {\n        throw ref new Platform::FailureException();\n    }\n\n    return fileData;\n}\n\ntask<Platform::Array<byte>^> BasicReaderWriter::ReadDataAsync(\n    _In_ Platform::String^ filename\n    )\n{\n    return task<StorageFile^>(m_location->GetFileAsync(filename)).then([=](StorageFile^ file)\n    {\n        return FileIO::ReadBufferAsync(file);\n    }).then([=](IBuffer^ buffer)\n    {\n        auto fileData = ref new Platform::Array<byte>(buffer->Length);\n        DataReader::FromBuffer(buffer)->ReadBytes(fileData);\n        return fileData;\n    });\n}\n\nuint32 BasicReaderWriter::WriteData(\n    _In_ Platform::String^ filename,\n    _In_ const Platform::Array<byte>^ fileData\n    )\n{\n    CREATEFILE2_EXTENDED_PARAMETERS extendedParams = {0};\n    extendedParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);\n    extendedParams.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;\n    extendedParams.dwFileFlags = FILE_FLAG_SEQUENTIAL_SCAN;\n    extendedParams.dwSecurityQosFlags = SECURITY_ANONYMOUS;\n    extendedParams.lpSecurityAttributes = nullptr;\n    extendedParams.hTemplateFile = nullptr;\n\n    Wrappers::FileHandle file(\n        CreateFile2(\n            Platform::String::Concat(m_locationPath, filename)->Data(),\n            GENERIC_WRITE,\n            0,\n            CREATE_ALWAYS,\n            &extendedParams\n            )\n        );\n    if (file.Get() == INVALID_HANDLE_VALUE)\n    {\n        throw ref new Platform::FailureException();\n    }\n\n    DWORD numBytesWritten;\n    if (\n        !WriteFile(\n            file.Get(),\n            fileData->Data,\n            fileData->Length,\n            &numBytesWritten,\n            nullptr\n            ) ||\n        numBytesWritten != fileData->Length\n        )\n    {\n        throw ref new Platform::FailureException();\n    }\n\n    return numBytesWritten;\n}\n\ntask<void> BasicReaderWriter::WriteDataAsync(\n    _In_ Platform::String^ filename,\n    _In_ const Platform::Array<byte>^ fileData\n    )\n{\n    return task<StorageFile^>(m_location->CreateFileAsync(filename, CreationCollisionOption::ReplaceExisting)).then([=](StorageFile^ file)\n    {\n        FileIO::WriteBytesAsync(file, fileData);\n    });\n}\n```\n\n \n\n \n\n\n\n\n"}