{"nodes":[{"pos":[17,140],"content":"Explains how to define and implement custom dependency properties for a Windows Runtime app using C++, C#, or Visual Basic.","needQuote":true,"needEscape":true,"nodes":[{"content":"Explains how to define and implement custom dependency properties for a Windows Runtime app using C++, C#, or Visual Basic.","pos":[0,123]}]},{"pos":[148,176],"content":"Custom dependency properties","needQuote":true,"needEscape":true,"nodes":[{"content":"Custom dependency properties","pos":[0,28]}]},{"content":"Custom dependency properties","pos":[233,261]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[263,301]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[302,397],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Here we explain how to define and implement your own dependency properties for a Windows Runtime app using C++, C#, or Visual Basic.","pos":[399,531]},{"content":"We list reasons why app developers and component authors might want to create custom dependency properties.","pos":[532,639]},{"content":"We describe the implementation steps for a custom dependency property, as well as some best practices that can improve performance, usability, or versatility of the dependency property.","pos":[640,825]},{"content":"Prerequisites","pos":[830,843]},{"content":"We assume that you have read the <bpt id=\"p1\">[</bpt>Dependency properties overview<ept id=\"p1\">](dependency-properties-overview.md)</ept> and that you understand dependency properties from the perspective of a consumer of existing dependency properties.","pos":[846,1062],"source":"We assume that you have read the [Dependency properties overview](dependency-properties-overview.md) and that you understand dependency properties from the perspective of a consumer of existing dependency properties."},{"content":"To follow the examples in this topic, you should also understand XAML and know how to write a basic Windows Runtime app using C++, C#, or Visual Basic.","pos":[1063,1214]},{"content":"What is a dependency property?","pos":[1219,1249]},{"content":"Dependency properties are properties that are registered with the Windows Runtime property system by calling the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyProperty.Register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept> method, and that are identified by a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DependencyProperty<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br242362)</ept> identifier member on the defining class.","pos":[1252,1617],"source":"Dependency properties are properties that are registered with the Windows Runtime property system by calling the [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) method, and that are identified by a [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) identifier member on the defining class."},{"content":"You can enable what would otherwise be a common language runtime (CLR) or C++ property to support styling, data binding, animations, and default values by implementing it as a dependency property.","pos":[1618,1814]},{"content":"Dependency properties can be used only by <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyObject<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept> types.","pos":[1815,1944],"source":" Dependency properties can be used only by [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) types."},{"content":"But <bpt id=\"p1\">**</bpt>DependencyObject<ept id=\"p1\">**</ept> is quite high in the class hierarchy, so the majority of classes that are intended for UI and presentation support can support dependency properties.","pos":[1945,2119],"source":" But **DependencyObject** is quite high in the class hierarchy, so the majority of classes that are intended for UI and presentation support can support dependency properties."},{"content":"For more information about dependency properties and some of the terminology and conventions used for describing them in this documentation, see <bpt id=\"p1\">[</bpt>Dependency properties overview<ept id=\"p1\">](dependency-properties-overview.md)</ept>.","pos":[2120,2333],"source":" For more information about dependency properties and some of the terminology and conventions used for describing them in this documentation, see [Dependency properties overview](dependency-properties-overview.md)."},{"content":"Examples of dependency properties in the Windows Runtime are: <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Control.Background<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209395)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>FrameworkElement.Width<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208751)</ept>, and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>TextBox.Text<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br209702)</ept>, among many others.","pos":[2335,2669],"source":"Examples of dependency properties in the Windows Runtime are: [**Control.Background**](https://msdn.microsoft.com/library/windows/apps/br209395), [**FrameworkElement.Width**](https://msdn.microsoft.com/library/windows/apps/br208751), and [**TextBox.Text**](https://msdn.microsoft.com/library/windows/apps/br209702), among many others."},{"content":"Each dependency property exposed by a class has a corresponding <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>static<ept id=\"p2\">**</ept> <bpt id=\"p3\">**</bpt>readonly<ept id=\"p3\">**</ept> property of type <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>DependencyProperty<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br242362)</ept> that is exposed on that same class and that is the identifier for the dependency property.","pos":[2670,2959],"source":" Each dependency property exposed by a class has a corresponding **public** **static** **readonly** property of type [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) that is exposed on that same class and that is the identifier for the dependency property."},{"content":"The identifier's name follows this convention: the name of the dependency property, with the string \"Property\" added to the end of the name.","pos":[2960,3100]},{"content":"For example, the corresponding <bpt id=\"p1\">**</bpt>DependencyProperty<ept id=\"p1\">**</ept> identifier for the <bpt id=\"p2\">**</bpt>Control.Background<ept id=\"p2\">**</ept> property is <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Control.BackgroundProperty<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br209396)</ept>.","pos":[3101,3300],"source":" For example, the corresponding **DependencyProperty** identifier for the **Control.Background** property is [**Control.BackgroundProperty**](https://msdn.microsoft.com/library/windows/apps/br209396)."},{"content":"The identifier stores the information about the dependency property as it was registered, and the identifier can then be used later for other operations involving the dependency property, such as calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SetValue<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242361)</ept>.","pos":[3301,3578],"source":" The identifier stores the information about the dependency property as it was registered, and the identifier can then be used later for other operations involving the dependency property, such as calling [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361)."},{"content":"Property wrappers","pos":[3584,3601]},{"content":"Dependency properties typically have a wrapper implementation.","pos":[3603,3665]},{"content":"Without the wrapper, the only way to get or set the properties would be to use the dependency property utility methods <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>GetValue<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242359)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>SetValue<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br242361)</ept> and to pass the identifier to them as a parameter.","pos":[3666,3985],"source":" Without the wrapper, the only way to get or set the properties would be to use the dependency property utility methods [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) and [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) and to pass the identifier to them as a parameter."},{"content":"This is a rather unnatural usage for something that is ostensibly a property.","pos":[3986,4063]},{"content":"But with the wrapper, your code and any other code that references the dependency property can use a straightforward object-property syntax that is natural for the language you're using.","pos":[4064,4250]},{"content":"If you implement a custom dependency property yourself and want it to be public and easy to call, define the property wrappers too.","pos":[4252,4383]},{"content":"The property wrappers are also useful for reporting basic information about the dependency property to reflection or static analysis processes.","pos":[4384,4527]},{"content":"Specifically, the wrapper is where you place attributes such as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ContentPropertyAttribute<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br228011)</ept>.","pos":[4528,4681],"source":" Specifically, the wrapper is where you place attributes such as [**ContentPropertyAttribute**](https://msdn.microsoft.com/library/windows/apps/br228011)."},{"content":"When to implement a property as a dependency property","pos":[4686,4739]},{"content":"Whenever you implement a public read/write property on a class, as long as your class derives from <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyObject<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>, you have the option to make your property work as a dependency property.","pos":[4741,4994],"source":"Whenever you implement a public read/write property on a class, as long as your class derives from [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356), you have the option to make your property work as a dependency property."},{"content":"Sometimes the typical technique of backing your property with a private field is adequate.","pos":[4995,5085]},{"content":"Defining your custom property as a dependency property is not always necessary or appropriate.","pos":[5086,5180]},{"content":"The choice will depend on the scenarios that you intend your property to support.","pos":[5181,5262]},{"content":"You might consider implementing your property as a dependency property when you want it to support one or more of these features of the Windows Runtime or of Windows Runtime apps:","pos":[5264,5443]},{"pos":[5449,5549],"content":"Setting the property through a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Style<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208849)</ept>","source":"Setting the property through a [**Style**](https://msdn.microsoft.com/library/windows/apps/br208849)"},{"content":"Acting as valid target property for data binding","pos":[5554,5602]},{"pos":[5607,5718],"content":"Supporting animated values through a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Storyboard<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br210490)</ept>","source":"Supporting animated values through a [**Storyboard**](https://msdn.microsoft.com/library/windows/apps/br210490)"},{"content":"Reporting when the previous value of the property has been changed by:","pos":[5723,5793]},{"content":"Actions taken by the property system itself","pos":[5802,5845]},{"content":"The environment","pos":[5854,5869]},{"content":"User actions","pos":[5878,5890]},{"content":"Reading and writing styles","pos":[5899,5925]},{"content":"Checklist for defining a dependency property","pos":[5930,5974]},{"content":"Defining a dependency property can be thought of as a set of concepts.","pos":[5976,6046]},{"content":"These concepts are not necessarily procedural steps, because several concepts can be addressed in a single line of code in the implementation.","pos":[6047,6189]},{"content":"This list gives just a quick overview.","pos":[6190,6228]},{"content":"We'll explain each concept in more detail later in this topic, and we'll show you example code in several languages.","pos":[6229,6345]},{"content":"(Optional) Create property metadata for the dependency property.","pos":[6351,6415]},{"content":"You need property metadata only if you want property-changed behavior, or a metadata-based default value that can be restored by calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ClearValue<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242357)</ept>.","pos":[6416,6628],"source":" You need property metadata only if you want property-changed behavior, or a metadata-based default value that can be restored by calling [**ClearValue**](https://msdn.microsoft.com/library/windows/apps/br242357)."},{"content":"Register the property name with the property system (call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept>), specifying an owner type and the type of the property value.","pos":[6633,6826],"source":"Register the property name with the property system (call [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)), specifying an owner type and the type of the property value."},{"content":"There's a required parameter for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept> that expects property metadata.","pos":[6827,6964],"source":" There's a required parameter for [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) that expects property metadata."},{"content":"Specify <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept> for this, or specify the actual property metadata if you have declared any.","pos":[6965,7057],"source":" Specify **null** for this, or specify the actual property metadata if you have declared any."},{"pos":[7062,7239],"content":"Define a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyProperty<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242362)</ept> identifier as a <bpt id=\"p3\">**</bpt>public<ept id=\"p3\">**</ept> <bpt id=\"p4\">**</bpt>static<ept id=\"p4\">**</ept> <bpt id=\"p5\">**</bpt>readonly<ept id=\"p5\">**</ept> property member on the owner type.","source":"Define a [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) identifier as a **public** **static** **readonly** property member on the owner type."},{"content":"Define a wrapper property, following the property accessor model that's used in the language you are implementing.","pos":[7244,7358]},{"content":"The wrapper property name should match the <bpt id=\"p1\">*</bpt>name<ept id=\"p1\">*</ept> string that you used in <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Register<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept>.","pos":[7359,7506],"source":" The wrapper property name should match the *name* string that you used in [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)."},{"content":"Implement the <bpt id=\"p1\">**</bpt>get<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>set<ept id=\"p2\">**</ept> accessors to connect the wrapper with the dependency property that it wraps, by calling <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>GetValue<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br242359)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>SetValue<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br242361)</ept> and passing your own property's identifier as a parameter.","pos":[7507,7837],"source":" Implement the **get** and **set** accessors to connect the wrapper with the dependency property that it wraps, by calling [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) and [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) and passing your own property's identifier as a parameter."},{"pos":[7842,7982],"content":"(Optional) Place attributes such as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ContentPropertyAttribute<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br228011)</ept> on the wrapper.","source":"(Optional) Place attributes such as [**ContentPropertyAttribute**](https://msdn.microsoft.com/library/windows/apps/br228011) on the wrapper."},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  If you are defining a custom attached property, you generally omit the wrapper.","pos":[7984,8073],"source":"**Note**  If you are defining a custom attached property, you generally omit the wrapper."},{"content":"Instead, you write a different style of accessor that a XAML processor can use.","pos":[8074,8153]},{"content":"See <bpt id=\"p1\">[</bpt>Custom attached properties<ept id=\"p1\">](custom-attached-properties.md)</ept>.","pos":[8154,8218],"source":" See [Custom attached properties](custom-attached-properties.md)."},{"content":"Registering the property","pos":[8224,8248]},{"content":"For your property to be a dependency property, you must register the property into a property store maintained by the Windows Runtime property system.","pos":[8250,8400]},{"content":"You must give the property a unique identifier to be used as the qualifier for later property-system operations.","pos":[8401,8513]},{"content":"These operations might be internal operations, or your own code calling property-system APIs.","pos":[8514,8607]},{"content":"To register the property, you call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept> method.","pos":[8608,8727],"source":" To register the property, you call the [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) method."},{"content":"For Microsoft .NET languages (C# and Microsoft Visual Basic) you call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept> within the body of your class (inside the class, but outside any member definitions).","pos":[8729,8957],"source":"For Microsoft .NET languages (C# and Microsoft Visual Basic) you call [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) within the body of your class (inside the class, but outside any member definitions)."},{"content":"The identifier is also provided by the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept> method call, as the return value.","pos":[8958,9103],"source":" The identifier is also provided by the [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) method call, as the return value."},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept> call is typically made outside of other member definitions because you use the return value to assign and create a <bpt id=\"p3\">**</bpt>public<ept id=\"p3\">**</ept> <bpt id=\"p4\">**</bpt>static<ept id=\"p4\">**</ept> <bpt id=\"p5\">**</bpt>readonly<ept id=\"p5\">**</ept> property of type <bpt id=\"p6\">[</bpt><bpt id=\"p7\">**</bpt>DependencyProperty<ept id=\"p7\">**</ept><ept id=\"p6\">](https://msdn.microsoft.com/library/windows/apps/br242362)</ept> as part of your class.","pos":[9104,9453],"source":" The [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) call is typically made outside of other member definitions because you use the return value to assign and create a **public** **static** **readonly** property of type [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) as part of your class."},{"content":"This property becomes the identifier for your dependency property.","pos":[9454,9520]},{"content":"Here are examples of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept> call.","pos":[9521,9624],"source":" Here are examples of the [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) call."},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  Registering the dependency property in a class body is the typical implementation, but you can also register a dependency property in the class static constructor.","pos":[10072,10245],"source":"**Note**  Registering the dependency property in a class body is the typical implementation, but you can also register a dependency property in the class static constructor."},{"content":"This approach may make sense if you need more than one line of code to initialize the dependency property.","pos":[10246,10352]},{"content":"For C++, you have options for how you split the implementation between the header and the code file.","pos":[10354,10454]},{"content":"The typical split is to declare the identifier itself as <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>static<ept id=\"p2\">**</ept> property in the header, with a <bpt id=\"p3\">**</bpt>get<ept id=\"p3\">**</ept> implementation but no <bpt id=\"p4\">**</bpt>set<ept id=\"p4\">**</ept>.","pos":[10455,10603],"source":" The typical split is to declare the identifier itself as **public** **static** property in the header, with a **get** implementation but no **set**."},{"content":"The <bpt id=\"p1\">**</bpt>get<ept id=\"p1\">**</ept> implementation refers to a private field, which is an uninitialized <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>DependencyProperty<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br242362)</ept> instance.","pos":[10604,10776],"source":" The **get** implementation refers to a private field, which is an uninitialized [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) instance."},{"content":"You can also declare the wrappers and the <bpt id=\"p1\">**</bpt>get<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>set<ept id=\"p2\">**</ept> implementations of the wrapper.","pos":[10777,10870],"source":" You can also declare the wrappers and the **get** and **set** implementations of the wrapper."},{"content":"In this case the header includes some minimal implementation.","pos":[10871,10932]},{"content":"If the wrapper needs Windows Runtime attribution, attribute in the header too.","pos":[10933,11011]},{"content":"Put the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept> call in the code file, within a helper function that only gets run when the app initializes the first time.","pos":[11012,11200],"source":" Put the [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) call in the code file, within a helper function that only gets run when the app initializes the first time."},{"content":"Use the return value of <bpt id=\"p1\">**</bpt>Register<ept id=\"p1\">**</ept> to fill the static but uninitialized identifiers that you declared in the header, which you initially set to <bpt id=\"p2\">**</bpt>nullptr<ept id=\"p2\">**</ept> at the root scope of the implementation file.","pos":[11201,11404],"source":" Use the return value of **Register** to fill the static but uninitialized identifiers that you declared in the header, which you initially set to **nullptr** at the root scope of the implementation file."},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  For the C++ code, the reason why you have a private field and a public read-only property that surfaces the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>DependencyProperty<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br242362)</ept> is so that other callers who use your dependency property can also use property-system utility APIs that require the identifier to be public.","pos":[12432,12774],"source":"**Note**  For the C++ code, the reason why you have a private field and a public read-only property that surfaces the [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) is so that other callers who use your dependency property can also use property-system utility APIs that require the identifier to be public."},{"content":"If you keep the identifier private, people can't use these utility APIs.","pos":[12775,12847]},{"content":"Examples of such API and scenarios include <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>GetValue<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242359)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>SetValue<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br242361)</ept> by choice, <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ClearValue<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br242357)</ept>, <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>GetAnimationBaseValue<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/br242358)</ept>, <bpt id=\"p9\">[</bpt><bpt id=\"p10\">**</bpt>SetBinding<ept id=\"p10\">**</ept><ept id=\"p9\">](https://msdn.microsoft.com/library/windows/apps/br244257)</ept>, and <bpt id=\"p11\">[</bpt><bpt id=\"p12\">**</bpt>Setter.Property<ept id=\"p12\">**</ept><ept id=\"p11\">](https://msdn.microsoft.com/library/windows/apps/br208836)</ept>.","pos":[12848,13374],"source":" Examples of such API and scenarios include [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) or [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) by choice, [**ClearValue**](https://msdn.microsoft.com/library/windows/apps/br242357), [**GetAnimationBaseValue**](https://msdn.microsoft.com/library/windows/apps/br242358), [**SetBinding**](https://msdn.microsoft.com/library/windows/apps/br244257), and [**Setter.Property**](https://msdn.microsoft.com/library/windows/apps/br208836)."},{"content":"You can't use a public field for this, because Windows Runtime compile rules don't allow public data members that use reference types like <bpt id=\"p1\">**</bpt>DependencyProperty<ept id=\"p1\">**</ept>.","pos":[13375,13537],"source":" You can't use a public field for this, because Windows Runtime compile rules don't allow public data members that use reference types like **DependencyProperty**."},{"content":"Dependency property name conventions","pos":[13542,13578]},{"content":"There are naming conventions for dependency properties; follow them in all but exceptional circumstances.","pos":[13580,13685]},{"content":"The dependency property itself has a basic name (\"Label\" in the preceding example) that is given as the first parameter of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept>.","pos":[13686,13882],"source":" The dependency property itself has a basic name (\"Label\" in the preceding example) that is given as the first parameter of [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)."},{"content":"The name must be unique within each registering type, and the uniqueness requirement also applies to any inherited members.","pos":[13883,14006]},{"content":"Dependency properties inherited through base types are considered to be part of the registering type already; names of inherited properties cannot be registered again.","pos":[14007,14174]},{"content":"<bpt id=\"p1\">**</bpt>Caution<ept id=\"p1\">**</ept>  Although the name you provide here can be any string identifier that is valid in programming for your language of choice, you usually want to be able to set your dependency property in XAML too.","pos":[14176,14383],"source":"**Caution**  Although the name you provide here can be any string identifier that is valid in programming for your language of choice, you usually want to be able to set your dependency property in XAML too."},{"content":"To be set in XAML, the property name you choose must be a valid XAML name.","pos":[14384,14458]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>XAML overview<ept id=\"p1\">](xaml-overview.md)</ept>.","pos":[14459,14512],"source":" For more info, see [XAML overview](xaml-overview.md)."},{"content":"When you create the identifier property, combine the name of the property as you registered it with the suffix \"Property\" (\"LabelProperty\", for example).","pos":[14514,14667]},{"content":"This property is your identifier for the dependency property, and it is used as an input for the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SetValue<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242361)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>GetValue<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br242359)</ept> calls you make in your own property wrappers.","pos":[14668,14960],"source":" This property is your identifier for the dependency property, and it is used as an input for the [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) and [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) calls you make in your own property wrappers."},{"content":"It is also used by the property system and potentially by XAML processors.","pos":[14961,15035]},{"content":"Implementing the wrapper","pos":[15040,15064]},{"pos":[15066,15311],"content":"Your property wrapper should call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>GetValue<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242359)</ept> in the <bpt id=\"p3\">**</bpt>get<ept id=\"p3\">**</ept> implementation, and <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>SetValue<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br242361)</ept> in the <bpt id=\"p6\">**</bpt>set<ept id=\"p6\">**</ept> implementation.","source":"Your property wrapper should call [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) in the **get** implementation, and [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) in the **set** implementation."},{"content":"<bpt id=\"p1\">**</bpt>Caution<ept id=\"p1\">**</ept>  In all but exceptional circumstances, your wrapper implementations should perform only the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>GetValue<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br242359)</ept> and <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>SetValue<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br242361)</ept> operations.","pos":[15313,15578],"source":"**Caution**  In all but exceptional circumstances, your wrapper implementations should perform only the [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) and [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) operations."},{"content":"Otherwise, you'll get different behavior when your property is set via XAML versus when it is set via code.","pos":[15579,15686]},{"content":"For efficiency, the XAML parser bypasses wrappers when setting dependency properties; whenever possible, it uses the registry of dependency properties.","pos":[15687,15838]},{"content":"Property metadata for a custom dependency property","pos":[16471,16521]},{"content":"When property metadata is assigned to a dependency property, the same metadata is applied to that property for any instance of the property-owner type or its subclasses.","pos":[16523,16692]},{"content":"In property metadata, you can specify two behaviors:","pos":[16693,16745]},{"content":"A default value that the property system assigns to all cases of the property.","pos":[16751,16829]},{"content":"A static callback method that is automatically invoked within the property system whenever a property value is detected.","pos":[16834,16954]},{"content":"Calling Register with property metadata","pos":[16960,16999]},{"content":"In the previous examples of calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyProperty.Register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept>, we passed a null value for the <bpt id=\"p3\">*</bpt>propertyMetadata<ept id=\"p3\">*</ept> parameter.","pos":[17001,17190],"source":"In the previous examples of calling [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829), we passed a null value for the *propertyMetadata* parameter."},{"content":"To enable a dependency property to provide a default value or use a property-changed callback, you must define a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PropertyMetadata<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208771)</ept> instance that provides one or both of these capabilities.","pos":[17191,17442],"source":" To enable a dependency property to provide a default value or use a property-changed callback, you must define a [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) instance that provides one or both of these capabilities."},{"pos":[17444,17698],"content":"Typically you provide a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PropertyMetadata<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208771)</ept> as an inline-created instance, within the parameters for <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DependencyProperty.Register<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept>.","source":"Typically you provide a [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) as an inline-created instance, within the parameters for [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)."},{"pos":[17700,18118],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  If you are defining a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>CreateDefaultValueCallback<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh701812)</ept> implementation, you must use the utility method <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>PropertyMetadata.Create<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/hh702099)</ept> rather than calling a <bpt id=\"p6\">[</bpt><bpt id=\"p7\">**</bpt>PropertyMetadata<ept id=\"p7\">**</ept><ept id=\"p6\">](https://msdn.microsoft.com/library/windows/apps/br208771)</ept> constructor to define the <bpt id=\"p8\">**</bpt>PropertyMetadata<ept id=\"p8\">**</ept> instance.","source":"**Note**  If you are defining a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) implementation, you must use the utility method [**PropertyMetadata.Create**](https://msdn.microsoft.com/library/windows/apps/hh702099) rather than calling a [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) constructor to define the **PropertyMetadata** instance."},{"content":"This next example modifies the previously shown <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyProperty.Register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept> examples by referencing a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>PropertyMetadata<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208771)</ept> instance with a <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>PropertyChangedCallback<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208770)</ept> value.","pos":[18120,18477],"source":"This next example modifies the previously shown [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) examples by referencing a [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) instance with a [**PropertyChangedCallback**](https://msdn.microsoft.com/library/windows/apps/br208770) value."},{"content":"The implementation of the \"OnLabelChanged\" callback will be shown later in this section.","pos":[18478,18566]},{"content":"Default value","pos":[19435,19448]},{"content":"You can specify a default value for a dependency property such that the property always returns a particular default value when it is unset.","pos":[19450,19590]},{"content":"This value can be different than the inherent default value for the type of that property.","pos":[19591,19681]},{"content":"If a default value is not specified, the default value for a dependency property is null for a reference type, or the default of the type for a value type or language primitive (for example, 0 for an integer or an empty string for a string).","pos":[19683,19924]},{"content":"The main reason for establishing a default value is that this value is restored when you call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ClearValue<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242357)</ept> on the property.","pos":[19925,20110],"source":" The main reason for establishing a default value is that this value is restored when you call [**ClearValue**](https://msdn.microsoft.com/library/windows/apps/br242357) on the property."},{"content":"Establishing a default value on a per-property basis might be more convenient than establishing default values in constructors, particularly for value types.","pos":[20111,20268]},{"content":"However, for reference types, make sure that establishing a default value does not create an unintentional singleton pattern.","pos":[20269,20394]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Best practices<ept id=\"p1\">](#best-practices)</ept> later in this topic","pos":[20395,20467],"source":" For more info, see [Best practices](#best-practices) later in this topic"},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  Do not register with a default value of <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>UnsetValue<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br242371)</ept>.","pos":[20469,20594],"source":"**Note**  Do not register with a default value of [**UnsetValue**](https://msdn.microsoft.com/library/windows/apps/br242371)."},{"content":"If you do, it will confuse property consumers and will have unintended consequences within the property system.","pos":[20595,20706]},{"content":"CreateDefaultValueCallback","pos":[20712,20738]},{"content":"In some scenarios, you are defining dependency properties for objects that are used on more than one UI thread.","pos":[20740,20851]},{"content":"This might be the case if you are defining a data object that is used by multiple apps, or a control that you use in more than one app.","pos":[20852,20987]},{"content":"You can enable the exchange of the object between different UI threads by providing a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CreateDefaultValueCallback<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701812)</ept> implementation rather than a default value instance, which is tied to the thread that registered the property.","pos":[20988,21275],"source":" You can enable the exchange of the object between different UI threads by providing a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) implementation rather than a default value instance, which is tied to the thread that registered the property."},{"content":"Basically a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CreateDefaultValueCallback<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701812)</ept> defines a factory for default values.","pos":[21276,21416],"source":" Basically a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) defines a factory for default values."},{"content":"The value returned by <bpt id=\"p1\">**</bpt>CreateDefaultValueCallback<ept id=\"p1\">**</ept> is always associated with the current UI <bpt id=\"p2\">**</bpt>CreateDefaultValueCallback<ept id=\"p2\">**</ept> thread that is using the object.","pos":[21417,21574],"source":" The value returned by **CreateDefaultValueCallback** is always associated with the current UI **CreateDefaultValueCallback** thread that is using the object."},{"pos":[21576,22016],"content":"To define metadata that specifies a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CreateDefaultValueCallback<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701812)</ept>, you must call <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>PropertyMetadata.Create<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh702115)</ept> to return a metadata instance; the <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>PropertyMetadata<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208771)</ept> constructors do not have a signature that includes a <bpt id=\"p7\">**</bpt>CreateDefaultValueCallback<ept id=\"p7\">**</ept> parameter.","source":"To define metadata that specifies a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812), you must call [**PropertyMetadata.Create**](https://msdn.microsoft.com/library/windows/apps/hh702115) to return a metadata instance; the [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) constructors do not have a signature that includes a **CreateDefaultValueCallback** parameter."},{"pos":[22018,22482],"content":"The typical implementation pattern for a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CreateDefaultValueCallback<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701812)</ept> is to create a new <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DependencyObject<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept> class, set the specific property value of each property of the <bpt id=\"p5\">**</bpt>DependencyObject<ept id=\"p5\">**</ept> to the intended default, and then return the new class as an <bpt id=\"p6\">**</bpt>Object<ept id=\"p6\">**</ept> reference via the return value of the <bpt id=\"p7\">**</bpt>CreateDefaultValueCallback<ept id=\"p7\">**</ept> method.","source":"The typical implementation pattern for a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) is to create a new [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) class, set the specific property value of each property of the **DependencyObject** to the intended default, and then return the new class as an **Object** reference via the return value of the **CreateDefaultValueCallback** method."},{"content":"Property-changed callback method","pos":[22488,22520]},{"content":"You can define a property-changed callback method to define your property's interactions with other dependency properties, or to set an internal property or state of your object whenever the property changes.","pos":[22522,22730]},{"content":"If your callback is invoked, the property system has determined that there is an effective property value change.","pos":[22731,22844]},{"content":"Because the callback method is static, the <bpt id=\"p1\">*</bpt>d<ept id=\"p1\">*</ept> parameter of the callback is important because it tells you which instance of the class has reported a change.","pos":[22845,23002],"source":" Because the callback method is static, the *d* parameter of the callback is important because it tells you which instance of the class has reported a change."},{"content":"A typical implementation uses the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>NewValue<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242364)</ept> property of the event data and processes that value in some manner, usually by performing some other change on the object passed as <bpt id=\"p3\">*</bpt>d<ept id=\"p3\">*</ept>.","pos":[23003,23246],"source":" A typical implementation uses the [**NewValue**](https://msdn.microsoft.com/library/windows/apps/br242364) property of the event data and processes that value in some manner, usually by performing some other change on the object passed as *d*."},{"content":"Additional responses to a property change are to reject the value reported by <bpt id=\"p1\">**</bpt>NewValue<ept id=\"p1\">**</ept>, to restore <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>OldValue<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br242365)</ept>, or to set the value to a programmatic constraint applied to the <bpt id=\"p4\">**</bpt>NewValue<ept id=\"p4\">**</ept>.","pos":[23247,23501],"source":" Additional responses to a property change are to reject the value reported by **NewValue**, to restore [**OldValue**](https://msdn.microsoft.com/library/windows/apps/br242365), or to set the value to a programmatic constraint applied to the **NewValue**."},{"content":"This next example shows a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PropertyChangedCallback<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208770)</ept> implementation.","pos":[23503,23632],"source":"This next example shows a [**PropertyChangedCallback**](https://msdn.microsoft.com/library/windows/apps/br208770) implementation."},{"content":"It implements the method you saw referenced in the previous <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept> examples, as part of the construction arguments for the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>PropertyMetadata<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208771)</ept>.","pos":[23633,23903],"source":" It implements the method you saw referenced in the previous [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) examples, as part of the construction arguments for the [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771)."},{"content":"The scenario addressed by this callback is that the class also has a calculated read-only property named \"HasLabelValue\" (implementation not shown).","pos":[23904,24052]},{"content":"Whenever the \"Label\" property gets reevaluated, this callback method is invoked, and the callback enables the dependent calculated value to remain in synchronization with changes to the dependency property.","pos":[24053,24259]},{"content":"Property changed behavior for structures and enumerations","pos":[25400,25457]},{"content":"If the type of a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyProperty<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242362)</ept> is an enumeration or a structure, the callback may be invoked even if the internal values of the structure or the enumeration value did not change.","pos":[25459,25706],"source":"If the type of a [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) is an enumeration or a structure, the callback may be invoked even if the internal values of the structure or the enumeration value did not change."},{"content":"This is different from a system primitive such as a string where it only is invoked if the value changed.","pos":[25707,25812]},{"content":"This is a side effect of box and unbox operations on these values that is done internally.","pos":[25813,25903]},{"content":"If you have a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PropertyChangedCallback<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208770)</ept> method for a property where your value is an enumeration or structure, you need to compare the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>OldValue<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br242365)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>NewValue<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br242364)</ept> by casting the values yourself and using the overloaded comparison operators that are available to the now-cast values.","pos":[25904,26370],"source":" If you have a [**PropertyChangedCallback**](https://msdn.microsoft.com/library/windows/apps/br208770) method for a property where your value is an enumeration or structure, you need to compare the [**OldValue**](https://msdn.microsoft.com/library/windows/apps/br242365) and [**NewValue**](https://msdn.microsoft.com/library/windows/apps/br242364) by casting the values yourself and using the overloaded comparison operators that are available to the now-cast values."},{"content":"Or, if no such operator is available (which might be the case for a custom structure), you may need to compare the individual values.","pos":[26371,26504]},{"content":"You would typically choose to do nothing if the result is that the values have not changed.","pos":[26505,26596]},{"content":"Best practices","pos":[27593,27607]},{"content":"Keep the following considerations in mind as best practices when as you define your custom dependency property.","pos":[27609,27720]},{"content":"DependencyObject and threading","pos":[27726,27756]},{"content":"All <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyObject<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept> instances must be created on the UI thread which is associated with the current <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Window<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br209041)</ept> that is shown by a Windows Runtime app.","pos":[27758,28033],"source":"All [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) instances must be created on the UI thread which is associated with the current [**Window**](https://msdn.microsoft.com/library/windows/apps/br209041) that is shown by a Windows Runtime app."},{"content":"Although each <bpt id=\"p1\">**</bpt>DependencyObject<ept id=\"p1\">**</ept> must be created on the main UI thread, the objects can be accessed using a dispatcher reference from other threads, by calling <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Dispatcher<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br230616)</ept>.","pos":[28034,28271],"source":" Although each **DependencyObject** must be created on the main UI thread, the objects can be accessed using a dispatcher reference from other threads, by calling [**Dispatcher**](https://msdn.microsoft.com/library/windows/apps/br230616)."},{"content":"The threading aspects of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyObject<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept> are relevant because it generally means that only code that runs on the UI thread can change or even read the value of a dependency property.","pos":[28273,28520],"source":"The threading aspects of [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) are relevant because it generally means that only code that runs on the UI thread can change or even read the value of a dependency property."},{"content":"Threading issues can usually be avoided in typical UI code that makes correct use of <bpt id=\"p1\">**</bpt>async<ept id=\"p1\">**</ept> patterns and background worker threads.","pos":[28521,28655],"source":" Threading issues can usually be avoided in typical UI code that makes correct use of **async** patterns and background worker threads."},{"content":"You typically only run into <bpt id=\"p1\">**</bpt>DependencyObject<ept id=\"p1\">**</ept>-related threading issues if you are defining your own <bpt id=\"p2\">**</bpt>DependencyObject<ept id=\"p2\">**</ept> types and you attempt to use them for data sources or other scenarios where a <bpt id=\"p3\">**</bpt>DependencyObject<ept id=\"p3\">**</ept> isn't necessarily appropriate.","pos":[28656,28909],"source":" You typically only run into **DependencyObject**-related threading issues if you are defining your own **DependencyObject** types and you attempt to use them for data sources or other scenarios where a **DependencyObject** isn't necessarily appropriate."},{"content":"Avoiding unintentional singletons","pos":[28915,28948]},{"content":"An unintentional singleton can happen if you are declaring a dependency property that takes a reference type, and you call a constructor for that reference type as part of the code that establishes your <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PropertyMetadata<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208771)</ept>.","pos":[28950,29234],"source":"An unintentional singleton can happen if you are declaring a dependency property that takes a reference type, and you call a constructor for that reference type as part of the code that establishes your [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771)."},{"content":"What happens is that all usages of the dependency property share just one instance of <bpt id=\"p1\">**</bpt>PropertyMetadata<ept id=\"p1\">**</ept> and thus try to share the single reference type you constructed.","pos":[29235,29406],"source":" What happens is that all usages of the dependency property share just one instance of **PropertyMetadata** and thus try to share the single reference type you constructed."},{"content":"Any subproperties of that value type that you set through your dependency property then propagate to other objects in ways you probably don't intend.","pos":[29407,29556]},{"content":"You can use class constructors to set initial values for a reference-type dependency property if you want a non-null value, but be aware that this would be considered a local value for purposes of <bpt id=\"p1\">[</bpt>Dependency properties overview<ept id=\"p1\">](dependency-properties-overview.md)</ept>.","pos":[29558,29823],"source":"You can use class constructors to set initial values for a reference-type dependency property if you want a non-null value, but be aware that this would be considered a local value for purposes of [Dependency properties overview](dependency-properties-overview.md)."},{"content":"It might be more appropriate to use a template for this purpose, if your class supports templates.","pos":[29824,29922]},{"content":"Another way to avoid a singleton pattern, but still provide a useful default, is to expose a static property on the reference type that provides a suitable default for the values of that class.","pos":[29923,30116]},{"content":"Collection-type dependency properties","pos":[30122,30159]},{"content":"Collection-type dependency properties have some additional implementation issues to consider.","pos":[30161,30254]},{"content":"Collection-type dependency properties are relatively rare in the Windows Runtime API.","pos":[30256,30341]},{"content":"In most cases, you can use collections where the items are a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyObject<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept> subclass, but the collection property itself is implemented as a conventional CLR or C++ property.","pos":[30342,30582],"source":" In most cases, you can use collections where the items are a [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) subclass, but the collection property itself is implemented as a conventional CLR or C++ property."},{"content":"This is because collections do not necessarily suit some typical scenarios where dependency properties are involved.","pos":[30583,30699]},{"content":"For example:","pos":[30700,30712]},{"content":"You do not typically animate a collection.","pos":[30718,30760]},{"content":"You do not typically prepopulate the items in a collection with styles or a template.","pos":[30765,30850]},{"content":"Although binding to collections is a major scenario, a collection does not need to be a dependency property to be a binding source.","pos":[30855,30986]},{"content":"For binding targets, it is more typical to use subclasses of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ItemsControl<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242803)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DataTemplate<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br242348)</ept> to support collection items, or to use view-model patterns.","pos":[30987,31264],"source":" For binding targets, it is more typical to use subclasses of [**ItemsControl**](https://msdn.microsoft.com/library/windows/apps/br242803) or [**DataTemplate**](https://msdn.microsoft.com/library/windows/apps/br242348) to support collection items, or to use view-model patterns."},{"content":"For more info about binding to and from collections, see <bpt id=\"p1\">[</bpt>Data binding in depth<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt210946)</ept>.","pos":[31265,31404],"source":" For more info about binding to and from collections, see [Data binding in depth](https://msdn.microsoft.com/library/windows/apps/mt210946)."},{"pos":[31409,31680],"content":"Notifications for collection changes are better addressed through interfaces such as <bpt id=\"p1\">**</bpt>INotifyPropertyChanged<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>INotifyCollectionChanged<ept id=\"p2\">**</ept>, or by deriving the collection type from <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ObservableCollection<ept id=\"p4\">**</ept><ept id=\"p3\">](T:System.Collections.ObjectModel.ObservableCollection%601)</ept>.","source":"Notifications for collection changes are better addressed through interfaces such as **INotifyPropertyChanged** or **INotifyCollectionChanged**, or by deriving the collection type from [**ObservableCollection**](T:System.Collections.ObjectModel.ObservableCollection%601)."},{"content":"Nevertheless, scenarios for collection-type dependency properties do exist.","pos":[31682,31757]},{"content":"The next three sections provide some guidance on how to implement a collection-type dependency property.","pos":[31758,31862]},{"content":"Initializing the collection","pos":[31868,31895]},{"content":"When you create a dependency property, you can establish a default value by means of dependency property metadata.","pos":[31897,32011]},{"content":"But be careful to not use a singleton static collection as the default value.","pos":[32012,32089]},{"content":"Instead, you must deliberately set the collection value to a unique (instance) collection as part of class-constructor logic for the owner class of the collection property.","pos":[32090,32262]},{"content":"Change notifications","pos":[32268,32288]},{"content":"Defining the collection as a dependency property does not automatically provide change notification for the items in the collection by virtue of the property system invoking the \"PropertyChanged\" callback method.","pos":[32290,32502]},{"content":"If you want notifications for collections or collection items—for example, for a data-binding scenario— implement the <bpt id=\"p1\">**</bpt>INotifyPropertyChanged<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>INotifyCollectionChanged<ept id=\"p2\">**</ept> interface.","pos":[32503,32690],"source":" If you want notifications for collections or collection items—for example, for a data-binding scenario— implement the **INotifyPropertyChanged** or **INotifyCollectionChanged** interface."},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Data binding in depth<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt210946)</ept>.","pos":[32691,32792],"source":" For more info, see [Data binding in depth](https://msdn.microsoft.com/library/windows/apps/mt210946)."},{"content":"Dependency property security considerations","pos":[32798,32841]},{"content":"Declare dependency properties as public properties.","pos":[32843,32894]},{"content":"Declare dependency property identifiers as public static read-only members.","pos":[32895,32970]},{"content":"Even if you attempt to declare other access levels permitted by a language (such as <bpt id=\"p1\">**</bpt>protected<ept id=\"p1\">**</ept>), a dependency property can always be accessed through the identifier in combination with the property-system APIs.","pos":[32971,33184],"source":" Even if you attempt to declare other access levels permitted by a language (such as **protected**), a dependency property can always be accessed through the identifier in combination with the property-system APIs."},{"content":"Declaring the dependency property identifier as internal or private will not work, because then the property system cannot operate properly.","pos":[33185,33325]},{"content":"Wrapper properties are really just for convenience, Security mechanisms applied to the wrappers can be bypassed by calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>GetValue<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242359)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>SetValue<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br242361)</ept> instead.","pos":[33327,33607],"source":"Wrapper properties are really just for convenience, Security mechanisms applied to the wrappers can be bypassed by calling [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) or [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) instead."},{"content":"So keep wrapper properties public; otherwise you just make your property harder for legitimate callers to use without providing any real security benefit.","pos":[33608,33762]},{"content":"The Windows Runtime does not provide a way to register a custom dependency property as read-only.","pos":[33764,33861]},{"content":"Dependency properties and class constructors","pos":[33867,33911]},{"content":"There is a general principle that class constructors should not call virtual methods.","pos":[33913,33998]},{"content":"This is because constructors can be called to accomplish base initialization of a derived class constructor, and entering the virtual method through the constructor might occur when the object instance being constructed is not yet completely initialized.","pos":[33999,34253]},{"content":"When you derive from any class that already derives from <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyObject<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>, remember that the property system itself calls and exposes virtual methods internally as part of its services.","pos":[34254,34503],"source":" When you derive from any class that already derives from [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356), remember that the property system itself calls and exposes virtual methods internally as part of its services."},{"content":"To avoid potential problems with run-time initialization, don't set dependency property values within constructors of classes.","pos":[34504,34630]},{"content":"Registering the dependency properties for C++/CX apps","pos":[34636,34689]},{"content":"The implementation for registering a property in C++/CX is trickier than C#C#, both because of the separation into header and implementation file and also because initialization at the root scope of the implementation file is a bad practice.","pos":[34691,34932]},{"content":"(Visual C++ component extensions (C++/CX) puts static initializer code from the root scope directly into <bpt id=\"p1\">**</bpt>DllMain<ept id=\"p1\">**</ept>, whereas C# compilers assign the static initializers to classes and thus avoid <bpt id=\"p2\">**</bpt>DllMain<ept id=\"p2\">**</ept> load lock issues.).","pos":[34933,35160],"source":" (Visual C++ component extensions (C++/CX) puts static initializer code from the root scope directly into **DllMain**, whereas C# compilers assign the static initializers to classes and thus avoid **DllMain** load lock issues.)."},{"content":"The best practice here is to declare a helper function that does all your dependency property registration for a class, one function per class.","pos":[35161,35304]},{"content":"Then for each custom class your app consumes, you'll have to reference the helper registration function that's exposed by each custom class you want to use.","pos":[35305,35461]},{"content":"Call each helper registration function once as part of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Application constructor<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242325)</ept> (<ph id=\"ph1\">`App::App()`</ph>), prior to <ph id=\"ph2\">`InitializeComponent`</ph>.","pos":[35462,35656],"source":" Call each helper registration function once as part of the [**Application constructor**](https://msdn.microsoft.com/library/windows/apps/br242325) (`App::App()`), prior to `InitializeComponent`."},{"content":"That constructor only runs when the app is really referenced for the first time, it won't run again if a suspended app resumes, for example.","pos":[35657,35797]},{"content":"Also, as seen in the previous C++ registration example, the <bpt id=\"p1\">**</bpt>nullptr<ept id=\"p1\">**</ept> check around each <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Register<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh701829)</ept> call is important: it's insurance that no caller of the function can register the property twice.","pos":[35798,36058],"source":" Also, as seen in the previous C++ registration example, the **nullptr** check around each [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) call is important: it's insurance that no caller of the function can register the property twice."},{"content":"A second registration call would probably crash your app without such a check because the property name would be a duplicate.","pos":[36059,36184]},{"content":"You can see this implementation pattern in the <bpt id=\"p1\">[</bpt>XAML user and custom controls sample<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=238581)</ept> if you look at the code for the C++/CX version of the sample.","pos":[36185,36381],"source":" You can see this implementation pattern in the [XAML user and custom controls sample](http://go.microsoft.com/fwlink/p/?linkid=238581) if you look at the code for the C++/CX version of the sample."},{"content":"Related topics","pos":[36386,36400]},{"content":"DependencyObject","pos":[36407,36423]},{"content":"DependencyProperty.Register","pos":[36490,36517]},{"content":"Dependency properties overview","pos":[36582,36612]},{"content":"XAML user and custom controls sample","pos":[36652,36688]}],"content":"---\ndescription: Explains how to define and implement custom dependency properties for a Windows Runtime app using C++, C#, or Visual Basic.\ntitle: Custom dependency properties\nms.assetid: 5ADF7935-F2CF-4BB6-B1A5-F535C2ED8EF8\n---\n\n# Custom dependency properties\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nHere we explain how to define and implement your own dependency properties for a Windows Runtime app using C++, C#, or Visual Basic. We list reasons why app developers and component authors might want to create custom dependency properties. We describe the implementation steps for a custom dependency property, as well as some best practices that can improve performance, usability, or versatility of the dependency property.\n\n## Prerequisites\n\n\nWe assume that you have read the [Dependency properties overview](dependency-properties-overview.md) and that you understand dependency properties from the perspective of a consumer of existing dependency properties. To follow the examples in this topic, you should also understand XAML and know how to write a basic Windows Runtime app using C++, C#, or Visual Basic.\n\n## What is a dependency property?\n\n\nDependency properties are properties that are registered with the Windows Runtime property system by calling the [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) method, and that are identified by a [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) identifier member on the defining class. You can enable what would otherwise be a common language runtime (CLR) or C++ property to support styling, data binding, animations, and default values by implementing it as a dependency property. Dependency properties can be used only by [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) types. But **DependencyObject** is quite high in the class hierarchy, so the majority of classes that are intended for UI and presentation support can support dependency properties. For more information about dependency properties and some of the terminology and conventions used for describing them in this documentation, see [Dependency properties overview](dependency-properties-overview.md).\n\nExamples of dependency properties in the Windows Runtime are: [**Control.Background**](https://msdn.microsoft.com/library/windows/apps/br209395), [**FrameworkElement.Width**](https://msdn.microsoft.com/library/windows/apps/br208751), and [**TextBox.Text**](https://msdn.microsoft.com/library/windows/apps/br209702), among many others. Each dependency property exposed by a class has a corresponding **public** **static** **readonly** property of type [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) that is exposed on that same class and that is the identifier for the dependency property. The identifier's name follows this convention: the name of the dependency property, with the string \"Property\" added to the end of the name. For example, the corresponding **DependencyProperty** identifier for the **Control.Background** property is [**Control.BackgroundProperty**](https://msdn.microsoft.com/library/windows/apps/br209396). The identifier stores the information about the dependency property as it was registered, and the identifier can then be used later for other operations involving the dependency property, such as calling [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361).\n\n##  Property wrappers\n\nDependency properties typically have a wrapper implementation. Without the wrapper, the only way to get or set the properties would be to use the dependency property utility methods [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) and [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) and to pass the identifier to them as a parameter. This is a rather unnatural usage for something that is ostensibly a property. But with the wrapper, your code and any other code that references the dependency property can use a straightforward object-property syntax that is natural for the language you're using.\n\nIf you implement a custom dependency property yourself and want it to be public and easy to call, define the property wrappers too. The property wrappers are also useful for reporting basic information about the dependency property to reflection or static analysis processes. Specifically, the wrapper is where you place attributes such as [**ContentPropertyAttribute**](https://msdn.microsoft.com/library/windows/apps/br228011).\n\n## When to implement a property as a dependency property\n\nWhenever you implement a public read/write property on a class, as long as your class derives from [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356), you have the option to make your property work as a dependency property. Sometimes the typical technique of backing your property with a private field is adequate. Defining your custom property as a dependency property is not always necessary or appropriate. The choice will depend on the scenarios that you intend your property to support.\n\nYou might consider implementing your property as a dependency property when you want it to support one or more of these features of the Windows Runtime or of Windows Runtime apps:\n\n-   Setting the property through a [**Style**](https://msdn.microsoft.com/library/windows/apps/br208849)\n-   Acting as valid target property for data binding\n-   Supporting animated values through a [**Storyboard**](https://msdn.microsoft.com/library/windows/apps/br210490)\n-   Reporting when the previous value of the property has been changed by:\n    -   Actions taken by the property system itself\n    -   The environment\n    -   User actions\n    -   Reading and writing styles\n\n## Checklist for defining a dependency property\n\nDefining a dependency property can be thought of as a set of concepts. These concepts are not necessarily procedural steps, because several concepts can be addressed in a single line of code in the implementation. This list gives just a quick overview. We'll explain each concept in more detail later in this topic, and we'll show you example code in several languages.\n\n-   (Optional) Create property metadata for the dependency property. You need property metadata only if you want property-changed behavior, or a metadata-based default value that can be restored by calling [**ClearValue**](https://msdn.microsoft.com/library/windows/apps/br242357).\n-   Register the property name with the property system (call [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)), specifying an owner type and the type of the property value. There's a required parameter for [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) that expects property metadata. Specify **null** for this, or specify the actual property metadata if you have declared any.\n-   Define a [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) identifier as a **public** **static** **readonly** property member on the owner type.\n-   Define a wrapper property, following the property accessor model that's used in the language you are implementing. The wrapper property name should match the *name* string that you used in [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829). Implement the **get** and **set** accessors to connect the wrapper with the dependency property that it wraps, by calling [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) and [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) and passing your own property's identifier as a parameter.\n-   (Optional) Place attributes such as [**ContentPropertyAttribute**](https://msdn.microsoft.com/library/windows/apps/br228011) on the wrapper.\n\n**Note**  If you are defining a custom attached property, you generally omit the wrapper. Instead, you write a different style of accessor that a XAML processor can use. See [Custom attached properties](custom-attached-properties.md). \n\n## Registering the property\n\nFor your property to be a dependency property, you must register the property into a property store maintained by the Windows Runtime property system. You must give the property a unique identifier to be used as the qualifier for later property-system operations. These operations might be internal operations, or your own code calling property-system APIs. To register the property, you call the [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) method.\n\nFor Microsoft .NET languages (C# and Microsoft Visual Basic) you call [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) within the body of your class (inside the class, but outside any member definitions). The identifier is also provided by the [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) method call, as the return value. The [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) call is typically made outside of other member definitions because you use the return value to assign and create a **public** **static** **readonly** property of type [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) as part of your class. This property becomes the identifier for your dependency property. Here are examples of the [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) call.\n\n> [!div class=\"tabbedCodeSnippets\"]\n```csharp\npublic static readonly DependencyProperty LabelProperty = DependencyProperty.Register(\n  \"Label\",\n  typeof(String),\n  typeof(ImageWithLabelControl),\n  new PropertyMetadata(null)\n);\n```\n```vb\nPublic Shared ReadOnly LabelProperty As DependencyProperty = \n    DependencyProperty.Register(\"Label\", \n      GetType(String), \n      GetType(ImageWithLabelControl), \n      New PropertyMetadata(Nothing))\n```\n\n**Note**  Registering the dependency property in a class body is the typical implementation, but you can also register a dependency property in the class static constructor. This approach may make sense if you need more than one line of code to initialize the dependency property.\n\nFor C++, you have options for how you split the implementation between the header and the code file. The typical split is to declare the identifier itself as **public** **static** property in the header, with a **get** implementation but no **set**. The **get** implementation refers to a private field, which is an uninitialized [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) instance. You can also declare the wrappers and the **get** and **set** implementations of the wrapper. In this case the header includes some minimal implementation. If the wrapper needs Windows Runtime attribution, attribute in the header too. Put the [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) call in the code file, within a helper function that only gets run when the app initializes the first time. Use the return value of **Register** to fill the static but uninitialized identifiers that you declared in the header, which you initially set to **nullptr** at the root scope of the implementation file.\n\n```cpp\n//.h file\n//using namespace Windows::UI::Xaml::Controls;\n//using namespace Windows::UI::Xaml::Interop;\n//using namespace Windows::UI::Xaml;\n//using namespace Platform;\n\npublic ref class ImageWithLabelControl sealed : public Control\n{  \nprivate:\n    static DependencyProperty^ _LabelProperty;\n...\npublic:\n    static void RegisterDependencyProperties(); \n    static property DependencyProperty^ LabelProperty\n    {\n        DependencyProperty^ get() {return _LabelProperty;}\n    }\n...\n};\n```\n\n```cpp\n//.cpp file\nusing namespace Windows::UI::Xaml;\nusing namespace Windows::UI::Xaml.Interop;\n\nDependencyProperty^ ImageWithLabelControl::_LabelProperty = nullptr;\n\n// This function is called from the App constructor in App.xaml.cpp \n// to register the properties\nvoid ImageWithLabelControl::RegisterDependencyProperties() \n{ \n    if (_LabelProperty == nullptr) \n    { \n        _LabelProperty = DependencyProperty::Register(\n          \"Label\", Platform::String::typeid, ImageWithLabelControl::typeid, nullptr); \n    } \n}\n```\n\n**Note**  For the C++ code, the reason why you have a private field and a public read-only property that surfaces the [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) is so that other callers who use your dependency property can also use property-system utility APIs that require the identifier to be public. If you keep the identifier private, people can't use these utility APIs. Examples of such API and scenarios include [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) or [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) by choice, [**ClearValue**](https://msdn.microsoft.com/library/windows/apps/br242357), [**GetAnimationBaseValue**](https://msdn.microsoft.com/library/windows/apps/br242358), [**SetBinding**](https://msdn.microsoft.com/library/windows/apps/br244257), and [**Setter.Property**](https://msdn.microsoft.com/library/windows/apps/br208836). You can't use a public field for this, because Windows Runtime compile rules don't allow public data members that use reference types like **DependencyProperty**.\n\n## Dependency property name conventions\n\nThere are naming conventions for dependency properties; follow them in all but exceptional circumstances. The dependency property itself has a basic name (\"Label\" in the preceding example) that is given as the first parameter of [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829). The name must be unique within each registering type, and the uniqueness requirement also applies to any inherited members. Dependency properties inherited through base types are considered to be part of the registering type already; names of inherited properties cannot be registered again.\n\n**Caution**  Although the name you provide here can be any string identifier that is valid in programming for your language of choice, you usually want to be able to set your dependency property in XAML too. To be set in XAML, the property name you choose must be a valid XAML name. For more info, see [XAML overview](xaml-overview.md).\n\nWhen you create the identifier property, combine the name of the property as you registered it with the suffix \"Property\" (\"LabelProperty\", for example). This property is your identifier for the dependency property, and it is used as an input for the [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) and [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) calls you make in your own property wrappers. It is also used by the property system and potentially by XAML processors.\n\n## Implementing the wrapper\n\nYour property wrapper should call [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) in the **get** implementation, and [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) in the **set** implementation.\n\n**Caution**  In all but exceptional circumstances, your wrapper implementations should perform only the [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) and [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) operations. Otherwise, you'll get different behavior when your property is set via XAML versus when it is set via code. For efficiency, the XAML parser bypasses wrappers when setting dependency properties; whenever possible, it uses the registry of dependency properties.\n\n> [!div class=\"tabbedCodeSnippets\"]\n```csharp\npublic String Label\n{\n    get { return (String)GetValue(LabelProperty); }\n    set { SetValue(LabelProperty, value); }\n}\n```\n```vb\nPublic Property Label() As String \n    Get \n        Return DirectCast(GetValue(LabelProperty), String) \n    End Get \n    Set(ByVal value As String) \n        SetValue(LabelProperty, value) \n    End Set \nEnd Property\n```\n```cpp\n//using namespace Platform;\npublic:\n...\n  property String^ Label\n  {\n    String^ get() {\n      return (String^)GetValue(LabelProperty);\n    }\n    void set(String^ value) {\n      SetValue(LabelProperty, value); \n    }\n  }\n```\n\n## Property metadata for a custom dependency property\n\nWhen property metadata is assigned to a dependency property, the same metadata is applied to that property for any instance of the property-owner type or its subclasses. In property metadata, you can specify two behaviors:\n\n-   A default value that the property system assigns to all cases of the property.\n-   A static callback method that is automatically invoked within the property system whenever a property value is detected.\n\n### Calling Register with property metadata\n\nIn the previous examples of calling [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829), we passed a null value for the *propertyMetadata* parameter. To enable a dependency property to provide a default value or use a property-changed callback, you must define a [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) instance that provides one or both of these capabilities.\n\nTypically you provide a [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) as an inline-created instance, within the parameters for [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829).\n\n**Note**  If you are defining a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) implementation, you must use the utility method [**PropertyMetadata.Create**](https://msdn.microsoft.com/library/windows/apps/hh702099) rather than calling a [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) constructor to define the **PropertyMetadata** instance.\n\nThis next example modifies the previously shown [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) examples by referencing a [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) instance with a [**PropertyChangedCallback**](https://msdn.microsoft.com/library/windows/apps/br208770) value. The implementation of the \"OnLabelChanged\" callback will be shown later in this section.\n\n> [!div class=\"tabbedCodeSnippets\"]\n```csharp\npublic static readonly DependencyProperty LabelProperty = DependencyProperty.Register(\n  \"Label\",\n  typeof(String),\n  typeof(ImageWithLabelControl),\n  new PropertyMetadata(null,new PropertyChangedCallback(OnLabelChanged))\n);\n```\n```vb\nPublic Shared ReadOnly LabelProperty As DependencyProperty = \n    DependencyProperty.Register(\"Label\", \n      GetType(String), \n      GetType(ImageWithLabelControl), \n      New PropertyMetadata(\n        Nothing, new PropertyChangedCallback(AddressOf OnLabelChanged)))\n```\n```cpp\nDependencyProperty^ ImageWithLabelControl::_LabelProperty = \n    DependencyProperty::Register(\"Label\", \n    Platform::String::typeid,\n    ImageWithLabelControl::typeid, \n    ref new PropertyMetadata(nullptr,\n      ref new PropertyChangedCallback(&amp;ImageWithLabelControl::OnLabelChanged))\n    );\n```\n\n### Default value\n\nYou can specify a default value for a dependency property such that the property always returns a particular default value when it is unset. This value can be different than the inherent default value for the type of that property.\n\nIf a default value is not specified, the default value for a dependency property is null for a reference type, or the default of the type for a value type or language primitive (for example, 0 for an integer or an empty string for a string). The main reason for establishing a default value is that this value is restored when you call [**ClearValue**](https://msdn.microsoft.com/library/windows/apps/br242357) on the property. Establishing a default value on a per-property basis might be more convenient than establishing default values in constructors, particularly for value types. However, for reference types, make sure that establishing a default value does not create an unintentional singleton pattern. For more info, see [Best practices](#best-practices) later in this topic\n\n**Note**  Do not register with a default value of [**UnsetValue**](https://msdn.microsoft.com/library/windows/apps/br242371). If you do, it will confuse property consumers and will have unintended consequences within the property system.\n\n### CreateDefaultValueCallback\n\nIn some scenarios, you are defining dependency properties for objects that are used on more than one UI thread. This might be the case if you are defining a data object that is used by multiple apps, or a control that you use in more than one app. You can enable the exchange of the object between different UI threads by providing a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) implementation rather than a default value instance, which is tied to the thread that registered the property. Basically a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) defines a factory for default values. The value returned by **CreateDefaultValueCallback** is always associated with the current UI **CreateDefaultValueCallback** thread that is using the object.\n\nTo define metadata that specifies a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812), you must call [**PropertyMetadata.Create**](https://msdn.microsoft.com/library/windows/apps/hh702115) to return a metadata instance; the [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) constructors do not have a signature that includes a **CreateDefaultValueCallback** parameter.\n\nThe typical implementation pattern for a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) is to create a new [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) class, set the specific property value of each property of the **DependencyObject** to the intended default, and then return the new class as an **Object** reference via the return value of the **CreateDefaultValueCallback** method.\n\n### Property-changed callback method\n\nYou can define a property-changed callback method to define your property's interactions with other dependency properties, or to set an internal property or state of your object whenever the property changes. If your callback is invoked, the property system has determined that there is an effective property value change. Because the callback method is static, the *d* parameter of the callback is important because it tells you which instance of the class has reported a change. A typical implementation uses the [**NewValue**](https://msdn.microsoft.com/library/windows/apps/br242364) property of the event data and processes that value in some manner, usually by performing some other change on the object passed as *d*. Additional responses to a property change are to reject the value reported by **NewValue**, to restore [**OldValue**](https://msdn.microsoft.com/library/windows/apps/br242365), or to set the value to a programmatic constraint applied to the **NewValue**.\n\nThis next example shows a [**PropertyChangedCallback**](https://msdn.microsoft.com/library/windows/apps/br208770) implementation. It implements the method you saw referenced in the previous [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) examples, as part of the construction arguments for the [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771). The scenario addressed by this callback is that the class also has a calculated read-only property named \"HasLabelValue\" (implementation not shown). Whenever the \"Label\" property gets reevaluated, this callback method is invoked, and the callback enables the dependent calculated value to remain in synchronization with changes to the dependency property.\n\n> [!div class=\"tabbedCodeSnippets\"]\n```csharp\nprivate static void OnLabelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {\n    ImageWithLabelControl iwlc = d as ImageWithLabelControl; //null checks omitted\n    String s = e.NewValue as String; //null checks omitted\n    if (s == String.Empty)\n    {\n        iwlc.HasLabelValue = false;\n    } else {\n        iwlc.HasLabelValue = true;\n    }\n}\n```\n```vb\n    Private Shared Sub OnLabelChanged(d As DependencyObject, e As DependencyPropertyChangedEventArgs)\n        Dim iwlc As ImageWithLabelControl = CType(d, ImageWithLabelControl) ' null checks omitted\n        Dim s As String = CType(e.NewValue,String) ' null checks omitted\n        If s Is String.Empty Then\n            iwlc.HasLabelValue = False\n        Else\n            iwlc.HasLabelValue = True\n        End If\n    End Sub\n```\n```cpp\nstatic void OnLabelChanged(DependencyObject^ d, DependencyPropertyChangedEventArgs^ e)\n{\n    ImageWithLabelControl^ iwlc = (ImageWithLabelControl^)d;\n    Platform::String^ s = (Platform::String^)(e->NewValue);\n    if (s->IsEmpty()) {\n        iwlc->HasLabelValue=false;\n    }\n}\n```\n\n### Property changed behavior for structures and enumerations\n\nIf the type of a [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) is an enumeration or a structure, the callback may be invoked even if the internal values of the structure or the enumeration value did not change. This is different from a system primitive such as a string where it only is invoked if the value changed. This is a side effect of box and unbox operations on these values that is done internally. If you have a [**PropertyChangedCallback**](https://msdn.microsoft.com/library/windows/apps/br208770) method for a property where your value is an enumeration or structure, you need to compare the [**OldValue**](https://msdn.microsoft.com/library/windows/apps/br242365) and [**NewValue**](https://msdn.microsoft.com/library/windows/apps/br242364) by casting the values yourself and using the overloaded comparison operators that are available to the now-cast values. Or, if no such operator is available (which might be the case for a custom structure), you may need to compare the individual values. You would typically choose to do nothing if the result is that the values have not changed.\n\n> [!div class=\"tabbedCodeSnippets\"]\n```csharp\nprivate static void OnVisibilityValueChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {\n    if ((Visibility)e.NewValue != (Visibility)e.OldValue)\n    {\n        //value really changed, invoke your changed logic here\n    } // else this was invoked because of boxing, do nothing\n}\n```\n```vb\nPrivate Shared Sub OnVisibilityValueChanged(d As DependencyObject, e As DependencyPropertyChangedEventArgs)\n    If CType(e.NewValue,Visibility) != CType(e.OldValue,Visibility) Then\n        '  value really changed, invoke your changed logic here\n    End If\n    '  else this was invoked because of boxing, do nothing\nEnd Sub\n```\n```cpp\nstatic void OnVisibilityValueChanged(DependencyObject^ d, DependencyPropertyChangedEventArgs^ e)\n{\n    if ((Visibility)e->NewValue != (Visibility)e->OldValue)\n    {\n        //value really changed, invoke your changed logic here\n    } \n    // else this was invoked because of boxing, do nothing\n    }\n}\n```\n\n## Best practices\n\nKeep the following considerations in mind as best practices when as you define your custom dependency property.\n\n### DependencyObject and threading\n\nAll [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) instances must be created on the UI thread which is associated with the current [**Window**](https://msdn.microsoft.com/library/windows/apps/br209041) that is shown by a Windows Runtime app. Although each **DependencyObject** must be created on the main UI thread, the objects can be accessed using a dispatcher reference from other threads, by calling [**Dispatcher**](https://msdn.microsoft.com/library/windows/apps/br230616).\n\nThe threading aspects of [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) are relevant because it generally means that only code that runs on the UI thread can change or even read the value of a dependency property. Threading issues can usually be avoided in typical UI code that makes correct use of **async** patterns and background worker threads. You typically only run into **DependencyObject**-related threading issues if you are defining your own **DependencyObject** types and you attempt to use them for data sources or other scenarios where a **DependencyObject** isn't necessarily appropriate.\n\n### Avoiding unintentional singletons\n\nAn unintentional singleton can happen if you are declaring a dependency property that takes a reference type, and you call a constructor for that reference type as part of the code that establishes your [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771). What happens is that all usages of the dependency property share just one instance of **PropertyMetadata** and thus try to share the single reference type you constructed. Any subproperties of that value type that you set through your dependency property then propagate to other objects in ways you probably don't intend.\n\nYou can use class constructors to set initial values for a reference-type dependency property if you want a non-null value, but be aware that this would be considered a local value for purposes of [Dependency properties overview](dependency-properties-overview.md). It might be more appropriate to use a template for this purpose, if your class supports templates. Another way to avoid a singleton pattern, but still provide a useful default, is to expose a static property on the reference type that provides a suitable default for the values of that class.\n\n### Collection-type dependency properties\n\nCollection-type dependency properties have some additional implementation issues to consider.\n\nCollection-type dependency properties are relatively rare in the Windows Runtime API. In most cases, you can use collections where the items are a [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) subclass, but the collection property itself is implemented as a conventional CLR or C++ property. This is because collections do not necessarily suit some typical scenarios where dependency properties are involved. For example:\n\n-   You do not typically animate a collection.\n-   You do not typically prepopulate the items in a collection with styles or a template.\n-   Although binding to collections is a major scenario, a collection does not need to be a dependency property to be a binding source. For binding targets, it is more typical to use subclasses of [**ItemsControl**](https://msdn.microsoft.com/library/windows/apps/br242803) or [**DataTemplate**](https://msdn.microsoft.com/library/windows/apps/br242348) to support collection items, or to use view-model patterns. For more info about binding to and from collections, see [Data binding in depth](https://msdn.microsoft.com/library/windows/apps/mt210946).\n-   Notifications for collection changes are better addressed through interfaces such as **INotifyPropertyChanged** or **INotifyCollectionChanged**, or by deriving the collection type from [**ObservableCollection**](T:System.Collections.ObjectModel.ObservableCollection%601).\n\nNevertheless, scenarios for collection-type dependency properties do exist. The next three sections provide some guidance on how to implement a collection-type dependency property.\n\n### Initializing the collection\n\nWhen you create a dependency property, you can establish a default value by means of dependency property metadata. But be careful to not use a singleton static collection as the default value. Instead, you must deliberately set the collection value to a unique (instance) collection as part of class-constructor logic for the owner class of the collection property.\n\n### Change notifications\n\nDefining the collection as a dependency property does not automatically provide change notification for the items in the collection by virtue of the property system invoking the \"PropertyChanged\" callback method. If you want notifications for collections or collection items—for example, for a data-binding scenario— implement the **INotifyPropertyChanged** or **INotifyCollectionChanged** interface. For more info, see [Data binding in depth](https://msdn.microsoft.com/library/windows/apps/mt210946).\n\n### Dependency property security considerations\n\nDeclare dependency properties as public properties. Declare dependency property identifiers as public static read-only members. Even if you attempt to declare other access levels permitted by a language (such as **protected**), a dependency property can always be accessed through the identifier in combination with the property-system APIs. Declaring the dependency property identifier as internal or private will not work, because then the property system cannot operate properly.\n\nWrapper properties are really just for convenience, Security mechanisms applied to the wrappers can be bypassed by calling [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) or [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) instead. So keep wrapper properties public; otherwise you just make your property harder for legitimate callers to use without providing any real security benefit.\n\nThe Windows Runtime does not provide a way to register a custom dependency property as read-only.\n\n### Dependency properties and class constructors\n\nThere is a general principle that class constructors should not call virtual methods. This is because constructors can be called to accomplish base initialization of a derived class constructor, and entering the virtual method through the constructor might occur when the object instance being constructed is not yet completely initialized. When you derive from any class that already derives from [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356), remember that the property system itself calls and exposes virtual methods internally as part of its services. To avoid potential problems with run-time initialization, don't set dependency property values within constructors of classes.\n\n### Registering the dependency properties for C++/CX apps\n\nThe implementation for registering a property in C++/CX is trickier than C#C#, both because of the separation into header and implementation file and also because initialization at the root scope of the implementation file is a bad practice. (Visual C++ component extensions (C++/CX) puts static initializer code from the root scope directly into **DllMain**, whereas C# compilers assign the static initializers to classes and thus avoid **DllMain** load lock issues.). The best practice here is to declare a helper function that does all your dependency property registration for a class, one function per class. Then for each custom class your app consumes, you'll have to reference the helper registration function that's exposed by each custom class you want to use. Call each helper registration function once as part of the [**Application constructor**](https://msdn.microsoft.com/library/windows/apps/br242325) (`App::App()`), prior to `InitializeComponent`. That constructor only runs when the app is really referenced for the first time, it won't run again if a suspended app resumes, for example. Also, as seen in the previous C++ registration example, the **nullptr** check around each [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) call is important: it's insurance that no caller of the function can register the property twice. A second registration call would probably crash your app without such a check because the property name would be a duplicate. You can see this implementation pattern in the [XAML user and custom controls sample](http://go.microsoft.com/fwlink/p/?linkid=238581) if you look at the code for the C++/CX version of the sample.\n\n## Related topics\n\n* [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356)\n* [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)\n* [Dependency properties overview](dependency-properties-overview.md)\n* [XAML user and custom controls sample](http://go.microsoft.com/fwlink/p/?linkid=238581)\n \n\n"}