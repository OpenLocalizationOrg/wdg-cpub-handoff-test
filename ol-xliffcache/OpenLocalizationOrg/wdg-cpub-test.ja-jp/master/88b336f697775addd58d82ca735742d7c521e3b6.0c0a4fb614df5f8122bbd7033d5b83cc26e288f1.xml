{"nodes":[{"pos":[17,132],"content":"You begin the porting process by creating a new Windows 10 project in Visual Studio and copying your files into it.","needQuote":true,"needEscape":true,"nodes":[{"content":"You begin the porting process by creating a new Windows 10 project in Visual Studio and copying your files into it.","pos":[0,115]}]},{"pos":[140,200],"content":"Porting a Windows Phone Silverlight project to a UWP project","needQuote":true,"needEscape":true,"nodes":[{"content":"Porting a Windows Phone Silverlight project to a UWP project","pos":[0,60]}]},{"content":"Porting a Windows Phone Silverlight project to a UWP project","pos":[257,317]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[319,357]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[358,453],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"pos":[455,554],"content":"The previous topic was <bpt id=\"p1\">[</bpt>Namespace and class mappings<ept id=\"p1\">](wpsl-to-uwp-namespace-and-class-mappings.md)</ept>.","source":"The previous topic was [Namespace and class mappings](wpsl-to-uwp-namespace-and-class-mappings.md)."},{"content":"You begin the porting process by creating a new Windows 10 project in Visual Studio and copying your files into it.","pos":[556,671]},{"content":"Create the project and copy files to it","pos":[676,715]},{"content":"Launch Microsoft Visual Studio 2015 and create a new Blank Application (Windows Universal) project.","pos":[721,820]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Jumpstart your Windows Store app using templates (C#, C++, Visual Basic)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh768232)</ept>.","pos":[821,973],"source":" For more info, see [Jumpstart your Windows Store app using templates (C#, C++, Visual Basic)](https://msdn.microsoft.com/library/windows/apps/hh768232)."},{"content":"Your new project builds an app package (an appx file) that will run on all device families.","pos":[974,1065]},{"content":"In your Windows Phone Silverlight app project, identify all the source code files and visual asset files that you want to reuse.","pos":[1070,1198]},{"content":"Using File Explorer, copy data models, view models, visual assets, Resource Dictionaries, folder structure, and anything else that you wish to re-use, to your new project.","pos":[1199,1370]},{"content":"Copy or create sub-folders on disk as necessary.","pos":[1371,1419]},{"content":"Copy views (for example, MainPage.xaml and MainPage.xaml.cs) into the new project node, too.","pos":[1424,1516]},{"content":"Again, create new sub-folders as necessary, and remove the existing views from the project.","pos":[1517,1608]},{"content":"But, before you over-write or remove a view that Visual Studio generated, keep a copy because it may be useful to refer to it later.","pos":[1609,1741]},{"content":"The first phase of porting a Windows Phone Silverlight app focuses on getting it to look good and work well on one device family.","pos":[1742,1871]},{"content":"Later, you'll turn your attention to making sure the views adapt themselves well to all form factors, and optionally to adding any adaptive code to get the most from a particular device family.","pos":[1872,2065]},{"content":"In <bpt id=\"p1\">**</bpt>Solution Explorer<ept id=\"p1\">**</ept>, make sure <bpt id=\"p2\">**</bpt>Show All Files<ept id=\"p2\">**</ept> is toggled on.","pos":[2070,2139],"source":"In **Solution Explorer**, make sure **Show All Files** is toggled on."},{"content":"Select the files that you copied, right-click them, and click <bpt id=\"p1\">**</bpt>Include In Project<ept id=\"p1\">**</ept>.","pos":[2140,2225],"source":" Select the files that you copied, right-click them, and click **Include In Project**."},{"content":"This will automatically include their containing folders.","pos":[2226,2283]},{"content":"You can then toggle <bpt id=\"p1\">**</bpt>Show All Files<ept id=\"p1\">**</ept> off if you like.","pos":[2284,2339],"source":" You can then toggle **Show All Files** off if you like."},{"content":"An alternative workflow, if you prefer, is to use the <bpt id=\"p1\">**</bpt>Add Existing Item<ept id=\"p1\">**</ept> command, having created any necessary sub-folders in the Visual Studio <bpt id=\"p2\">**</bpt>Solution Explorer<ept id=\"p2\">**</ept>.","pos":[2340,2509],"source":" An alternative workflow, if you prefer, is to use the **Add Existing Item** command, having created any necessary sub-folders in the Visual Studio **Solution Explorer**."},{"content":"Double-check that your visual assets have <bpt id=\"p1\">**</bpt>Build Action<ept id=\"p1\">**</ept> set to <bpt id=\"p2\">**</bpt>Content<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>Copy to Output Directory<ept id=\"p3\">**</ept> set to <bpt id=\"p4\">**</bpt>Do not copy<ept id=\"p4\">**</ept>.","pos":[2510,2644],"source":" Double-check that your visual assets have **Build Action** set to **Content** and **Copy to Output Directory** set to **Do not copy**."},{"content":"The differences in namespace and class names will generate lots of build errors at this stage.","pos":[2649,2743]},{"content":"For example, if you open the views that Visual Studio generated, you'll see that they are of type <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Page<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227503)</ept>, and not <bpt id=\"p3\">**</bpt>PhoneApplicationPage<ept id=\"p3\">**</ept>.","pos":[2744,2945],"source":" For example, if you open the views that Visual Studio generated, you'll see that they are of type [**Page**](https://msdn.microsoft.com/library/windows/apps/br227503), and not **PhoneApplicationPage**."},{"content":"There are lots of XAML markup and imperative code differences that the following topics in this porting guide cover in detail.","pos":[2946,3072]},{"content":"But, you'll make fast progress just following these general steps: change \"clr-namespace\" to \"using\" in your namespace prefix declarations in XAML markup; use the <bpt id=\"p1\">[</bpt>Namespace and class mappings<ept id=\"p1\">](wpsl-to-uwp-namespace-and-class-mappings.md)</ept> topic and Visual Studio's <bpt id=\"p2\">**</bpt>Find and Replace<ept id=\"p2\">**</ept> command to make bulk changes to your source code (for example, replace \"System.Windows\" with \"Windows.UI.Xaml\"); and in the imperative code editor in Visual Studio use the <bpt id=\"p3\">**</bpt>Resolve<ept id=\"p3\">**</ept> and <bpt id=\"p4\">**</bpt>Organize Usings<ept id=\"p4\">**</ept> commands on the context menu for more targeted changes.","pos":[3073,3622],"source":" But, you'll make fast progress just following these general steps: change \"clr-namespace\" to \"using\" in your namespace prefix declarations in XAML markup; use the [Namespace and class mappings](wpsl-to-uwp-namespace-and-class-mappings.md) topic and Visual Studio's **Find and Replace** command to make bulk changes to your source code (for example, replace \"System.Windows\" with \"Windows.UI.Xaml\"); and in the imperative code editor in Visual Studio use the **Resolve** and **Organize Usings** commands on the context menu for more targeted changes."},{"content":"Extension SDKs","pos":[3627,3641]},{"content":"Most of the Universal Windows Platform (UWP) APIs your ported app will call are implemented in the set of APIs known as the universal device family.","pos":[3643,3791]},{"content":"But, some are implemented in extension SDKs, and Visual Studio only recognizes APIs that are implemented by your app's target device family or by any extension SDKs that you have referenced.","pos":[3792,3982]},{"content":"If you get compile errors about namespaces or types or members that could not be found, then this is likely to be the cause.","pos":[3984,4108]},{"content":"Open the API's topic in the API reference documentation and navigate to the Requirements section: that will tell you what the implementing device family is.","pos":[4109,4265]},{"content":"If that's not your target device family, then to make the API available to your project, you will need a reference to the extension SDK for that device family.","pos":[4266,4425]},{"content":"Click <bpt id=\"p1\">**</bpt>Project<ept id=\"p1\">**</ept> <ph id=\"ph1\">&amp;gt;</ph> <bpt id=\"p2\">**</bpt>Add Reference<ept id=\"p2\">**</ept> <ph id=\"ph2\">&amp;gt;</ph> <bpt id=\"p3\">**</bpt>Windows Universal<ept id=\"p3\">**</ept> <ph id=\"ph3\">&amp;gt;</ph> <bpt id=\"p4\">**</bpt>Extensions<ept id=\"p4\">**</ept> and select the appropriate extension SDK.","pos":[4427,4556],"source":"Click **Project** &gt; **Add Reference** &gt; **Windows Universal** &gt; **Extensions** and select the appropriate extension SDK."},{"content":"For example, if the APIs you want to call are available only in the mobile device family, and they were introduced in version 10.0.x.y, then select <bpt id=\"p1\">**</bpt>Windows Mobile Extensions for the UWP<ept id=\"p1\">**</ept>.","pos":[4557,4747],"source":" For example, if the APIs you want to call are available only in the mobile device family, and they were introduced in version 10.0.x.y, then select **Windows Mobile Extensions for the UWP**."},{"content":"That will add the following reference to your project file:","pos":[4749,4808]},{"content":"The name and version number match the folders in the installed location of your SDK.","pos":[4987,5071]},{"content":"For example, the above information matches this folder name:","pos":[5072,5132]},{"content":"Unless your app targets the device family that implements the API, you'll need to use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ApiInformation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn949001)</ept> class to test for the presence of the API before you call it (this is called adaptive code).","pos":[5212,5473],"source":"Unless your app targets the device family that implements the API, you'll need to use the [**ApiInformation**](https://msdn.microsoft.com/library/windows/apps/dn949001) class to test for the presence of the API before you call it (this is called adaptive code)."},{"content":"This condition will then be evaluated wherever your app runs, but it will only evaluate to true on devices where the API is present and therefore available to call.","pos":[5474,5638]},{"content":"Only use extension SDKs and adaptive code after first checking whether a universal API exists.","pos":[5639,5733]},{"content":"Some examples are given in the section below.","pos":[5734,5779]},{"pos":[5781,5828],"content":"Also, see <bpt id=\"p1\">[</bpt>App package manifest<ept id=\"p1\">](#appxpackage)</ept>.","source":"Also, see [App package manifest](#appxpackage)."},{"content":"Maximizing markup and code reuse","pos":[5833,5865]},{"content":"You will find that refactoring a little, and/or adding adaptive code (which is explained below), will allow you to maximize the markup and code that works across all device families.","pos":[5867,6049]},{"content":"Here are more details.","pos":[6050,6072]},{"content":"Files that are common to all device families need no special consideration.","pos":[6078,6153]},{"content":"Those files will be used by the app on all the device families that it runs on.","pos":[6154,6233]},{"content":"This includes XAML markup files, imperative source code files, and asset files.","pos":[6234,6313]},{"content":"It is possible for your app to detect the device family that it is running on and navigate to a view that has been designed specifically for that device family.","pos":[6318,6478]},{"content":"For more details, see <bpt id=\"p1\">[</bpt>Detecting the platform your app is running on<ept id=\"p1\">](wpsl-to-uwp-input-and-sensors.md#detecting-the-platform)</ept>.","pos":[6479,6606],"source":" For more details, see [Detecting the platform your app is running on](wpsl-to-uwp-input-and-sensors.md#detecting-the-platform)."},{"content":"A similar technique that you may find useful if there is no alternative is to give a markup file or <bpt id=\"p1\">**</bpt>ResourceDictionary<ept id=\"p1\">**</ept> file (or the folder that contains the file) a special name such that it is automatically loaded at runtime only when your app runs on a particular device family.","pos":[6611,6895],"source":"A similar technique that you may find useful if there is no alternative is to give a markup file or **ResourceDictionary** file (or the folder that contains the file) a special name such that it is automatically loaded at runtime only when your app runs on a particular device family."},{"content":"This technique is illustrated in the <bpt id=\"p1\">[</bpt>Bookstore1<ept id=\"p1\">](wpsl-to-uwp-case-study-bookstore1.md#an-optional-adjustment)</ept> case study.","pos":[6896,7018],"source":" This technique is illustrated in the [Bookstore1](wpsl-to-uwp-case-study-bookstore1.md#an-optional-adjustment) case study."},{"content":"To use features that are not available on all device families (for example, printers, scanners, or the camera button) you can write adaptive code.","pos":[7023,7169]},{"content":"See the third example in <bpt id=\"p1\">[</bpt>Conditional compilation, and adaptive code<ept id=\"p1\">](#conditional-compilation)</ept> in this topic.","pos":[7170,7280],"source":" See the third example in [Conditional compilation, and adaptive code](#conditional-compilation) in this topic."},{"content":"If you want to support both Windows Phone Silverlight and Windows 10, then you may be able to share source code files between projects.","pos":[7285,7420]},{"content":"Here's how: in Visual Studio, right-click the project in <bpt id=\"p1\">**</bpt>Solution Explorer<ept id=\"p1\">**</ept>, select <bpt id=\"p2\">**</bpt>Add Existing Item<ept id=\"p2\">**</ept>, select the files to share, and then click <bpt id=\"p3\">**</bpt>Add As Link<ept id=\"p3\">**</ept>.","pos":[7421,7589],"source":" Here's how: in Visual Studio, right-click the project in **Solution Explorer**, select **Add Existing Item**, select the files to share, and then click **Add As Link**."},{"content":"Store your source code files in a common folder on the file system where the projects that link to them can see them, and don't forget to add them to source control.","pos":[7590,7755]},{"content":"If you can factor your imperative source code so that most, if not all, of a file will work on both platforms, then you don't need to have two copies of it.","pos":[7756,7912]},{"content":"You can wrap any platform-specific logic in the file inside conditional compilation directives where possible, or run-time conditions where necessary.","pos":[7913,8063]},{"content":"See the next section below, and <bpt id=\"p1\">[</bpt>C# Preprocessor Directives<ept id=\"p1\">](http://msdn.microsoft.com/library/ed8yd1ha.aspx)</ept>.","pos":[8064,8174],"source":" See the next section below, and [C# Preprocessor Directives](http://msdn.microsoft.com/library/ed8yd1ha.aspx)."},{"content":"For reuse at the binary level, rather than the source code level, there are Portable Class Libraries, which support the subset of .NET APIs that are available in Windows Phone Silverlight as well as the subset for Windows 10 apps (.NET Core).","pos":[8179,8421]},{"content":"Portable Class Library assemblies are binary compatible with these .NET platforms and more.","pos":[8422,8513]},{"content":"Use Visual Studio to create a project that targets a Portable Class Library.","pos":[8514,8590]},{"content":"See <bpt id=\"p1\">[</bpt>Cross-Platform Development with the Portable Class Library<ept id=\"p1\">](http://msdn.microsoft.com/library/gg597391.aspx)</ept>.","pos":[8591,8705],"source":" See [Cross-Platform Development with the Portable Class Library](http://msdn.microsoft.com/library/gg597391.aspx)."},{"content":"Conditional compilation, and adaptive code","pos":[8710,8752]},{"content":"If you want to support both Windows Phone Silverlight and Windows 10 in a single code file then you can do that.","pos":[8754,8866]},{"content":"If you look in your Windows 10 project at the project properties pages, you'll see that the project defines WINDOWS\\_UAP as a conditional compilation symbol.","pos":[8867,9024]},{"content":"In general, you can use the following logic to perform conditional compilation.","pos":[9025,9104]},{"content":"If you have code that you've been sharing between a Windows Phone Silverlight app and a Windows Store app, then you may already have source code with logic like this:","pos":[9304,9470]},{"content":"If so, and if you now want to support Windows 10 in addition, then you can do that, too.","pos":[9671,9759]},{"content":"You may have used conditional compilation to limit handling of the hardware back button to Windows Phone.","pos":[10066,10171]},{"content":"In Windows 10, the back button event is a universal concept.","pos":[10172,10232]},{"content":"Back buttons implemented in hardware or in software will all raise the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BackRequested<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn893596)</ept> event, so that's the one to handle.","pos":[10233,10417],"source":" Back buttons implemented in hardware or in software will all raise the [**BackRequested**](https://msdn.microsoft.com/library/windows/apps/dn893596) event, so that's the one to handle."},{"content":"You may have used conditional compilation to limit handling of the hardware camera button to Windows Phone.","pos":[10720,10827]},{"content":"In Windows 10, the hardware camera button is a concept particular to the mobile device family.","pos":[10828,10922]},{"content":"Because one app package will be running on all devices, we change our compile-time condition into a run-time condition using what is known as adaptive code.","pos":[10923,11079]},{"content":"To do that, we use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ApiInformation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn949001)</ept> class to query at run-time for the presence of the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>HardwareButtons<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/jj207557)</ept> class.","pos":[11080,11319],"source":" To do that, we use the [**ApiInformation**](https://msdn.microsoft.com/library/windows/apps/dn949001) class to query at run-time for the presence of the [**HardwareButtons**](https://msdn.microsoft.com/library/windows/apps/jj207557) class."},{"content":"<bpt id=\"p1\">**</bpt>HardwareButtons<ept id=\"p1\">**</ept> is defined in the mobile extension SDK, so we'll need to add a reference to that SDK to our project for this code to compile.","pos":[11320,11465],"source":"**HardwareButtons** is defined in the mobile extension SDK, so we'll need to add a reference to that SDK to our project for this code to compile."},{"content":"Note, though, that the handler will only be executed on a device that implements the types defined in the mobile extension SDK, and that's the mobile device family.","pos":[11466,11630]},{"content":"So, the following code is careful only to use features that are present, although it achieves it in a different way from conditional compilation.","pos":[11631,11776]},{"pos":[12357,12472],"content":"Also, see <bpt id=\"p1\">[</bpt>Detecting the platform your app is running on<ept id=\"p1\">](wpsl-to-uwp-input-and-sensors.md#detecting-the-platform)</ept>.","source":"Also, see [Detecting the platform your app is running on](wpsl-to-uwp-input-and-sensors.md#detecting-the-platform)."},{"content":"The app package manifest","pos":[12477,12501]},{"content":"The settings in your project (including any extension SDKs references) determine the API surface area that your app can call.","pos":[12503,12628]},{"content":"But, your app package manifest is what determines the actual set of devices that your customers can install your app onto from the Store.","pos":[12629,12766]},{"content":"For more info, see Examples in <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TargetDeviceFamily<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn986903)</ept>.","pos":[12767,12881],"source":" For more info, see Examples in [**TargetDeviceFamily**](https://msdn.microsoft.com/library/windows/apps/dn986903)."},{"content":"It's worth knowing how to edit the app package manifest, because the topics that follow talk about using it for various declarations, capabilities, and other settings that some features need.","pos":[12883,13074]},{"content":"You can use the Visual Studio app package manifest editor to edit it.","pos":[13075,13144]},{"content":"If the <bpt id=\"p1\">**</bpt>Solution Explorer<ept id=\"p1\">**</ept> is not shown, choose it from the <bpt id=\"p2\">**</bpt>View<ept id=\"p2\">**</ept> menu.","pos":[13145,13221],"source":" If the **Solution Explorer** is not shown, choose it from the **View** menu."},{"content":"Double-click <bpt id=\"p1\">**</bpt>Package.appxmanifest<ept id=\"p1\">**</ept>.","pos":[13222,13260],"source":" Double-click **Package.appxmanifest**."},{"content":"This opens the manifest editor window.","pos":[13261,13299]},{"content":"Select the appropriate tab to make changes and then save the changes.","pos":[13300,13369]},{"content":"You may want to ensure that the <bpt id=\"p1\">**</bpt>pm:PhoneIdentity<ept id=\"p1\">**</ept> element in the ported app manifest matches what is in the app manifest of the app you're porting (for full details, see the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>pm:PhoneIdentity<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/dn934763)</ept> topic).","pos":[13370,13635],"source":" You may want to ensure that the **pm:PhoneIdentity** element in the ported app manifest matches what is in the app manifest of the app you're porting (for full details, see the [**pm:PhoneIdentity**](https://msdn.microsoft.com/library/windows/apps/dn934763) topic)."},{"pos":[13637,13750],"content":"See <bpt id=\"p1\">[</bpt>Package manifest schema reference for Windows 10<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn934820)</ept>.","source":"See [Package manifest schema reference for Windows 10](https://msdn.microsoft.com/library/windows/apps/dn934820)."},{"pos":[13752,13820],"content":"The next topic is <bpt id=\"p1\">[</bpt>Troubleshooting<ept id=\"p1\">](wpsl-to-uwp-troubleshooting.md)</ept>.","source":"The next topic is [Troubleshooting](wpsl-to-uwp-troubleshooting.md)."}],"content":"---\ndescription: You begin the porting process by creating a new Windows 10 project in Visual Studio and copying your files into it.\ntitle: Porting a Windows Phone Silverlight project to a UWP project\nms.assetid: d86c99c5-eb13-4e37-b000-6a657543d8f4\n---\n\n# Porting a Windows Phone Silverlight project to a UWP project\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nThe previous topic was [Namespace and class mappings](wpsl-to-uwp-namespace-and-class-mappings.md).\n\nYou begin the porting process by creating a new Windows 10 project in Visual Studio and copying your files into it.\n\n## Create the project and copy files to it\n\n1.  Launch Microsoft Visual Studio 2015 and create a new Blank Application (Windows Universal) project. For more info, see [Jumpstart your Windows Store app using templates (C#, C++, Visual Basic)](https://msdn.microsoft.com/library/windows/apps/hh768232). Your new project builds an app package (an appx file) that will run on all device families.\n2.  In your Windows Phone Silverlight app project, identify all the source code files and visual asset files that you want to reuse. Using File Explorer, copy data models, view models, visual assets, Resource Dictionaries, folder structure, and anything else that you wish to re-use, to your new project. Copy or create sub-folders on disk as necessary.\n3.  Copy views (for example, MainPage.xaml and MainPage.xaml.cs) into the new project node, too. Again, create new sub-folders as necessary, and remove the existing views from the project. But, before you over-write or remove a view that Visual Studio generated, keep a copy because it may be useful to refer to it later. The first phase of porting a Windows Phone Silverlight app focuses on getting it to look good and work well on one device family. Later, you'll turn your attention to making sure the views adapt themselves well to all form factors, and optionally to adding any adaptive code to get the most from a particular device family.\n4.  In **Solution Explorer**, make sure **Show All Files** is toggled on. Select the files that you copied, right-click them, and click **Include In Project**. This will automatically include their containing folders. You can then toggle **Show All Files** off if you like. An alternative workflow, if you prefer, is to use the **Add Existing Item** command, having created any necessary sub-folders in the Visual Studio **Solution Explorer**. Double-check that your visual assets have **Build Action** set to **Content** and **Copy to Output Directory** set to **Do not copy**.\n5.  The differences in namespace and class names will generate lots of build errors at this stage. For example, if you open the views that Visual Studio generated, you'll see that they are of type [**Page**](https://msdn.microsoft.com/library/windows/apps/br227503), and not **PhoneApplicationPage**. There are lots of XAML markup and imperative code differences that the following topics in this porting guide cover in detail. But, you'll make fast progress just following these general steps: change \"clr-namespace\" to \"using\" in your namespace prefix declarations in XAML markup; use the [Namespace and class mappings](wpsl-to-uwp-namespace-and-class-mappings.md) topic and Visual Studio's **Find and Replace** command to make bulk changes to your source code (for example, replace \"System.Windows\" with \"Windows.UI.Xaml\"); and in the imperative code editor in Visual Studio use the **Resolve** and **Organize Usings** commands on the context menu for more targeted changes.\n\n## Extension SDKs\n\nMost of the Universal Windows Platform (UWP) APIs your ported app will call are implemented in the set of APIs known as the universal device family. But, some are implemented in extension SDKs, and Visual Studio only recognizes APIs that are implemented by your app's target device family or by any extension SDKs that you have referenced.\n\nIf you get compile errors about namespaces or types or members that could not be found, then this is likely to be the cause. Open the API's topic in the API reference documentation and navigate to the Requirements section: that will tell you what the implementing device family is. If that's not your target device family, then to make the API available to your project, you will need a reference to the extension SDK for that device family.\n\nClick **Project** &gt; **Add Reference** &gt; **Windows Universal** &gt; **Extensions** and select the appropriate extension SDK. For example, if the APIs you want to call are available only in the mobile device family, and they were introduced in version 10.0.x.y, then select **Windows Mobile Extensions for the UWP**.\n\nThat will add the following reference to your project file:\n\n```XML\n<ItemGroup>\n    <SDKReference Include=\"WindowsMobile, Version=10.0.x.y\">\n        <Name>Windows Mobile Extensions for the UWP</Name>\n    </SDKReference>\n</ItemGroup>\n```\n\nThe name and version number match the folders in the installed location of your SDK. For example, the above information matches this folder name:\n\n`\\Program Files (x86)\\Windows Kits\\10\\Extension SDKs\\WindowsMobile\\10.0.x.y`\n\nUnless your app targets the device family that implements the API, you'll need to use the [**ApiInformation**](https://msdn.microsoft.com/library/windows/apps/dn949001) class to test for the presence of the API before you call it (this is called adaptive code). This condition will then be evaluated wherever your app runs, but it will only evaluate to true on devices where the API is present and therefore available to call. Only use extension SDKs and adaptive code after first checking whether a universal API exists. Some examples are given in the section below.\n\nAlso, see [App package manifest](#appxpackage).\n\n## Maximizing markup and code reuse\n\nYou will find that refactoring a little, and/or adding adaptive code (which is explained below), will allow you to maximize the markup and code that works across all device families. Here are more details.\n\n-   Files that are common to all device families need no special consideration. Those files will be used by the app on all the device families that it runs on. This includes XAML markup files, imperative source code files, and asset files.\n-   It is possible for your app to detect the device family that it is running on and navigate to a view that has been designed specifically for that device family. For more details, see [Detecting the platform your app is running on](wpsl-to-uwp-input-and-sensors.md#detecting-the-platform).\n-   A similar technique that you may find useful if there is no alternative is to give a markup file or **ResourceDictionary** file (or the folder that contains the file) a special name such that it is automatically loaded at runtime only when your app runs on a particular device family. This technique is illustrated in the [Bookstore1](wpsl-to-uwp-case-study-bookstore1.md#an-optional-adjustment) case study.\n-   To use features that are not available on all device families (for example, printers, scanners, or the camera button) you can write adaptive code. See the third example in [Conditional compilation, and adaptive code](#conditional-compilation) in this topic.\n-   If you want to support both Windows Phone Silverlight and Windows 10, then you may be able to share source code files between projects. Here's how: in Visual Studio, right-click the project in **Solution Explorer**, select **Add Existing Item**, select the files to share, and then click **Add As Link**. Store your source code files in a common folder on the file system where the projects that link to them can see them, and don't forget to add them to source control. If you can factor your imperative source code so that most, if not all, of a file will work on both platforms, then you don't need to have two copies of it. You can wrap any platform-specific logic in the file inside conditional compilation directives where possible, or run-time conditions where necessary. See the next section below, and [C# Preprocessor Directives](http://msdn.microsoft.com/library/ed8yd1ha.aspx).\n-   For reuse at the binary level, rather than the source code level, there are Portable Class Libraries, which support the subset of .NET APIs that are available in Windows Phone Silverlight as well as the subset for Windows 10 apps (.NET Core). Portable Class Library assemblies are binary compatible with these .NET platforms and more. Use Visual Studio to create a project that targets a Portable Class Library. See [Cross-Platform Development with the Portable Class Library](http://msdn.microsoft.com/library/gg597391.aspx).\n\n## Conditional compilation, and adaptive code\n\nIf you want to support both Windows Phone Silverlight and Windows 10 in a single code file then you can do that. If you look in your Windows 10 project at the project properties pages, you'll see that the project defines WINDOWS\\_UAP as a conditional compilation symbol. In general, you can use the following logic to perform conditional compilation.\n\n```csharp\n#if WINDOWS_UAP\n    // Code that you want to compile into the Windows 10 app.\n#else\n    // Code that you want to compile into the Windows Phone Silverlight app.\n#endif // WINDOWS_UAP\n```\n\nIf you have code that you've been sharing between a Windows Phone Silverlight app and a Windows Store app, then you may already have source code with logic like this:\n\n```csharp\n#if NETFX_CORE\n    // Code that you want to compile into the Windows Store app.\n#else\n    // Code that you want to compile into the Windows Phone Silverlight app.\n#endif // NETFX_CORE\n```\n\nIf so, and if you now want to support Windows 10 in addition, then you can do that, too.\n\n```csharp\n#if WINDOWS_UAP\n    // Code that you want to compile into the Windows 10 app.\n#else\n#if NETFX_CORE\n    // Code that you want to compile into the Windows Store app.\n#else\n    // Code that you want to compile into the Windows Phone Silverlight app.\n#endif // NETFX_CORE\n#endif // WINDOWS_UAP\n```\n\nYou may have used conditional compilation to limit handling of the hardware back button to Windows Phone. In Windows 10, the back button event is a universal concept. Back buttons implemented in hardware or in software will all raise the [**BackRequested**](https://msdn.microsoft.com/library/windows/apps/dn893596) event, so that's the one to handle.\n\n```csharp\n       Windows.UI.Core.SystemNavigationManager.GetForCurrentView().BackRequested +=\n            this.ViewModelLocator_BackRequested;\n\n...\n\n    private void ViewModelLocator_BackRequested(object sender, Windows.UI.Core.BackRequestedEventArgs e)\n    {\n        // Handle the event.\n    }\n\n```\n\nYou may have used conditional compilation to limit handling of the hardware camera button to Windows Phone. In Windows 10, the hardware camera button is a concept particular to the mobile device family. Because one app package will be running on all devices, we change our compile-time condition into a run-time condition using what is known as adaptive code. To do that, we use the [**ApiInformation**](https://msdn.microsoft.com/library/windows/apps/dn949001) class to query at run-time for the presence of the [**HardwareButtons**](https://msdn.microsoft.com/library/windows/apps/jj207557) class. **HardwareButtons** is defined in the mobile extension SDK, so we'll need to add a reference to that SDK to our project for this code to compile. Note, though, that the handler will only be executed on a device that implements the types defined in the mobile extension SDK, and that's the mobile device family. So, the following code is careful only to use features that are present, although it achieves it in a different way from conditional compilation.\n\n```csharp\n       // Note: Cache the value instead of querying it more than once.\n        bool isHardwareButtonsAPIPresent = Windows.Foundation.Metadata.ApiInformation.IsTypePresent\n            (\"Windows.Phone.UI.Input.HardwareButtons\");\n\n        if (isHardwareButtonsAPIPresent)\n        {\n            Windows.Phone.UI.Input.HardwareButtons.CameraPressed +=\n                this.HardwareButtons_CameraPressed;\n        }\n\n    ...\n\n    private void HardwareButtons_CameraPressed(object sender, Windows.Phone.UI.Input.CameraEventArgs e)\n    {\n        // Handle the event.\n    }\n```\n\nAlso, see [Detecting the platform your app is running on](wpsl-to-uwp-input-and-sensors.md#detecting-the-platform).\n\n## The app package manifest\n\nThe settings in your project (including any extension SDKs references) determine the API surface area that your app can call. But, your app package manifest is what determines the actual set of devices that your customers can install your app onto from the Store. For more info, see Examples in [**TargetDeviceFamily**](https://msdn.microsoft.com/library/windows/apps/dn986903).\n\nIt's worth knowing how to edit the app package manifest, because the topics that follow talk about using it for various declarations, capabilities, and other settings that some features need. You can use the Visual Studio app package manifest editor to edit it. If the **Solution Explorer** is not shown, choose it from the **View** menu. Double-click **Package.appxmanifest**. This opens the manifest editor window. Select the appropriate tab to make changes and then save the changes. You may want to ensure that the **pm:PhoneIdentity** element in the ported app manifest matches what is in the app manifest of the app you're porting (for full details, see the [**pm:PhoneIdentity**](https://msdn.microsoft.com/library/windows/apps/dn934763) topic).\n\nSee [Package manifest schema reference for Windows 10](https://msdn.microsoft.com/library/windows/apps/dn934820).\n\nThe next topic is [Troubleshooting](wpsl-to-uwp-troubleshooting.md).\n\n"}