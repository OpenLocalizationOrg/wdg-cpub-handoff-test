{"nodes":[{"pos":[11,29],"content":"Draw to the screen","needQuote":true,"needEscape":true,"nodes":[{"content":"Draw to the screen","pos":[0,18]}]},{"pos":[43,112],"content":"Finally, we port the code that draws the spinning cube to the screen.","needQuote":true,"needEscape":true,"nodes":[{"content":"Finally, we port the code that draws the spinning cube to the screen.","pos":[0,69]}]},{"content":"Draw to the screen","pos":[169,187]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[190,228]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[229,324],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Important APIs","pos":[329,343]},{"content":"ID3D11Texture2D","pos":[354,369]},{"content":"ID3D11RenderTargetView","pos":[441,463]},{"content":"IDXGISwapChain1","pos":[535,550]},{"content":"Finally, we port the code that draws the spinning cube to the screen.","pos":[616,685]},{"content":"In OpenGL ES 2.0, your drawing context is defined as an EGLContext type, which contains the window and surface parameters as well the resources necessary for drawing to the render targets that will be used to compose the final image displayed to the window.","pos":[687,944]},{"content":"You use this context to configure the graphics resources to correctly display the results of your shader pipeline on the display.","pos":[945,1074]},{"content":"One of the primary resources is the \"back buffer\" (or \"frame buffer object\") that contains the final, composited render targets, ready for presentation to the display.","pos":[1075,1242]},{"content":"With Direct3D, the process of configuring the graphics resources for drawing to the display is more didactic, and requires quite a few more APIs.","pos":[1244,1389]},{"content":"(A Microsoft Visual Studio Direct3D template can significantly simplify this process, though!) To obtain a context (called a Direct3D device context), you must first obtain an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> object, and use it to create and configure an <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext1<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept> object.","pos":[1390,1788],"source":" (A Microsoft Visual Studio Direct3D template can significantly simplify this process, though!) To obtain a context (called a Direct3D device context), you must first obtain an [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575) object, and use it to create and configure an [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) object."},{"content":"These two objects are used in conjunction to configure the specific resources you need for drawing to the display.","pos":[1789,1903]},{"content":"In short, the DXGI APIs contain primarily APIs for managing resources that directly pertain to the graphics adapter, and Direct3D contains the APIs that allow you to interface between the GPU and your main program running on the CPU.","pos":[1905,2138]},{"content":"For the purposes of comparison in this sample, here are the relevant types from each API:","pos":[2140,2229]},{"pos":[2235,2392],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept>: provides a virtual representation of the graphics device and its resources.","source":"[**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575): provides a virtual representation of the graphics device and its resources."},{"pos":[2397,2559],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept>: provides the interface to configure buffers and issue rendering commands.","source":"[**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598): provides the interface to configure buffers and issue rendering commands."},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404631)</ept>: the swap chain is analogous to the back buffer in OpenGL ES 2.0.","pos":[2564,2712],"source":"[**IDXGISwapChain1**](https://msdn.microsoft.com/library/windows/desktop/hh404631): the swap chain is analogous to the back buffer in OpenGL ES 2.0."},{"content":"It is the region of memory on the graphics adapter that contains the final rendered image(s) for display.","pos":[2713,2818]},{"content":"It is called the \"swap chain\" because it has several buffers that can be written to and \"swapped\" to present the latest render to the screen.","pos":[2819,2960]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11RenderTargetView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</ept>: this contains the 2D bitmap buffer that the Direct3D device context draws into, and which is presented by the swap chain.","pos":[2965,3177],"source":"[**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582): this contains the 2D bitmap buffer that the Direct3D device context draws into, and which is presented by the swap chain."},{"content":"As with OpenGL ES 2.0, you can have multiple render targets, some of which are not bound to the swap chain but are used for multi-pass shading techniques.","pos":[3178,3332]},{"content":"In the template, the renderer object contains the following fields:","pos":[3334,3401]},{"content":"Direct3D 11: Device and device context declarations","pos":[3403,3454]},{"content":"Here's how the back buffer is configured as a render target and provided to the swap chain.","pos":[3836,3927]},{"pos":[4142,4446],"content":"The Direct3D runtime implicitly creates an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISurface1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff471343)</ept> for the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11Texture2D<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept>, which represents the texture as a \"back buffer\" that the swap chain can use for display.","source":"The Direct3D runtime implicitly creates an [**IDXGISurface1**](https://msdn.microsoft.com/library/windows/desktop/ff471343) for the [**ID3D11Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff476635), which represents the texture as a \"back buffer\" that the swap chain can use for display."},{"pos":[4448,4688],"content":"The initialization and configuration of the Direct3D device and device context, as well as the render targets, can be found in the custom <bpt id=\"p1\">**</bpt>CreateDeviceResources<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>CreateWindowSizeDependentResources<ept id=\"p2\">**</ept> methods in the Direct3D template.","source":"The initialization and configuration of the Direct3D device and device context, as well as the render targets, can be found in the custom **CreateDeviceResources** and **CreateWindowSizeDependentResources** methods in the Direct3D template."},{"pos":[4690,4847],"content":"For more info on Direct3D device context as it relates to EGL and the EGLContext type, read <bpt id=\"p1\">[</bpt>Port EGL code to DXGI and Direct3D<ept id=\"p1\">](moving-from-egl-to-dxgi.md)</ept>.","source":"For more info on Direct3D device context as it relates to EGL and the EGLContext type, read [Port EGL code to DXGI and Direct3D](moving-from-egl-to-dxgi.md)."},{"content":"Instructions","pos":[4852,4864]},{"content":"Step 1: Rendering the scene and displaying it","pos":[4870,4915]},{"content":"After updating the cube data (in this case, by rotating it slightly around the y axis), the Render method sets the viewport to the dimensions of he drawing context (an EGLContext).","pos":[4917,5097]},{"content":"This context contains the color buffer that will be displayed to the window surface (an EGLSurface), using the configured display (EGLDisplay).","pos":[5098,5241]},{"content":"At this time, the example updates the vertex data attributes, re-binds the index buffer, draws the cube, and swaps in color buffer drawn by the shading pipeline to the display surface.","pos":[5242,5426]},{"content":"OpenGL ES 2.0: Rendering a frame for display","pos":[5428,5472]},{"content":"In Direct3D 11, the process is very similar.","pos":[6823,6867]},{"content":"(We're assuming that you're using the viewport and render target configuration from the Direct3D template.","pos":[6868,6974]},{"pos":[6980,7178],"content":"Update the constant buffers (the model-view-projection matrix, in this case) with calls to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::UpdateSubresource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446790)</ept>.","source":"Update the constant buffers (the model-view-projection matrix, in this case) with calls to [**ID3D11DeviceContext1::UpdateSubresource**](https://msdn.microsoft.com/library/windows/desktop/hh446790)."},{"pos":[7183,7318],"content":"Set the vertex buffer with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::IASetVertexBuffers<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476456)</ept>.","source":"Set the vertex buffer with [**ID3D11DeviceContext1::IASetVertexBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476456)."},{"pos":[7323,7455],"content":"Set the index buffer with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::IASetIndexBuffer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476453)</ept>.","source":"Set the index buffer with [**ID3D11DeviceContext1::IASetIndexBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476453)."},{"pos":[7460,7630],"content":"Set the specific triangle topology (a triangle list) with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::IASetPrimitiveTopology<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476455)</ept>.","source":"Set the specific triangle topology (a triangle list) with [**ID3D11DeviceContext1::IASetPrimitiveTopology**](https://msdn.microsoft.com/library/windows/desktop/ff476455)."},{"pos":[7635,7788],"content":"Set the input layout of the vertex buffer with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::IASetInputLayout<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476454)</ept>.","source":"Set the input layout of the vertex buffer with [**ID3D11DeviceContext1::IASetInputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476454)."},{"pos":[7793,7922],"content":"Bind the vertex shader with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::VSSetShader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</ept>.","source":"Bind the vertex shader with [**ID3D11DeviceContext1::VSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476493)."},{"pos":[7927,8058],"content":"Bind the fragment shader with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::PSSetShader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</ept>.","source":"Bind the fragment shader with [**ID3D11DeviceContext1::PSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476472)."},{"pos":[8063,8272],"content":"Send the indexed vertices through the shaders and output the color results to the render target buffer with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::DrawIndexed<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476409)</ept>.","source":"Send the indexed vertices through the shaders and output the color results to the render target buffer with [**ID3D11DeviceContext1::DrawIndexed**](https://msdn.microsoft.com/library/windows/desktop/ff476409)."},{"pos":[8277,8408],"content":"Display the render target buffer with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1::Present1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</ept>.","source":"Display the render target buffer with [**IDXGISwapChain1::Present1**](https://msdn.microsoft.com/library/windows/desktop/hh446797)."},{"content":"Direct3D 11: Rendering a frame for display","pos":[8410,8452]},{"pos":[9708,9864],"content":"Once <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1::Present1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</ept> is called, your frame is output to the configured display.","source":"Once [**IDXGISwapChain1::Present1**](https://msdn.microsoft.com/library/windows/desktop/hh446797) is called, your frame is output to the configured display."},{"content":"Previous step","pos":[9869,9882]},{"content":"Port the GLSL","pos":[9886,9899]},{"content":"Remarks","pos":[9923,9930]},{"content":"This example glosses over much of the complexity that goes into configuring device resources, especially for Universal Windows Platform (UWP) DirectX apps.","pos":[9932,10087]},{"content":"We suggest you review the full template code, especially the parts that perform the window and device resource setup and management.","pos":[10088,10220]},{"content":"UWP apps have to support rotation events as well as suspend/resume events, and the template demonstrates best practices for handling the loss of an interface or a change in the display parameters.","pos":[10221,10417]},{"content":"Related topics","pos":[10422,10436]},{"content":"How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11","pos":[10442,10501]},{"content":"Port the shader objects","pos":[10563,10586]},{"content":"Port the GLSL","pos":[10618,10631]},{"content":"Draw to the screen","pos":[10654,10672]}],"content":"---\ntitle: Draw to the screen\ndescription: Finally, we port the code that draws the spinning cube to the screen.\nms.assetid: cc681548-f694-f613-a19d-1525a184d4ab\n---\n\n# Draw to the screen\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\n**Important APIs**\n\n-   [**ID3D11Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff476635)\n-   [**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582)\n-   [**IDXGISwapChain1**](https://msdn.microsoft.com/library/windows/desktop/hh404631)\n\nFinally, we port the code that draws the spinning cube to the screen.\n\nIn OpenGL ES 2.0, your drawing context is defined as an EGLContext type, which contains the window and surface parameters as well the resources necessary for drawing to the render targets that will be used to compose the final image displayed to the window. You use this context to configure the graphics resources to correctly display the results of your shader pipeline on the display. One of the primary resources is the \"back buffer\" (or \"frame buffer object\") that contains the final, composited render targets, ready for presentation to the display.\n\nWith Direct3D, the process of configuring the graphics resources for drawing to the display is more didactic, and requires quite a few more APIs. (A Microsoft Visual Studio Direct3D template can significantly simplify this process, though!) To obtain a context (called a Direct3D device context), you must first obtain an [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575) object, and use it to create and configure an [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) object. These two objects are used in conjunction to configure the specific resources you need for drawing to the display.\n\nIn short, the DXGI APIs contain primarily APIs for managing resources that directly pertain to the graphics adapter, and Direct3D contains the APIs that allow you to interface between the GPU and your main program running on the CPU.\n\nFor the purposes of comparison in this sample, here are the relevant types from each API:\n\n-   [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575): provides a virtual representation of the graphics device and its resources.\n-   [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598): provides the interface to configure buffers and issue rendering commands.\n-   [**IDXGISwapChain1**](https://msdn.microsoft.com/library/windows/desktop/hh404631): the swap chain is analogous to the back buffer in OpenGL ES 2.0. It is the region of memory on the graphics adapter that contains the final rendered image(s) for display. It is called the \"swap chain\" because it has several buffers that can be written to and \"swapped\" to present the latest render to the screen.\n-   [**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582): this contains the 2D bitmap buffer that the Direct3D device context draws into, and which is presented by the swap chain. As with OpenGL ES 2.0, you can have multiple render targets, some of which are not bound to the swap chain but are used for multi-pass shading techniques.\n\nIn the template, the renderer object contains the following fields:\n\nDirect3D 11: Device and device context declarations\n\n``` syntax\nPlatform::Agile<Windows::UI::Core::CoreWindow>       m_window;\n\nMicrosoft::WRL::ComPtr<ID3D11Device1>                m_d3dDevice;\nMicrosoft::WRL::ComPtr<ID3D11DeviceContext1>          m_d3dContext;\nMicrosoft::WRL::ComPtr<IDXGISwapChain1>                      m_swapChainCoreWindow;\nMicrosoft::WRL::ComPtr<ID3D11RenderTargetView>          m_d3dRenderTargetViewWin;\n```\n\nHere's how the back buffer is configured as a render target and provided to the swap chain.\n\n``` syntax\nComPtr<ID3D11Texture2D> backBuffer;\nm_swapChainCoreWindow->GetBuffer(0, IID_PPV_ARGS(backBuffer));\nm_d3dDevice->CreateRenderTargetView(\n  backBuffer.Get(),\n  nullptr,\n  &m_d3dRenderTargetViewWin);\n```\n\nThe Direct3D runtime implicitly creates an [**IDXGISurface1**](https://msdn.microsoft.com/library/windows/desktop/ff471343) for the [**ID3D11Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff476635), which represents the texture as a \"back buffer\" that the swap chain can use for display.\n\nThe initialization and configuration of the Direct3D device and device context, as well as the render targets, can be found in the custom **CreateDeviceResources** and **CreateWindowSizeDependentResources** methods in the Direct3D template.\n\nFor more info on Direct3D device context as it relates to EGL and the EGLContext type, read [Port EGL code to DXGI and Direct3D](moving-from-egl-to-dxgi.md).\n\n## Instructions\n\n### Step 1: Rendering the scene and displaying it\n\nAfter updating the cube data (in this case, by rotating it slightly around the y axis), the Render method sets the viewport to the dimensions of he drawing context (an EGLContext). This context contains the color buffer that will be displayed to the window surface (an EGLSurface), using the configured display (EGLDisplay). At this time, the example updates the vertex data attributes, re-binds the index buffer, draws the cube, and swaps in color buffer drawn by the shading pipeline to the display surface.\n\nOpenGL ES 2.0: Rendering a frame for display\n\n``` syntax\nvoid Render(GraphicsContext *drawContext)\n{\n  Renderer *renderer = drawContext->renderer;\n\n  int loc;\n   \n  // Set the viewport\n  glViewport ( 0, 0, drawContext->width, drawContext->height );\n   \n   \n  // Clear the color buffer\n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n  glEnable(GL_DEPTH_TEST);\n\n\n  // Use the program object\n  glUseProgram (renderer->programObject);\n\n  // Load the a_position attribute with the vertex position portion of a vertex buffer element\n  loc = glGetAttribLocation(renderer->programObject, \"a_position\");\n  glVertexAttribPointer(loc, 3, GL_FLOAT, GL_FALSE, \n      sizeof(Vertex), 0);\n  glEnableVertexAttribArray(loc);\n\n  // Load the a_color attribute with the color position portion of a vertex buffer element\n  loc = glGetAttribLocation(renderer->programObject, \"a_color\");\n  glVertexAttribPointer(loc, 4, GL_FLOAT, GL_FALSE, \n      sizeof(Vertex), (GLvoid*) (sizeof(float) * 3));\n  glEnableVertexAttribArray(loc);\n\n  // Bind the index buffer\n  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, renderer->indexBuffer);\n\n  // Load the MVP matrix\n  glUniformMatrix4fv(renderer->mvpLoc, 1, GL_FALSE, (GLfloat*) &renderer->mvpMatrix.m[0][0]);\n\n  // Draw the cube\n  glDrawElements(GL_TRIANGLES, renderer->numIndices, GL_UNSIGNED_INT, 0);\n\n  eglSwapBuffers(drawContext->eglDisplay, drawContext->eglSurface);\n}\n```\n\nIn Direct3D 11, the process is very similar. (We're assuming that you're using the viewport and render target configuration from the Direct3D template.\n\n-   Update the constant buffers (the model-view-projection matrix, in this case) with calls to [**ID3D11DeviceContext1::UpdateSubresource**](https://msdn.microsoft.com/library/windows/desktop/hh446790).\n-   Set the vertex buffer with [**ID3D11DeviceContext1::IASetVertexBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476456).\n-   Set the index buffer with [**ID3D11DeviceContext1::IASetIndexBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476453).\n-   Set the specific triangle topology (a triangle list) with [**ID3D11DeviceContext1::IASetPrimitiveTopology**](https://msdn.microsoft.com/library/windows/desktop/ff476455).\n-   Set the input layout of the vertex buffer with [**ID3D11DeviceContext1::IASetInputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476454).\n-   Bind the vertex shader with [**ID3D11DeviceContext1::VSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476493).\n-   Bind the fragment shader with [**ID3D11DeviceContext1::PSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476472).\n-   Send the indexed vertices through the shaders and output the color results to the render target buffer with [**ID3D11DeviceContext1::DrawIndexed**](https://msdn.microsoft.com/library/windows/desktop/ff476409).\n-   Display the render target buffer with [**IDXGISwapChain1::Present1**](https://msdn.microsoft.com/library/windows/desktop/hh446797).\n\nDirect3D 11: Rendering a frame for display\n\n``` syntax\nvoid RenderObject::Render()\n{\n  // ...\n\n  // Only update shader resources that have changed since the last frame.\n  m_d3dContext->UpdateSubresource(\n    m_constantBuffer.Get(),\n    0,\n    NULL,\n    &m_constantBufferData,\n    0,\n    0);\n\n  // Set up the IA stage corresponding to the current draw operation.\n  UINT stride = sizeof(VertexPositionColor);\n  UINT offset = 0;\n  m_d3dContext->IASetVertexBuffers(\n    0,\n    1,\n    m_vertexBuffer.GetAddressOf(),\n    &stride,\n    &offset);\n\n  m_d3dContext->IASetIndexBuffer(\n    m_indexBuffer.Get(),\n    DXGI_FORMAT_R16_UINT,\n    0);\n\n  m_d3dContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n  m_d3dContext->IASetInputLayout(m_inputLayout.Get());\n\n  // Set up the vertex shader corresponding to the current draw operation.\n  m_d3dContext->VSSetShader(\n    m_vertexShader.Get(),\n    nullptr,\n    0);\n\n  m_d3dContext->VSSetConstantBuffers(\n    0,\n    1,\n    m_constantBuffer.GetAddressOf());\n\n  // Set up the pixel shader corresponding to the current draw operation.\n  m_d3dContext->PSSetShader(\n    m_pixelShader.Get(),\n    nullptr,\n    0);\n\n  m_d3dContext->DrawIndexed(\n    m_indexCount,\n    0,\n    0);\n\n    // ...\n\n  m_swapChainCoreWindow->Present1(1, 0, &parameters);\n}\n\n```\n\nOnce [**IDXGISwapChain1::Present1**](https://msdn.microsoft.com/library/windows/desktop/hh446797) is called, your frame is output to the configured display.\n\n## Previous step\n\n\n[Port the GLSL](port-the-glsl.md)\n\n## Remarks\n\nThis example glosses over much of the complexity that goes into configuring device resources, especially for Universal Windows Platform (UWP) DirectX apps. We suggest you review the full template code, especially the parts that perform the window and device resource setup and management. UWP apps have to support rotation events as well as suspend/resume events, and the template demonstrates best practices for handling the loss of an interface or a change in the display parameters.\n\n## Related topics\n\n\n* [How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11](port-a-simple-opengl-es-2-0-renderer-to-directx-11-1.md)\n* [Port the shader objects](port-the-shader-config.md)\n* [Port the GLSL](port-the-glsl.md)\n* [Draw to the screen](draw-to-the-screen.md)\n\n \n\n \n\n\n\n\n"}