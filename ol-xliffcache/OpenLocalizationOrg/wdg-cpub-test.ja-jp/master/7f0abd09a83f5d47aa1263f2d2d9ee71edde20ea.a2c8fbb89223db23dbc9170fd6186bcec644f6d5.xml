{"nodes":[{"pos":[11,67],"content":"Adding input and interactivity to the Marble Maze sample","needQuote":true,"needEscape":true,"nodes":[{"content":"Adding input and interactivity to the Marble Maze sample","pos":[0,56]}]},{"pos":[81,206],"content":"Universal Windows Platform (UWP) app games run on a wide variety of devices, such as desktop computers, laptops, and tablets.","needQuote":true,"needEscape":true,"nodes":[{"content":"Universal Windows Platform (UWP) app games run on a wide variety of devices, such as desktop computers, laptops, and tablets.","pos":[0,125]}]},{"content":"Adding input and interactivity to the Marble Maze sample","pos":[263,319]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[322,360]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[361,456],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Universal Windows Platform (UWP) app games run on a wide variety of devices, such as desktop computers, laptops, and tablets.","pos":[459,584]},{"content":"A device can have a wide variety of input and control mechanisms.","pos":[585,650]},{"content":"Support multiple input devices to enable your game to accommodate a wider range of preferences and abilities among your customers.","pos":[651,781]},{"content":"This document describes the key practices to keep in mind when you work with input devices and shows how Marble Maze applies these practices.","pos":[782,923]},{"pos":[927,1085],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   The sample code that corresponds to this document is found in the <bpt id=\"p2\">[</bpt>DirectX Marble Maze game sample<ept id=\"p2\">](http://go.microsoft.com/fwlink/?LinkId=624011)</ept>.","source":"**Note**   The sample code that corresponds to this document is found in the [DirectX Marble Maze game sample](http://go.microsoft.com/fwlink/?LinkId=624011)."},{"content":"Here are some of the key points that this document discusses for when you work with input in your game:","pos":[1089,1192]},{"content":"When possible, support multiple input devices to enable your game to accommodate a wider range of preferences and abilities among your customers.","pos":[1198,1343]},{"content":"Although game controller and sensor usage is optional, we strongly recommend it to enhance the player experience.","pos":[1344,1457]},{"content":"We designed the game controller and sensor API to help you more easily integrate these input devices.","pos":[1458,1559]},{"content":"To initialize touch, you must register for window events such as when the pointer is activated, released, and moved.","pos":[1564,1680]},{"content":"To initialize the accelerometer, create a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows::Devices::Sensors::Accelerometer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br225687)</ept> object when you initialize the application.","pos":[1681,1871],"source":" To initialize the accelerometer, create a [**Windows::Devices::Sensors::Accelerometer**](https://msdn.microsoft.com/library/windows/apps/br225687) object when you initialize the application."},{"content":"The Xbox 360 controller doesn't require initialization.","pos":[1872,1927]},{"content":"For single-player games, consider whether to combine input from all possible Xbox 360 controllers.","pos":[1932,2030]},{"content":"This way, you don’t have to track what input comes from which controller.","pos":[2031,2104]},{"content":"Process Windows events before you process input devices.","pos":[2109,2165]},{"content":"The Xbox 360 controller and the accelerometer support polling.","pos":[2170,2232]},{"content":"That is, you can poll for data when you need it.","pos":[2233,2281]},{"content":"For touch, record touch events in data structures that are available to your input processing code.","pos":[2282,2381]},{"content":"Consider whether to normalize input values to a common format.","pos":[2386,2448]},{"content":"Doing so can simplify how input is interpreted by other components of your game, such as physics simulation, and can make it easier to write games that work on different screen resolutions.","pos":[2449,2638]},{"content":"Input devices supported by Marble Maze","pos":[2643,2681]},{"content":"Marble Maze supports Xbox 360 common controller devices, mouse, and touch to select menu items, and the Xbox 360 controller, mouse, touch, and the accelerometer to control game play.","pos":[2684,2866]},{"content":"Marble Maze uses the XInput API to poll the controller for input.","pos":[2867,2932]},{"content":"Touch enables applications to track and respond to fingertip input.","pos":[2933,3000]},{"content":"An accelerometer is a sensor that measures the force that is applied along the x, y, and z axes.","pos":[3001,3097]},{"content":"By using the Windows Runtime, you can poll the current state of the accelerometer device, as well as receive touch events through the Windows Runtime event-handling mechanism.","pos":[3098,3273]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  This document uses touch to refer to both touch and mouse input and pointer to refer to any device that uses pointer events.","pos":[3277,3411],"source":"**Note**  This document uses touch to refer to both touch and mouse input and pointer to refer to any device that uses pointer events."},{"content":"Because touch and the mouse use standard pointer events, you can use either device to select menu items and control game play.","pos":[3412,3538]},{"pos":[3545,3717],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  The package manifest sets Landscape as the supported rotation for the game to prevent the orientation from changing when you rotate the device to roll the marble.","source":"**Note**  The package manifest sets Landscape as the supported rotation for the game to prevent the orientation from changing when you rotate the device to roll the marble."},{"content":"Initializing input devices","pos":[3725,3751]},{"content":"The Xbox 360 controller does not require initialization.","pos":[3754,3810]},{"content":"To initialize touch, you must register for windowing events such as when the pointer is activated (for example, your user presses the mouse button or touches the screen), released, and moved.","pos":[3811,4002]},{"content":"To initialize the accelerometer, you have to create a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows::Devices::Sensors::Accelerometer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br225687)</ept> object when you initialize the application.","pos":[4003,4205],"source":" To initialize the accelerometer, you have to create a [**Windows::Devices::Sensors::Accelerometer**](https://msdn.microsoft.com/library/windows/apps/br225687) object when you initialize the application."},{"content":"The following example shows how the <bpt id=\"p1\">**</bpt>DirectXPage<ept id=\"p1\">**</ept> constructor registers for the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Windows::UI::Core::CoreIndependentInputSource::PointerPressed<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/dn298471)</ept>, <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>Windows::UI::Core::CoreIndependentInputSource::PointerReleased<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/dn298472)</ept>, and <bpt id=\"p6\">[</bpt><bpt id=\"p7\">**</bpt>Windows::UI::Core::CoreIndependentInputSource::PointerMoved<ept id=\"p7\">**</ept><ept id=\"p6\">](https://msdn.microsoft.com/library/windows/apps/dn298469)</ept> pointer events for the <bpt id=\"p8\">[</bpt><bpt id=\"p9\">**</bpt>SwapChainPanel<ept id=\"p9\">**</ept><ept id=\"p8\">](https://msdn.microsoft.com/library/windows/apps/dn252834)</ept>.","pos":[4207,4774],"source":"The following example shows how the **DirectXPage** constructor registers for the [**Windows::UI::Core::CoreIndependentInputSource::PointerPressed**](https://msdn.microsoft.com/library/windows/apps/dn298471), [**Windows::UI::Core::CoreIndependentInputSource::PointerReleased**](https://msdn.microsoft.com/library/windows/apps/dn298472), and [**Windows::UI::Core::CoreIndependentInputSource::PointerMoved**](https://msdn.microsoft.com/library/windows/apps/dn298469) pointer events for the [**SwapChainPanel**](https://msdn.microsoft.com/library/windows/apps/dn252834)."},{"content":"These events are registered during app initialization and before the game loop.","pos":[4775,4854]},{"content":"These events are handled in a separate thread that invokes the event handlers.","pos":[4856,4934]},{"pos":[4936,5077],"content":"For more information about how the application is initialized, see <bpt id=\"p1\">[</bpt>Marble Maze application structure<ept id=\"p1\">](marble-maze-application-structure.md)</ept>.","source":"For more information about how the application is initialized, see [Marble Maze application structure](marble-maze-application-structure.md)."},{"content":"The MarbleMaze class also creates a std::map object to hold touch events.","pos":[5455,5528]},{"content":"The key for this map object is a value that uniquely identifies the input pointer.","pos":[5529,5611]},{"content":"Each key maps to the distance between every touch point and the center of the screen.","pos":[5612,5697]},{"content":"Marble Maze later uses these values to calculate the amount by which the maze is tilted.","pos":[5698,5786]},{"content":"The MarbleMaze class holds an Accelerometer object.","pos":[5869,5920]},{"content":"The Accelerometer object is initialized in the MarbleMaze::Initialize method, as shown in the following example.","pos":[6003,6115]},{"content":"The Windows::Devices::Sensors::Accelerometer::GetDefault method returns an instance of the default accelerometer.","pos":[6116,6229]},{"content":"If there is no default accelerometer, Accelerometer::GetDefault the value of m\\_accelerometer remains nullptr.","pos":[6230,6340]},{"content":"Navigating the menus","pos":[6497,6517]},{"content":"Tracking Xbox 360 controller input","pos":[6525,6559]},{"content":"You can use the mouse, touch, or the Xbox 360 controller to navigate the menus, as follows:","pos":[6561,6652]},{"content":"Use the directional pad to change the active menu item.","pos":[6658,6713]},{"content":"Use touch, the A button, or the Start button to pick a menu item or close the current menu, such as the high-score table.","pos":[6718,6839]},{"content":"Use the Start button to pause or resume the game.","pos":[6844,6893]},{"content":"Click on a menu item with the mouse to choose that action.","pos":[6898,6956]},{"content":"Tracking touch and mouse input","pos":[6963,6993]},{"content":"To track Xbox 360 controller input, the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method defines an array of buttons that define the input behaviors.","pos":[6995,7125],"source":"To track Xbox 360 controller input, the **MarbleMaze::Update** method defines an array of buttons that define the input behaviors."},{"content":"XInput provides only the current state of the controller.","pos":[7126,7183]},{"content":"Therefore, <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> also defines two arrays that track, for each possible Xbox 360 controller, whether each button was pressed during the previous frame and whether each button is currently pressed.","pos":[7184,7396],"source":" Therefore, **MarbleMaze::Update** also defines two arrays that track, for each possible Xbox 360 controller, whether each button was pressed during the previous frame and whether each button is currently pressed."},{"content":"You can connect up to four Xbox 360 controllers to a Windows device.","pos":[8088,8156]},{"content":"To avoid having to figure out which controller is the active one, the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method combines input across all controllers.","pos":[8157,8295],"source":" To avoid having to figure out which controller is the active one, the **MarbleMaze::Update** method combines input across all controllers."},{"content":"If your game supports more than one player, you have to track input for each player separately.","pos":[8363,8458]},{"pos":[8460,8572],"content":"In a loop, the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method polls each controller for input and reads the state of each button.","source":"In a loop, the **MarbleMaze::Update** method polls each controller for input and reads the state of each button."},{"content":"After the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method polls for input, it updates the combined input array.","pos":[9396,9489],"source":"After the **MarbleMaze::Update** method polls for input, it updates the combined input array."},{"content":"The combined input array tracks only which buttons are pressed but were not previously pressed.","pos":[9490,9585]},{"content":"This enables the game to perform an action only at the time a button is initially pressed, and not when the button is held.","pos":[9586,9709]},{"content":"After the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method collects button input, it performs any actions that must happen.","pos":[10058,10162],"source":"After the **MarbleMaze::Update** method collects button input, it performs any actions that must happen."},{"content":"For example, when the Start button (XINPUT\\_GAMEPAD\\_START) is pressed, the game state changes from active to paused or from paused to active.","pos":[10163,10305]},{"content":"If the main menu is active, the active menu item changes when the directional pad is pressed up or down.","pos":[10681,10785]},{"content":"If the user chooses the current selection, the appropriate UI element is marked as being chosen.","pos":[10786,10882]},{"pos":[12246,12366],"content":"After the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method processes controller input, it saves the current input state for the next frame.","source":"After the **MarbleMaze::Update** method processes controller input, it saves the current input state for the next frame."},{"content":"Tracking touch and mouse input","pos":[12491,12521]},{"content":"For touch and mouse input, a menu item is chosen when the user touches or clicks it.","pos":[12523,12607]},{"content":"The following example shows how the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method processes pointer input to select menu items.","pos":[12608,12719],"source":" The following example shows how the **MarbleMaze::Update** method processes pointer input to select menu items."},{"content":"The <bpt id=\"p1\">**</bpt>m\\_pointQueue<ept id=\"p1\">**</ept> member variable tracks the locations where the user touched or clicked on the screen.","pos":[12720,12827],"source":" The **m\\_pointQueue** member variable tracks the locations where the user touched or clicked on the screen."},{"content":"The way in which Marble Maze collects pointer input is described in greater detail later in this document in the section Processing pointer input.","pos":[12828,12974]},{"content":"The <bpt id=\"p1\">**</bpt>UserInterface::HitTest<ept id=\"p1\">**</ept> method determines whether the provided point is located in the bounds of any UI element.","pos":[13205,13324],"source":"The **UserInterface::HitTest** method determines whether the provided point is located in the bounds of any UI element."},{"content":"Any UI elements that pass this test are marked as being touched.","pos":[13325,13389]},{"content":"This method uses the <bpt id=\"p1\">**</bpt>PointInRect<ept id=\"p1\">**</ept> helper function to determine whether the provided point is located in the bounds of each UI element.","pos":[13390,13527],"source":" This method uses the **PointInRect** helper function to determine whether the provided point is located in the bounds of each UI element."},{"content":"Updating the game state","pos":[13984,14007]},{"pos":[14009,14139],"content":"After the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method processes controller and touch input, it updates the game state if any button was pressed.","source":"After the **MarbleMaze::Update** method processes controller and touch input, it updates the game state if any button was pressed."},{"content":"Controlling game play","pos":[14470,14491]},{"content":"The game loop and the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method work together to update the state of game objects.","pos":[14494,14596],"source":"The game loop and the **MarbleMaze::Update** method work together to update the state of game objects."},{"content":"If your game accepts input from multiple devices, you can accumulate the input from all devices into one set of variables so that you can write code that's easier to maintain.","pos":[14597,14772]},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method defines one set of variables that accumulates movement from all devices.","pos":[14773,14879],"source":" The **MarbleMaze::Update** method defines one set of variables that accumulates movement from all devices."},{"content":"The input mechanism can vary from one input device to another.","pos":[14949,15011]},{"content":"For example, pointer input is handled by using the Windows Runtime event-handling model.","pos":[15012,15100]},{"content":"Conversely, you poll for input data from the Xbox 360 controller when you need it.","pos":[15101,15183]},{"content":"We recommend that you always follow the input mechanism that is prescribed for a given device.","pos":[15184,15278]},{"content":"This section describes how Marble Maze reads input from each device, how it updates the combined input values, and how it uses the combined input values to update the state of the game.","pos":[15279,15464]},{"content":"Processing pointer input","pos":[15471,15495]},{"content":"When you work with pointer input, call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows::UI::Core::CoreDispatcher::ProcessEvents<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208217)</ept> method to process window events.","pos":[15497,15685],"source":"When you work with pointer input, call the [**Windows::UI::Core::CoreDispatcher::ProcessEvents**](https://msdn.microsoft.com/library/windows/apps/br208217) method to process window events."},{"content":"Call this method in your game loop before you update or render the scene.","pos":[15686,15759]},{"content":"Marble Maze passes <bpt id=\"p1\">**</bpt>CoreProcessEventsOption::ProcessAllIfPresent<ept id=\"p1\">**</ept> to this method to process all queued events, and then immediately return.","pos":[15760,15901],"source":" Marble Maze passes **CoreProcessEventsOption::ProcessAllIfPresent** to this method to process all queued events, and then immediately return."},{"content":"After events are processed, Marble Maze renders and presents the next frame.","pos":[15902,15978]},{"content":"The Windows Runtime calls the registered handler for each event that occurred.","pos":[16129,16207]},{"content":"The <bpt id=\"p1\">**</bpt>DirectXApp<ept id=\"p1\">**</ept> class registers for events and forwards pointer information to the <bpt id=\"p2\">**</bpt>MarbleMaze<ept id=\"p2\">**</ept> class.","pos":[16208,16315],"source":" The **DirectXApp** class registers for events and forwards pointer information to the **MarbleMaze** class."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze<ept id=\"p1\">**</ept> class reacts to pointer events by updating the map object that holds touch events.","pos":[16999,17100],"source":"The **MarbleMaze** class reacts to pointer events by updating the map object that holds touch events."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::AddTouch<ept id=\"p1\">**</ept> method is called when the pointer is first pressed, for example, when the user initially touches the screen on a touch-enabled device.","pos":[17101,17264],"source":" The **MarbleMaze::AddTouch** method is called when the pointer is first pressed, for example, when the user initially touches the screen on a touch-enabled device."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::AddTouch<ept id=\"p1\">**</ept> method is called when the pointer position moves.","pos":[17265,17343],"source":" The **MarbleMaze::AddTouch** method is called when the pointer position moves."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::RemoveTouch<ept id=\"p1\">**</ept> method is called when the pointer is released, for example, when the user stops touching the screen.","pos":[17344,17476],"source":" The **MarbleMaze::RemoveTouch** method is called when the pointer is released, for example, when the user stops touching the screen."},{"content":"The PointToTouch function translates the current pointer position so that the origin is in the center of the screen, and then scales the coordinates so that they range approximately between -1.0 and +1.0.","pos":[17927,18131]},{"content":"This makes it easier to calculate the tilt of the maze in a consistent way across different input methods.","pos":[18132,18238]},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method updates the combined input values by incrementing the tilt factor by a constant scaling value.","pos":[18570,18698],"source":"The **MarbleMaze::Update** method updates the combined input values by incrementing the tilt factor by a constant scaling value."},{"content":"This scaling value was determined by experimenting with several different values.","pos":[18699,18780]},{"content":"Processing accelerometer input","pos":[19077,19107]},{"content":"To process accelerometer input, the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method calls the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Windows::Devices::Sensors::Accelerometer::GetCurrentReading<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br225699)</ept> method.","pos":[19109,19316],"source":"To process accelerometer input, the **MarbleMaze::Update** method calls the [**Windows::Devices::Sensors::Accelerometer::GetCurrentReading**](https://msdn.microsoft.com/library/windows/apps/br225699) method."},{"content":"This method returns a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows::Devices::Sensors::AccelerometerReading<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br225688)</ept> object, which represents an accelerometer reading.","pos":[19317,19501],"source":" This method returns a [**Windows::Devices::Sensors::AccelerometerReading**](https://msdn.microsoft.com/library/windows/apps/br225688) object, which represents an accelerometer reading."},{"content":"The <bpt id=\"p1\">**</bpt>Windows::Devices::Sensors::AccelerometerReading::AccelerationX<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Windows::Devices::Sensors::AccelerometerReading::AccelerationY<ept id=\"p2\">**</ept> properties hold the g-force acceleration along the x and y axes, respectively.","pos":[19502,19722],"source":" The **Windows::Devices::Sensors::AccelerometerReading::AccelerationX** and **Windows::Devices::Sensors::AccelerometerReading::AccelerationY** properties hold the g-force acceleration along the x and y axes, respectively."},{"content":"The following example shows how the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method polls the accelerometer and updates the combined input values.","pos":[19724,19852],"source":"The following example shows how the **MarbleMaze::Update** method polls the accelerometer and updates the combined input values."},{"content":"As you tilt the device, gravity causes the marble to move faster.","pos":[19853,19918]},{"content":"Because you cannot be sure that an accelerometer is present on the user’s computer, always ensure that you have a valid Accelerometer object before you poll the accelerometer.","pos":[20383,20558]},{"content":"Processing Xbox 360 controller input","pos":[20564,20600]},{"content":"The following example shows how the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method reads from the Xbox 360 controller and updates the combined input values.","pos":[20602,20741],"source":"The following example shows how the **MarbleMaze::Update** method reads from the Xbox 360 controller and updates the combined input values."},{"content":"The <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method uses a for loop to enable input to be received from any connected controller.","pos":[20742,20853],"source":" The **MarbleMaze::Update** method uses a for loop to enable input to be received from any connected controller."},{"content":"The <bpt id=\"p1\">**</bpt>XInputGetState<ept id=\"p1\">**</ept> method fills an XINPUT\\_STATE object with current state of the controller.","pos":[20854,20951],"source":" The **XInputGetState** method fills an XINPUT\\_STATE object with current state of the controller."},{"content":"The <bpt id=\"p1\">**</bpt>combinedTiltX<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>combinedTiltY<ept id=\"p2\">**</ept> values are updated according to the x and y values of the left thumbstick.","pos":[20952,21070],"source":" The **combinedTiltX** and **combinedTiltY** values are updated according to the x and y values of the left thumbstick."},{"content":"XInput defines the <bpt id=\"p1\">**</bpt>XINPUT\\_GAMEPAD\\_LEFT\\_THUMB\\_DEADZONE<ept id=\"p1\">**</ept> constant for the left thumbstick.","pos":[21894,21989],"source":"XInput defines the **XINPUT\\_GAMEPAD\\_LEFT\\_THUMB\\_DEADZONE** constant for the left thumbstick."},{"content":"This is an appropriate dead zone threshold for most games.","pos":[21990,22048]},{"content":"<bpt id=\"p1\">**</bpt>Important<ept id=\"p1\">**</ept>  When you work with the Xbox 360 controller, always account for the dead zone.","pos":[22052,22144],"source":"**Important**  When you work with the Xbox 360 controller, always account for the dead zone."},{"content":"The dead zone refers to the variance among gamepads in their sensitivity to initial movement.","pos":[22145,22238]},{"content":"In some controllers, a small movement may generate no reading, but in others it may generate a measurable reading.","pos":[22239,22353]},{"content":"To account for this in your game, create a zone of non-movement for initial thumbstick movement.","pos":[22354,22450]},{"content":"For more information about the dead zone, see <bpt id=\"p1\">[</bpt>Getting Started With XInput.<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ee417001)</ept>","pos":[22451,22588],"source":" For more information about the dead zone, see [Getting Started With XInput.](https://msdn.microsoft.com/library/windows/desktop/ee417001)"},{"content":"Applying input to the game state","pos":[22598,22630]},{"content":"Devices report input values in different ways.","pos":[22632,22678]},{"content":"For example, pointer input might be in screen coordinates, and controller input might be in a completely different format.","pos":[22679,22801]},{"content":"One challenge with combining input from multiple devices into one set of input values is normalization, or converting values to a common format.","pos":[22802,22946]},{"content":"Marble Maze normalizes values by scaling them to the range \\[-1.0, 1.0\\].","pos":[22947,23020]},{"content":"To normalize Xbox 360 controller input, Marble Maze divides the input values by 32768 because thumbstick input values always fall between -32768 and 32767.","pos":[23021,23176]},{"content":"The <bpt id=\"p1\">**</bpt>PointToTouch<ept id=\"p1\">**</ept> function, which is previously described in this section, achieves a similar result by converting screen coordinates to normalized values that range approximately between -1.0 and +1.0.","pos":[23177,23382],"source":" The **PointToTouch** function, which is previously described in this section, achieves a similar result by converting screen coordinates to normalized values that range approximately between -1.0 and +1.0."},{"content":"<bpt id=\"p1\">**</bpt>Tip<ept id=\"p1\">**</ept>  Even if your application uses one input method, we recommend that you always normalize input values.","pos":[23386,23495],"source":"**Tip**  Even if your application uses one input method, we recommend that you always normalize input values."},{"content":"Doing so can simplify how input is interpreted by other components of your game, such as physics simulation, and makes it easier to write games that work on different screen resolutions.","pos":[23496,23682]},{"content":"After the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method processes input, it creates a vector that represents the effect of the tilt of the maze on the marble.","pos":[23687,23829],"source":"After the **MarbleMaze::Update** method processes input, it creates a vector that represents the effect of the tilt of the maze on the marble."},{"content":"The following example shows how Marble Maze uses the <bpt id=\"p1\">**</bpt>XMVector3Normalize<ept id=\"p1\">**</ept> function to create a normalized gravity vector.","pos":[23830,23953],"source":" The following example shows how Marble Maze uses the **XMVector3Normalize** function to create a normalized gravity vector."},{"content":"The <bpt id=\"p1\">*</bpt>MaxTilt<ept id=\"p1\">*</ept> variable constrains the amount by which the maze tilts and prevents the maze from tilting on its side.","pos":[23954,24070],"source":" The *MaxTilt* variable constrains the amount by which the maze tilts and prevents the maze from tilting on its side."},{"content":"To complete the update of scene objects, Marble Maze passes the updated gravity vector to the physics simulation, updates the physics simulation for the time that has elapsed since the previous frame, and updates the position and orientation of the marble.","pos":[24252,24508]},{"content":"If the marble has fallen through the maze, the <bpt id=\"p1\">**</bpt>MarbleMaze::Update<ept id=\"p1\">**</ept> method places the marble back at the last checkpoint that the marble touched and resets the state of the physics simulation.","pos":[24509,24703],"source":" If the marble has fallen through the maze, the **MarbleMaze::Update** method places the marble back at the last checkpoint that the marble touched and resets the state of the physics simulation."},{"content":"This section does not describe how the physics simulation works.","pos":[25549,25613]},{"content":"For details about that, see Physics.h and Physics.cpp in the Marble Maze sources.","pos":[25614,25695]},{"content":"Next steps","pos":[25700,25710]},{"content":"Read <bpt id=\"p1\">[</bpt>Adding audio to the Marble Maze sample<ept id=\"p1\">](adding-audio-to-the-marble-maze-sample.md)</ept> for information about some of the key practices to keep in mind when you work with audio.","pos":[25713,25891],"source":"Read [Adding audio to the Marble Maze sample](adding-audio-to-the-marble-maze-sample.md) for information about some of the key practices to keep in mind when you work with audio."},{"content":"The document discusses how Marble Maze uses Microsoft Media Foundation and XAudio2 to load, mix, and play audio resources.","pos":[25892,26014]},{"content":"Related topics","pos":[26019,26033]},{"content":"Adding audio to the Marble Maze sample","pos":[26039,26077]},{"content":"Adding visual content to the Marble Maze sample","pos":[26125,26172]},{"content":"Developing Marble Maze, a UWP game in C++ and DirectX","pos":[26229,26282]}],"content":"---\ntitle: Adding input and interactivity to the Marble Maze sample\ndescription: Universal Windows Platform (UWP) app games run on a wide variety of devices, such as desktop computers, laptops, and tablets.\nms.assetid: b946bf62-c0ca-f9ec-1a87-8195b89a5ab4\n---\n\n# Adding input and interactivity to the Marble Maze sample\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\nUniversal Windows Platform (UWP) app games run on a wide variety of devices, such as desktop computers, laptops, and tablets. A device can have a wide variety of input and control mechanisms. Support multiple input devices to enable your game to accommodate a wider range of preferences and abilities among your customers. This document describes the key practices to keep in mind when you work with input devices and shows how Marble Maze applies these practices.\n\n> **Note**   The sample code that corresponds to this document is found in the [DirectX Marble Maze game sample](http://go.microsoft.com/fwlink/?LinkId=624011).\n\n \nHere are some of the key points that this document discusses for when you work with input in your game:\n\n-   When possible, support multiple input devices to enable your game to accommodate a wider range of preferences and abilities among your customers. Although game controller and sensor usage is optional, we strongly recommend it to enhance the player experience. We designed the game controller and sensor API to help you more easily integrate these input devices.\n-   To initialize touch, you must register for window events such as when the pointer is activated, released, and moved. To initialize the accelerometer, create a [**Windows::Devices::Sensors::Accelerometer**](https://msdn.microsoft.com/library/windows/apps/br225687) object when you initialize the application. The Xbox 360 controller doesn't require initialization.\n-   For single-player games, consider whether to combine input from all possible Xbox 360 controllers. This way, you don’t have to track what input comes from which controller.\n-   Process Windows events before you process input devices.\n-   The Xbox 360 controller and the accelerometer support polling. That is, you can poll for data when you need it. For touch, record touch events in data structures that are available to your input processing code.\n-   Consider whether to normalize input values to a common format. Doing so can simplify how input is interpreted by other components of your game, such as physics simulation, and can make it easier to write games that work on different screen resolutions.\n\n## Input devices supported by Marble Maze\n\n\nMarble Maze supports Xbox 360 common controller devices, mouse, and touch to select menu items, and the Xbox 360 controller, mouse, touch, and the accelerometer to control game play. Marble Maze uses the XInput API to poll the controller for input. Touch enables applications to track and respond to fingertip input. An accelerometer is a sensor that measures the force that is applied along the x, y, and z axes. By using the Windows Runtime, you can poll the current state of the accelerometer device, as well as receive touch events through the Windows Runtime event-handling mechanism.\n\n> **Note**  This document uses touch to refer to both touch and mouse input and pointer to refer to any device that uses pointer events. Because touch and the mouse use standard pointer events, you can use either device to select menu items and control game play.\n\n \n\n> **Note**  The package manifest sets Landscape as the supported rotation for the game to prevent the orientation from changing when you rotate the device to roll the marble.\n\n \n\n## Initializing input devices\n\n\nThe Xbox 360 controller does not require initialization. To initialize touch, you must register for windowing events such as when the pointer is activated (for example, your user presses the mouse button or touches the screen), released, and moved. To initialize the accelerometer, you have to create a [**Windows::Devices::Sensors::Accelerometer**](https://msdn.microsoft.com/library/windows/apps/br225687) object when you initialize the application.\n\nThe following example shows how the **DirectXPage** constructor registers for the [**Windows::UI::Core::CoreIndependentInputSource::PointerPressed**](https://msdn.microsoft.com/library/windows/apps/dn298471), [**Windows::UI::Core::CoreIndependentInputSource::PointerReleased**](https://msdn.microsoft.com/library/windows/apps/dn298472), and [**Windows::UI::Core::CoreIndependentInputSource::PointerMoved**](https://msdn.microsoft.com/library/windows/apps/dn298469) pointer events for the [**SwapChainPanel**](https://msdn.microsoft.com/library/windows/apps/dn252834). These events are registered during app initialization and before the game loop.\n\nThese events are handled in a separate thread that invokes the event handlers.\n\nFor more information about how the application is initialized, see [Marble Maze application structure](marble-maze-application-structure.md).\n\n```cpp\ncoreInput->PointerPressed += ref new TypedEventHandler<Object^, PointerEventArgs^>(this, &DirectXPage::OnPointerPressed);\ncoreInput->PointerMoved += ref new TypedEventHandler<Object^, PointerEventArgs^>(this, &DirectXPage::OnPointerMoved);\ncoreInput->PointerReleased += ref new TypedEventHandler<Object^, PointerEventArgs^>(this, &DirectXPage::OnPointerReleased);\n```\n\nThe MarbleMaze class also creates a std::map object to hold touch events. The key for this map object is a value that uniquely identifies the input pointer. Each key maps to the distance between every touch point and the center of the screen. Marble Maze later uses these values to calculate the amount by which the maze is tilted.\n\n```cpp\ntypedef std::map<int, XMFLOAT2> TouchMap;\nTouchMap        m_touches;\n```\n\nThe MarbleMaze class holds an Accelerometer object.\n\n```cpp\nWindows::Devices::Sensors::Accelerometer^           m_accelerometer;\n```\n\nThe Accelerometer object is initialized in the MarbleMaze::Initialize method, as shown in the following example. The Windows::Devices::Sensors::Accelerometer::GetDefault method returns an instance of the default accelerometer. If there is no default accelerometer, Accelerometer::GetDefault the value of m\\_accelerometer remains nullptr.\n\n```cpp\n// Returns accelerometer ref if there is one; nullptr otherwise.\nm_accelerometer = Windows::Devices::Sensors::Accelerometer::GetDefault();\n```\n\n##  Navigating the menus\n\n\n###  Tracking Xbox 360 controller input\n\nYou can use the mouse, touch, or the Xbox 360 controller to navigate the menus, as follows:\n\n-   Use the directional pad to change the active menu item.\n-   Use touch, the A button, or the Start button to pick a menu item or close the current menu, such as the high-score table.\n-   Use the Start button to pause or resume the game.\n-   Click on a menu item with the mouse to choose that action.\n\n###  Tracking touch and mouse input\n\nTo track Xbox 360 controller input, the **MarbleMaze::Update** method defines an array of buttons that define the input behaviors. XInput provides only the current state of the controller. Therefore, **MarbleMaze::Update** also defines two arrays that track, for each possible Xbox 360 controller, whether each button was pressed during the previous frame and whether each button is currently pressed.\n\n```cpp\n// This array contains the constants from XINPUT that map to the \n// particular buttons that are used by the game. \n// The index of the array is used to associate the state of that button in \n// the wasButtonDown, isButtonDown, and combinedButtonPressed variables. \n\nstatic const WORD buttons[] = {\n    XINPUT_GAMEPAD_A,\n    XINPUT_GAMEPAD_START,\n    XINPUT_GAMEPAD_DPAD_UP,\n    XINPUT_GAMEPAD_DPAD_DOWN,\n    XINPUT_GAMEPAD_DPAD_LEFT,\n    XINPUT_GAMEPAD_DPAD_RIGHT,\n    XINPUT_GAMEPAD_BACK,\n};\n\nstatic const int buttonCount = ARRAYSIZE(buttons);\nstatic bool wasButtonDown[XUSER_MAX_COUNT][buttonCount] = { false, };\nbool isButtonDown[XUSER_MAX_COUNT][buttonCount] = { false, };\n```\n\nYou can connect up to four Xbox 360 controllers to a Windows device. To avoid having to figure out which controller is the active one, the **MarbleMaze::Update** method combines input across all controllers.\n\n```cpp\nbool combinedButtonPressed[buttonCount] = { false, };\n```\n\nIf your game supports more than one player, you have to track input for each player separately.\n\nIn a loop, the **MarbleMaze::Update** method polls each controller for input and reads the state of each button.\n\n```cpp\n// Account for input on any connected controller.\nXINPUT_STATE inputState = {0};\nfor (DWORD userIndex = 0; userIndex < XUSER_MAX_COUNT; ++userIndex)\n{\n    DWORD result = XInputGetState(userIndex, &inputState);\n    if(result != ERROR_SUCCESS) \n        continue;\n\n    SHORT thumbLeftX = inputState.Gamepad.sThumbLX;\n    if (abs(thumbLeftX) < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE) \n        thumbLeftX = 0;\n\n    SHORT thumbLeftY = inputState.Gamepad.sThumbLY;\n    if (abs(thumbLeftY) < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE) \n        thumbLeftY = 0;\n\n    combinedTiltX += static_cast<float>(thumbLeftX) / 32768.0f;\n    combinedTiltY += static_cast<float>(thumbLeftY) / 32768.0f;\n\n    for (int i = 0; i < buttonCount; ++i)\n        isButtonDown[userIndex][i] = (inputState.Gamepad.wButtons & buttons[i]) == buttons[i];\n}\n```\n\nAfter the **MarbleMaze::Update** method polls for input, it updates the combined input array. The combined input array tracks only which buttons are pressed but were not previously pressed. This enables the game to perform an action only at the time a button is initially pressed, and not when the button is held.\n\n```cpp\nbool combinedButtonPressed[buttonCount] = { false, };\nfor (int i = 0; i < buttonCount; ++i)\n{\n    for (DWORD userIndex = 0; userIndex < XUSER_MAX_COUNT; ++userIndex)\n    {\n        bool pressed = !wasButtonDown[userIndex][i] && isButtonDown[userIndex][i];\n        combinedButtonPressed[i] = combinedButtonPressed[i] || pressed;\n    }\n}\n```\n\nAfter the **MarbleMaze::Update** method collects button input, it performs any actions that must happen. For example, when the Start button (XINPUT\\_GAMEPAD\\_START) is pressed, the game state changes from active to paused or from paused to active.\n\n```cpp\n// Check whether the user paused or resumed the game. \n// XINPUT_GAMEPAD_START  \nif (combinedButtonPressed[1] || m_pauseKeyPressed)\n{\n    m_pauseKeyPressed = false;\n    if (m_gameState == GameState::InGameActive)\n        SetGameState(GameState::InGamePaused);\n    else if (m_gameState == GameState::InGamePaused)\n        SetGameState(GameState::InGameActive);\n}\n```\n\nIf the main menu is active, the active menu item changes when the directional pad is pressed up or down. If the user chooses the current selection, the appropriate UI element is marked as being chosen.\n\n```cpp\n// Handle menu navigation. \n\n// XINPUT_GAMEPAD_A or XINPUT_GAMEPAD_START \nbool chooseSelection = (combinedButtonPressed[0] || combinedButtonPressed[1]);\n\n// XINPUT_GAMEPAD_DPAD_UP \nbool moveUp = combinedButtonPressed[2];\n\n// XINPUT_GAMEPAD_DPAD_DOWN \nbool moveDown = combinedButtonPressed[3];                                           \n\nswitch (m_gameState)\n{\ncase GameState::MainMenu:\n    if (chooseSelection)\n    {\n        m_audio.PlaySoundEffect(MenuSelectedEvent);\n\n        if (m_startGameButton.GetSelected())\n            m_startGameButton.SetPressed(true);\n\n        if (m_highScoreButton.GetSelected())\n            m_highScoreButton.SetPressed(true);\n    }\n    if (moveUp || moveDown)\n    {\n        m_startGameButton.SetSelected(!m_startGameButton.GetSelected());\n        m_highScoreButton.SetSelected(!m_startGameButton.GetSelected());\n\n        m_audio.PlaySoundEffect(MenuChangeEvent);\n    }\n    break;\n\ncase GameState::HighScoreDisplay:\n    if (chooseSelection || anyPoints)\n        SetGameState(GameState::MainMenu);\n    break;\n\ncase GameState::PostGameResults:\n    if (chooseSelection || anyPoints)\n        SetGameState(GameState::HighScoreDisplay);\n    break;\n\ncase GameState::InGamePaused:\n    if (m_pausedText.IsPressed())\n    {\n        m_pausedText.SetPressed(false);\n        SetGameState(GameState::InGameActive); \n    }\n    break;\n}\n```\n\nAfter the **MarbleMaze::Update** method processes controller input, it saves the current input state for the next frame.\n\n```cpp\n// Update the button state for the next frame.\nmemcpy(wasButtonDown, isButtonDown, sizeof(wasButtonDown));\n```\n\n### Tracking touch and mouse input\n\nFor touch and mouse input, a menu item is chosen when the user touches or clicks it. The following example shows how the **MarbleMaze::Update** method processes pointer input to select menu items. The **m\\_pointQueue** member variable tracks the locations where the user touched or clicked on the screen. The way in which Marble Maze collects pointer input is described in greater detail later in this document in the section Processing pointer input.\n\n```cpp\n// Check whether the user chose a button from the UI. \nbool anyPoints = !m_pointQueue.empty();\nwhile (!m_pointQueue.empty())\n{\n    UserInterface::GetInstance().HitTest(m_pointQueue.front());\n    m_pointQueue.pop();\n}\n```\n\nThe **UserInterface::HitTest** method determines whether the provided point is located in the bounds of any UI element. Any UI elements that pass this test are marked as being touched. This method uses the **PointInRect** helper function to determine whether the provided point is located in the bounds of each UI element.\n\n```cpp\nvoid UserInterface::HitTest(D2D1_POINT_2F point)\n{\n    for (auto iter = m_elements.begin(); iter != m_elements.end(); ++iter)\n    {\n        if (!(*iter)->IsVisible())\n            continue;\n\n        TextButton* textButton = dynamic_cast<TextButton*>(*iter);\n        if (textButton != nullptr)\n        {\n            D2D1_RECT_F bounds = (*iter)->GetBounds();\n            textButton->SetPressed(PointInRect(point, bounds));\n        }\n    }\n}\n```\n\n### Updating the game state\n\nAfter the **MarbleMaze::Update** method processes controller and touch input, it updates the game state if any button was pressed.\n\n```cpp\n// Update the game state if the user chose a menu option. \nif (m_startGameButton.IsPressed())\n{\n    SetGameState(GameState::PreGameCountdown);\n    m_startGameButton.SetPressed(false);\n}\nif (m_highScoreButton.IsPressed())\n{\n    SetGameState(GameState::HighScoreDisplay);\n    m_highScoreButton.SetPressed(false);\n}\n```\n\n##  Controlling game play\n\n\nThe game loop and the **MarbleMaze::Update** method work together to update the state of game objects. If your game accepts input from multiple devices, you can accumulate the input from all devices into one set of variables so that you can write code that's easier to maintain. The **MarbleMaze::Update** method defines one set of variables that accumulates movement from all devices.\n\n```cpp\nfloat combinedTiltX = 0.0f;\nfloat combinedTiltY = 0.0f;\n```\n\nThe input mechanism can vary from one input device to another. For example, pointer input is handled by using the Windows Runtime event-handling model. Conversely, you poll for input data from the Xbox 360 controller when you need it. We recommend that you always follow the input mechanism that is prescribed for a given device. This section describes how Marble Maze reads input from each device, how it updates the combined input values, and how it uses the combined input values to update the state of the game.\n\n###  Processing pointer input\n\nWhen you work with pointer input, call the [**Windows::UI::Core::CoreDispatcher::ProcessEvents**](https://msdn.microsoft.com/library/windows/apps/br208217) method to process window events. Call this method in your game loop before you update or render the scene. Marble Maze passes **CoreProcessEventsOption::ProcessAllIfPresent** to this method to process all queued events, and then immediately return. After events are processed, Marble Maze renders and presents the next frame.\n\n```cpp\n// Process windowing events.\nCoreWindow::GetForCurrentThread()->Dispatcher->ProcessEvents(CoreProcessEventsOption::ProcessAllIfPresent);\n```\n\nThe Windows Runtime calls the registered handler for each event that occurred. The **DirectXApp** class registers for events and forwards pointer information to the **MarbleMaze** class.\n\n```cpp\nvoid DirectXApp::OnPointerPressed(\n    _In_ Windows::UI::Core::CoreWindow^ sender,\n    _In_ Windows::UI::Core::PointerEventArgs^ args\n    )\n{\n    m_renderer->AddTouch(args->CurrentPoint->PointerId, args->CurrentPoint->Position);\n}\n\nvoid DirectXApp::OnPointerReleased(\n    _In_ Windows::UI::Core::CoreWindow^ sender,\n    _In_ Windows::UI::Core::PointerEventArgs^ args\n    )\n{\n    m_renderer->RemoveTouch(args->CurrentPoint->PointerId);\n}\n\nvoid DirectXApp::OnPointerMoved(\n    _In_ Windows::UI::Core::CoreWindow^ sender,\n    _In_ Windows::UI::Core::PointerEventArgs^ args\n    )\n{\n    m_renderer->UpdateTouch(args->CurrentPoint->PointerId, args->CurrentPoint->Position);\n}\n```\n\nThe **MarbleMaze** class reacts to pointer events by updating the map object that holds touch events. The **MarbleMaze::AddTouch** method is called when the pointer is first pressed, for example, when the user initially touches the screen on a touch-enabled device. The **MarbleMaze::AddTouch** method is called when the pointer position moves. The **MarbleMaze::RemoveTouch** method is called when the pointer is released, for example, when the user stops touching the screen.\n\n```cpp\nvoid MarbleMaze::AddTouch(int id, Windows::Foundation::Point point)\n{\n    m_touches[id] = PointToTouch(point, m_windowBounds);\n\n    m_pointQueue.push(D2D1::Point2F(point.X, point.Y));\n}\n\nvoid MarbleMaze::UpdateTouch(int id, Windows::Foundation::Point point)\n{\n    if (m_touches.find(id) != m_touches.end())\n        m_touches[id] = PointToTouch(point, m_windowBounds);\n}\n\nvoid MarbleMaze::RemoveTouch(int id)\n{\n    m_touches.erase(id);\n}\n```\n\nThe PointToTouch function translates the current pointer position so that the origin is in the center of the screen, and then scales the coordinates so that they range approximately between -1.0 and +1.0. This makes it easier to calculate the tilt of the maze in a consistent way across different input methods.\n\n```cpp\ninline XMFLOAT2 PointToTouch(Windows::Foundation::Point point, Windows::Foundation::Rect bounds)\n{\n    float touchRadius = min(bounds.Width, bounds.Height);\n    float dx = (point.X - (bounds.Width / 2.0f)) / touchRadius;\n    float dy = ((bounds.Height / 2.0f) - point.Y) / touchRadius;\n\n    return XMFLOAT2(dx, dy);\n}\n```\n\nThe **MarbleMaze::Update** method updates the combined input values by incrementing the tilt factor by a constant scaling value. This scaling value was determined by experimenting with several different values.\n\n```cpp\n// Account for touch input. \nconst float touchScalingFactor = 2.0f;\nfor (TouchMap::const_iterator iter = m_touches.cbegin(); iter != m_touches.cend(); ++iter)\n{\n    combinedTiltX += iter->second.x * touchScalingFactor;\n    combinedTiltY += iter->second.y * touchScalingFactor;\n}\n```\n\n### Processing accelerometer input\n\nTo process accelerometer input, the **MarbleMaze::Update** method calls the [**Windows::Devices::Sensors::Accelerometer::GetCurrentReading**](https://msdn.microsoft.com/library/windows/apps/br225699) method. This method returns a [**Windows::Devices::Sensors::AccelerometerReading**](https://msdn.microsoft.com/library/windows/apps/br225688) object, which represents an accelerometer reading. The **Windows::Devices::Sensors::AccelerometerReading::AccelerationX** and **Windows::Devices::Sensors::AccelerometerReading::AccelerationY** properties hold the g-force acceleration along the x and y axes, respectively.\n\nThe following example shows how the **MarbleMaze::Update** method polls the accelerometer and updates the combined input values. As you tilt the device, gravity causes the marble to move faster.\n\n```cpp\n// Account for sensors. \nconst float acceleromterScalingFactor = 3.5f;\nif (m_accelerometer != nullptr)\n{\n    Windows::Devices::Sensors::AccelerometerReading^ reading =\n        m_accelerometer->GetCurrentReading();\n\n    if (reading != nullptr)\n    {\n        combinedTiltX += static_cast<float>(reading->AccelerationX) * acceleromterScalingFactor;\n        combinedTiltY += static_cast<float>(reading->AccelerationY) * acceleromterScalingFactor;\n    }\n}\n```\n\nBecause you cannot be sure that an accelerometer is present on the user’s computer, always ensure that you have a valid Accelerometer object before you poll the accelerometer.\n\n### Processing Xbox 360 controller input\n\nThe following example shows how the **MarbleMaze::Update** method reads from the Xbox 360 controller and updates the combined input values. The **MarbleMaze::Update** method uses a for loop to enable input to be received from any connected controller. The **XInputGetState** method fills an XINPUT\\_STATE object with current state of the controller. The **combinedTiltX** and **combinedTiltY** values are updated according to the x and y values of the left thumbstick.\n\n```cpp\n// Account for input on any connected controller.\nXINPUT_STATE inputState = {0};\nfor (DWORD userIndex = 0; userIndex < XUSER_MAX_COUNT; ++userIndex)\n{\n    DWORD result = XInputGetState(userIndex, &inputState);\n    if(result != ERROR_SUCCESS) \n        continue;\n\n    SHORT thumbLeftX = inputState.Gamepad.sThumbLX;\n    if (abs(thumbLeftX) < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE) \n        thumbLeftX = 0;\n\n    SHORT thumbLeftY = inputState.Gamepad.sThumbLY;\n    if (abs(thumbLeftY) < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE) \n        thumbLeftY = 0;\n\n    combinedTiltX += static_cast<float>(thumbLeftX) / 32768.0f;\n    combinedTiltY += static_cast<float>(thumbLeftY) / 32768.0f;\n\n    for (int i = 0; i < buttonCount; ++i)\n        isButtonDown[userIndex][i] = (inputState.Gamepad.wButtons & buttons[i]) == buttons[i];\n}\n```\n\nXInput defines the **XINPUT\\_GAMEPAD\\_LEFT\\_THUMB\\_DEADZONE** constant for the left thumbstick. This is an appropriate dead zone threshold for most games.\n\n> **Important**  When you work with the Xbox 360 controller, always account for the dead zone. The dead zone refers to the variance among gamepads in their sensitivity to initial movement. In some controllers, a small movement may generate no reading, but in others it may generate a measurable reading. To account for this in your game, create a zone of non-movement for initial thumbstick movement. For more information about the dead zone, see [Getting Started With XInput.](https://msdn.microsoft.com/library/windows/desktop/ee417001)\n\n \n\n###  Applying input to the game state\n\nDevices report input values in different ways. For example, pointer input might be in screen coordinates, and controller input might be in a completely different format. One challenge with combining input from multiple devices into one set of input values is normalization, or converting values to a common format. Marble Maze normalizes values by scaling them to the range \\[-1.0, 1.0\\]. To normalize Xbox 360 controller input, Marble Maze divides the input values by 32768 because thumbstick input values always fall between -32768 and 32767. The **PointToTouch** function, which is previously described in this section, achieves a similar result by converting screen coordinates to normalized values that range approximately between -1.0 and +1.0.\n\n> **Tip**  Even if your application uses one input method, we recommend that you always normalize input values. Doing so can simplify how input is interpreted by other components of your game, such as physics simulation, and makes it easier to write games that work on different screen resolutions.\n\n \n\nAfter the **MarbleMaze::Update** method processes input, it creates a vector that represents the effect of the tilt of the maze on the marble. The following example shows how Marble Maze uses the **XMVector3Normalize** function to create a normalized gravity vector. The *MaxTilt* variable constrains the amount by which the maze tilts and prevents the maze from tilting on its side.\n\n```cpp\nconst float maxTilt = 1.0f / 8.0f;\nXMVECTOR gravity = XMVectorSet(combinedTiltX * maxTilt, combinedTiltY * maxTilt, 1.0f, 0.0f);\ngravity = XMVector3Normalize(gravity);\n```\n\nTo complete the update of scene objects, Marble Maze passes the updated gravity vector to the physics simulation, updates the physics simulation for the time that has elapsed since the previous frame, and updates the position and orientation of the marble. If the marble has fallen through the maze, the **MarbleMaze::Update** method places the marble back at the last checkpoint that the marble touched and resets the state of the physics simulation.\n\n```cpp\nXMFLOAT3 g;\nXMStoreFloat3(&g, gravity);\nm_physics.SetGravity(g);\n```\n\n```cpp\n// Only update physics when gameplay is active.\nm_physics.UpdatePhysicsSimulation(timeDelta);\n```\n\n```cpp\n// Check whether the marble fell off of the maze. \nconst float fadeOutDepth = 0.0f;\nconst float resetDepth = 80.0f;\nif (marblePosition.z >= fadeOutDepth)\n{\n    m_targetLightStrength = 0.0f;\n}\nif (marblePosition.z >= resetDepth)\n{\n    // Reset marble.\n    memcpy(&marblePosition, &m_checkpoints[m_currentCheckpoint], sizeof(XMFLOAT3));\n    oldMarblePosition = marblePosition;\n    m_physics.SetPosition((const XMFLOAT3&)marblePosition);\n    m_physics.SetVelocity(XMFLOAT3(0, 0, 0));\n    m_lightStrength = 0.0f;\n    m_targetLightStrength = 1.0f;\n\n    m_resetCamera = true;\n    m_resetMarbleRotation = true;\n    m_audio.PlaySoundEffect(FallingEvent);\n}\n```\n\nThis section does not describe how the physics simulation works. For details about that, see Physics.h and Physics.cpp in the Marble Maze sources.\n\n## Next steps\n\n\nRead [Adding audio to the Marble Maze sample](adding-audio-to-the-marble-maze-sample.md) for information about some of the key practices to keep in mind when you work with audio. The document discusses how Marble Maze uses Microsoft Media Foundation and XAudio2 to load, mix, and play audio resources.\n\n## Related topics\n\n\n* [Adding audio to the Marble Maze sample](adding-audio-to-the-marble-maze-sample.md)\n* [Adding visual content to the Marble Maze sample](adding-visual-content-to-the-marble-maze-sample.md)\n* [Developing Marble Maze, a UWP game in C++ and DirectX](developing-marble-maze-a-windows-store-game-in-cpp-and-directx.md)\n\n \n\n \n\n\n\n\n"}