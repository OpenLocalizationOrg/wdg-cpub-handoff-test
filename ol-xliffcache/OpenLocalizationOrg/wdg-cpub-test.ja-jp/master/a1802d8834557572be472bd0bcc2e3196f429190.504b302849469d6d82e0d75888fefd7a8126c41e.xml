{"nodes":[{"pos":[11,40],"content":"Complete code for BasicLoader","needQuote":true,"needEscape":true,"nodes":[{"content":"Complete code for BasicLoader","pos":[0,29]}]},{"pos":[54,194],"content":"Complete code for a class and methods that convert and load common graphics resources, such as meshes, textures, and various shader objects.","needQuote":true,"needEscape":true,"nodes":[{"content":"Complete code for a class and methods that convert and load common graphics resources, such as meshes, textures, and various shader objects.","pos":[0,140]}]},{"content":"Complete code for BasicLoader","pos":[251,280]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[283,321]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[322,417],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Complete code for a class and methods that convert and load common graphics resources, such as meshes, textures, and various shader objects.","pos":[419,559]},{"content":"This topic contains these sections:","pos":[561,596]},{"content":"Technologies","pos":[603,615]},{"content":"Requirements","pos":[637,649]},{"content":"View the code (C++)","pos":[671,690]},{"content":"Download location","pos":[753,770]},{"content":"This sample is not available for download.","pos":[773,815]},{"content":"Technologies","pos":[820,832]},{"content":"Programming languages","pos":[924,945]},{"content":"C++","pos":[948,951]},{"content":"Programming models","pos":[968,986]},{"content":"Windows Runtime","pos":[992,1007]},{"content":"Requirements","pos":[1014,1026]},{"content":"Minimum supported client","pos":[1030,1054]},{"content":"Windows 10","pos":[1057,1067]},{"content":"Minimum supported server","pos":[1168,1192]},{"content":"Windows Server 2016 Technical Preview","pos":[1195,1232]},{"content":"Minimum required SDK","pos":[1237,1257]},{"content":"View the code (C++)","pos":[1308,1327]},{"content":"BasicLoader.h","pos":[1332,1345]},{"content":"BasicLoader.cpp","pos":[6829,6844]}],"content":"---\ntitle: Complete code for BasicLoader\ndescription: Complete code for a class and methods that convert and load common graphics resources, such as meshes, textures, and various shader objects.\nms.assetid: b37f5852-278c-57b8-0834-002fb837e158\n---\n\n# Complete code for BasicLoader\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nComplete code for a class and methods that convert and load common graphics resources, such as meshes, textures, and various shader objects.\n\nThis topic contains these sections:\n\n-   [Technologies](#technologies)\n-   [Requirements](#requirements)\n-   [View the code (C++)](#view-the-code-c-)\n\n<span id=\"download_locations\"></span>\n## Download location\n\n\nThis sample is not available for download.\n\n## Technologies\n\n|                       |                 |\n|-----------------------|-----------------|\n| Programming languages | C++             |\n| Programming models    | Windows Runtime |\n\n## Requirements\n\n| Minimum supported client | Windows 10                            |\n|--------------------------|---------------------------------------|\n| Minimum supported server | Windows Server 2016 Technical Preview |\n| Minimum required SDK     |                                       |\n\n## View the code (C++)\n\n## BasicLoader.h\n\n```cpp\n//// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF\n//// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n//// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A\n//// PARTICULAR PURPOSE.\n////\n//// Copyright (c) Microsoft Corporation. All rights reserved\n\n#pragma once\n\n#include \"BasicReaderWriter.h\"\n\n// A simple loader class that provides support for loading shaders, textures,\n// and meshes from files on disk. Provides synchronous and asynchronous methods.\nref class BasicLoader\n{\ninternal:\n    BasicLoader(\n        _In_ ID3D11Device* d3dDevice,\n        _In_opt_ IWICImagingFactory2* wicFactory = nullptr\n        );\n\n    void LoadTexture(\n        _In_ Platform::String^ filename,\n        _Out_opt_ ID3D11Texture2D** texture,\n        _Out_opt_ ID3D11ShaderResourceView** textureView\n        );\n\n    concurrency::task<void> LoadTextureAsync(\n        _In_ Platform::String^ filename,\n        _Out_opt_ ID3D11Texture2D** texture,\n        _Out_opt_ ID3D11ShaderResourceView** textureView\n        );\n\n    void LoadShader(\n        _In_ Platform::String^ filename,\n        _In_reads_opt_(layoutDescNumElements) D3D11_INPUT_ELEMENT_DESC layoutDesc[],\n        _In_ uint32 layoutDescNumElements,\n        _Out_ ID3D11VertexShader** shader,\n        _Out_opt_ ID3D11InputLayout** layout\n        );\n\n    concurrency::task<void> LoadShaderAsync(\n        _In_ Platform::String^ filename,\n        _In_reads_opt_(layoutDescNumElements) D3D11_INPUT_ELEMENT_DESC layoutDesc[],\n        _In_ uint32 layoutDescNumElements,\n        _Out_ ID3D11VertexShader** shader,\n        _Out_opt_ ID3D11InputLayout** layout\n        );\n\n    void LoadShader(\n        _In_ Platform::String^ filename,\n        _Out_ ID3D11PixelShader** shader\n        );\n\n    concurrency::task<void> LoadShaderAsync(\n        _In_ Platform::String^ filename,\n        _Out_ ID3D11PixelShader** shader\n        );\n\n    void LoadShader(\n        _In_ Platform::String^ filename,\n        _Out_ ID3D11ComputeShader** shader\n        );\n\n    concurrency::task<void> LoadShaderAsync(\n        _In_ Platform::String^ filename,\n        _Out_ ID3D11ComputeShader** shader\n        );\n\n    void LoadShader(\n        _In_ Platform::String^ filename,\n        _Out_ ID3D11GeometryShader** shader\n        );\n\n    concurrency::task<void> LoadShaderAsync(\n        _In_ Platform::String^ filename,\n        _Out_ ID3D11GeometryShader** shader\n        );\n\n    void LoadShader(\n        _In_ Platform::String^ filename,\n        _In_reads_opt_(numEntries) const D3D11_SO_DECLARATION_ENTRY* streamOutDeclaration,\n        _In_ uint32 numEntries,\n        _In_reads_opt_(numStrides) const uint32* bufferStrides,\n        _In_ uint32 numStrides,\n        _In_ uint32 rasterizedStream,\n        _Out_ ID3D11GeometryShader** shader\n        );\n\n    concurrency::task<void> LoadShaderAsync(\n        _In_ Platform::String^ filename,\n        _In_reads_opt_(numEntries) const D3D11_SO_DECLARATION_ENTRY* streamOutDeclaration,\n        _In_ uint32 numEntries,\n        _In_reads_opt_(numStrides) const uint32* bufferStrides,\n        _In_ uint32 numStrides,\n        _In_ uint32 rasterizedStream,\n        _Out_ ID3D11GeometryShader** shader\n        );\n\n    void LoadShader(\n        _In_ Platform::String^ filename,\n        _Out_ ID3D11HullShader** shader\n        );\n\n    concurrency::task<void> LoadShaderAsync(\n        _In_ Platform::String^ filename,\n        _Out_ ID3D11HullShader** shader\n        );\n\n    void LoadShader(\n        _In_ Platform::String^ filename,\n        _Out_ ID3D11DomainShader** shader\n        );\n\n    concurrency::task<void> LoadShaderAsync(\n        _In_ Platform::String^ filename,\n        _Out_ ID3D11DomainShader** shader\n        );\n\n    void LoadMesh(\n        _In_ Platform::String^ filename,\n        _Out_ ID3D11Buffer** vertexBuffer,\n        _Out_ ID3D11Buffer** indexBuffer,\n        _Out_opt_ uint32* vertexCount,\n        _Out_opt_ uint32* indexCount\n        );\n\n    concurrency::task<void> LoadMeshAsync(\n        _In_ Platform::String^ filename,\n        _Out_ ID3D11Buffer** vertexBuffer,\n        _Out_ ID3D11Buffer** indexBuffer,\n        _Out_opt_ uint32* vertexCount,\n        _Out_opt_ uint32* indexCount\n        );\n\nprivate:\n    Microsoft::WRL::ComPtr<ID3D11Device> m_d3dDevice;\n    Microsoft::WRL::ComPtr<IWICImagingFactory2> m_wicFactory;\n    BasicReaderWriter^ m_basicReaderWriter;\n\n    template <class DeviceChildType>\n    inline void SetDebugName(\n        _In_ DeviceChildType* object,\n        _In_ Platform::String^ name\n        );\n\n    Platform::String^ GetExtension(\n        _In_ Platform::String^ filename\n        );\n\n    void CreateTexture(\n        _In_ bool decodeAsDDS,\n        _In_reads_bytes_(dataSize) byte* data,\n        _In_ uint32 dataSize,\n        _Out_opt_ ID3D11Texture2D** texture,\n        _Out_opt_ ID3D11ShaderResourceView** textureView,\n        _In_opt_ Platform::String^ debugName\n        );\n\n    void CreateInputLayout(\n        _In_reads_bytes_(bytecodeSize) byte* bytecode,\n        _In_ uint32 bytecodeSize,\n        _In_reads_opt_(layoutDescNumElements) D3D11_INPUT_ELEMENT_DESC* layoutDesc,\n        _In_ uint32 layoutDescNumElements,\n        _Out_ ID3D11InputLayout** layout\n        );\n\n    void CreateMesh(\n        _In_ byte* meshData,\n        _Out_ ID3D11Buffer** vertexBuffer,\n        _Out_ ID3D11Buffer** indexBuffer,\n        _Out_opt_ uint32* vertexCount,\n        _Out_opt_ uint32* indexCount,\n        _In_opt_ Platform::String^ debugName\n        );\n};\n```\n\n## BasicLoader.cpp\n\n\n```cpp\n//// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF\n//// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n//// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A\n//// PARTICULAR PURPOSE.\n////\n//// Copyright (c) Microsoft Corporation. All rights reserved\n\n#include \"pch.h\"\n#include \"BasicLoader.h\"\n#include \"BasicShapes.h\"\n#include \"DDSTextureLoader.h\"\n#include \"DirectXSample.h\"\n#include <memory>\n\nusing namespace Microsoft::WRL;\nusing namespace Windows::Storage;\nusing namespace Windows::Storage::Streams;\nusing namespace Windows::Foundation;\nusing namespace Windows::ApplicationModel;\nusing namespace std;\nusing namespace concurrency;\n\nBasicLoader::BasicLoader(\n    _In_ ID3D11Device* d3dDevice,\n    _In_opt_ IWICImagingFactory2* wicFactory\n    ) :\n    m_d3dDevice(d3dDevice),\n    m_wicFactory(wicFactory)\n{\n    // Create a new BasicReaderWriter to do raw file I/O.\n    m_basicReaderWriter = ref new BasicReaderWriter();\n}\n\ntemplate <class DeviceChildType>\ninline void BasicLoader::SetDebugName(\n    _In_ DeviceChildType* object,\n    _In_ Platform::String^ name\n    )\n{\n#if defined(_DEBUG)\n    // Only assign debug names in debug builds.\n\n    char nameString[1024];\n    int nameStringLength = WideCharToMultiByte(\n        CP_ACP,\n        0,\n        name->Data(),\n        -1,\n        nameString,\n        1024,\n        nullptr,\n        nullptr\n        );\n\n    if (nameStringLength == 0)\n    {\n        char defaultNameString[] = \"BasicLoaderObject\";\n        DX::ThrowIfFailed(\n            object->SetPrivateData(\n                WKPDID_D3DDebugObjectName,\n                sizeof(defaultNameString) - 1,\n                defaultNameString\n                )\n            );\n    }\n    else\n    {\n        DX::ThrowIfFailed(\n            object->SetPrivateData(\n                WKPDID_D3DDebugObjectName,\n                nameStringLength - 1,\n                nameString\n                )\n            );\n    }\n#endif\n}\n\nPlatform::String^ BasicLoader::GetExtension(\n    _In_ Platform::String^ filename\n    )\n{\n    int lastDotIndex = -1;\n    for (int i = filename->Length() - 1; i >= 0 && lastDotIndex == -1; i--)\n    {\n        if (*(filename->Data() + i) == '.')\n        {\n            lastDotIndex = i;\n        }\n    }\n    if (lastDotIndex != -1)\n    {\n        std::unique_ptr<wchar_t[]> extension(new wchar_t[filename->Length() - lastDotIndex]);\n        for (unsigned int i = 0; i < filename->Length() - lastDotIndex; i++)\n        {\n            extension[i] = tolower(*(filename->Data() + lastDotIndex + 1 + i));\n        }\n        return ref new Platform::String(extension.get());\n    }\n    return \"\";\n}\n\nvoid BasicLoader::CreateTexture(\n    _In_ bool decodeAsDDS,\n    _In_reads_bytes_(dataSize) byte* data,\n    _In_ uint32 dataSize,\n    _Out_opt_ ID3D11Texture2D** texture,\n    _Out_opt_ ID3D11ShaderResourceView** textureView,\n    _In_opt_ Platform::String^ debugName\n    )\n{\n    ComPtr<ID3D11ShaderResourceView> shaderResourceView;\n    ComPtr<ID3D11Texture2D> texture2D;\n\n    if (decodeAsDDS)\n    {\n        ComPtr<ID3D11Resource> resource;\n\n        if (textureView == nullptr)\n        {\n            CreateDDSTextureFromMemory(\n                m_d3dDevice.Get(),\n                data,\n                dataSize,\n                &resource,\n                nullptr\n                );\n        }\n        else\n        {\n            CreateDDSTextureFromMemory(\n                m_d3dDevice.Get(),\n                data,\n                dataSize,\n                &resource,\n                &shaderResourceView\n                );\n        }\n\n        DX::ThrowIfFailed(\n            resource.As(&texture2D)\n            );\n    }\n    else\n    {\n        if (m_wicFactory.Get() == nullptr)\n        {\n            // A WIC factory object is required in order to load texture\n            // assets stored in non-DDS formats.  If BasicLoader was not\n            // initialized with one, create one as needed.\n            DX::ThrowIfFailed(\n                CoCreateInstance(\n                    CLSID_WICImagingFactory,\n                    nullptr,\n                    CLSCTX_INPROC_SERVER,\n                    IID_PPV_ARGS(&m_wicFactory)\n                    )\n                );\n        }\n\n        ComPtr<IWICStream> stream;\n        DX::ThrowIfFailed(\n            m_wicFactory->CreateStream(&stream)\n            );\n\n        DX::ThrowIfFailed(\n            stream->InitializeFromMemory(\n                data,\n                dataSize\n                )\n            );\n\n        ComPtr<IWICBitmapDecoder> bitmapDecoder;\n        DX::ThrowIfFailed(\n            m_wicFactory->CreateDecoderFromStream(\n                stream.Get(),\n                nullptr,\n                WICDecodeMetadataCacheOnDemand,\n                &bitmapDecoder\n                )\n            );\n\n        ComPtr<IWICBitmapFrameDecode> bitmapFrame;\n        DX::ThrowIfFailed(\n            bitmapDecoder->GetFrame(0, &bitmapFrame)\n            );\n\n        ComPtr<IWICFormatConverter> formatConverter;\n        DX::ThrowIfFailed(\n            m_wicFactory->CreateFormatConverter(&formatConverter)\n            );\n\n        DX::ThrowIfFailed(\n            formatConverter->Initialize(\n                bitmapFrame.Get(),\n                GUID_WICPixelFormat32bppPBGRA,\n                WICBitmapDitherTypeNone,\n                nullptr,\n                0.0,\n                WICBitmapPaletteTypeCustom\n                )\n            );\n\n        uint32 width;\n        uint32 height;\n        DX::ThrowIfFailed(\n            bitmapFrame->GetSize(&width, &height)\n            );\n\n        std::unique_ptr<byte[]> bitmapPixels(new byte[width * height * 4]);\n        DX::ThrowIfFailed(\n            formatConverter->CopyPixels(\n                nullptr,\n                width * 4,\n                width * height * 4,\n                bitmapPixels.get()\n                )\n            );\n\n        D3D11_SUBRESOURCE_DATA initialData;\n        ZeroMemory(&initialData, sizeof(initialData));\n        initialData.pSysMem = bitmapPixels.get();\n        initialData.SysMemPitch = width * 4;\n        initialData.SysMemSlicePitch = 0;\n\n        CD3D11_TEXTURE2D_DESC textureDesc(\n            DXGI_FORMAT_B8G8R8A8_UNORM,\n            width,\n            height,\n            1,\n            1\n            );\n\n        DX::ThrowIfFailed(\n            m_d3dDevice->CreateTexture2D(\n                &textureDesc,\n                &initialData,\n                &texture2D\n                )\n            );\n\n        if (textureView != nullptr)\n        {\n            CD3D11_SHADER_RESOURCE_VIEW_DESC shaderResourceViewDesc(\n                texture2D.Get(),\n                D3D11_SRV_DIMENSION_TEXTURE2D\n                );\n\n            DX::ThrowIfFailed(\n                m_d3dDevice->CreateShaderResourceView(\n                    texture2D.Get(),\n                    &shaderResourceViewDesc,\n                    &shaderResourceView\n                    )\n                );\n        }\n    }\n\n    SetDebugName(texture2D.Get(), debugName);\n\n    if (texture != nullptr)\n    {\n        *texture = texture2D.Detach();\n    }\n    if (textureView != nullptr)\n    {\n        *textureView = shaderResourceView.Detach();\n    }\n}\n\nvoid BasicLoader::CreateInputLayout(\n    _In_reads_bytes_(bytecodeSize) byte* bytecode,\n    _In_ uint32 bytecodeSize,\n    _In_reads_opt_(layoutDescNumElements) D3D11_INPUT_ELEMENT_DESC* layoutDesc,\n    _In_ uint32 layoutDescNumElements,\n    _Out_ ID3D11InputLayout** layout\n    )\n{\n    if (layoutDesc == nullptr)\n    {\n        // If no input layout is specified, use the BasicVertex layout.\n        const D3D11_INPUT_ELEMENT_DESC basicVertexLayoutDesc[] =\n        {\n            { \"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },\n            { \"NORMAL\",   0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },\n            { \"TEXCOORD\", 0, DXGI_FORMAT_R32G32_FLOAT,    0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 },\n        };\n\n        DX::ThrowIfFailed(\n            m_d3dDevice->CreateInputLayout(\n                basicVertexLayoutDesc,\n                ARRAYSIZE(basicVertexLayoutDesc),\n                bytecode,\n                bytecodeSize,\n                layout\n                )\n            );\n    }\n    else\n    {\n        DX::ThrowIfFailed(\n            m_d3dDevice->CreateInputLayout(\n                layoutDesc,\n                layoutDescNumElements,\n                bytecode,\n                bytecodeSize,\n                layout\n                )\n            );\n    }\n}\n\nvoid BasicLoader::CreateMesh(\n    _In_ byte* meshData,\n    _Out_ ID3D11Buffer** vertexBuffer,\n    _Out_ ID3D11Buffer** indexBuffer,\n    _Out_opt_ uint32* vertexCount,\n    _Out_opt_ uint32* indexCount,\n    _In_opt_ Platform::String^ debugName\n    )\n{\n    // The first 4 bytes of the BasicMesh format define the number of vertices in the mesh.\n    uint32 numVertices = *reinterpret_cast<uint32*>(meshData);\n\n    // The following 4 bytes define the number of indices in the mesh.\n    uint32 numIndices = *reinterpret_cast<uint32*>(meshData + sizeof(uint32));\n\n    // The next segment of the BasicMesh format contains the vertices of the mesh.\n    BasicVertex* vertices = reinterpret_cast<BasicVertex*>(meshData + sizeof(uint32) * 2);\n\n    // The last segment of the BasicMesh format contains the indices of the mesh.\n    uint16* indices = reinterpret_cast<uint16*>(meshData + sizeof(uint32) * 2 + sizeof(BasicVertex) * numVertices);\n\n    // Create the vertex and index buffers with the mesh data.\n\n    D3D11_SUBRESOURCE_DATA vertexBufferData = {0};\n    vertexBufferData.pSysMem = vertices;\n    vertexBufferData.SysMemPitch = 0;\n    vertexBufferData.SysMemSlicePitch = 0;\n    CD3D11_BUFFER_DESC vertexBufferDesc(numVertices * sizeof(BasicVertex), D3D11_BIND_VERTEX_BUFFER);\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateBuffer(\n            &vertexBufferDesc,\n            &vertexBufferData,\n            vertexBuffer\n            )\n        );\n\n    D3D11_SUBRESOURCE_DATA indexBufferData = {0};\n    indexBufferData.pSysMem = indices;\n    indexBufferData.SysMemPitch = 0;\n    indexBufferData.SysMemSlicePitch = 0;\n    CD3D11_BUFFER_DESC indexBufferDesc(numIndices * sizeof(uint16), D3D11_BIND_INDEX_BUFFER);\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateBuffer(\n            &indexBufferDesc,\n            &indexBufferData,\n            indexBuffer\n            )\n        );\n\n    SetDebugName(*vertexBuffer, Platform::String::Concat(debugName, \"_VertexBuffer\"));\n    SetDebugName(*indexBuffer, Platform::String::Concat(debugName, \"_IndexBuffer\"));\n\n    if (vertexCount != nullptr)\n    {\n        *vertexCount = numVertices;\n    }\n    if (indexCount != nullptr)\n    {\n        *indexCount = numIndices;\n    }\n}\n\nvoid BasicLoader::LoadTexture(\n    _In_ Platform::String^ filename,\n    _Out_opt_ ID3D11Texture2D** texture,\n    _Out_opt_ ID3D11ShaderResourceView** textureView\n    )\n{\n    Platform::Array<byte>^ textureData = m_basicReaderWriter->ReadData(filename);\n\n    CreateTexture(\n        GetExtension(filename) == \"dds\",\n        textureData->Data,\n        textureData->Length,\n        texture,\n        textureView,\n        filename\n        );\n}\n\ntask<void> BasicLoader::LoadTextureAsync(\n    _In_ Platform::String^ filename,\n    _Out_opt_ ID3D11Texture2D** texture,\n    _Out_opt_ ID3D11ShaderResourceView** textureView\n    )\n{\n    return m_basicReaderWriter->ReadDataAsync(filename).then([=](const Platform::Array<byte>^ textureData)\n    {\n        CreateTexture(\n            GetExtension(filename) == \"dds\",\n            textureData->Data,\n            textureData->Length,\n            texture,\n            textureView,\n            filename\n            );\n    });\n}\n\nvoid BasicLoader::LoadShader(\n    _In_ Platform::String^ filename,\n    _In_reads_opt_(layoutDescNumElements) D3D11_INPUT_ELEMENT_DESC layoutDesc[],\n    _In_ uint32 layoutDescNumElements,\n    _Out_ ID3D11VertexShader** shader,\n    _Out_opt_ ID3D11InputLayout** layout\n    )\n{\n    Platform::Array<byte>^ bytecode = m_basicReaderWriter->ReadData(filename);\n\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateVertexShader(\n            bytecode->Data,\n            bytecode->Length,\n            nullptr,\n            shader\n            )\n        );\n\n    SetDebugName(*shader, filename);\n\n    if (layout != nullptr)\n    {\n        CreateInputLayout(\n            bytecode->Data,\n            bytecode->Length,\n            layoutDesc,\n            layoutDescNumElements,\n            layout\n            );\n\n        SetDebugName(*layout, filename);\n    }\n}\n\ntask<void> BasicLoader::LoadShaderAsync(\n    _In_ Platform::String^ filename,\n    _In_reads_opt_(layoutDescNumElements) D3D11_INPUT_ELEMENT_DESC layoutDesc[],\n    _In_ uint32 layoutDescNumElements,\n    _Out_ ID3D11VertexShader** shader,\n    _Out_opt_ ID3D11InputLayout** layout\n    )\n{\n    // This method assumes that the lifetime of input arguments may be shorter\n    // than the duration of this task.  In order to ensure accurate results, a\n    // copy of all arguments passed by pointer must be made.  The method then\n    // ensures that the lifetime of the copied data exceeds that of the task.\n\n    // Create copies of the layoutDesc array as well as the SemanticName strings,\n    // both of which are pointers to data whose lifetimes may be shorter than that\n    // of this method's task.\n    shared_ptr<vector<D3D11_INPUT_ELEMENT_DESC>> layoutDescCopy;\n    shared_ptr<vector<string>> layoutDescSemanticNamesCopy;\n    if (layoutDesc != nullptr)\n    {\n        layoutDescCopy.reset(\n            new vector<D3D11_INPUT_ELEMENT_DESC>(\n                layoutDesc,\n                layoutDesc + layoutDescNumElements\n                )\n            );\n\n        layoutDescSemanticNamesCopy.reset(\n            new vector<string>(layoutDescNumElements)\n            );\n\n        for (uint32 i = 0; i < layoutDescNumElements; i++)\n        {\n            layoutDescSemanticNamesCopy->at(i).assign(layoutDesc[i].SemanticName);\n        }\n    }\n\n    return m_basicReaderWriter->ReadDataAsync(filename).then([=](const Platform::Array<byte>^ bytecode)\n    {\n        DX::ThrowIfFailed(\n            m_d3dDevice->CreateVertexShader(\n                bytecode->Data,\n                bytecode->Length,\n                nullptr,\n                shader\n                )\n            );\n\n        SetDebugName(*shader, filename);\n\n        if (layout != nullptr)\n        {\n            if (layoutDesc != nullptr)\n            {\n                // Reassign the SemanticName elements of the layoutDesc array copy to point\n                // to the corresponding copied strings. Performing the assignment inside the\n                // lambda body ensures that the lambda will take a reference to the shared_ptr\n                // that holds the data.  This will guarantee that the data is still valid when\n                // CreateInputLayout is called.\n                for (uint32 i = 0; i < layoutDescNumElements; i++)\n                {\n                    layoutDescCopy->at(i).SemanticName = layoutDescSemanticNamesCopy->at(i).c_str();\n                }\n            }\n\n            CreateInputLayout(\n                bytecode->Data,\n                bytecode->Length,\n                layoutDesc == nullptr ? nullptr : layoutDescCopy->data(),\n                layoutDescNumElements,\n                layout\n                );\n\n            SetDebugName(*layout, filename);\n        }\n    });\n}\n\nvoid BasicLoader::LoadShader(\n    _In_ Platform::String^ filename,\n    _Out_ ID3D11PixelShader** shader\n    )\n{\n    Platform::Array<byte>^ bytecode = m_basicReaderWriter->ReadData(filename);\n\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreatePixelShader(\n            bytecode->Data,\n            bytecode->Length,\n            nullptr,\n            shader\n            )\n        );\n\n    SetDebugName(*shader, filename);\n}\n\ntask<void> BasicLoader::LoadShaderAsync(\n    _In_ Platform::String^ filename,\n    _Out_ ID3D11PixelShader** shader\n    )\n{\n    return m_basicReaderWriter->ReadDataAsync(filename).then([=](const Platform::Array<byte>^ bytecode)\n    {\n        DX::ThrowIfFailed(\n            m_d3dDevice->CreatePixelShader(\n                bytecode->Data,\n                bytecode->Length,\n                nullptr,\n                shader\n                )\n            );\n\n        SetDebugName(*shader, filename);\n    });\n}\n\nvoid BasicLoader::LoadShader(\n    _In_ Platform::String^ filename,\n    _Out_ ID3D11ComputeShader** shader\n    )\n{\n    Platform::Array<byte>^ bytecode = m_basicReaderWriter->ReadData(filename);\n\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateComputeShader(\n            bytecode->Data,\n            bytecode->Length,\n            nullptr,\n            shader\n            )\n        );\n\n    SetDebugName(*shader, filename);\n}\n\ntask<void> BasicLoader::LoadShaderAsync(\n    _In_ Platform::String^ filename,\n    _Out_ ID3D11ComputeShader** shader\n    )\n{\n    return m_basicReaderWriter->ReadDataAsync(filename).then([=](const Platform::Array<byte>^ bytecode)\n    {\n        DX::ThrowIfFailed(\n            m_d3dDevice->CreateComputeShader(\n                bytecode->Data,\n                bytecode->Length,\n                nullptr,\n                shader\n                )\n            );\n\n        SetDebugName(*shader, filename);\n    });\n}\n\nvoid BasicLoader::LoadShader(\n    _In_ Platform::String^ filename,\n    _Out_ ID3D11GeometryShader** shader\n    )\n{\n    Platform::Array<byte>^ bytecode = m_basicReaderWriter->ReadData(filename);\n\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateGeometryShader(\n            bytecode->Data,\n            bytecode->Length,\n            nullptr,\n            shader\n            )\n        );\n\n    SetDebugName(*shader, filename);\n}\n\ntask<void> BasicLoader::LoadShaderAsync(\n    _In_ Platform::String^ filename,\n    _Out_ ID3D11GeometryShader** shader\n    )\n{\n    return m_basicReaderWriter->ReadDataAsync(filename).then([=](const Platform::Array<byte>^ bytecode)\n    {\n        DX::ThrowIfFailed(\n            m_d3dDevice->CreateGeometryShader(\n                bytecode->Data,\n                bytecode->Length,\n                nullptr,\n                shader\n                )\n            );\n\n        SetDebugName(*shader, filename);\n    });\n}\n\nvoid BasicLoader::LoadShader(\n    _In_ Platform::String^ filename,\n    _In_reads_opt_(numEntries) const D3D11_SO_DECLARATION_ENTRY* streamOutDeclaration,\n    _In_ uint32 numEntries,\n    _In_reads_opt_(numStrides) const uint32* bufferStrides,\n    _In_ uint32 numStrides,\n    _In_ uint32 rasterizedStream,\n    _Out_ ID3D11GeometryShader** shader\n    )\n{\n    Platform::Array<byte>^ bytecode = m_basicReaderWriter->ReadData(filename);\n\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateGeometryShaderWithStreamOutput(\n            bytecode->Data,\n            bytecode->Length,\n            streamOutDeclaration,\n            numEntries,\n            bufferStrides,\n            numStrides,\n            rasterizedStream,\n            nullptr,\n            shader\n            )\n        );\n\n    SetDebugName(*shader, filename);\n}\n\ntask<void> BasicLoader::LoadShaderAsync(\n    _In_ Platform::String^ filename,\n    _In_reads_opt_(numEntries) const D3D11_SO_DECLARATION_ENTRY* streamOutDeclaration,\n    _In_ uint32 numEntries,\n    _In_reads_opt_(numStrides) const uint32* bufferStrides,\n    _In_ uint32 numStrides,\n    _In_ uint32 rasterizedStream,\n    _Out_ ID3D11GeometryShader** shader\n    )\n{\n    // This method assumes that the lifetime of input arguments may be shorter\n    // than the duration of this task.  In order to ensure accurate results, a\n    // copy of all arguments passed by pointer must be made.  The method then\n    // ensures that the lifetime of the copied data exceeds that of the task.\n\n    // Create copies of the streamOutDeclaration array as well as the SemanticName\n    // strings, both of which are pointers to data whose lifetimes may be shorter\n    // than that of this method's task.\n    shared_ptr<vector<D3D11_SO_DECLARATION_ENTRY>> streamOutDeclarationCopy;\n    shared_ptr<vector<string>> streamOutDeclarationSemanticNamesCopy;\n    if (streamOutDeclaration != nullptr)\n    {\n        streamOutDeclarationCopy.reset(\n            new vector<D3D11_SO_DECLARATION_ENTRY>(\n                streamOutDeclaration,\n                streamOutDeclaration + numEntries\n                )\n            );\n\n        streamOutDeclarationSemanticNamesCopy.reset(\n            new vector<string>(numEntries)\n            );\n\n        for (uint32 i = 0; i < numEntries; i++)\n        {\n            streamOutDeclarationSemanticNamesCopy->at(i).assign(streamOutDeclaration[i].SemanticName);\n        }\n    }\n    \n    // Create a copy of the bufferStrides array, which is a pointer to data\n    // whose lifetime may be shorter than that of this method's task.\n    shared_ptr<vector<uint32>> bufferStridesCopy;\n    if (bufferStrides != nullptr)\n    {\n        bufferStridesCopy.reset(\n            new vector<uint32>(\n                bufferStrides,\n                bufferStrides + numStrides\n                )\n            );\n    }\n\n    return m_basicReaderWriter->ReadDataAsync(filename).then([=](const Platform::Array<byte>^ bytecode)\n    {\n        if (streamOutDeclaration != nullptr)\n        {\n            // Reassign the SemanticName elements of the streamOutDeclaration array copy to\n            // point to the corresponding copied strings. Performing the assignment inside the\n            // lambda body ensures that the lambda will take a reference to the shared_ptr\n            // that holds the data.  This will guarantee that the data is still valid when\n            // CreateGeometryShaderWithStreamOutput is called.\n            for (uint32 i = 0; i < numEntries; i++)\n            {\n                streamOutDeclarationCopy->at(i).SemanticName = streamOutDeclarationSemanticNamesCopy->at(i).c_str();\n            }\n        }\n\n        DX::ThrowIfFailed(\n            m_d3dDevice->CreateGeometryShaderWithStreamOutput(\n                bytecode->Data,\n                bytecode->Length,\n                streamOutDeclaration == nullptr ? nullptr : streamOutDeclarationCopy->data(),\n                numEntries,\n                bufferStrides == nullptr ? nullptr : bufferStridesCopy->data(),\n                numStrides,\n                rasterizedStream,\n                nullptr,\n                shader\n                )\n            );\n\n        SetDebugName(*shader, filename);\n    });\n}\n\nvoid BasicLoader::LoadShader(\n    _In_ Platform::String^ filename,\n    _Out_ ID3D11HullShader** shader\n    )\n{\n    Platform::Array<byte>^ bytecode = m_basicReaderWriter->ReadData(filename);\n\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateHullShader(\n            bytecode->Data,\n            bytecode->Length,\n            nullptr,\n            shader\n            )\n        );\n\n    SetDebugName(*shader, filename);\n}\n\ntask<void> BasicLoader::LoadShaderAsync(\n    _In_ Platform::String^ filename,\n    _Out_ ID3D11HullShader** shader\n    )\n{\n    return m_basicReaderWriter->ReadDataAsync(filename).then([=](const Platform::Array<byte>^ bytecode)\n    {\n        DX::ThrowIfFailed(\n            m_d3dDevice->CreateHullShader(\n                bytecode->Data,\n                bytecode->Length,\n                nullptr,\n                shader\n                )\n            );\n\n        SetDebugName(*shader, filename);\n    });\n}\n\nvoid BasicLoader::LoadShader(\n    _In_ Platform::String^ filename,\n    _Out_ ID3D11DomainShader** shader\n    )\n{\n    Platform::Array<byte>^ bytecode = m_basicReaderWriter->ReadData(filename);\n\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateDomainShader(\n            bytecode->Data,\n            bytecode->Length,\n            nullptr,\n            shader\n            )\n        );\n\n    SetDebugName(*shader, filename);\n}\n\ntask<void> BasicLoader::LoadShaderAsync(\n    _In_ Platform::String^ filename,\n    _Out_ ID3D11DomainShader** shader\n    )\n{\n    return m_basicReaderWriter->ReadDataAsync(filename).then([=](const Platform::Array<byte>^ bytecode)\n    {\n        DX::ThrowIfFailed(\n            m_d3dDevice->CreateDomainShader(\n                bytecode->Data,\n                bytecode->Length,\n                nullptr,\n                shader\n                )\n            );\n\n        SetDebugName(*shader, filename);\n    });\n}\n\nvoid BasicLoader::LoadMesh(\n    _In_ Platform::String^ filename,\n    _Out_ ID3D11Buffer** vertexBuffer,\n    _Out_ ID3D11Buffer** indexBuffer,\n    _Out_opt_ uint32* vertexCount,\n    _Out_opt_ uint32* indexCount\n    )\n{\n    Platform::Array<byte>^ meshData = m_basicReaderWriter->ReadData(filename);\n\n    CreateMesh(\n        meshData->Data,\n        vertexBuffer,\n        indexBuffer,\n        vertexCount,\n        indexCount,\n        filename\n        );\n}\n\ntask<void> BasicLoader::LoadMeshAsync(\n    _In_ Platform::String^ filename,\n    _Out_ ID3D11Buffer** vertexBuffer,\n    _Out_ ID3D11Buffer** indexBuffer,\n    _Out_opt_ uint32* vertexCount,\n    _Out_opt_ uint32* indexCount\n    )\n{\n    return m_basicReaderWriter->ReadDataAsync(filename).then([=](const Platform::Array<byte>^ meshData)\n    {\n        CreateMesh(\n            meshData->Data,\n            vertexBuffer,\n            indexBuffer,\n            vertexCount,\n            indexCount,\n            filename\n            );\n    });\n}\n```\n\n \n\n \n\n\n\n\n"}