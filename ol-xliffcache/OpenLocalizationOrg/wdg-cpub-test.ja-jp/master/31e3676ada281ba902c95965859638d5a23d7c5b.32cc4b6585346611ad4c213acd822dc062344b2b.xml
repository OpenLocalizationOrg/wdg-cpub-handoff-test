{"nodes":[{"pos":[11,58],"content":"Supporting screen orientation (DirectX and C++)","needQuote":true,"needEscape":true,"nodes":[{"content":"Supporting screen orientation (DirectX and C++)","pos":[0,47]}]},{"pos":[72,248],"content":"Here, we'll discuss best practices for handling screen rotation in your UWP DirectX app, so that the Windows 10 device's graphics hardware are used efficiently and effectively.","needQuote":true,"needEscape":true,"nodes":[{"content":"Here, we'll discuss best practices for handling screen rotation in your UWP DirectX app, so that the Windows 10 device's graphics hardware are used efficiently and effectively.","pos":[0,176]}]},{"content":"Supporting screen orientation (DirectX and C++)","pos":[305,352]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[355,393]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[394,489],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Your Universal Windows Platform (UWP) app can support multiple screen orientations when you handle the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DisplayInformation::OrientationChanged<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event.","pos":[491,703],"source":"Your Universal Windows Platform (UWP) app can support multiple screen orientations when you handle the [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268) event."},{"content":"Here, we'll discuss best practices for handling screen rotation in your UWP DirectX app, so that the Windows 10 device's graphics hardware are used efficiently and effectively.","pos":[704,880]},{"content":"Before you start, remember that graphics hardware always outputs pixel data in the same way, regardless of the orientation of the device.","pos":[882,1019]},{"content":"Windows 10 devices can determine their current display orientation (with some sort of sensor, or with a software toggle) and allow users to change the display settings.","pos":[1020,1188]},{"content":"Because of this, Windows 10 itself handles the rotation of the images to ensure they are \"upright\" based on the orientation of the device.","pos":[1189,1327]},{"content":"By default, your app receives the notification that something has changed in orientation, for example, a window size.","pos":[1328,1445]},{"content":"When this happens, Windows 10 immediately rotates the image for final display.","pos":[1446,1524]},{"content":"For three of the four specific screen orientations (discussed later), Windows 10 uses additional graphic resources and computation to display the final image.","pos":[1525,1683]},{"content":"For UWP DirectX apps, the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DisplayInformation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn264258)</ept> object provides basic display orientation data that your app can query.","pos":[1685,1865],"source":"For UWP DirectX apps, the [**DisplayInformation**](https://msdn.microsoft.com/library/windows/apps/dn264258) object provides basic display orientation data that your app can query."},{"content":"The default orientation is <bpt id=\"p1\">*</bpt>landscape<ept id=\"p1\">*</ept>, where the pixel width of the display is greater than the height; the alternative orientation is <bpt id=\"p2\">*</bpt>portrait<ept id=\"p2\">*</ept>, where the display is rotated 90 degrees in either direction and the width becomes less than the height.","pos":[1866,2117],"source":" The default orientation is *landscape*, where the pixel width of the display is greater than the height; the alternative orientation is *portrait*, where the display is rotated 90 degrees in either direction and the width becomes less than the height."},{"content":"Windows 10 defines four specific display orientation modes:","pos":[2119,2178]},{"content":"Landscape—the default display orientation for Windows 10, and is considered the base or identity angle for rotation (0 degrees).","pos":[2184,2312]},{"content":"Portrait—the display has been rotated clockwise 90 degrees (or counter-clockwise 270 degrees).","pos":[2317,2411]},{"content":"Landscape, flipped—the display has been rotated 180 degrees (turned upside-down).","pos":[2416,2497]},{"content":"Portrait, flipped—the display has been rotated clockwise 270 degrees (or counter-clockwise 90 degrees).","pos":[2502,2605]},{"content":"When the display rotates from one orientation to another, Windows 10 internally performs a rotation operation to align the drawn image with the new orientation, and the user sees an upright image on the screen.","pos":[2607,2817]},{"content":"Also, Windows 10 displays automatic transition animations to create a smooth user experience when shifting from one orientation to another.","pos":[2819,2958]},{"content":"As the display orientation shifts, the user sees these shifts as a fixed zoom and rotation animation of the displayed screen image.","pos":[2959,3090]},{"content":"Time is allocated by Windows 10 to the app for layout in the new orientation.","pos":[3091,3168]},{"content":"Overall, this is the general process for handling changes in screen orientation:","pos":[3170,3250]},{"content":"Use a combination of the window bounds values and the display orientation data to keep the swap chain aligned with the native display orientation of the device.","pos":[3256,3416]},{"pos":[3421,3578],"content":"Notify Windows 10 of the orientation of the swap chain using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1::SetRotation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</ept>.","source":"Notify Windows 10 of the orientation of the swap chain using [**IDXGISwapChain1::SetRotation**](https://msdn.microsoft.com/library/windows/desktop/hh446801)."},{"content":"Change the rendering code to generate images aligned with the user orientation of the device.","pos":[3583,3676]},{"content":"Resizing the swap chain and pre-rotating its contents","pos":[3681,3734]},{"content":"To perform a basic display resize and pre-rotate its contents in your UWP DirectX app , implement these steps:","pos":[3737,3847]},{"pos":[3853,3973],"content":"Handle the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DisplayInformation::OrientationChanged<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event.","source":"Handle the [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268) event."},{"content":"Resize the swap chain to the new dimensions of the window.","pos":[3978,4036]},{"pos":[4041,4183],"content":"Call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1::SetRotation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</ept> to set the orientation of the swap chain.","source":"Call [**IDXGISwapChain1::SetRotation**](https://msdn.microsoft.com/library/windows/desktop/hh446801) to set the orientation of the swap chain."},{"content":"Recreate any window size dependent resources, such as your render targets and other pixel data buffers.","pos":[4188,4291]},{"content":"Now's let's look at those steps in a bit more detail.","pos":[4293,4346]},{"content":"Your first step is to register a handler for the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DisplayInformation::OrientationChanged<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event.","pos":[4348,4506],"source":"Your first step is to register a handler for the [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268) event."},{"content":"This event is raised in your app every time the screen orientation changes, such as when the display is rotated.","pos":[4507,4619]},{"pos":[4621,5078],"content":"To handle the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DisplayInformation::OrientationChanged<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event, you connect your handler for <bpt id=\"p3\">**</bpt>DisplayInformation::OrientationChanged<ept id=\"p3\">**</ept> in the required <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>SetWindow<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/hh700509)</ept> method, which is one of the methods of the <bpt id=\"p6\">[</bpt><bpt id=\"p7\">**</bpt>IFrameworkView<ept id=\"p7\">**</ept><ept id=\"p6\">](https://msdn.microsoft.com/library/windows/apps/hh700478)</ept> interface that your view provider must implement.","source":"To handle the [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268) event, you connect your handler for **DisplayInformation::OrientationChanged** in the required [**SetWindow**](https://msdn.microsoft.com/library/windows/apps/hh700509) method, which is one of the methods of the [**IFrameworkView**](https://msdn.microsoft.com/library/windows/apps/hh700478) interface that your view provider must implement."},{"content":"In this code example, the event handler for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DisplayInformation::OrientationChanged<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> is a method called <bpt id=\"p3\">**</bpt>OnOrientationChanged<ept id=\"p3\">**</ept>.","pos":[5080,5271],"source":"In this code example, the event handler for [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268) is a method called **OnOrientationChanged**."},{"content":"When <bpt id=\"p1\">**</bpt>DisplayInformation::OrientationChanged<ept id=\"p1\">**</ept> is raised, it in turn calls a method called <bpt id=\"p2\">**</bpt>SetCurrentOrientation<ept id=\"p2\">**</ept> which then calls <bpt id=\"p3\">**</bpt>CreateWindowSizeDependentResources<ept id=\"p3\">**</ept>.","pos":[5272,5446],"source":" When **DisplayInformation::OrientationChanged** is raised, it in turn calls a method called **SetCurrentOrientation** which then calls **CreateWindowSizeDependentResources**."},{"content":"Next, you resize the swap chain for the new screen orientation and prepare it to rotate the contents of the graphic pipeline when the rendering is performed.","pos":[6269,6426]},{"content":"In this example, <bpt id=\"p1\">**</bpt>DirectXBase::CreateWindowSizeDependentResources<ept id=\"p1\">**</ept> is a method that handles calling IDXGISwapChain::ResizeBuffers, setting a 3D and a 2D rotation matrix, calling SetRotation, and recreating your resources.","pos":[6427,6650],"source":" In this example, **DirectXBase::CreateWindowSizeDependentResources** is a method that handles calling IDXGISwapChain::ResizeBuffers, setting a 3D and a 2D rotation matrix, calling SetRotation, and recreating your resources."},{"content":"After saving the current height and width values of the window for the next time this method is called, convert the device independent pixel (DIP) values for the display bounds to pixels.","pos":[15160,15347]},{"content":"In the sample, you call <bpt id=\"p1\">**</bpt>ConvertDipsToPixels<ept id=\"p1\">**</ept>, which is a simple function that runs this code:","pos":[15348,15444],"source":" In the sample, you call **ConvertDipsToPixels**, which is a simple function that runs this code:"},{"content":"You add the 0.5f to ensure rounding to the nearest integer value.","pos":[15486,15551]},{"content":"As an aside, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> coordinates are always defined in DIPs.","pos":[15553,15680],"source":"As an aside, [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) coordinates are always defined in DIPs."},{"content":"For Windows 10 and earlier versions of Windows, a DIP is defined as 1/96th of an inch, and aligned to the OS's definition of <bpt id=\"p1\">*</bpt>up<ept id=\"p1\">*</ept>.","pos":[15681,15811],"source":" For Windows 10 and earlier versions of Windows, a DIP is defined as 1/96th of an inch, and aligned to the OS's definition of *up*."},{"content":"When the display orientation rotates to portrait mode, the app flips the width and height of the <bpt id=\"p1\">**</bpt>CoreWindow<ept id=\"p1\">**</ept>, and the render target size (bounds) must change accordingly.","pos":[15812,15985],"source":" When the display orientation rotates to portrait mode, the app flips the width and height of the **CoreWindow**, and the render target size (bounds) must change accordingly."},{"content":"Because Direct3D’s coordinates are always in physical pixels, you must convert from <bpt id=\"p1\">**</bpt>CoreWindow<ept id=\"p1\">**</ept>'s DIP values to integer pixel values before you pass these values to Direct3D to set up the swap chain.","pos":[15986,16188],"source":" Because Direct3D’s coordinates are always in physical pixels, you must convert from **CoreWindow**'s DIP values to integer pixel values before you pass these values to Direct3D to set up the swap chain."},{"content":"Process-wise, you're doing a bit more work than you would if you simply resized the swap chain: you're actually rotating the Direct2D and Direct3D components of your image before you composite them for presentation, and you're telling the swap chain that you've rendered the results in a new orientation.","pos":[16190,16494]},{"content":"Here's a little more detail on this process, as shown in the code example for <bpt id=\"p1\">**</bpt>DX::DeviceResources::CreateWindowSizeDependentResources<ept id=\"p1\">**</ept>:","pos":[16495,16633],"source":" Here's a little more detail on this process, as shown in the code example for **DX::DeviceResources::CreateWindowSizeDependentResources**:"},{"content":"Determine the new orientation of the display.","pos":[16639,16684]},{"content":"If the display has flipped from landscape to portrait, or vice versa, swap the height and width values—changed from DIP values to pixels, of course—for the display bounds.","pos":[16685,16856]},{"content":"Then, check to see if the swap chain has been created.","pos":[16862,16916]},{"content":"If it hasn't been created, create it by calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGIFactory2::CreateSwapChainForCoreWindow<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404559)</ept>.","pos":[16917,17076],"source":" If it hasn't been created, create it by calling [**IDXGIFactory2::CreateSwapChainForCoreWindow**](https://msdn.microsoft.com/library/windows/desktop/hh404559)."},{"content":"Otherwise, resize the existing swap chain's buffers to the new display dimensions by calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapchain:ResizeBuffers<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb174577)</ept>.","pos":[17077,17266],"source":" Otherwise, resize the existing swap chain's buffers to the new display dimensions by calling [**IDXGISwapchain:ResizeBuffers**](https://msdn.microsoft.com/library/windows/desktop/bb174577)."},{"content":"Although you don't need to resize the swap chain for the rotation event—you're outputting the content already rotated by your rendering pipeline, after all—there are other size change events, such as snap and fill events, that require resizing.","pos":[17267,17511]},{"content":"After that, set the appropriate 2-D or 3-D matrix transformation to apply to the pixels or the vertices (respectively) in the graphics pipeline when rendering them to the swap chain.","pos":[17517,17699]},{"content":"We have 4 possible rotation matrices:","pos":[17700,17737]},{"content":"landscape (DXGI\\_MODE\\_ROTATION\\_IDENTITY)","pos":[17747,17789]},{"content":"portrait (DXGI\\_MODE\\_ROTATION\\_ROTATE270)","pos":[17798,17840]},{"content":"landscape, flipped (DXGI\\_MODE\\_ROTATION\\_ROTATE180)","pos":[17849,17901]},{"content":"portrait, flipped (DXGI\\_MODE\\_ROTATION\\_ROTATE90)","pos":[17910,17960]},{"content":"The correct matrix is selected based on the data provided by Windows 10 (such as the results of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DisplayInformation::OrientationChanged<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept>) for determining display orientation, and it will be multiplied by the coordinates of each pixel (Direct2D) or vertex (Direct3D) in the scene, effectively rotating them to align to the orientation of the screen.","pos":[17966,18376],"source":"The correct matrix is selected based on the data provided by Windows 10 (such as the results of [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268)) for determining display orientation, and it will be multiplied by the coordinates of each pixel (Direct2D) or vertex (Direct3D) in the scene, effectively rotating them to align to the orientation of the screen."},{"content":"(Note that in Direct2D, the screen origin is defined as the upper-left corner, while in Direct3D the origin is defined as the logical center of the window.)","pos":[18377,18533]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   For more info about the 2-D transformations used for rotation and how to define them, see <bpt id=\"p2\">[</bpt>Defining matrices for screen rotation (2-D)<ept id=\"p2\">](#defining_matrices_2d)</ept>.","pos":[18537,18707],"source":"**Note**   For more info about the 2-D transformations used for rotation and how to define them, see [Defining matrices for screen rotation (2-D)](#defining_matrices_2d)."},{"content":"For more info about the 3-D transformations used for rotation, see <bpt id=\"p1\">[</bpt>Defining matrices for screen rotation (3-D)<ept id=\"p1\">](#defining_matrices_3d)</ept>.","pos":[18708,18844],"source":" For more info about the 3-D transformations used for rotation, see [Defining matrices for screen rotation (3-D)](#defining_matrices_3d)."},{"pos":[18849,19041],"content":"Now, here's the important bit: call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1::SetRotation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</ept> and provide it with your updated rotation matrix, like this:","source":"Now, here's the important bit: call [**IDXGISwapChain1::SetRotation**](https://msdn.microsoft.com/library/windows/desktop/hh446801) and provide it with your updated rotation matrix, like this:"},{"content":"You also store the selected rotation matrix where your render method can get it when it computes the new projection.","pos":[19082,19198]},{"content":"You'll use this matrix when you render your final 3-D projection or composite your final 2-D layout.","pos":[19199,19299]},{"content":"(It doesn't automatically apply it for you.)","pos":[19300,19344]},{"content":"After that, create a new render target for the rotated 3-D view, as well as a new depth stencil buffer for the view.","pos":[19346,19462]},{"content":"Set the 3-D rendering viewport for the rotated scene by calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext:RSSetViewports<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476480)</ept>.","pos":[19463,19629],"source":" Set the 3-D rendering viewport for the rotated scene by calling [**ID3D11DeviceContext:RSSetViewports**](https://msdn.microsoft.com/library/windows/desktop/ff476480)."},{"content":"Lastly, if you have 2-D images to rotate or lay out, create a 2-D render target as a writable bitmap for the resized swap chain using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID2D1DeviceContext::CreateBitmapFromDxgiSurface<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404482)</ept> and composite your new layout for the updated orientation.","pos":[19631,19938],"source":"Lastly, if you have 2-D images to rotate or lay out, create a 2-D render target as a writable bitmap for the resized swap chain using [**ID2D1DeviceContext::CreateBitmapFromDxgiSurface**](https://msdn.microsoft.com/library/windows/desktop/hh404482) and composite your new layout for the updated orientation."},{"content":"Set any properties you need to on the render target, such as the anti-aliasing mode (as seen in the code example).","pos":[19939,20053]},{"content":"Now, present the swap chain.","pos":[20055,20083]},{"content":"Reduce the rotation delay by using CoreWindowResizeManager","pos":[20088,20146]},{"content":"By default, Windows 10 provides a short but noticeable window of time for any app, regardless of app model or language, to complete the rotation of the image.","pos":[20149,20307]},{"content":"However, chances are that when your app performs the rotation calculation using one of the techniques described here, it will be done well before this window of time has closed.","pos":[20308,20485]},{"content":"You'd like to get that time back and complete the rotation animation, right?","pos":[20486,20562]},{"content":"That's where <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindowResizeManager<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/jj215603)</ept> comes in.","pos":[20563,20673],"source":" That's where [**CoreWindowResizeManager**](https://msdn.microsoft.com/library/windows/apps/jj215603) comes in."},{"pos":[20675,21365],"content":"Here's how to use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindowResizeManager<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/jj215603)</ept>: when a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DisplayInformation::OrientationChanged<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event is raised, call <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>CoreWindowResizeManager::GetForCurrentView<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/hh404170)</ept> within the handler for the event to obtain an instance of <bpt id=\"p7\">**</bpt>CoreWindowResizeManager<ept id=\"p7\">**</ept> and, when the layout for the new orientation is complete and presented, call the <bpt id=\"p8\">[</bpt><bpt id=\"p9\">**</bpt>NotifyLayoutCompleted<ept id=\"p9\">**</ept><ept id=\"p8\">](https://msdn.microsoft.com/library/windows/apps/jj215605)</ept> to let Windows know that it can complete the rotation animation and display the app screen.","source":"Here's how to use [**CoreWindowResizeManager**](https://msdn.microsoft.com/library/windows/apps/jj215603): when a [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268) event is raised, call [**CoreWindowResizeManager::GetForCurrentView**](https://msdn.microsoft.com/library/windows/apps/hh404170) within the handler for the event to obtain an instance of **CoreWindowResizeManager** and, when the layout for the new orientation is complete and presented, call the [**NotifyLayoutCompleted**](https://msdn.microsoft.com/library/windows/apps/jj215605) to let Windows know that it can complete the rotation animation and display the app screen."},{"pos":[21367,21533],"content":"Here's what the code in your event handler for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DisplayInformation::OrientationChanged<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> might look like:","source":"Here's what the code in your event handler for [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268) might look like:"},{"content":"When a user rotates the orientation of the display, Windows 10 shows an animation independent of your app as feedback to the user.","pos":[21755,21885]},{"content":"There are three parts to that animation that happen in the following order:","pos":[21886,21961]},{"content":"Windows 10 shrinks the original image.","pos":[21967,22005]},{"content":"Windows 10 holds the image for the time it takes to rebuild the new layout.","pos":[22010,22085]},{"content":"This is the window of time that you'd like to reduce, because your app probably doesn't need all of it.","pos":[22086,22189]},{"content":"When the layout window expires, or when a notification of layout completion is received, Windows rotates the image and then cross-fade zooms to new orientation.","pos":[22194,22354]},{"content":"As suggested in the third bullet, when an app calls <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>NotifyLayoutCompleted<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/jj215605)</ept>, Windows 10 stops the timeout window, completes the rotation animation and returns control to your app, which is now drawing in the new display orientation.","pos":[22356,22650],"source":"As suggested in the third bullet, when an app calls [**NotifyLayoutCompleted**](https://msdn.microsoft.com/library/windows/apps/jj215605), Windows 10 stops the timeout window, completes the rotation animation and returns control to your app, which is now drawing in the new display orientation."},{"content":"The overall effect is that your app now feels a little bit more fluid and responsive, and works a little more efficiently!","pos":[22651,22773]},{"content":"Appendix A: Applying matrices for screen rotation (2-D)","pos":[22778,22833]},{"content":"In the sample in <bpt id=\"p1\">[</bpt>Optimizing the rotation process<ept id=\"p1\">](#rotation)</ept> (and in the <bpt id=\"p2\">[</bpt>DXGI swap chain rotation sample<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?linkid=257600)</ept>), you might have noticed that we had separate rotation matrices for Direct2D output and Direct3D output.","pos":[22836,23097],"source":"In the sample in [Optimizing the rotation process](#rotation) (and in the [DXGI swap chain rotation sample](http://go.microsoft.com/fwlink/p/?linkid=257600)), you might have noticed that we had separate rotation matrices for Direct2D output and Direct3D output."},{"content":"Let's look at the 2-D matrices, first.","pos":[23098,23136]},{"content":"There are two reasons that we can't apply the same rotation matrices to Direct2D and Direct3D content:","pos":[23138,23240]},{"content":"One, they use different Cartesian coordinate models.","pos":[23246,23298]},{"content":"Direct2D uses the right-handed rule, where the y-coordinate increases in positive value moving upward from the origin.","pos":[23299,23417]},{"content":"However, Direct3D uses the left-handed rule, where the y-coordinate increases in positive value rightward from the origin.","pos":[23418,23540]},{"content":"The result is the origin for the screen coordinates is located in the upper-left for Direct2D, while the origin for the screen (the projection plane) is in the lower-left for Direct3D.","pos":[23541,23725]},{"content":"(See <bpt id=\"p1\">[</bpt>3-D coordinate systems<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/bb324490.aspx)</ept> for more info.)","pos":[23726,23834],"source":" (See [3-D coordinate systems](https://msdn.microsoft.com/library/windows/apps/bb324490.aspx) for more info.)"},{"content":"direct3d coordinate system.","pos":[23842,23869]},{"content":"direct2d coordinate system.","pos":[23900,23927]},{"content":"Two, the 3-D rotation matrices must be specified explicitly to avoid rounding errors.","pos":[23962,24047]},{"content":"The swap chain assumes that the origin is located in the lower-left, so you must perform a rotation to align the right-handed Direct2D coordinate system with the left-handed one used by the swap chain.","pos":[24049,24250]},{"content":"Specifically, you reposition the image under the new left-handed orientation by multiplying the rotation matrix with a translation matrix for the rotated coordinate system origin, and transform the image from the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept>'s coordinate space to the swap chain's coordinate space.","pos":[24251,24595],"source":" Specifically, you reposition the image under the new left-handed orientation by multiplying the rotation matrix with a translation matrix for the rotated coordinate system origin, and transform the image from the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225)'s coordinate space to the swap chain's coordinate space."},{"content":"Your app also must consistently apply this transform when the Direct2D render target is connected with the swap chain.","pos":[24596,24714]},{"content":"However, if your app is drawing to intermediate surfaces that are not associated directly with the swap chain, don't apply this coordinate space transformation.","pos":[24715,24875]},{"content":"Your code to select the correct matrix from the four possible rotations might look like this (be aware of the translation to the new coordinate system origin):","pos":[24877,25036]},{"pos":[26371,26784],"content":"After you have the correct rotation matrix and origin for the 2-D image, set it with a call to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID2D1DeviceContext::SetTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/dd742857)</ept> between your calls to <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID2D1DeviceContext::BeginDraw<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/dd371768)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ID2D1DeviceContext::EndDraw<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/dd371924)</ept>.","source":"After you have the correct rotation matrix and origin for the 2-D image, set it with a call to [**ID2D1DeviceContext::SetTransform**](https://msdn.microsoft.com/library/windows/desktop/dd742857) between your calls to [**ID2D1DeviceContext::BeginDraw**](https://msdn.microsoft.com/library/windows/desktop/dd371768) and [**ID2D1DeviceContext::EndDraw**](https://msdn.microsoft.com/library/windows/desktop/dd371924)."},{"content":"<bpt id=\"p1\">**</bpt>Warning<ept id=\"p1\">**</ept>   Direct2D doesn't have a transformation stack.","pos":[26786,26845],"source":"**Warning**   Direct2D doesn't have a transformation stack."},{"content":"If your app is also using the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID2D1DeviceContext::SetTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/dd742857)</ept> as a part of its drawing code, this matrix needs to be post-multiplied to any other transform you have applied.","pos":[26846,27087],"source":" If your app is also using the [**ID2D1DeviceContext::SetTransform**](https://msdn.microsoft.com/library/windows/desktop/dd742857) as a part of its drawing code, this matrix needs to be post-multiplied to any other transform you have applied."},{"content":"The next time you present the swap chain, your 2-D image will be rotated to match the new display orientation.","pos":[28089,28199]},{"content":"Appendix B: Applying matrices for screen rotation (3-D)","pos":[28204,28259]},{"content":"In the sample in <bpt id=\"p1\">[</bpt>Optimizing the rotation process<ept id=\"p1\">](#rotation)</ept> (and in the <bpt id=\"p2\">[</bpt>DXGI swap chain rotation sample<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?linkid=257600)</ept>), we defined a specific transformation matrix for each possible screen orientation.","pos":[28262,28502],"source":"In the sample in [Optimizing the rotation process](#rotation) (and in the [DXGI swap chain rotation sample](http://go.microsoft.com/fwlink/p/?linkid=257600)), we defined a specific transformation matrix for each possible screen orientation."},{"content":"Now, let's look at the matrixes for rotating 3-D scenes.","pos":[28503,28559]},{"content":"As before, you create a set of matrices for each of the 4 possible orientations.","pos":[28560,28640]},{"content":"To prevent rounding errors and thus minor visual artifacts, declare the matrices explicitly in your code.","pos":[28641,28746]},{"content":"You set up these 3-D rotation matrices as follows.","pos":[28748,28798]},{"content":"The matrices shown in the following code example are standard rotation matrices for 0, 90, 180, and 270 degree rotations of the vertices that define points in the camera's 3-D scene space.","pos":[28799,28987]},{"content":"Each vertex's \\[x, y, z\\] coordinate value in the scene is multiplied by this rotation matrix when the 2-D projection of the scene is computed.","pos":[28988,29131]},{"pos":[29890,30056],"content":"You set the rotation type on the swap chain with a call to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1::SetRotation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</ept>, like this:","source":"You set the rotation type on the swap chain with a call to [**IDXGISwapChain1::SetRotation**](https://msdn.microsoft.com/library/windows/desktop/hh446801), like this:"},{"content":"Now, in your render method, implement some code similar to this:","pos":[30100,30164]},{"content":"Now, when you call your render method, it multiplies the current rotation matrix (as specified by the class variable <bpt id=\"p1\">**</bpt>m\\_orientationTransform3D<ept id=\"p1\">**</ept>) with the current projection matrix, and assigns the results of that operation as the new projection matrix for your renderer.","pos":[30651,30924],"source":"Now, when you call your render method, it multiplies the current rotation matrix (as specified by the class variable **m\\_orientationTransform3D**) with the current projection matrix, and assigns the results of that operation as the new projection matrix for your renderer."},{"content":"Present the swap chain to see the scene in the updated display orientation.","pos":[30925,31000]}],"content":"---\ntitle: Supporting screen orientation (DirectX and C++)\ndescription: Here, we'll discuss best practices for handling screen rotation in your UWP DirectX app, so that the Windows 10 device's graphics hardware are used efficiently and effectively.\nms.assetid: f23818a6-e372-735d-912b-89cabeddb6d4\n---\n\n# Supporting screen orientation (DirectX and C++)\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nYour Universal Windows Platform (UWP) app can support multiple screen orientations when you handle the [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268) event. Here, we'll discuss best practices for handling screen rotation in your UWP DirectX app, so that the Windows 10 device's graphics hardware are used efficiently and effectively.\n\nBefore you start, remember that graphics hardware always outputs pixel data in the same way, regardless of the orientation of the device. Windows 10 devices can determine their current display orientation (with some sort of sensor, or with a software toggle) and allow users to change the display settings. Because of this, Windows 10 itself handles the rotation of the images to ensure they are \"upright\" based on the orientation of the device. By default, your app receives the notification that something has changed in orientation, for example, a window size. When this happens, Windows 10 immediately rotates the image for final display. For three of the four specific screen orientations (discussed later), Windows 10 uses additional graphic resources and computation to display the final image.\n\nFor UWP DirectX apps, the [**DisplayInformation**](https://msdn.microsoft.com/library/windows/apps/dn264258) object provides basic display orientation data that your app can query. The default orientation is *landscape*, where the pixel width of the display is greater than the height; the alternative orientation is *portrait*, where the display is rotated 90 degrees in either direction and the width becomes less than the height.\n\nWindows 10 defines four specific display orientation modes:\n\n-   Landscape—the default display orientation for Windows 10, and is considered the base or identity angle for rotation (0 degrees).\n-   Portrait—the display has been rotated clockwise 90 degrees (or counter-clockwise 270 degrees).\n-   Landscape, flipped—the display has been rotated 180 degrees (turned upside-down).\n-   Portrait, flipped—the display has been rotated clockwise 270 degrees (or counter-clockwise 90 degrees).\n\nWhen the display rotates from one orientation to another, Windows 10 internally performs a rotation operation to align the drawn image with the new orientation, and the user sees an upright image on the screen.\n\nAlso, Windows 10 displays automatic transition animations to create a smooth user experience when shifting from one orientation to another. As the display orientation shifts, the user sees these shifts as a fixed zoom and rotation animation of the displayed screen image. Time is allocated by Windows 10 to the app for layout in the new orientation.\n\nOverall, this is the general process for handling changes in screen orientation:\n\n1.  Use a combination of the window bounds values and the display orientation data to keep the swap chain aligned with the native display orientation of the device.\n2.  Notify Windows 10 of the orientation of the swap chain using [**IDXGISwapChain1::SetRotation**](https://msdn.microsoft.com/library/windows/desktop/hh446801).\n3.  Change the rendering code to generate images aligned with the user orientation of the device.\n\n## Resizing the swap chain and pre-rotating its contents\n\n\nTo perform a basic display resize and pre-rotate its contents in your UWP DirectX app , implement these steps:\n\n1.  Handle the [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268) event.\n2.  Resize the swap chain to the new dimensions of the window.\n3.  Call [**IDXGISwapChain1::SetRotation**](https://msdn.microsoft.com/library/windows/desktop/hh446801) to set the orientation of the swap chain.\n4.  Recreate any window size dependent resources, such as your render targets and other pixel data buffers.\n\nNow's let's look at those steps in a bit more detail.\n\nYour first step is to register a handler for the [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268) event. This event is raised in your app every time the screen orientation changes, such as when the display is rotated.\n\nTo handle the [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268) event, you connect your handler for **DisplayInformation::OrientationChanged** in the required [**SetWindow**](https://msdn.microsoft.com/library/windows/apps/hh700509) method, which is one of the methods of the [**IFrameworkView**](https://msdn.microsoft.com/library/windows/apps/hh700478) interface that your view provider must implement.\n\nIn this code example, the event handler for [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268) is a method called **OnOrientationChanged**. When **DisplayInformation::OrientationChanged** is raised, it in turn calls a method called **SetCurrentOrientation** which then calls **CreateWindowSizeDependentResources**.\n\n```cpp\nvoid App::SetWindow(CoreWindow^ window)\n{\n  // ... Other UI event handlers assigned here ...\n  \n    currentDisplayInformation->OrientationChanged +=\n        ref new TypedEventHandler<DisplayInformation^, Object^>(this, &App::OnOrientationChanged);\n\n  // ...\n}\n}\n```\n\n```cpp\nvoid App::OnOrientationChanged(DisplayInformation^ sender, Object^ args)\n{\n    m_deviceResources->SetCurrentOrientation(sender->CurrentOrientation);\n    m_main->CreateWindowSizeDependentResources();\n}\n\n// This method is called in the event handler for the OrientationChanged event.\nvoid DX::DeviceResources::SetCurrentOrientation(DisplayOrientations currentOrientation)\n{\n    if (m_currentOrientation != currentOrientation)\n    {\n        m_currentOrientation = currentOrientation;\n        CreateWindowSizeDependentResources();\n    }\n}\n```\n\nNext, you resize the swap chain for the new screen orientation and prepare it to rotate the contents of the graphic pipeline when the rendering is performed. In this example, **DirectXBase::CreateWindowSizeDependentResources** is a method that handles calling IDXGISwapChain::ResizeBuffers, setting a 3D and a 2D rotation matrix, calling SetRotation, and recreating your resources.\n\n```cpp\nvoid DX::DeviceResources::CreateWindowSizeDependentResources() \n{\n    // Clear the previous window size specific context.\n    ID3D11RenderTargetView* nullViews[] = {nullptr};\n    m_d3dContext->OMSetRenderTargets(ARRAYSIZE(nullViews), nullViews, nullptr);\n    m_d3dRenderTargetView = nullptr;\n    m_d2dContext->SetTarget(nullptr);\n    m_d2dTargetBitmap = nullptr;\n    m_d3dDepthStencilView = nullptr;\n    m_d3dContext->Flush();\n\n    // Calculate the necessary render target size in pixels.\n    m_outputSize.Width = DX::ConvertDipsToPixels(m_logicalSize.Width, m_dpi);\n    m_outputSize.Height = DX::ConvertDipsToPixels(m_logicalSize.Height, m_dpi);\n    \n    // Prevent zero size DirectX content from being created.\n    m_outputSize.Width = max(m_outputSize.Width, 1);\n    m_outputSize.Height = max(m_outputSize.Height, 1);\n\n    // The width and height of the swap chain must be based on the window's\n    // natively-oriented width and height. If the window is not in the native\n    // orientation, the dimensions must be reversed.\n    DXGI_MODE_ROTATION displayRotation = ComputeDisplayRotation();\n\n    bool swapDimensions = displayRotation == DXGI_MODE_ROTATION_ROTATE90 || displayRotation == DXGI_MODE_ROTATION_ROTATE270;\n    m_d3dRenderTargetSize.Width = swapDimensions ? m_outputSize.Height : m_outputSize.Width;\n    m_d3dRenderTargetSize.Height = swapDimensions ? m_outputSize.Width : m_outputSize.Height;\n\n    if (m_swapChain != nullptr)\n    {\n        // If the swap chain already exists, resize it.\n        HRESULT hr = m_swapChain->ResizeBuffers(\n            2, // Double-buffered swap chain.\n            lround(m_d3dRenderTargetSize.Width),\n            lround(m_d3dRenderTargetSize.Height),\n            DXGI_FORMAT_B8G8R8A8_UNORM,\n            0\n            );\n\n        if (hr == DXGI_ERROR_DEVICE_REMOVED || hr == DXGI_ERROR_DEVICE_RESET)\n        {\n            // If the device was removed for any reason, a new device and swap chain will need to be created.\n            HandleDeviceLost();\n\n            // Everything is set up now. Do not continue execution of this method. HandleDeviceLost will reenter this method \n            // and correctly set up the new device.\n            return;\n        }\n        else\n        {\n            DX::ThrowIfFailed(hr);\n        }\n    }\n    else\n    {\n        // Otherwise, create a new one using the same adapter as the existing Direct3D device.\n        DXGI_SWAP_CHAIN_DESC1 swapChainDesc = {0};\n\n        swapChainDesc.Width = lround(m_d3dRenderTargetSize.Width); // Match the size of the window.\n        swapChainDesc.Height = lround(m_d3dRenderTargetSize.Height);\n        swapChainDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM; // This is the most common swap chain format.\n        swapChainDesc.Stereo = false;\n        swapChainDesc.SampleDesc.Count = 1; // Don't use multi-sampling.\n        swapChainDesc.SampleDesc.Quality = 0;\n        swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\n        swapChainDesc.BufferCount = 2; // Use double-buffering to minimize latency.\n        swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL; // All Windows Store apps must use this SwapEffect.\n        swapChainDesc.Flags = 0;    \n        swapChainDesc.Scaling = DXGI_SCALING_NONE;\n        swapChainDesc.AlphaMode = DXGI_ALPHA_MODE_IGNORE;\n\n        // This sequence obtains the DXGI factory that was used to create the Direct3D device above.\n        ComPtr<IDXGIDevice3> dxgiDevice;\n        DX::ThrowIfFailed(\n            m_d3dDevice.As(&dxgiDevice)\n            );\n\n        ComPtr<IDXGIAdapter> dxgiAdapter;\n        DX::ThrowIfFailed(\n            dxgiDevice->GetAdapter(&dxgiAdapter)\n            );\n\n        ComPtr<IDXGIFactory2> dxgiFactory;\n        DX::ThrowIfFailed(\n            dxgiAdapter->GetParent(IID_PPV_ARGS(&dxgiFactory))\n            );\n\n        DX::ThrowIfFailed(\n            dxgiFactory->CreateSwapChainForCoreWindow(\n                m_d3dDevice.Get(),\n                reinterpret_cast<IUnknown*>(m_window.Get()),\n                &swapChainDesc,\n                nullptr,\n                &m_swapChain\n                )\n            );\n\n        // Ensure that DXGI does not queue more than one frame at a time. This both reduces latency and\n        // ensures that the application will only render after each VSync, minimizing power consumption.\n        DX::ThrowIfFailed(\n            dxgiDevice->SetMaximumFrameLatency(1)\n            );\n    }\n\n    // Set the proper orientation for the swap chain, and generate 2D and\n    // 3D matrix transformations for rendering to the rotated swap chain.\n    // Note the rotation angle for the 2D and 3D transforms are different.\n    // This is due to the difference in coordinate spaces.  Additionally,\n    // the 3D matrix is specified explicitly to avoid rounding errors.\n\n    switch (displayRotation)\n    {\n    case DXGI_MODE_ROTATION_IDENTITY:\n        m_orientationTransform2D = Matrix3x2F::Identity();\n        m_orientationTransform3D = ScreenRotation::Rotation0;\n        break;\n\n    case DXGI_MODE_ROTATION_ROTATE90:\n        m_orientationTransform2D = \n            Matrix3x2F::Rotation(90.0f) *\n            Matrix3x2F::Translation(m_logicalSize.Height, 0.0f);\n        m_orientationTransform3D = ScreenRotation::Rotation270;\n        break;\n\n    case DXGI_MODE_ROTATION_ROTATE180:\n        m_orientationTransform2D = \n            Matrix3x2F::Rotation(180.0f) *\n            Matrix3x2F::Translation(m_logicalSize.Width, m_logicalSize.Height);\n        m_orientationTransform3D = ScreenRotation::Rotation180;\n        break;\n\n    case DXGI_MODE_ROTATION_ROTATE270:\n        m_orientationTransform2D = \n            Matrix3x2F::Rotation(270.0f) *\n            Matrix3x2F::Translation(0.0f, m_logicalSize.Width);\n        m_orientationTransform3D = ScreenRotation::Rotation90;\n        break;\n\n    default:\n        throw ref new FailureException();\n    }\n\n\n    //SDM: only instance of SetRotation\n    DX::ThrowIfFailed(\n        m_swapChain->SetRotation(displayRotation)\n        );\n\n    // Create a render target view of the swap chain back buffer.\n    ComPtr<ID3D11Texture2D> backBuffer;\n    DX::ThrowIfFailed(\n        m_swapChain->GetBuffer(0, IID_PPV_ARGS(&backBuffer))\n        );\n\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateRenderTargetView(\n            backBuffer.Get(),\n            nullptr,\n            &m_d3dRenderTargetView\n            )\n        );\n\n    // Create a depth stencil view for use with 3D rendering if needed.\n    CD3D11_TEXTURE2D_DESC depthStencilDesc(\n        DXGI_FORMAT_D24_UNORM_S8_UINT, \n        lround(m_d3dRenderTargetSize.Width),\n        lround(m_d3dRenderTargetSize.Height),\n        1, // This depth stencil view has only one texture.\n        1, // Use a single mipmap level.\n        D3D11_BIND_DEPTH_STENCIL\n        );\n\n    ComPtr<ID3D11Texture2D> depthStencil;\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateTexture2D(\n            &depthStencilDesc,\n            nullptr,\n            &depthStencil\n            )\n        );\n\n    CD3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc(D3D11_DSV_DIMENSION_TEXTURE2D);\n    DX::ThrowIfFailed(\n        m_d3dDevice->CreateDepthStencilView(\n            depthStencil.Get(),\n            &depthStencilViewDesc,\n            &m_d3dDepthStencilView\n            )\n        );\n    \n    // Set the 3D rendering viewport to target the entire window.\n    m_screenViewport = CD3D11_VIEWPORT(\n        0.0f,\n        0.0f,\n        m_d3dRenderTargetSize.Width,\n        m_d3dRenderTargetSize.Height\n        );\n\n    m_d3dContext->RSSetViewports(1, &m_screenViewport);\n\n    // Create a Direct2D target bitmap associated with the\n    // swap chain back buffer and set it as the current target.\n    D2D1_BITMAP_PROPERTIES1 bitmapProperties = \n        D2D1::BitmapProperties1(\n            D2D1_BITMAP_OPTIONS_TARGET | D2D1_BITMAP_OPTIONS_CANNOT_DRAW,\n            D2D1::PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED),\n            m_dpi,\n            m_dpi\n            );\n\n    ComPtr<IDXGISurface2> dxgiBackBuffer;\n    DX::ThrowIfFailed(\n        m_swapChain->GetBuffer(0, IID_PPV_ARGS(&dxgiBackBuffer))\n        );\n\n    DX::ThrowIfFailed(\n        m_d2dContext->CreateBitmapFromDxgiSurface(\n            dxgiBackBuffer.Get(),\n            &bitmapProperties,\n            &m_d2dTargetBitmap\n            )\n        );\n\n    m_d2dContext->SetTarget(m_d2dTargetBitmap.Get());\n\n    // Grayscale text anti-aliasing is recommended for all Windows Store apps.\n    m_d2dContext->SetTextAntialiasMode(D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE);\n\n}\n\n```\n\nAfter saving the current height and width values of the window for the next time this method is called, convert the device independent pixel (DIP) values for the display bounds to pixels. In the sample, you call **ConvertDipsToPixels**, which is a simple function that runs this code:\n\n` floor((dips * dpi / 96.0f) + 0.5f);`\n\nYou add the 0.5f to ensure rounding to the nearest integer value.\n\nAs an aside, [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) coordinates are always defined in DIPs. For Windows 10 and earlier versions of Windows, a DIP is defined as 1/96th of an inch, and aligned to the OS's definition of *up*. When the display orientation rotates to portrait mode, the app flips the width and height of the **CoreWindow**, and the render target size (bounds) must change accordingly. Because Direct3D’s coordinates are always in physical pixels, you must convert from **CoreWindow**'s DIP values to integer pixel values before you pass these values to Direct3D to set up the swap chain.\n\nProcess-wise, you're doing a bit more work than you would if you simply resized the swap chain: you're actually rotating the Direct2D and Direct3D components of your image before you composite them for presentation, and you're telling the swap chain that you've rendered the results in a new orientation. Here's a little more detail on this process, as shown in the code example for **DX::DeviceResources::CreateWindowSizeDependentResources**:\n\n-   Determine the new orientation of the display. If the display has flipped from landscape to portrait, or vice versa, swap the height and width values—changed from DIP values to pixels, of course—for the display bounds.\n\n-   Then, check to see if the swap chain has been created. If it hasn't been created, create it by calling [**IDXGIFactory2::CreateSwapChainForCoreWindow**](https://msdn.microsoft.com/library/windows/desktop/hh404559). Otherwise, resize the existing swap chain's buffers to the new display dimensions by calling [**IDXGISwapchain:ResizeBuffers**](https://msdn.microsoft.com/library/windows/desktop/bb174577). Although you don't need to resize the swap chain for the rotation event—you're outputting the content already rotated by your rendering pipeline, after all—there are other size change events, such as snap and fill events, that require resizing.\n\n-   After that, set the appropriate 2-D or 3-D matrix transformation to apply to the pixels or the vertices (respectively) in the graphics pipeline when rendering them to the swap chain. We have 4 possible rotation matrices:\n\n    -   landscape (DXGI\\_MODE\\_ROTATION\\_IDENTITY)\n    -   portrait (DXGI\\_MODE\\_ROTATION\\_ROTATE270)\n    -   landscape, flipped (DXGI\\_MODE\\_ROTATION\\_ROTATE180)\n    -   portrait, flipped (DXGI\\_MODE\\_ROTATION\\_ROTATE90)\n\n    The correct matrix is selected based on the data provided by Windows 10 (such as the results of [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268)) for determining display orientation, and it will be multiplied by the coordinates of each pixel (Direct2D) or vertex (Direct3D) in the scene, effectively rotating them to align to the orientation of the screen. (Note that in Direct2D, the screen origin is defined as the upper-left corner, while in Direct3D the origin is defined as the logical center of the window.)\n\n> **Note**   For more info about the 2-D transformations used for rotation and how to define them, see [Defining matrices for screen rotation (2-D)](#defining_matrices_2d). For more info about the 3-D transformations used for rotation, see [Defining matrices for screen rotation (3-D)](#defining_matrices_3d).\n\n \n\nNow, here's the important bit: call [**IDXGISwapChain1::SetRotation**](https://msdn.microsoft.com/library/windows/desktop/hh446801) and provide it with your updated rotation matrix, like this:\n\n`m_swapChain->SetRotation(rotation);`\n\nYou also store the selected rotation matrix where your render method can get it when it computes the new projection. You'll use this matrix when you render your final 3-D projection or composite your final 2-D layout. (It doesn't automatically apply it for you.)\n\nAfter that, create a new render target for the rotated 3-D view, as well as a new depth stencil buffer for the view. Set the 3-D rendering viewport for the rotated scene by calling [**ID3D11DeviceContext:RSSetViewports**](https://msdn.microsoft.com/library/windows/desktop/ff476480).\n\nLastly, if you have 2-D images to rotate or lay out, create a 2-D render target as a writable bitmap for the resized swap chain using [**ID2D1DeviceContext::CreateBitmapFromDxgiSurface**](https://msdn.microsoft.com/library/windows/desktop/hh404482) and composite your new layout for the updated orientation. Set any properties you need to on the render target, such as the anti-aliasing mode (as seen in the code example).\n\nNow, present the swap chain.\n\n## Reduce the rotation delay by using CoreWindowResizeManager\n\n\nBy default, Windows 10 provides a short but noticeable window of time for any app, regardless of app model or language, to complete the rotation of the image. However, chances are that when your app performs the rotation calculation using one of the techniques described here, it will be done well before this window of time has closed. You'd like to get that time back and complete the rotation animation, right? That's where [**CoreWindowResizeManager**](https://msdn.microsoft.com/library/windows/apps/jj215603) comes in.\n\nHere's how to use [**CoreWindowResizeManager**](https://msdn.microsoft.com/library/windows/apps/jj215603): when a [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268) event is raised, call [**CoreWindowResizeManager::GetForCurrentView**](https://msdn.microsoft.com/library/windows/apps/hh404170) within the handler for the event to obtain an instance of **CoreWindowResizeManager** and, when the layout for the new orientation is complete and presented, call the [**NotifyLayoutCompleted**](https://msdn.microsoft.com/library/windows/apps/jj215605) to let Windows know that it can complete the rotation animation and display the app screen.\n\nHere's what the code in your event handler for [**DisplayInformation::OrientationChanged**](https://msdn.microsoft.com/library/windows/apps/dn264268) might look like:\n\n```cpp\nCoreWindowResizeManager^ resizeManager = Windows::UI::Core::CoreWindowResizeManager::GetForCurrentView();\n\n// ... build the layout for the new display orientation ...\n\nresizeManager->NotifyLayoutCompleted();\n```\n\nWhen a user rotates the orientation of the display, Windows 10 shows an animation independent of your app as feedback to the user. There are three parts to that animation that happen in the following order:\n\n-   Windows 10 shrinks the original image.\n-   Windows 10 holds the image for the time it takes to rebuild the new layout. This is the window of time that you'd like to reduce, because your app probably doesn't need all of it.\n-   When the layout window expires, or when a notification of layout completion is received, Windows rotates the image and then cross-fade zooms to new orientation.\n\nAs suggested in the third bullet, when an app calls [**NotifyLayoutCompleted**](https://msdn.microsoft.com/library/windows/apps/jj215605), Windows 10 stops the timeout window, completes the rotation animation and returns control to your app, which is now drawing in the new display orientation. The overall effect is that your app now feels a little bit more fluid and responsive, and works a little more efficiently!\n\n## Appendix A: Applying matrices for screen rotation (2-D)\n\n\nIn the sample in [Optimizing the rotation process](#rotation) (and in the [DXGI swap chain rotation sample](http://go.microsoft.com/fwlink/p/?linkid=257600)), you might have noticed that we had separate rotation matrices for Direct2D output and Direct3D output. Let's look at the 2-D matrices, first.\n\nThere are two reasons that we can't apply the same rotation matrices to Direct2D and Direct3D content:\n\n-   One, they use different Cartesian coordinate models. Direct2D uses the right-handed rule, where the y-coordinate increases in positive value moving upward from the origin. However, Direct3D uses the left-handed rule, where the y-coordinate increases in positive value rightward from the origin. The result is the origin for the screen coordinates is located in the upper-left for Direct2D, while the origin for the screen (the projection plane) is in the lower-left for Direct3D. (See [3-D coordinate systems](https://msdn.microsoft.com/library/windows/apps/bb324490.aspx) for more info.)\n\n    ![direct3d coordinate system.](images/direct3d-origin.png)![direct2d coordinate system.](images/direct2d-origin.png)\n\n-   Two, the 3-D rotation matrices must be specified explicitly to avoid rounding errors.\n\nThe swap chain assumes that the origin is located in the lower-left, so you must perform a rotation to align the right-handed Direct2D coordinate system with the left-handed one used by the swap chain. Specifically, you reposition the image under the new left-handed orientation by multiplying the rotation matrix with a translation matrix for the rotated coordinate system origin, and transform the image from the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225)'s coordinate space to the swap chain's coordinate space. Your app also must consistently apply this transform when the Direct2D render target is connected with the swap chain. However, if your app is drawing to intermediate surfaces that are not associated directly with the swap chain, don't apply this coordinate space transformation.\n\nYour code to select the correct matrix from the four possible rotations might look like this (be aware of the translation to the new coordinate system origin):\n\n```cpp\n   \n// Set the proper orientation for the swap chain, and generate 2D and\n// 3D matrix transformations for rendering to the rotated swap chain.\n// Note the rotation angle for the 2D and 3D transforms are different.\n// This is due to the difference in coordinate spaces.  Additionally,\n// the 3D matrix is specified explicitly to avoid rounding errors.\n\nswitch (displayRotation)\n{\ncase DXGI_MODE_ROTATION_IDENTITY:\n    m_orientationTransform2D = Matrix3x2F::Identity();\n    m_orientationTransform3D = ScreenRotation::Rotation0;\n    break;\n\ncase DXGI_MODE_ROTATION_ROTATE90:\n    m_orientationTransform2D = \n        Matrix3x2F::Rotation(90.0f) *\n        Matrix3x2F::Translation(m_logicalSize.Height, 0.0f);\n    m_orientationTransform3D = ScreenRotation::Rotation270;\n    break;\n\ncase DXGI_MODE_ROTATION_ROTATE180:\n    m_orientationTransform2D = \n        Matrix3x2F::Rotation(180.0f) *\n        Matrix3x2F::Translation(m_logicalSize.Width, m_logicalSize.Height);\n    m_orientationTransform3D = ScreenRotation::Rotation180;\n    break;\n\ncase DXGI_MODE_ROTATION_ROTATE270:\n    m_orientationTransform2D = \n        Matrix3x2F::Rotation(270.0f) *\n        Matrix3x2F::Translation(0.0f, m_logicalSize.Width);\n    m_orientationTransform3D = ScreenRotation::Rotation90;\n    break;\n\ndefault:\n    throw ref new FailureException();\n}\n    \n```\n\nAfter you have the correct rotation matrix and origin for the 2-D image, set it with a call to [**ID2D1DeviceContext::SetTransform**](https://msdn.microsoft.com/library/windows/desktop/dd742857) between your calls to [**ID2D1DeviceContext::BeginDraw**](https://msdn.microsoft.com/library/windows/desktop/dd371768) and [**ID2D1DeviceContext::EndDraw**](https://msdn.microsoft.com/library/windows/desktop/dd371924).\n\n**Warning**   Direct2D doesn't have a transformation stack. If your app is also using the [**ID2D1DeviceContext::SetTransform**](https://msdn.microsoft.com/library/windows/desktop/dd742857) as a part of its drawing code, this matrix needs to be post-multiplied to any other transform you have applied.\n\n \n\n```cpp\n    ID2D1DeviceContext* context = m_deviceResources->GetD2DDeviceContext();\n    Windows::Foundation::Size logicalSize = m_deviceResources->GetLogicalSize();\n\n    context->SaveDrawingState(m_stateBlock.Get());\n    context->BeginDraw();\n\n    // Position on the bottom right corner.\n    D2D1::Matrix3x2F screenTranslation = D2D1::Matrix3x2F::Translation(\n        logicalSize.Width - m_textMetrics.layoutWidth,\n        logicalSize.Height - m_textMetrics.height\n        );\n\n    context->SetTransform(screenTranslation * m_deviceResources->GetOrientationTransform2D());\n\n    DX::ThrowIfFailed(\n        m_textFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_TRAILING)\n        );\n\n    context->DrawTextLayout(\n        D2D1::Point2F(0.f, 0.f),\n        m_textLayout.Get(),\n        m_whiteBrush.Get()\n        );\n\n    // Ignore D2DERR_RECREATE_TARGET here. This error indicates that the device\n    // is lost. It will be handled during the next call to Present.\n    HRESULT hr = context->EndDraw();\n```\n\nThe next time you present the swap chain, your 2-D image will be rotated to match the new display orientation.\n\n## Appendix B: Applying matrices for screen rotation (3-D)\n\n\nIn the sample in [Optimizing the rotation process](#rotation) (and in the [DXGI swap chain rotation sample](http://go.microsoft.com/fwlink/p/?linkid=257600)), we defined a specific transformation matrix for each possible screen orientation. Now, let's look at the matrixes for rotating 3-D scenes. As before, you create a set of matrices for each of the 4 possible orientations. To prevent rounding errors and thus minor visual artifacts, declare the matrices explicitly in your code.\n\nYou set up these 3-D rotation matrices as follows. The matrices shown in the following code example are standard rotation matrices for 0, 90, 180, and 270 degree rotations of the vertices that define points in the camera's 3-D scene space. Each vertex's \\[x, y, z\\] coordinate value in the scene is multiplied by this rotation matrix when the 2-D projection of the scene is computed.\n\n```cpp\n   \n// 0-degree Z-rotation\nstatic const XMFLOAT4X4 Rotation0( \n    1.0f, 0.0f, 0.0f, 0.0f,\n    0.0f, 1.0f, 0.0f, 0.0f,\n    0.0f, 0.0f, 1.0f, 0.0f,\n    0.0f, 0.0f, 0.0f, 1.0f\n    );\n\n// 90-degree Z-rotation\nstatic const XMFLOAT4X4 Rotation90(\n    0.0f, 1.0f, 0.0f, 0.0f,\n    -1.0f, 0.0f, 0.0f, 0.0f,\n    0.0f, 0.0f, 1.0f, 0.0f,\n    0.0f, 0.0f, 0.0f, 1.0f\n    );\n\n// 180-degree Z-rotation\nstatic const XMFLOAT4X4 Rotation180(\n    -1.0f, 0.0f, 0.0f, 0.0f,\n    0.0f, -1.0f, 0.0f, 0.0f,\n    0.0f, 0.0f, 1.0f, 0.0f,\n    0.0f, 0.0f, 0.0f, 1.0f\n    );\n\n// 270-degree Z-rotation\nstatic const XMFLOAT4X4 Rotation270( \n    0.0f, -1.0f, 0.0f, 0.0f,\n    1.0f, 0.0f, 0.0f, 0.0f,\n    0.0f, 0.0f, 1.0f, 0.0f,\n    0.0f, 0.0f, 0.0f, 1.0f\n    );            \n    }\n```\n\nYou set the rotation type on the swap chain with a call to [**IDXGISwapChain1::SetRotation**](https://msdn.microsoft.com/library/windows/desktop/hh446801), like this:\n\n`   m_swapChain->SetRotation(rotation);`\n\nNow, in your render method, implement some code similar to this:\n\n``` syntax\nstruct ConstantBuffer // This struct is provided for illustration.\n{\n    // Other constant buffer matrices and data are defined here.\n\n    float4x4 projection; // Current matrix for projection\n} ;\nConstantBuffer  m_constantBufferData;          // Constant buffer resource data\n\n// ...\n\n// Rotate the projection matrix as it will be used to render to the rotated swap chain.\nm_constantBufferData.projection = mul(m_constantBufferData.projection, m_rotationTransform3D);\n```\n\nNow, when you call your render method, it multiplies the current rotation matrix (as specified by the class variable **m\\_orientationTransform3D**) with the current projection matrix, and assigns the results of that operation as the new projection matrix for your renderer. Present the swap chain to see the scene in the updated display orientation.\n\n \n\n \n\n\n\n\n"}