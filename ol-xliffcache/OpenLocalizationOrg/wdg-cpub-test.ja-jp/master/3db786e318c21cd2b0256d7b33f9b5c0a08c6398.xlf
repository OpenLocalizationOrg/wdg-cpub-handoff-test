<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="ja-jp" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-00ddeee</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">3db786e318c21cd2b0256d7b33f9b5c0a08c6398</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\debug-test-perf\optimize-gridview-and-listview.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">955f2e473e26b686b3e762f86adf9d2e4deda5e0</mda:meta><mda:meta type="olxliffhash">3fd92504ef1bb3aa8f07787a1ddc5b6f5e1d0941</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>ListView and GridView UI optimization</source>
					<target>ListView and GridView UI optimization</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Improve ListView and GridView performance and startup time through UI virtualization, element reduction, and progressive updating of items.</source>
					<target>Improve ListView and GridView performance and startup time through UI virtualization, element reduction, and progressive updating of items.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>ListView and GridView UI optimization</source>
					<target>ListView and GridView UI optimization</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Note</source>
					<target>Note</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://channel9.msdn.com/events/build/2013/3-158)</data>
				</originalData>
				<segment state="initial">
					<source>For more details, see the //build/ session <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dramatically Increase Performance when Users Interact with Large Amounts of Data in GridView and ListView</pc>.</source>
					<target>For more details, see the //build/ session <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dramatically Increase Performance when Users Interact with Large Amounts of Data in GridView and ListView</pc>.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242705)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Improve <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> performance and startup time through UI virtualization, element reduction, and progressive updating of items.</source>
					<target>Improve <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> performance and startup time through UI virtualization, element reduction, and progressive updating of items.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](listview-and-gridview-data-optimization.md)</data>
				</originalData>
				<segment state="initial">
					<source>For data virtualization techniques, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView and GridView data virtualization</pc>.</source>
					<target>For data virtualization techniques, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView and GridView data virtualization</pc>.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>Two key factors in collection performance</source>
					<target>Two key factors in collection performance</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>Manipulating collections is a common scenario.</source>
					<target>Manipulating collections is a common scenario.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>A photo viewer has collections of photos, a reader has collections of articles/books/stories, and a shopping app has collections of products.</source>
					<target>A photo viewer has collections of photos, a reader has collections of articles/books/stories, and a shopping app has collections of products.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>This topic shows what you can do to make your app efficient at manipulating collections.</source>
					<target>This topic shows what you can do to make your app efficient at manipulating collections.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>There are two key factors in performance when it comes to collections: one is the time spent by the UI thread creating items; the other is the memory used by both the raw data set and the UI elements used to render that data.</source>
					<target>There are two key factors in performance when it comes to collections: one is the time spent by the UI thread creating items; the other is the memory used by both the raw data set and the UI elements used to render that data.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>For smooth panning/scrolling, it's vital that the UI thread do an efficient and smart job of instantiating, data-binding, and laying out items.</source>
					<target>For smooth panning/scrolling, it's vital that the UI thread do an efficient and smart job of instantiating, data-binding, and laying out items.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>UI virtualization</source>
					<target>UI virtualization</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>UI virtualization is the most important improvement you can make.</source>
					<target>UI virtualization is the most important improvement you can make.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>This means that UI elements representing the items are created on demand.</source>
					<target>This means that UI elements representing the items are created on demand.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>For an items control bound to a 1000-item collection, it would be a waste of resources to create the UI for all the items at the same time, because they can't all be displayed at the same time.</source>
					<target>For an items control bound to a 1000-item collection, it would be a waste of resources to create the UI for all the items at the same time, because they can't all be displayed at the same time.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242705)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242803)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> (and other standard <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ItemsControl</pc></pc>-derived controls) perform UI virtualization for you.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> (and other standard <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ItemsControl</pc></pc>-derived controls) perform UI virtualization for you.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>When items are close to being scrolled into view (a few pages away), the framework generates the UI for the items and caches them.</source>
					<target>When items are close to being scrolled into view (a few pages away), the framework generates the UI for the items and caches them.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>When it's unlikely that the items will be shown again, the framework re-claims the memory.</source>
					<target>When it's unlikely that the items will be shown again, the framework re-claims the memory.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242803-itemspanel)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/Dn298849)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/Dn298795)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>If you provide a custom items panel template (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsPanel</pc></pc>) then make sure you use a virtualizing panel such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ItemsWrapGrid</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ItemsStackPanel</pc></pc>.</source>
					<target>If you provide a custom items panel template (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsPanel</pc></pc>) then make sure you use a virtualizing panel such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ItemsWrapGrid</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ItemsStackPanel</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227651)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR227717)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR209635)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>If you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VariableSizedWrapGrid</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">WrapGrid</pc></pc>, or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">StackPanel</pc></pc>, then you will not get virtualization.</source>
					<target>If you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VariableSizedWrapGrid</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">WrapGrid</pc></pc>, or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">StackPanel</pc></pc>, then you will not get virtualization.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>The concept of a viewport is critical to UI virtualization because the framework must create the elements that are likely to be shown.</source>
					<target>The concept of a viewport is critical to UI virtualization because the framework must create the elements that are likely to be shown.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242803)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In general, the viewport of an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsControl</pc></pc> is the extent of the logical control.</source>
					<target>In general, the viewport of an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsControl</pc></pc> is the extent of the logical control.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, the viewport of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> is the width and height of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ListView</pc> element.</source>
					<target>For example, the viewport of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> is the width and height of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ListView</pc> element.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209527)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242704)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Some panels allow child elements unlimited space, examples being <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollViewer</pc></pc> and a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Grid</pc></pc>, with auto-sized rows or columns.</source>
					<target>Some panels allow child elements unlimited space, examples being <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollViewer</pc></pc> and a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Grid</pc></pc>, with auto-sized rows or columns.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When a virtualized <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ItemsControl</pc> is placed in a panel like that, it takes enough room to display all of its items, which defeats virtualization.</source>
					<target>When a virtualized <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ItemsControl</pc> is placed in a panel like that, it takes enough room to display all of its items, which defeats virtualization.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Restore virtualization by setting a width and height on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ItemsControl</pc>.</source>
					<target>Restore virtualization by setting a width and height on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ItemsControl</pc>.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Element reduction per item</source>
					<target>Element reduction per item</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Keep the number of UI elements used to render your items to a reasonable minimum.</source>
					<target>Keep the number of UI elements used to render your items to a reasonable minimum.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>When an items control is first shown, all the elements needed to render a viewport full of items are created.</source>
					<target>When an items control is first shown, all the elements needed to render a viewport full of items are created.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Also, as items approach the viewport, the framework updates the UI elements in cached item templates with the bound data objects.</source>
					<target>Also, as items approach the viewport, the framework updates the UI elements in cached item templates with the bound data objects.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>Minimizing the complexity of the markup inside templates pays off in memory and in time spent on the UI thread, improving responsiveness especially while panning/scrolling.</source>
					<target>Minimizing the complexity of the markup inside templates pays off in memory and in time spent on the UI thread, improving responsiveness especially while panning/scrolling.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242803-itemtemplate)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242878item)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242705item)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR242803-itemcontainerstyle)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>The templates in question are the item template (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemTemplate</pc></pc>) and the control template of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ListViewItem</pc></pc> or a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">GridViewItem</pc></pc> (the item control template, or <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">ItemContainerStyle</pc></pc>).</source>
					<target>The templates in question are the item template (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemTemplate</pc></pc>) and the control template of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ListViewItem</pc></pc> or a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">GridViewItem</pc></pc> (the item control template, or <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">ItemContainerStyle</pc></pc>).</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>The benefit of even a small reduction in element count is multiplied by the number of items displayed.</source>
					<target>The benefit of even a small reduction in element count is multiplied by the number of items displayed.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](optimize-xaml-loading.md)</data>
				</originalData>
				<segment state="initial">
					<source>For examples of element reduction, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optimize your XAML markup</pc>.</source>
					<target>For examples of element reduction, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optimize your XAML markup</pc>.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878item)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242705item)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/Dn298500)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/Dn279298)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>The default control templates for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListViewItem</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridViewItem</pc></pc> contain a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ListViewItemPresenter</pc></pc> and a <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">GridViewItemPresenter</pc></pc> element, respectively.</source>
					<target>The default control templates for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListViewItem</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridViewItem</pc></pc> contain a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ListViewItemPresenter</pc></pc> and a <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">GridViewItemPresenter</pc></pc> element, respectively.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Each of these presenters is a single optimized element that displays complex visuals for focus, selection, and other visual states.</source>
					<target>Each of these presenters is a single optimized element that displays complex visuals for focus, selection, and other visual states.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242803-itemcontainerstyle)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>If you already have custom item control templates (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemContainerStyle</pc></pc>), or if in future you edit a copy of an item control template, then we recommend you use a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ListViewItemPresenter</pc> or a <pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridViewItemPresenter</pc> because those elements will give you optimum balance between performance and customizability in the majority of cases.</source>
					<target>If you already have custom item control templates (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemContainerStyle</pc></pc>), or if in future you edit a copy of an item control template, then we recommend you use a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ListViewItemPresenter</pc> or a <pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridViewItemPresenter</pc> because those elements will give you optimum balance between performance and customizability in the majority of cases.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>You customize these presenters by setting properties on them.</source>
					<target>You customize these presenters by setting properties on them.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>For example, here's markup that removes the check mark that appears by default when an item is selected, and changes the background color of the selected item to orange.</source>
					<target>For example, here's markup that removes the check mark that appears by default when an item is selected, and changes the background color of the selected item to orange.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn298500-selectioncheckmarkvisualenabled)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/Dn298500-selectedbackground)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>There are about 25 properties with self-describing names similar to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SelectionCheckMarkVisualEnabled</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SelectedBackground</pc></pc>.</source>
					<target>There are about 25 properties with self-describing names similar to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SelectionCheckMarkVisualEnabled</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SelectedBackground</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">`ListViewItemExpanded`</data>
					<data id="id2">`GridViewItemExpanded`</data>
				</originalData>
				<segment state="initial">
					<source>Should the presenter types prove not to be customizable enough for your use case, you can edit a copy of the <ph dataRef="id1" id="ph1" /> or <ph dataRef="id2" id="ph2" /> control template instead.</source>
					<target>Should the presenter types prove not to be customizable enough for your use case, you can edit a copy of the <ph dataRef="id1" id="ph1" /> or <ph dataRef="id2" id="ph2" /> control template instead.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">`\Program Files (x86)\Windows Kits\10\DesignTime\CommonConfiguration\Neutral\UAP\&lt;version&gt;\Generic\generic.xaml`</data>
				</originalData>
				<segment state="initial">
					<source>These can be found in <ph dataRef="id1" id="ph1" />.</source>
					<target>These can be found in <ph dataRef="id1" id="ph1" />.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Be aware that using these templates means trading some performance for the increase in customization.</source>
					<target>Be aware that using these templates means trading some performance for the increase in customization.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Update ListView and GridView items progressively</source>
					<target>Update ListView and GridView items progressively</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242705)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>If you're using data virtualization then you can keep <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> responsiveness high by configuring the control to render temporary UI elements for the items still being (down)loaded.</source>
					<target>If you're using data virtualization then you can keep <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> responsiveness high by configuring the control to render temporary UI elements for the items still being (down)loaded.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>The temporary elements are then progressively replaced with actual UI as data loads.</source>
					<target>The temporary elements are then progressively replaced with actual UI as data loads.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242705)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Also—no matter where you're loading data from (local disk, network, or cloud)—a user can pan/scroll a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> so rapidly that it's not possible to render each item with full fidelity while preserving smooth panning/scrolling.</source>
					<target>Also—no matter where you're loading data from (local disk, network, or cloud)—a user can pan/scroll a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> so rapidly that it's not possible to render each item with full fidelity while preserving smooth panning/scrolling.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>To preserve smooth panning/scrolling you can choose to render an item in multiple phases in addition to using placeholders.</source>
					<target>To preserve smooth panning/scrolling you can choose to render an item in multiple phases in addition to using placeholders.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>An example of these techniques is often seen in photo-viewing apps: even though not all of the images have been loaded and displayed, the user can still pan/scroll and interact with the collection.</source>
					<target>An example of these techniques is often seen in photo-viewing apps: even though not all of the images have been loaded and displayed, the user can still pan/scroll and interact with the collection.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Or, for a "movie" item, you could show the title in the first phase, the rating in the second phase, and an image of the poster in the third phase.</source>
					<target>Or, for a "movie" item, you could show the title in the first phase, the rating in the second phase, and an image of the poster in the third phase.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>The user sees the most important data about each item as early as possible, and that means they're able to take action at once.</source>
					<target>The user sees the most important data about each item as early as possible, and that means they're able to take action at once.</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Then the less important info is filled-in as time allows.</source>
					<target>Then the less important info is filled-in as time allows.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>Here are the platform features you can use to implement these techniques.</source>
					<target>Here are the platform features you can use to implement these techniques.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>Placeholders</source>
					<target>Placeholders</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-showsscrollingplaceholders)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The temporary placeholder visuals feature is on by default, and it's controlled with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ShowsScrollingPlaceholders</pc></pc> property.</source>
					<target>The temporary placeholder visuals feature is on by default, and it's controlled with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ShowsScrollingPlaceholders</pc></pc> property.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>During fast panning/scrolling, this feature gives the user a visual hint that there are more items yet to fully display while also preserving smoothness.</source>
					<target>During fast panning/scrolling, this feature gives the user a visual hint that there are more items yet to fully display while also preserving smoothness.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If you use one of the techniques below then you can set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ShowsScrollingPlaceholders</pc> to false if you prefer not to have the system render placeholders.</source>
					<target>If you use one of the techniques below then you can set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ShowsScrollingPlaceholders</pc> to false if you prefer not to have the system render placeholders.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>Progressive data template updates using x:Phase</source>
					<target>Progressive data template updates using x:Phase</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204790)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
				</originalData>
				<segment state="initial">
					<source>Here's how to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase attribute</pc> with <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{x:Bind}</pc> bindings to implement progressive data template updates.</source>
					<target>Here's how to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase attribute</pc> with <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{x:Bind}</pc> bindings to implement progressive data template updates.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>Here's what the binding source looks like (this is the data source that we'll bind to).</source>
					<target>Here's what the binding source looks like (this is the data source that we'll bind to).</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">`DeferMainPage.xaml`</data>
				</originalData>
				<segment state="initial">
					<source>Here's the markup that <ph dataRef="id1" id="ph1" /> contains.</source>
					<target>Here's the markup that <ph dataRef="id1" id="ph1" /> contains.</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The grid view contains an item template with elements bound to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Title</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Subtitle</pc>, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Description</pc> properties of the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">MyItem</pc> class.</source>
					<target>The grid view contains an item template with elements bound to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Title</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Subtitle</pc>, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Description</pc> properties of the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">MyItem</pc> class.</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Note that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase</pc> defaults to 0.</source>
					<target>Note that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase</pc> defaults to 0.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>Here, items will be initially rendered with just the title visible.</source>
					<target>Here, items will be initially rendered with just the title visible.</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>Then the subtitle element will be data bound and made visible for all the items and so on until all the phases have been processed.</source>
					<target>Then the subtitle element will be data bound and made visible for all the items and so on until all the phases have been processed.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-showsscrollingplaceholders)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>If you run the app now and pan/scroll quickly through the grid view then you'll notice that as each new item appears on the screen, at first it is rendered as a dark gray rectangle (thanks to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ShowsScrollingPlaceholders</pc></pc> property defaulting to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">true</pc>), then the title appears, followed by subtitle, followed by description.</source>
					<target>If you run the app now and pan/scroll quickly through the grid view then you'll notice that as each new item appears on the screen, at first it is rendered as a dark gray rectangle (thanks to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ShowsScrollingPlaceholders</pc></pc> property defaulting to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">true</pc>), then the title appears, followed by subtitle, followed by description.</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>Progressive data template updates using ContainerContentChanging</source>
					<target>Progressive data template updates using ContainerContentChanging</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The general strategy for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContainerContentChanging</pc></pc> event is to use <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Opacity</pc> to hide elements that don’t need to be immediately visible.</source>
					<target>The general strategy for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContainerContentChanging</pc></pc> event is to use <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Opacity</pc> to hide elements that don’t need to be immediately visible.</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>When elements are recycled, they will retain their old values so we want to hide those elements until we've updated those values from the new data item.</source>
					<target>When elements are recycled, they will retain their old values so we want to hide those elements until we've updated those values from the new data item.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>We use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Phase</pc> property on the event arguments to determine which elements to update and show.</source>
					<target>We use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Phase</pc> property on the event arguments to determine which elements to update and show.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>If additional phases are needed, we register a callback.</source>
					<target>If additional phases are needed, we register a callback.</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>We'll use the same binding source as for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase</pc>.</source>
					<target>We'll use the same binding source as for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase</pc>.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<originalData>
					<data id="id1">`MainPage.xaml`</data>
				</originalData>
				<segment state="initial">
					<source>Here's the markup that <ph dataRef="id1" id="ph1" /> contains.</source>
					<target>Here's the markup that <ph dataRef="id1" id="ph1" /> contains.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>The grid view declares a handler to its <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContainerContentChanging</pc></pc> event, and it contains an item template with elements used to display the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Title</pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Subtitle</pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Description</pc> properties of the <pc dataRefEnd="id12" dataRefStart="id11" id="p6">MyItem</pc> class.</source>
					<target>The grid view declares a handler to its <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContainerContentChanging</pc></pc> event, and it contains an item template with elements used to display the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Title</pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Subtitle</pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Description</pc> properties of the <pc dataRefEnd="id12" dataRefStart="id11" id="p6">MyItem</pc> class.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>To get the maximum performance benefits of using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ContainerContentChanging</pc>, we don't use bindings in the markup but we instead assign values programmatically.</source>
					<target>To get the maximum performance benefits of using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ContainerContentChanging</pc>, we don't use bindings in the markup but we instead assign values programmatically.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>The exception here is the element displaying the title, which we consider to be in phase 0.</source>
					<target>The exception here is the element displaying the title, which we consider to be in phase 0.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Lastly, here's the implementation of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContainerContentChanging</pc></pc> event handler.</source>
					<target>Lastly, here's the implementation of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContainerContentChanging</pc></pc> event handler.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This code also shows how we add a property of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RecordingViewModel</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MainPage</pc> to expose the binding source class from the class that represents our page of markup.</source>
					<target>This code also shows how we add a property of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RecordingViewModel</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MainPage</pc> to expose the binding source class from the class that represents our page of markup.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
				</originalData>
				<segment state="initial">
					<source>As long as you don't have any <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc> bindings in your data template, then mark the event arguments object as handled in the first phase of the handler to hint to the item that it needn't set a data context.</source>
					<target>As long as you don't have any <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc> bindings in your data template, then mark the event arguments object as handled in the first phase of the handler to hint to the item that it needn't set a data context.</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If you run the app now and pan/scroll quickly through the grid view then you'll see the same behavior as for as for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase</pc>.</source>
					<target>If you run the app now and pan/scroll quickly through the grid view then you'll see the same behavior as for as for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase</pc>.</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>Container-recycling with heterogeneous collections</source>
					<target>Container-recycling with heterogeneous collections</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>In some applications, you need to have different UI for different types of item within a collection.</source>
					<target>In some applications, you need to have different UI for different types of item within a collection.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>This can create a situation where it is impossible for virtualizing panels to reuse/recycle the visual elements used to display the items.</source>
					<target>This can create a situation where it is impossible for virtualizing panels to reuse/recycle the visual elements used to display the items.</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Recreating the visual elements for an item during panning undoes many of the performance wins provided by virtualization.</source>
					<target>Recreating the visual elements for an item during panning undoes many of the performance wins provided by virtualization.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>However, a little planning can allow virtualizing panels to reuse the elements.</source>
					<target>However, a little planning can allow virtualizing panels to reuse the elements.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Developers have a couple of options depending on their scenario: the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingItemContainer</pc></pc> event, or an item template selector.</source>
					<target>Developers have a couple of options depending on their scenario: the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingItemContainer</pc></pc> event, or an item template selector.</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChoosingItemContainer</pc> event is the most performant approach.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChoosingItemContainer</pc> event is the most performant approach.</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>The ChoosingItemContainer event</source>
					<target>The ChoosingItemContainer event</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242878item)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">/</data>
					<data id="id10">[</data>
					<data id="id11">](https://msdn.microsoft.com/library/windows/apps/BR242705item)</data>
					<data id="id12">**</data>
					<data id="id13">**</data>
					<data id="id14">[</data>
					<data id="id15">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
					<data id="id16">**</data>
					<data id="id17">**</data>
					<data id="id18">/</data>
					<data id="id19">[</data>
					<data id="id20">](https://msdn.microsoft.com/library/windows/apps/BR242705)</data>
					<data id="id21">**</data>
					<data id="id22">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingItemContainer</pc></pc> is an event that allows you to provide an item (<pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ListViewItem</pc></pc><ph dataRef="id9" id="ph1" /><pc dataRefEnd="id11" dataRefStart="id10" id="p5"><pc dataRefEnd="id13" dataRefStart="id12" id="p6">GridViewItem</pc></pc>) to the <pc dataRefEnd="id15" dataRefStart="id14" id="p7"><pc dataRefEnd="id17" dataRefStart="id16" id="p8">ListView</pc></pc><ph dataRef="id18" id="ph2" /><pc dataRefEnd="id20" dataRefStart="id19" id="p9"><pc dataRefEnd="id22" dataRefStart="id21" id="p10">GridView</pc></pc> whenever a new item is needed during start-up or recycling.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingItemContainer</pc></pc> is an event that allows you to provide an item (<pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ListViewItem</pc></pc><ph dataRef="id9" id="ph1" /><pc dataRefEnd="id11" dataRefStart="id10" id="p5"><pc dataRefEnd="id13" dataRefStart="id12" id="p6">GridViewItem</pc></pc>) to the <pc dataRefEnd="id15" dataRefStart="id14" id="p7"><pc dataRefEnd="id17" dataRefStart="id16" id="p8">ListView</pc></pc><ph dataRef="id18" id="ph2" /><pc dataRefEnd="id20" dataRefStart="id19" id="p9"><pc dataRefEnd="id22" dataRefStart="id21" id="p10">GridView</pc></pc> whenever a new item is needed during start-up or recycling.</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>You can create a container based on the type of data item the container will display (shown in the example below).</source>
					<target>You can create a container based on the type of data item the container will display (shown in the example below).</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChoosingItemContainer</pc> is the most performant way to use different data templates for different items.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChoosingItemContainer</pc> is the most performant way to use different data templates for different items.</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Container caching is something that can be achieved using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChoosingItemContainer</pc>.</source>
					<target>Container caching is something that can be achieved using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChoosingItemContainer</pc>.</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>For example, if you have five different template, with one template occurring an order of magnitude more often than the others, then ChoosingItemContainer allows you not only to create items at the ratios needed but also to keep an appropriate number of elements cached and available for recycling.</source>
					<target>For example, if you have five different template, with one template occurring an order of magnitude more often than the others, then ChoosingItemContainer allows you not only to create items at the ratios needed but also to keep an appropriate number of elements cached and available for recycling.</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosinggroupheadercontainer)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingGroupHeaderContainer</pc></pc> provides the same functionality for group headers.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingGroupHeaderContainer</pc></pc> provides the same functionality for group headers.</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>Item template selector</source>
					<target>Item template selector</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209469)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>An item template selector (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataTemplateSelector</pc></pc>) allows an app to return a different item template at runtime based on the type of the data item that will be displayed.</source>
					<target>An item template selector (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataTemplateSelector</pc></pc>) allows an app to return a different item template at runtime based on the type of the data item that will be displayed.</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>This makes development more productive, but it makes UI virtualization more difficult because not every item template can be reused for every data item.</source>
					<target>This makes development more productive, but it makes UI virtualization more difficult because not every item template can be reused for every data item.</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878item)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">/</data>
					<data id="id6">[</data>
					<data id="id7">](https://msdn.microsoft.com/library/windows/apps/BR242705item)</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
				</originalData>
				<segment state="initial">
					<source>When recycling an item (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListViewItem</pc></pc><ph dataRef="id5" id="ph1" /><pc dataRefEnd="id7" dataRefStart="id6" id="p3"><pc dataRefEnd="id9" dataRefStart="id8" id="p4">GridViewItem</pc></pc>), the framework must decide whether the items that are available for use in the recycle queue (the recycle queue is a cache of items that are not currently being used to display data) have an item template that will match the one desired by the current data item.</source>
					<target>When recycling an item (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListViewItem</pc></pc><ph dataRef="id5" id="ph1" /><pc dataRefEnd="id7" dataRefStart="id6" id="p3"><pc dataRefEnd="id9" dataRefStart="id8" id="p4">GridViewItem</pc></pc>), the framework must decide whether the items that are available for use in the recycle queue (the recycle queue is a cache of items that are not currently being used to display data) have an item template that will match the one desired by the current data item.</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>If there are no items in the recycle queue with the appropriate item template then a new item is created, and the appropriate item template is instantiated for it.</source>
					<target>If there are no items in the recycle queue with the appropriate item template then a new item is created, and the appropriate item template is instantiated for it.</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>If, on other hand, the recycle queue contains an item with the appropriate item template then that item is removed from the recycle queue and is used for the current data item.</source>
					<target>If, on other hand, the recycle queue contains an item with the appropriate item template then that item is removed from the recycle queue and is used for the current data item.</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>An item template selector works in situations where only a small number of item templates are used and there is a flat distribution throughout the collection of items that use different item templates.</source>
					<target>An item template selector works in situations where only a small number of item templates are used and there is a flat distribution throughout the collection of items that use different item templates.</target>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>When there is an uneven distribution of items that use different item templates then new item templates will likely need to be created during panning, and this negates many of the gains provided by virtualization.</source>
					<target>When there is an uneven distribution of items that use different item templates then new item templates will likely need to be created during panning, and this negates many of the gains provided by virtualization.</target>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>Additionally, an item template selector only considers five possible candidates when evaluating whether a particular container can be reused for the current data item.</source>
					<target>Additionally, an item template selector only considers five possible candidates when evaluating whether a particular container can be reused for the current data item.</target>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>So you should carefully consider whether your data is appropriate for use with an item template selector before using one in your app.</source>
					<target>So you should carefully consider whether your data is appropriate for use with an item template selector before using one in your app.</target>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>If your collection is mostly homogeneous then the selector is returning the same type most (possibly all) of the time.</source>
					<target>If your collection is mostly homogeneous then the selector is returning the same type most (possibly all) of the time.</target>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Just be aware of the price you're paying for the rare exceptions to that homegeneity, and consider whether using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingItemContainer</pc></pc> (or two items controls) is preferable.</source>
					<target>Just be aware of the price you're paying for the rare exceptions to that homegeneity, and consider whether using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingItemContainer</pc></pc> (or two items controls) is preferable.</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>