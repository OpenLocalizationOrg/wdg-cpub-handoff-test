{"nodes":[{"pos":[11,31],"content":"Add a user interface","needQuote":true,"needEscape":true,"nodes":[{"content":"Add a user interface","pos":[0,20]}]},{"pos":[45,150],"content":"You've seen how the sample game implements the main game object as well as the basic rendering framework.","needQuote":true,"needEscape":true,"nodes":[{"content":"You've seen how the sample game implements the main game object as well as the basic rendering framework.","pos":[0,105]}]},{"content":"Add a user interface","pos":[207,227]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[230,268]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[269,364],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"You've seen how the sample game implements the main game object as well as the basic rendering framework.","pos":[366,471]},{"content":"Now, let's look at how the sample game provides feedback about game state to the player.","pos":[472,560]},{"content":"Here, you learn how you can add simple menu options and heads-up display components on top of the 3-D graphics pipeline output.","pos":[561,688]},{"content":"Objective","pos":[693,702]},{"content":"To add basic user interface graphics and behaviors to a Universal Windows Platform (UWP) DirectX game.","pos":[709,811]},{"content":"The user interface overlay","pos":[816,842]},{"pos":[845,1142],"content":"While there are many ways to display text and user interface elements in a DirectX game, we are going to focus on one, <bpt id=\"p1\">[</bpt>Direct2D<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dd370990.aspx)</ept> (with <bpt id=\"p2\">[</bpt>DirectWrite<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/dd368038)</ept> for the text elements).","source":"While there are many ways to display text and user interface elements in a DirectX game, we are going to focus on one, [Direct2D](https://msdn.microsoft.com/library/windows/apps/dd370990.aspx) (with [DirectWrite](https://msdn.microsoft.com/library/windows/desktop/dd368038) for the text elements)."},{"content":"First, let's be clear about what Direct2D is not.","pos":[1144,1193]},{"content":"It's not specifically designed for user interfaces or layouts, like HTML or XAML.","pos":[1194,1275]},{"content":"It doesn't provide user interface components, like list boxes or buttons; and it doesn't provide layout components like divs, tables, or grids.","pos":[1276,1419]},{"content":"Direct2D is a set of 2-D drawing APIs used to draw pixel-based primitives and effects.","pos":[1421,1507]},{"content":"When starting out with Direct2D, keep it simple.","pos":[1508,1556]},{"content":"Complex layouts and interface behaviors need time and planning.","pos":[1557,1620]},{"content":"If your game requires a complex user interface to play, like those found in simulation and strategy games, consider XAML instead.","pos":[1621,1750]},{"pos":[1752,1885],"content":"(For info about developing a user interface with XAML in a UWP DirectX game, see <bpt id=\"p1\">[</bpt>Extending the game sample<ept id=\"p1\">](tutorial-resources.md)</ept>.)","source":"(For info about developing a user interface with XAML in a UWP DirectX game, see [Extending the game sample](tutorial-resources.md).)"},{"content":"In this game sample, we have two major UI components: the heads-up display for the score and in-game controls; and an overlay used to display game state text and options (such as pause info and level start options).","pos":[1887,2102]},{"content":"Using Direct2D for a heads-up display","pos":[2108,2145]},{"content":"This is the in-game heads-up display for the game sample without the game visuals.","pos":[2147,2229]},{"content":"It's simple and uncluttered, allowing the player to focus on navigating the 3-D world and shooting the targets.","pos":[2230,2341]},{"content":"A good interface or heads-up display must never obfuscate the ability of the player to process and react to the events in the game.","pos":[2342,2473]},{"content":"a screen shot of the game overlay","pos":[2477,2510]},{"content":"As you can see, the overlay consists of basic primitives: two intersecting line segments for the cross hairs, and two rectangles for the <bpt id=\"p1\">[</bpt>move-look controller<ept id=\"p1\">](tutorial--adding-controls.md)</ept>.","pos":[2553,2743],"source":"As you can see, the overlay consists of basic primitives: two intersecting line segments for the cross hairs, and two rectangles for the [move-look controller](tutorial--adding-controls.md)."},{"content":"In the upper-right corner, DirectWrite text informs the player of the current number of successful hits, the number of shots the player has made, the time remaining in the level, and the current level number.","pos":[2744,2952]},{"content":"The in-game heads-up display state of the overlay is drawn in the <bpt id=\"p1\">**</bpt>Render<ept id=\"p1\">**</ept> method of the <bpt id=\"p2\">**</bpt>GameHud<ept id=\"p2\">**</ept> class, and is coded like this:","pos":[2953,3086],"source":" The in-game heads-up display state of the overlay is drawn in the **Render** method of the **GameHud** class, and is coded like this:"},{"content":"In this code, the Direct2D render target established for the overlay is updated to reflect the changes in the number of hits, the time remaining, and the level number.","pos":[7827,7994]},{"content":"The rectangles are drawn with calls to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DrawRect<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/dd371902)</ept>, and the cross hairs are drawn with a pair of calls to <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DrawLine<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/dd371895)</ept>.","pos":[7995,8241],"source":" The rectangles are drawn with calls to [**DrawRect**](https://msdn.microsoft.com/library/windows/desktop/dd371902), and the cross hairs are drawn with a pair of calls to [**DrawLine**](https://msdn.microsoft.com/library/windows/desktop/dd371895)."},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   You probably noticed the call to <bpt id=\"p2\">**</bpt>GameHud::Render<ept id=\"p2\">**</ept> takes a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Windows::Foundation::Rect<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br225994)</ept> parameter, which contains the size of the main window rectangle.","pos":[8245,8471],"source":"**Note**   You probably noticed the call to **GameHud::Render** takes a [**Windows::Foundation::Rect**](https://msdn.microsoft.com/library/windows/apps/br225994) parameter, which contains the size of the main window rectangle."},{"content":"This demonstrates an essential part of UI programming: obtaining the size of window in a measurement called DIPs (device independent pixels), where a DIP is defined as 1/96 of an inch.","pos":[8472,8656]},{"content":"Direct2D scales the drawing units to actual pixels when the drawing occurs, and it does so by using the Windows dots per inch (DPI) setting.","pos":[8657,8797]},{"content":"Similarly, when you draw text using DirectWrite, you specify DIPs rather than points for the size of the font.","pos":[8798,8908]},{"content":"DIPs are expressed as floating point numbers.","pos":[8909,8954]},{"content":"Displaying game state information with an overlay","pos":[8963,9012]},{"content":"Besides the heads-up display, the game sample has an overlay that represents five game states, and all of which feature a large black rectangle primitive with text for the player to read.","pos":[9014,9201]},{"content":"(Be aware that the move-look controller rectangles are not drawn, because they are not active in these states.) These overlay states are:","pos":[9202,9339]},{"content":"The game start overlay.","pos":[9345,9368]},{"content":"We show this when the player starts the game.","pos":[9369,9414]},{"content":"It contains the high score across game sessions.","pos":[9415,9463]},{"content":"a screen shot of the start screen for simple3dgamedx","pos":[9471,9523]},{"content":"The pause state.","pos":[9560,9576]},{"content":"a screen shot of the pause screen for simple3dgamedx","pos":[9584,9636]},{"content":"The level start state.","pos":[9682,9704]},{"content":"We show this when the player starts a new level.","pos":[9705,9753]},{"content":"a screen shot of the level start screen for simple3dgamedx","pos":[9761,9819]},{"content":"The game over state.","pos":[9867,9887]},{"content":"We show this when the player fails a level.","pos":[9888,9931]},{"content":"a screen shot of the game over screen for simple3dgamedx","pos":[9939,9995]},{"content":"The game stat display state.","pos":[10044,10072]},{"content":"We show this when the player wins.","pos":[10073,10107]},{"content":"It contains the final score the player has achieved.","pos":[10108,10160]},{"content":"the victory screen for simple3dgamedx","pos":[10168,10205]},{"content":"Let's look at how we initialize and draw the overlay for these five states.","pos":[10251,10326]},{"content":"Initializing and drawing the overlay","pos":[10332,10368]},{"content":"The five explicit states have some things in common: one, they all use a black rectangle in the center of the screen as their background; two, the displayed text is either title text or body text; and three, the text uses the Segoe UI font and is drawn on top of the back rectangle.","pos":[10370,10652]},{"content":"As a result, the resources they need and the methods that implement them are very similar.","pos":[10653,10743]},{"content":"The game sample has four methods( <bpt id=\"p1\">**</bpt>GameInfoOverlay::Initialize<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>GameInfoOverlay::SetDpi<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>GameInfoOverlay::RecreateDirectXResources<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>GameInfoOverlay::RecreateDpiDependentResources<ept id=\"p4\">**</ept>) that it uses to initialize, set the dots per inch, recreate the DirectWrite resources (the text elements), and construct this overlay for display, respectively.","pos":[10745,11104],"source":"The game sample has four methods( **GameInfoOverlay::Initialize**, **GameInfoOverlay::SetDpi**, **GameInfoOverlay::RecreateDirectXResources**, and **GameInfoOverlay::RecreateDpiDependentResources**) that it uses to initialize, set the dots per inch, recreate the DirectWrite resources (the text elements), and construct this overlay for display, respectively."},{"content":"This is the code for these four methods:","pos":[11105,11145]},{"content":"The <bpt id=\"p1\">**</bpt>Initialize<ept id=\"p1\">**</ept> method obtains a factory from the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID2D1Device<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/hh404478)</ept> object passed to it, which it uses to create an <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>ID2D1DeviceContext<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/desktop/hh404479)</ept> that the overlay object itself can draw into, and sets the <bpt id=\"p6\">**</bpt>m\\_dWriteFactory<ept id=\"p6\">**</ept> field to the provided <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>IDWriteFactory<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/desktop/dd368183)</ept> reference.","pos":[15504,15964],"source":"The **Initialize** method obtains a factory from the [**ID2D1Device**](https://msdn.microsoft.com/library/windows/desktop/hh404478) object passed to it, which it uses to create an [**ID2D1DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/hh404479) that the overlay object itself can draw into, and sets the **m\\_dWriteFactory** field to the provided [**IDWriteFactory**](https://msdn.microsoft.com/library/windows/desktop/dd368183) reference."},{"content":"It also sets the DPI for the context.","pos":[15965,16002]},{"content":"Then, it calls <bpt id=\"p1\">**</bpt>RecreateDeviceResources<ept id=\"p1\">**</ept> to assemble and draw the overlay.","pos":[16003,16079],"source":" Then, it calls **RecreateDeviceResources** to assemble and draw the overlay."},{"content":"<bpt id=\"p1\">**</bpt>RecreateDeviceResources<ept id=\"p1\">**</ept> uses the DirectWrite factory object to create formatters (brushes) for the title and body text strings that will be displayed on the overlay.","pos":[16081,16250],"source":"**RecreateDeviceResources** uses the DirectWrite factory object to create formatters (brushes) for the title and body text strings that will be displayed on the overlay."},{"content":"It creates a white brush to draw the text, a black brush to draw the background, and an orange brush to draw action messages.","pos":[16251,16376]},{"content":"Then, it calls <bpt id=\"p1\">**</bpt>RecreateDpiDependentResources<ept id=\"p1\">**</ept> to prepare a bitmap to draw the text on by calling <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID2D1DeviceContext::CreateBitmap<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/hh404480)</ept>.","pos":[16377,16577],"source":" Then, it calls **RecreateDpiDependentResources** to prepare a bitmap to draw the text on by calling [**ID2D1DeviceContext::CreateBitmap**](https://msdn.microsoft.com/library/windows/desktop/hh404480)."},{"content":"Lastly, <bpt id=\"p1\">**</bpt>RecreateDpiDependentResources<ept id=\"p1\">**</ept> sets the render target for the Direct2D device context to the bitmap and clears it, which then sets each pixel in the bitmap to the color black.","pos":[16578,16764],"source":" Lastly, **RecreateDpiDependentResources** sets the render target for the Direct2D device context to the bitmap and clears it, which then sets each pixel in the bitmap to the color black."},{"content":"Now, all the overlay needs is some text to display!","pos":[16766,16817]},{"content":"Representing game state in the overlay","pos":[16823,16861]},{"content":"Each of the five overlay states in the game sample has a corresponding method on the <bpt id=\"p1\">**</bpt>GameInfoOverlay<ept id=\"p1\">**</ept> object.","pos":[16863,16975],"source":"Each of the five overlay states in the game sample has a corresponding method on the **GameInfoOverlay** object."},{"content":"These methods draw a variation of the overlay to communicate explicit info to the player about the game itself.","pos":[16976,17087]},{"content":"This communication is, of course, represented as two strings: a title string, and a body string.","pos":[17088,17184]},{"content":"Because the sample already configured the resources and layout for this info in the <bpt id=\"p1\">**</bpt>RecreateDeviceResources<ept id=\"p1\">**</ept> method, it only needs to provide the overlay state-specific strings.","pos":[17185,17365],"source":" Because the sample already configured the resources and layout for this info in the **RecreateDeviceResources** method, it only needs to provide the overlay state-specific strings."},{"pos":[17367,17534],"content":"Now, in the definition of the <bpt id=\"p1\">**</bpt>GameInfoOverlay<ept id=\"p1\">**</ept> class, the sample declared three rectangular areas that correspond to specific regions of the overlay, as shown here:","source":"Now, in the definition of the **GameInfoOverlay** class, the sample declared three rectangular areas that correspond to specific regions of the overlay, as shown here:"},{"content":"These areas each have a specific purpose:","pos":[17999,18040]},{"pos":[18046,18098],"content":"<bpt id=\"p1\">**</bpt>titleRectangle<ept id=\"p1\">**</ept> is where the title text is drawn.","source":"**titleRectangle** is where the title text is drawn."},{"pos":[18103,18153],"content":"<bpt id=\"p1\">**</bpt>bodyRectangle<ept id=\"p1\">**</ept> is where the body text is drawn.","source":"**bodyRectangle** is where the body text is drawn."},{"content":"<bpt id=\"p1\">**</bpt>actionRectangle<ept id=\"p1\">**</ept> is where the text that informs the player to take a specific action is drawn.","pos":[18158,18255],"source":"**actionRectangle** is where the text that informs the player to take a specific action is drawn."},{"content":"(It's in the bottom left of the overlay bitmap.)","pos":[18256,18304]},{"pos":[18306,18449],"content":"With these areas in mind, let's look at one of the state-specific methods, <bpt id=\"p1\">**</bpt>GameInfoOverlay::SetGameStats<ept id=\"p1\">**</ept>, and see how the overlay is drawn.","source":"With these areas in mind, let's look at one of the state-specific methods, **GameInfoOverlay::SetGameStats**, and see how the overlay is drawn."},{"content":"Using the Direct2D device context that the <bpt id=\"p1\">**</bpt>GameInfoOverlay<ept id=\"p1\">**</ept> object initialized and configured using <bpt id=\"p2\">**</bpt>Initialize<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>RecreateDirectXResources<ept id=\"p3\">**</ept>, this method fills the title and body rectangles with black using the background brush.","pos":[20135,20373],"source":"Using the Direct2D device context that the **GameInfoOverlay** object initialized and configured using **Initialize** and **RecreateDirectXResources**, this method fills the title and body rectangles with black using the background brush."},{"content":"It draws the text for the \"High Score\" string to the title rectangle and a string containing the updates game state information to the body rectangle using the white text brush.","pos":[20374,20551]},{"pos":[20553,20816],"content":"The action rectangle is updated by a subsequent call to <bpt id=\"p1\">**</bpt>GameInfoOverlay::SetAction<ept id=\"p1\">**</ept> from a method on the <bpt id=\"p2\">**</bpt>DirectXApp<ept id=\"p2\">**</ept> object, which provides the game state info needed by <bpt id=\"p3\">**</bpt>SetAction<ept id=\"p3\">**</ept> to determine the right message to the player (such as \"Tap to continue\").","source":"The action rectangle is updated by a subsequent call to **GameInfoOverlay::SetAction** from a method on the **DirectXApp** object, which provides the game state info needed by **SetAction** to determine the right message to the player (such as \"Tap to continue\")."},{"pos":[20818,20926],"content":"The overlay for any given state is chosen in the <bpt id=\"p1\">**</bpt>SetGameInfoOverlay<ept id=\"p1\">**</ept> method on <bpt id=\"p2\">**</bpt>DirectXApp<ept id=\"p2\">**</ept>, like this:","source":"The overlay for any given state is chosen in the **SetGameInfoOverlay** method on **DirectXApp**, like this:"},{"content":"And now the game sample has a way to communicate text info to the player based on game state.","pos":[22445,22538]},{"content":"Next steps","pos":[22544,22554]},{"pos":[22556,22715],"content":"In the next topic, <bpt id=\"p1\">[</bpt>Adding controls<ept id=\"p1\">](tutorial--adding-controls.md)</ept>, we look at how the player interacts with the game sample, and how input changes game state.","source":"In the next topic, [Adding controls](tutorial--adding-controls.md), we look at how the player interacts with the game sample, and how input changes game state."},{"content":"Complete sample code for this section","pos":[22721,22758]},{"content":"GameHud.h","pos":[22760,22769]},{"content":"GameHud.cpp","pos":[24969,24980]},{"content":"GameInfoOverlay.h","pos":[37215,37232]},{"content":"GameInfoOverlay.cpp","pos":[39626,39645]},{"content":"Related topics","pos":[55959,55973]},{"content":"Create a simple UWP game with DirectX","pos":[55977,56014]}],"content":"---\ntitle: Add a user interface\ndescription: You've seen how the sample game implements the main game object as well as the basic rendering framework.\nms.assetid: fa40173e-6cde-b71b-e307-db90f0388485\n---\n\n# Add a user interface\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nYou've seen how the sample game implements the main game object as well as the basic rendering framework. Now, let's look at how the sample game provides feedback about game state to the player. Here, you learn how you can add simple menu options and heads-up display components on top of the 3-D graphics pipeline output.\n\n## Objective\n\n\n-   To add basic user interface graphics and behaviors to a Universal Windows Platform (UWP) DirectX game.\n\n## The user interface overlay\n\n\nWhile there are many ways to display text and user interface elements in a DirectX game, we are going to focus on one, [Direct2D](https://msdn.microsoft.com/library/windows/apps/dd370990.aspx) (with [DirectWrite](https://msdn.microsoft.com/library/windows/desktop/dd368038) for the text elements).\n\nFirst, let's be clear about what Direct2D is not. It's not specifically designed for user interfaces or layouts, like HTML or XAML. It doesn't provide user interface components, like list boxes or buttons; and it doesn't provide layout components like divs, tables, or grids.\n\nDirect2D is a set of 2-D drawing APIs used to draw pixel-based primitives and effects. When starting out with Direct2D, keep it simple. Complex layouts and interface behaviors need time and planning. If your game requires a complex user interface to play, like those found in simulation and strategy games, consider XAML instead.\n\n(For info about developing a user interface with XAML in a UWP DirectX game, see [Extending the game sample](tutorial-resources.md).)\n\nIn this game sample, we have two major UI components: the heads-up display for the score and in-game controls; and an overlay used to display game state text and options (such as pause info and level start options).\n\n### Using Direct2D for a heads-up display\n\nThis is the in-game heads-up display for the game sample without the game visuals. It's simple and uncluttered, allowing the player to focus on navigating the 3-D world and shooting the targets. A good interface or heads-up display must never obfuscate the ability of the player to process and react to the events in the game.\n\n![a screen shot of the game overlay](images/sample3dgame-overlay-nogame.png)\n\nAs you can see, the overlay consists of basic primitives: two intersecting line segments for the cross hairs, and two rectangles for the [move-look controller](tutorial--adding-controls.md). In the upper-right corner, DirectWrite text informs the player of the current number of successful hits, the number of shots the player has made, the time remaining in the level, and the current level number. The in-game heads-up display state of the overlay is drawn in the **Render** method of the **GameHud** class, and is coded like this:\n\n```cpp\nvoid GameHud::Render(\n    _In_ Simple3DGame^ game,\n    _In_ ID2D1DeviceContext* d2dContext,\n    _In_ Windows::Foundation::Rect windowBounds\n    )\n{\n    if (m_showTitle)\n    {\n        d2dContext->DrawBitmap(\n            m_logoBitmap.Get(),\n            D2D1::RectF(\n                GameConstants::Margin,\n                GameConstants::Margin,\n                m_logoSize.width + GameConstants::Margin,\n                m_logoSize.height + GameConstants::Margin\n                )\n            );\n        d2dContext->DrawTextLayout(\n            Point2F(m_logoSize.width + 2.0f * GameConstants::Margin, GameConstants::Margin),\n            m_titleHeaderLayout.Get(),\n            m_textBrush.Get()\n            );\n        d2dContext->DrawTextLayout(\n            Point2F(GameConstants::Margin, m_titleBodyVerticalOffset),\n            m_titleBodyLayout.Get(),\n            m_textBrush.Get()\n            );\n    }\n\n    if (game != nullptr)\n    {\n        // This section is only used after the game state has been initialized.\n        static const int bufferLength = 256;\n        static char16 wsbuffer[bufferLength];\n        int length = swprintf_s(\n            wsbuffer,\n            bufferLength,\n            L\"Hits:\\t%10d\\nShots:\\t%10d\\nTime:\\t%8.1f\",\n            game->TotalHits(),\n            game->TotalShots(),\n            game->TimeRemaining()\n            );\n\n        d2dContext->DrawText(\n            wsbuffer,\n            length,\n            m_textFormatBody.Get(),\n            D2D1::RectF(\n                windowBounds.Width - GameConstants::HudRightOffset,\n                GameConstants::HudTopOffset,\n                windowBounds.Width,\n                GameConstants::HudTopOffset + (GameConstants::HudBodyPointSize + GameConstants::Margin) * 3\n                ),\n            m_textBrush.Get()\n            );\n\n        // Using the unicode characters starting at 0x2780 ( ➀ ) for the consecutive levels of the game.\n        // For completed levels, start with 0x278A ( ➊ ) (This is 0x2780 + 10).\n        uint32 levelCharacter[6];\n        for (uint32 i = 0; i < 6; i++)\n        {\n            levelCharacter[i] = 0x2780 + i + ((static_cast<uint32>(game->LevelCompleted()) == i) ? 10 : 0);\n        }\n        length = swprintf_s(\n            wsbuffer,\n            bufferLength,\n            L\"%lc %lc %lc %lc %lc %lc\",\n            levelCharacter[0],\n            levelCharacter[1],\n            levelCharacter[2],\n            levelCharacter[3],\n            levelCharacter[4],\n            levelCharacter[5]\n            );\n        d2dContext->DrawText(\n            wsbuffer,\n            length,\n            m_textFormatBodySymbol.Get(),\n            D2D1::RectF(\n                windowBounds.Width - GameConstants::HudRightOffset,\n                GameConstants::HudTopOffset + (GameConstants::HudBodyPointSize + GameConstants::Margin) * 3 + GameConstants::Margin,\n                windowBounds.Width,\n                GameConstants::HudTopOffset + (GameConstants::HudBodyPointSize+ GameConstants::Margin) * 4\n                ),\n            m_textBrush.Get()\n            );\n\n        if (game->IsActivePlay())\n        {\n            // Draw a rectangle for the touch input for the move control.\n            d2dContext->DrawRectangle(\n                D2D1::RectF(\n                    0.0f,\n                    windowBounds.Height - GameConstants::TouchRectangleSize,\n                    GameConstants::TouchRectangleSize,\n                    windowBounds.Height\n                    ),\n                m_textBrush.Get()\n                );\n            // Draw a rectangle for the touch input for the fire control.\n            d2dContext->DrawRectangle(\n                D2D1::RectF(\n                    windowBounds.Width - GameConstants::TouchRectangleSize,\n                    windowBounds.Height - GameConstants::TouchRectangleSize,\n                    windowBounds.Width,\n                    windowBounds.Height\n                    ),\n                m_textBrush.Get()\n                );\n\n            // Draw the cross hairs.\n            d2dContext->DrawLine(\n                D2D1::Point2F(windowBounds.Width / 2.0f - GameConstants::CrossHairHalfSize, windowBounds.Height / 2.0f),\n                D2D1::Point2F(windowBounds.Width / 2.0f + GameConstants::CrossHairHalfSize, windowBounds.Height / 2.0f),\n                m_textBrush.Get(),\n                3.0f\n                );\n            d2dContext->DrawLine(\n                D2D1::Point2F(windowBounds.Width / 2.0f, windowBounds.Height / 2.0f - GameConstants::CrossHairHalfSize),\n                D2D1::Point2F(windowBounds.Width / 2.0f, windowBounds.Height / 2.0f + GameConstants::CrossHairHalfSize),\n                m_textBrush.Get(),\n                3.0f\n                );\n        }\n    }\n}\n```\n\nIn this code, the Direct2D render target established for the overlay is updated to reflect the changes in the number of hits, the time remaining, and the level number. The rectangles are drawn with calls to [**DrawRect**](https://msdn.microsoft.com/library/windows/desktop/dd371902), and the cross hairs are drawn with a pair of calls to [**DrawLine**](https://msdn.microsoft.com/library/windows/desktop/dd371895).\n\n> **Note**   You probably noticed the call to **GameHud::Render** takes a [**Windows::Foundation::Rect**](https://msdn.microsoft.com/library/windows/apps/br225994) parameter, which contains the size of the main window rectangle. This demonstrates an essential part of UI programming: obtaining the size of window in a measurement called DIPs (device independent pixels), where a DIP is defined as 1/96 of an inch. Direct2D scales the drawing units to actual pixels when the drawing occurs, and it does so by using the Windows dots per inch (DPI) setting. Similarly, when you draw text using DirectWrite, you specify DIPs rather than points for the size of the font. DIPs are expressed as floating point numbers.\n\n \n\n### Displaying game state information with an overlay\n\nBesides the heads-up display, the game sample has an overlay that represents five game states, and all of which feature a large black rectangle primitive with text for the player to read. (Be aware that the move-look controller rectangles are not drawn, because they are not active in these states.) These overlay states are:\n\n-   The game start overlay. We show this when the player starts the game. It contains the high score across game sessions.\n\n    ![a screen shot of the start screen for simple3dgamedx](images/simple3dgamestart.png)\n\n-   The pause state.\n\n    ![a screen shot of the pause screen for simple3dgamedx](images/simple3dgame-overlay-pause.png)\n\n-   The level start state. We show this when the player starts a new level.\n\n    ![a screen shot of the level start screen for simple3dgamedx](images/simple3dgame-overlay-newgame.png)\n\n-   The game over state. We show this when the player fails a level.\n\n    ![a screen shot of the game over screen for simple3dgamedx](images/simple3dgame-overlay-gameover.png)\n\n-   The game stat display state. We show this when the player wins. It contains the final score the player has achieved.\n\n    ![the victory screen for simple3dgamedx](images/simple3dgame-overlay-gamestats.png)\n\nLet's look at how we initialize and draw the overlay for these five states.\n\n### Initializing and drawing the overlay\n\nThe five explicit states have some things in common: one, they all use a black rectangle in the center of the screen as their background; two, the displayed text is either title text or body text; and three, the text uses the Segoe UI font and is drawn on top of the back rectangle. As a result, the resources they need and the methods that implement them are very similar.\n\nThe game sample has four methods( **GameInfoOverlay::Initialize**, **GameInfoOverlay::SetDpi**, **GameInfoOverlay::RecreateDirectXResources**, and **GameInfoOverlay::RecreateDpiDependentResources**) that it uses to initialize, set the dots per inch, recreate the DirectWrite resources (the text elements), and construct this overlay for display, respectively. This is the code for these four methods:\n\n```cpp\nvoid GameInfoOverlay::Initialize(\n    _In_ ID2D1Device*         d2dDevice,\n    _In_ ID2D1DeviceContext*  d2dContext,\n    _In_ IDWriteFactory*      dwriteFactory,\n    _In_ float                dpi)\n{\n    m_initialized = true;\n\n    m_dwriteFactory = dwriteFactory;\n    m_dpi = dpi;\n    m_d2dDevice = d2dDevice;\n    m_d2dContext = d2dContext;\n\n    ComPtr<ID2D1Factory> factory;\n    d2dDevice->GetFactory(&factory);\n\n    DX::ThrowIfFailed(\n        factory.As(&m_d2dFactory)\n        );\n\n    RecreateDirectXResources();\n}\n```\n\n```cpp\nvoid GameInfoOverlay::SetDpi(float dpi)\n{\n    if (m_initialized)\n    {\n        if (dpi != m_dpi)\n        {\n            m_dpi = dpi;\n            RecreateDpiDependentResources();\n        }\n    }\n}\n```\n\n```cpp\nvoid GameInfoOverlay::RecreateDirectXResources()\n{\n    if (!m_initialized)\n    {\n        return;\n    }\n\n    // Create D2D Resources.\n    DX::ThrowIfFailed(\n        m_dwriteFactory->CreateTextFormat(\n            L\"Segoe UI\",\n            nullptr,\n            DWRITE_FONT_WEIGHT_MEDIUM,\n            DWRITE_FONT_STYLE_NORMAL,\n            DWRITE_FONT_STRETCH_NORMAL,\n            32,         // font size\n            L\"en-us\",   // locale\n            &m_textFormatTitle\n            )\n        );\n\n    DX::ThrowIfFailed(\n        m_dwriteFactory->CreateTextFormat(\n            L\"Segoe UI\",\n            nullptr,\n            DWRITE_FONT_WEIGHT_LIGHT,\n            DWRITE_FONT_STYLE_NORMAL,\n            DWRITE_FONT_STRETCH_NORMAL,\n            24,         // font size\n            L\"en-us\",   // locale\n            &m_textFormatBody\n            )\n        );\n\n    DX::ThrowIfFailed(\n        m_textFormatTitle->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER)\n        );\n    DX::ThrowIfFailed(\n        m_textFormatTitle->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR)\n        );\n    DX::ThrowIfFailed(\n        m_textFormatBody->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING)\n        );\n    DX::ThrowIfFailed(\n        m_textFormatBody->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR)\n        );\n\n    DX::ThrowIfFailed(\n        m_d2dContext->CreateSolidColorBrush(\n            D2D1::ColorF(D2D1::ColorF::White),\n            &m_textBrush\n            )\n        );\n    DX::ThrowIfFailed(\n        m_d2dContext->CreateSolidColorBrush(\n            D2D1::ColorF(D2D1::ColorF::Black),\n            &m_backgroundBrush\n            )\n        );\n     DX::ThrowIfFailed(\n        m_d2dContext->CreateSolidColorBrush(\n            D2D1::ColorF(0xdb7100, 1.0f),\n            &m_actionBrush\n            )\n        );\n\n     RecreateDpiDependentResources();\n}\n```\n\n```cpp\nvoid GameInfoOverlay::RecreateDpiDependentResources()\n{\n    m_levelBitmap = nullptr;\n\n    // Create a D2D bitmap to be used for Game Info Overlay when waiting to\n    // start a level or to display game statistics.\n    D2D1_BITMAP_PROPERTIES1 properties;\n    properties.pixelFormat.format = DXGI_FORMAT_B8G8R8A8_UNORM;\n    properties.pixelFormat.alphaMode = D2D1_ALPHA_MODE_PREMULTIPLIED;\n    properties.dpiX = m_dpi;\n    properties.dpiY = m_dpi;\n    properties.bitmapOptions = D2D1_BITMAP_OPTIONS_TARGET;\n    properties.colorContext = nullptr;\n    DX::ThrowIfFailed(\n        m_d2dContext->CreateBitmap(\n            D2D1::SizeU(\n                static_cast<UINT32>(GameInfoOverlayConstant::Width * m_dpi / 96.0f),\n                static_cast<UINT32>(GameInfoOverlayConstant::Height * m_dpi / 96.0f)\n                ),\n            nullptr,\n            0,\n            &properties,\n            &m_levelBitmap\n            )\n        );\n    m_d2dContext->SetTarget(m_levelBitmap.Get());\n    m_d2dContext->BeginDraw();\n    m_d2dContext->SetTransform(D2D1::Matrix3x2F::Identity());\n    m_d2dContext->Clear(D2D1::ColorF(D2D1::ColorF::Black));\n    HRESULT hr = m_d2dContext->EndDraw();\n    if (hr != D2DERR_RECREATE_TARGET)\n    {\n        // The D2DERR_RECREATE_TARGET indicates there has been a problem with the underlying\n        // D3D device.  All subsequent rendering will be ignored until the device is recreated.\n        // This error will be propagated and the appropriate D3D error will be returned from the\n        // swapchain->Present(...) call.   At that point, the sample will recreate the device\n        // and all associated resources.  As a result, the D2DERR_RECREATE_TARGET doesn't\n        // need to be handled here.\n        DX::ThrowIfFailed(hr);\n    }\n}\n\n```\n\nThe **Initialize** method obtains a factory from the [**ID2D1Device**](https://msdn.microsoft.com/library/windows/desktop/hh404478) object passed to it, which it uses to create an [**ID2D1DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/hh404479) that the overlay object itself can draw into, and sets the **m\\_dWriteFactory** field to the provided [**IDWriteFactory**](https://msdn.microsoft.com/library/windows/desktop/dd368183) reference. It also sets the DPI for the context. Then, it calls **RecreateDeviceResources** to assemble and draw the overlay.\n\n**RecreateDeviceResources** uses the DirectWrite factory object to create formatters (brushes) for the title and body text strings that will be displayed on the overlay. It creates a white brush to draw the text, a black brush to draw the background, and an orange brush to draw action messages. Then, it calls **RecreateDpiDependentResources** to prepare a bitmap to draw the text on by calling [**ID2D1DeviceContext::CreateBitmap**](https://msdn.microsoft.com/library/windows/desktop/hh404480). Lastly, **RecreateDpiDependentResources** sets the render target for the Direct2D device context to the bitmap and clears it, which then sets each pixel in the bitmap to the color black.\n\nNow, all the overlay needs is some text to display!\n\n### Representing game state in the overlay\n\nEach of the five overlay states in the game sample has a corresponding method on the **GameInfoOverlay** object. These methods draw a variation of the overlay to communicate explicit info to the player about the game itself. This communication is, of course, represented as two strings: a title string, and a body string. Because the sample already configured the resources and layout for this info in the **RecreateDeviceResources** method, it only needs to provide the overlay state-specific strings.\n\nNow, in the definition of the **GameInfoOverlay** class, the sample declared three rectangular areas that correspond to specific regions of the overlay, as shown here:\n\n```cpp\nstatic const D2D1_RECT_F titleRectangle = D2D1::RectF(50.0f, 50.0f, GameInfoOverlayConstant::Width - 50.0f, 100.0f);\nstatic const D2D1_RECT_F bodyRectangle = D2D1::RectF(50.0f, 110.0f, GameInfoOverlayConstant::Width - 50.0f, GameInfoOverlayConstant::Height - 50.0f);\nstatic const D2D1_RECT_F actionRectangle = D2D1::RectF(50.0f, GameInfoOverlayConstant::Height - 45.0f, GameInfoOverlayConstant::Width - 50.0f, GameInfoOverlayConstant::Height - 5.0f);\n```\n\nThese areas each have a specific purpose:\n\n-   **titleRectangle** is where the title text is drawn.\n-   **bodyRectangle** is where the body text is drawn.\n-   **actionRectangle** is where the text that informs the player to take a specific action is drawn. (It's in the bottom left of the overlay bitmap.)\n\nWith these areas in mind, let's look at one of the state-specific methods, **GameInfoOverlay::SetGameStats**, and see how the overlay is drawn.\n\n```cpp\nvoid GameInfoOverlay::SetGameStats(int maxLevel, int hitCount, int shotCount)\n{\n    int length;\n    Platform::String^ string;\n\n    m_d2dContext->SetTarget(m_levelBitmap.Get());\n    m_d2dContext->BeginDraw();\n    m_d2dContext->SetTransform(D2D1::Matrix3x2F::Identity());\n    m_d2dContext->FillRectangle(&titleRectangle, m_backgroundBrush.Get());\n    m_d2dContext->FillRectangle(&bodyRectangle, m_backgroundBrush.Get());\n    string = \"High Score\";\n\n    m_d2dContext->DrawText(\n        string->Data(),\n        string->Length(),\n        m_textFormatTitle.Get(),\n        titleRectangle,\n        m_textBrush.Get()\n        );\n    length = swprintf_s(\n        wsbuffer,\n        bufferLength,\n        L\"Levels Completed %d\\nTotal Points %d\\nTotal Shots %d\",\n        maxLevel,\n        hitCount,\n        shotCount\n        );\n    string = ref new Platform::String(wsbuffer, length);\n    m_d2dContext->DrawText(\n        string->Data(),\n        string->Length(),\n        m_textFormatBody.Get(),\n        bodyRectangle,\n        m_textBrush.Get()\n        );\n    HRESULT hr = m_d2dContext->EndDraw();\n    if (hr != D2DERR_RECREATE_TARGET)\n    {\n        // The D2DERR_RECREATE_TARGET indicates there has been a problem with the underlying\n        // D3D device.  All subsequent rendering will be ignored until the device is recreated.\n        // This error will be propagated and the appropriate D3D error will be returned from the\n        // swapchain->Present(...) call.   At that point, the sample will recreate the device\n        // and all associated resources.  As a result, the D2DERR_RECREATE_TARGET doesn't\n        // need to be handled here.\n        DX::ThrowIfFailed(hr);\n    }\n}\n```\n\nUsing the Direct2D device context that the **GameInfoOverlay** object initialized and configured using **Initialize** and **RecreateDirectXResources**, this method fills the title and body rectangles with black using the background brush. It draws the text for the \"High Score\" string to the title rectangle and a string containing the updates game state information to the body rectangle using the white text brush.\n\nThe action rectangle is updated by a subsequent call to **GameInfoOverlay::SetAction** from a method on the **DirectXApp** object, which provides the game state info needed by **SetAction** to determine the right message to the player (such as \"Tap to continue\").\n\nThe overlay for any given state is chosen in the **SetGameInfoOverlay** method on **DirectXApp**, like this:\n\n```cpp\nvoid DirectXApp::SetGameInfoOverlay(GameInfoOverlayState state)\n{\n    m_gameInfoOverlayState = state;\n    switch (state)\n    {\n    case GameInfoOverlayState::Loading:\n        m_renderer->InfoOverlay()->SetGameLoading(m_loadingCount);\n        break;\n\n    case GameInfoOverlayState::GameStats:\n        m_renderer->InfoOverlay()->SetGameStats(\n            m_game->HighScore().levelCompleted + 1,\n            m_game->HighScore().totalHits,\n            m_game->HighScore().totalShots\n            );\n        break;\n\n    case GameInfoOverlayState::LevelStart:\n        m_renderer->InfoOverlay()->SetLevelStart(\n            m_game->LevelCompleted() + 1,\n            m_game->CurrentLevel()->Objective(),\n            m_game->CurrentLevel()->TimeLimit(),\n            m_game->BonusTime()\n            );\n        break;\n\n    case GameInfoOverlayState::GameOverCompleted:\n        m_renderer->InfoOverlay()->SetGameOver(\n            true,\n            m_game->LevelCompleted() + 1,\n            m_game->TotalHits(),\n            m_game->TotalShots(),\n            m_game->HighScore().totalHits\n            );\n        break;\n\n    case GameInfoOverlayState::GameOverExpired:\n        m_renderer->InfoOverlay()->SetGameOver(\n            false,\n            m_game->LevelCompleted(),\n            m_game->TotalHits(),\n            m_game->TotalShots(),\n            m_game->HighScore().totalHits\n            );\n        break;\n\n    case GameInfoOverlayState::Pause:\n        m_renderer->InfoOverlay()->SetPause();\n        break;\n    }\n}\n```\n\nAnd now the game sample has a way to communicate text info to the player based on game state.\n\n### Next steps\n\nIn the next topic, [Adding controls](tutorial--adding-controls.md), we look at how the player interacts with the game sample, and how input changes game state.\n\n### Complete sample code for this section\n\nGameHud.h\n\n```cpp\n//// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF\n//// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n//// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A\n//// PARTICULAR PURPOSE.\n////\n//// Copyright (c) Microsoft Corporation. All rights reserved\n\n#pragma once\n\n#include \"Simple3DGame.h\"\n#include \"DirectXSample.h\"\n\nref class Simple3DGame;\n\nref class GameHud\n{\ninternal:\n    GameHud(\n        _In_ Platform::String^ titleHeader,\n        _In_ Platform::String^ titleBody\n        );\n\n    void CreateDeviceIndependentResources(\n        _In_ IDWriteFactory* dwriteFactory,\n        _In_ IWICImagingFactory* wicFactory\n        );\n\n    void CreateDeviceResources(_In_ ID2D1DeviceContext* d2dContext);\n    void UpdateForWindowSizeChange(_In_ Windows::Foundation::Rect windowBounds);\n    void Render(\n        _In_ Simple3DGame^ game,\n        _In_ ID2D1DeviceContext* d2dContext,\n        _In_ Windows::Foundation::Rect windowBounds\n        );\n\nprivate:\n    Microsoft::WRL::ComPtr<IDWriteFactory>              m_dwriteFactory;\n    Microsoft::WRL::ComPtr<IWICImagingFactory>          m_wicFactory;\n\n    Microsoft::WRL::ComPtr<ID2D1SolidColorBrush>        m_textBrush;\n    Microsoft::WRL::ComPtr<IDWriteTextFormat>           m_textFormatBody;\n    Microsoft::WRL::ComPtr<IDWriteTextFormat>           m_textFormatBodySymbol;\n\n    Microsoft::WRL::ComPtr<IDWriteTextFormat>           m_textFormatTitleHeader;\n    Microsoft::WRL::ComPtr<IDWriteTextFormat>           m_textFormatTitleBody;\n    Microsoft::WRL::ComPtr<ID2D1Bitmap>                 m_logoBitmap;\n    Microsoft::WRL::ComPtr<IDWriteTextLayout>           m_titleHeaderLayout;\n    Microsoft::WRL::ComPtr<IDWriteTextLayout>           m_titleBodyLayout;\n\n    bool                                                m_showTitle;\n    Platform::String^                                   m_titleHeader;\n    Platform::String^                                   m_titleBody;\n\n    float                                               m_titleBodyVerticalOffset;\n    D2D1_SIZE_F                                         m_logoSize;\n    D2D1_SIZE_F                                         m_maxTitleSize;\n};\n```\n\nGameHud.cpp\n\n```cpp\n//// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF\n//// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n//// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A\n//// PARTICULAR PURPOSE.\n////\n//// Copyright (c) Microsoft Corporation. All rights reserved\n\n#include \"pch.h\"\n#include \"GameHud.h\"\n#include \"GameConstants.h\"\n\nusing namespace Microsoft::WRL;\nusing namespace Windows::UI::Core;\nusing namespace Windows::ApplicationModel;\nusing namespace Windows::Foundation;\nusing namespace Windows::Storage;\nusing namespace Windows::UI::ViewManagement;\nusing namespace Windows::Graphics::Display;\nusing namespace D2D1;\n\n//----------------------------------------------------------------------\n\nGameHud::GameHud(\n    _In_ Platform::String^ titleHeader,\n    _In_ Platform::String^ titleBody\n    )\n{\n    m_titleHeader = titleHeader;\n    m_titleBody = titleBody;\n\n    m_showTitle = true;\n    m_titleBodyVerticalOffset = GameConstants::Margin;\n    m_logoSize = D2D1::SizeF(0.0f, 0.0f);\n}\n\n//----------------------------------------------------------------------\n\nvoid GameHud::CreateDeviceIndependentResources(\n    _In_ IDWriteFactory* dwriteFactory,\n    _In_ IWICImagingFactory* wicFactory\n    )\n{\n    m_dwriteFactory = dwriteFactory;\n    m_wicFactory = wicFactory;\n\n    DX::ThrowIfFailed(\n        m_dwriteFactory->CreateTextFormat(\n            L\"Segoe UI\",\n            nullptr,\n            DWRITE_FONT_WEIGHT_LIGHT,\n            DWRITE_FONT_STYLE_NORMAL,\n            DWRITE_FONT_STRETCH_NORMAL,\n            GameConstants::HudBodyPointSize,\n            L\"en-us\",\n            &m_textFormatBody\n            )\n        );\n    DX::ThrowIfFailed(\n        m_dwriteFactory->CreateTextFormat(\n            L\"Segoe UI Symbol\",\n            nullptr,\n            DWRITE_FONT_WEIGHT_LIGHT,\n            DWRITE_FONT_STYLE_NORMAL,\n            DWRITE_FONT_STRETCH_NORMAL,\n            GameConstants::HudBodyPointSize,\n            L\"en-us\",\n            &m_textFormatBodySymbol\n            )\n        );\n    DX::ThrowIfFailed(\n        m_dwriteFactory->CreateTextFormat(\n            L\"Segoe UI Light\",\n            nullptr,\n            DWRITE_FONT_WEIGHT_LIGHT,\n            DWRITE_FONT_STYLE_NORMAL,\n            DWRITE_FONT_STRETCH_NORMAL,\n            GameConstants::HudTitleHeaderPointSize,\n            L\"en-us\",\n            &m_textFormatTitleHeader\n            )\n        );\n    DX::ThrowIfFailed(\n        m_dwriteFactory->CreateTextFormat(\n            L\"Segoe UI Light\",\n            nullptr,\n            DWRITE_FONT_WEIGHT_LIGHT,\n            DWRITE_FONT_STYLE_NORMAL,\n            DWRITE_FONT_STRETCH_NORMAL,\n            GameConstants::HudTitleBodyPointSize,\n            L\"en-us\",\n            &m_textFormatTitleBody\n            )\n        );\n\n    DX::ThrowIfFailed(m_textFormatBody->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING));\n    DX::ThrowIfFailed(m_textFormatBody->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR));\n    DX::ThrowIfFailed(m_textFormatBodySymbol->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING));\n    DX::ThrowIfFailed(m_textFormatBodySymbol->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR));\n    DX::ThrowIfFailed(m_textFormatTitleHeader->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING));\n    DX::ThrowIfFailed(m_textFormatTitleHeader->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR));\n    DX::ThrowIfFailed(m_textFormatTitleBody->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING));\n    DX::ThrowIfFailed(m_textFormatTitleBody->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR));\n}\n\n//----------------------------------------------------------------------\n\nvoid GameHud::CreateDeviceResources(_In_ ID2D1DeviceContext* d2dContext)\n{\n    auto location = Package::Current->InstalledLocation;\n    Platform::String^ path = Platform::String::Concat(location->Path, \"\\\\\");\n    path = Platform::String::Concat(path, \"windows-sdk.png\");\n\n    ComPtr<IWICBitmapDecoder> wicBitmapDecoder;\n    DX::ThrowIfFailed(\n        m_wicFactory->CreateDecoderFromFilename(\n            path->Data(),\n            nullptr,\n            GENERIC_READ,\n            WICDecodeMetadataCacheOnDemand,\n            &wicBitmapDecoder\n            )\n        );\n\n    ComPtr<IWICBitmapFrameDecode> wicBitmapFrame;\n    DX::ThrowIfFailed(\n        wicBitmapDecoder->GetFrame(0, &wicBitmapFrame)\n        );\n\n    ComPtr<IWICFormatConverter> wicFormatConverter;\n    DX::ThrowIfFailed(\n        m_wicFactory->CreateFormatConverter(&wicFormatConverter)\n        );\n\n    DX::ThrowIfFailed(\n        wicFormatConverter->Initialize(\n            wicBitmapFrame.Get(),\n            GUID_WICPixelFormat32bppPBGRA,\n            WICBitmapDitherTypeNone,\n            nullptr,\n            0.0,\n            WICBitmapPaletteTypeCustom  // The BGRA format has no palette, so this value is ignored.\n            )\n        );\n\n    double dpiX = 96.0f;\n    double dpiY = 96.0f;\n    DX::ThrowIfFailed(\n        wicFormatConverter->GetResolution(&dpiX, &dpiY)\n        );\n\n    // Create D2D Resources.\n    DX::ThrowIfFailed(\n        d2dContext->CreateBitmapFromWicBitmap(\n            wicFormatConverter.Get(),\n            BitmapProperties(\n                PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED),\n                static_cast<float>(dpiX),\n                static_cast<float>(dpiY)\n                ),\n            &m_logoBitmap\n            )\n        );\n\n    m_logoSize = m_logoBitmap->GetSize();\n\n    DX::ThrowIfFailed(\n        d2dContext->CreateSolidColorBrush(\n            D2D1::ColorF(D2D1::ColorF::White),\n            &m_textBrush\n            )\n        );\n}\n\n//----------------------------------------------------------------------\n\nvoid GameHud::UpdateForWindowSizeChange(_In_ Windows::Foundation::Rect windowBounds)\n{\n    m_maxTitleSize.width = windowBounds.Width - GameConstants::HudSafeWidth;\n    m_maxTitleSize.height = windowBounds.Height;\n\n    float headerWidth = m_maxTitleSize.width - (m_logoSize.width + 2 * GameConstants::Margin);\n\n    if (headerWidth > 0)\n    {\n        // Only resize the text layout for the Title area when there is enough space.\n        m_showTitle = true;\n\n        DX::ThrowIfFailed(\n            m_dwriteFactory->CreateTextLayout(\n                m_titleHeader->Data(),\n                m_titleHeader->Length(),\n                m_textFormatTitleHeader.Get(),\n                headerWidth,\n                m_maxTitleSize.height,\n                &m_titleHeaderLayout\n                )\n            );\n\n        DWRITE_TEXT_METRICS metrics = {0};\n        DX::ThrowIfFailed(\n            m_titleHeaderLayout->GetMetrics(&metrics)\n            );\n\n        // Compute the vertical size of the laid out header and logo.  This could change\n        // based on the window size and the layout of the text.  In some cases, the text\n        // may wrap.\n        m_titleBodyVerticalOffset = max(m_logoSize.height + GameConstants::Margin * 2, metrics.height + 2 * GameConstants::Margin);\n\n        DX::ThrowIfFailed(\n            m_dwriteFactory->CreateTextLayout(\n                m_titleBody->Data(),\n                m_titleBody->Length(),\n                m_textFormatTitleBody.Get(),\n                m_maxTitleSize.width,\n                m_maxTitleSize.height - m_titleBodyVerticalOffset,\n                &m_titleBodyLayout\n                )\n            );\n    }\n    else\n    {\n        // Not enough horizontal space for the titles, so just turn it off.\n        m_showTitle = false;\n    }\n}\n\n//----------------------------------------------------------------------\n\nvoid GameHud::Render(\n    _In_ Simple3DGame^ game,\n    _In_ ID2D1DeviceContext* d2dContext,\n    _In_ Windows::Foundation::Rect windowBounds\n    )\n{\n    if (m_showTitle)\n    {\n        d2dContext->DrawBitmap(\n            m_logoBitmap.Get(),\n            D2D1::RectF(\n                GameConstants::Margin,\n                GameConstants::Margin,\n                m_logoSize.width + GameConstants::Margin,\n                m_logoSize.height + GameConstants::Margin\n                )\n            );\n        d2dContext->DrawTextLayout(\n            Point2F(m_logoSize.width + 2.0f * GameConstants::Margin, GameConstants::Margin),\n            m_titleHeaderLayout.Get(),\n            m_textBrush.Get()\n            );\n        d2dContext->DrawTextLayout(\n            Point2F(GameConstants::Margin, m_titleBodyVerticalOffset),\n            m_titleBodyLayout.Get(),\n            m_textBrush.Get()\n            );\n    }\n\n    if (game != nullptr)\n    {\n        // This section is only used after the game state has been initialized.\n        static const int bufferLength = 256;\n        static char16 wsbuffer[bufferLength];\n        int length = swprintf_s(\n            wsbuffer,\n            bufferLength,\n            L\"Hits:\\t%10d\\nShots:\\t%10d\\nTime:\\t%8.1f\",\n            game->TotalHits(),\n            game->TotalShots(),\n            game->TimeRemaining()\n            );\n\n        d2dContext->DrawText(\n            wsbuffer,\n            length,\n            m_textFormatBody.Get(),\n            D2D1::RectF(\n                windowBounds.Width - GameConstants::HudRightOffset,\n                GameConstants::HudTopOffset,\n                windowBounds.Width,\n                GameConstants::HudTopOffset + (GameConstants::HudBodyPointSize + GameConstants::Margin) * 3\n                ),\n            m_textBrush.Get()\n            );\n\n        // Using the unicode characters starting at 0x2780 ( ➀ ) for the consecutive levels of the game.\n        // For completed levels start with 0x278A ( ➊ ) (This is 0x2780 + 10).\n        uint32 levelCharacter[6];\n        for (uint32 i = 0; i < 6; i++)\n        {\n            levelCharacter[i] = 0x2780 + i + ((static_cast<uint32>(game->LevelCompleted()) == i) ? 10 : 0);\n        }\n        length = swprintf_s(\n            wsbuffer,\n            bufferLength,\n            L\"%lc %lc %lc %lc %lc %lc\",\n            levelCharacter[0],\n            levelCharacter[1],\n            levelCharacter[2],\n            levelCharacter[3],\n            levelCharacter[4],\n            levelCharacter[5]\n            );\n        d2dContext->DrawText(\n            wsbuffer,\n            length,\n            m_textFormatBodySymbol.Get(),\n            D2D1::RectF(\n                windowBounds.Width - GameConstants::HudRightOffset,\n                GameConstants::HudTopOffset + (GameConstants::HudBodyPointSize + GameConstants::Margin) * 3 + GameConstants::Margin,\n                windowBounds.Width,\n                GameConstants::HudTopOffset + (GameConstants::HudBodyPointSize+ GameConstants::Margin) * 4\n                ),\n            m_textBrush.Get()\n            );\n\n        if (game->IsActivePlay())\n        {\n            // Draw a rectangle for the touch input for the move control.\n            d2dContext->DrawRectangle(\n                D2D1::RectF(\n                    0.0f,\n                    windowBounds.Height - GameConstants::TouchRectangleSize,\n                    GameConstants::TouchRectangleSize,\n                    windowBounds.Height\n                    ),\n                m_textBrush.Get()\n                );\n            // Draw a rectangle for the touch input for the fire control.\n            d2dContext->DrawRectangle(\n                D2D1::RectF(\n                    windowBounds.Width - GameConstants::TouchRectangleSize,\n                    windowBounds.Height - GameConstants::TouchRectangleSize,\n                    windowBounds.Width,\n                    windowBounds.Height\n                    ),\n                m_textBrush.Get()\n                );\n\n            // Draw the cross hairs.\n            d2dContext->DrawLine(\n                D2D1::Point2F(windowBounds.Width / 2.0f - GameConstants::CrossHairHalfSize, windowBounds.Height / 2.0f),\n                D2D1::Point2F(windowBounds.Width / 2.0f + GameConstants::CrossHairHalfSize, windowBounds.Height / 2.0f),\n                m_textBrush.Get(),\n                3.0f\n                );\n            d2dContext->DrawLine(\n                D2D1::Point2F(windowBounds.Width / 2.0f, windowBounds.Height / 2.0f - GameConstants::CrossHairHalfSize),\n                D2D1::Point2F(windowBounds.Width / 2.0f, windowBounds.Height / 2.0f + GameConstants::CrossHairHalfSize),\n                m_textBrush.Get(),\n                3.0f\n                );\n        }\n    }\n}\n```\n\nGameInfoOverlay.h\n\n```cpp\n//// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF\n//// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n//// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A\n//// PARTICULAR PURPOSE.\n////\n//// Copyright (c) Microsoft Corporation. All rights reserved\n\n#pragma once\n\nnamespace GameInfoOverlayConstant\n{\n    static const float Width    = 750.0f;\n    static const float Height   = 380.0f;\n};\n\nenum class GameInfoOverlayCommand\n{\n    None,\n    TapToContinue,\n    PleaseWait,\n    PlayAgain,\n};\n\nref class GameInfoOverlay\n{\ninternal:\n    GameInfoOverlay();\n\n    void Initialize(\n        _In_ ID2D1Device*         d2dDevice,\n        _In_ ID2D1DeviceContext*  d2dContext,\n        _In_ IDWriteFactory*      dwriteFactory,\n        _In_ float                dpi\n        );\n\n    void RecreateDirectXResources();\n    void SetDpi(float dpi);\n\n    void SetGameLoading(uint32 dots);\n    void SetGameStats(int maxLevel, int hitCount, int shotCount);\n    void SetGameOver(bool win, int maxLevel, int hitCount, int shotCount, int highScore);\n    void SetLevelStart(int level, Platform::String^ objective, float timeLimit, float bonusTime);\n    void SetPause();\n    void SetAction(GameInfoOverlayCommand action);\n    void HideGameInfoOverlay() { m_visible = false; };\n    void ShowGameInfoOverlay() { m_visible = true; };\n    bool Visible() { return m_visible; };\n    ID2D1Bitmap1* Bitmap() { return m_levelBitmap.Get(); }\n\nprivate:\n    void RecreateDpiDependentResources();\n\n    bool                                            m_initialized;\n    float                                           m_dpi;\n    bool                                            m_visible;\n\n    Microsoft::WRL::ComPtr<ID2D1Factory1>           m_d2dFactory;\n    Microsoft::WRL::ComPtr<ID2D1Device>             m_d2dDevice;\n    Microsoft::WRL::ComPtr<ID2D1DeviceContext>      m_d2dContext;\n    Microsoft::WRL::ComPtr<IDWriteFactory>          m_dwriteFactory;\n\n    Microsoft::WRL::ComPtr<ID2D1Bitmap1>            m_levelBitmap;\n    Microsoft::WRL::ComPtr<IDWriteTextFormat>       m_textFormatTitle;\n    Microsoft::WRL::ComPtr<IDWriteTextFormat>       m_textFormatBody;\n    Microsoft::WRL::ComPtr<ID2D1SolidColorBrush>    m_textBrush;\n    Microsoft::WRL::ComPtr<ID2D1SolidColorBrush>    m_backgroundBrush;\n    Microsoft::WRL::ComPtr<ID2D1SolidColorBrush>    m_actionBrush;\n};\n```\n\nGameInfoOverlay.cpp\n\n```cpp\n//// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF\n//// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n//// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A\n//// PARTICULAR PURPOSE.\n////\n//// Copyright (c) Microsoft Corporation. All rights reserved\n\n#include \"pch.h\"\n#include \"GameInfoOverlay.h\"\n#include \"DirectXSample.h\"\n\nusing namespace Windows::UI::Core;\nusing namespace Windows::Foundation;\nusing namespace Microsoft::WRL;\nusing namespace Windows::UI::ViewManagement;\nusing namespace Windows::Graphics::Display;\nusing namespace D2D1;\n\nstatic const D2D1_RECT_F titleRectangle = D2D1::RectF(50.0f, 50.0f, GameInfoOverlayConstant::Width - 50.0f, 100.0f);\nstatic const D2D1_RECT_F bodyRectangle = D2D1::RectF(50.0f, 110.0f, GameInfoOverlayConstant::Width - 50.0f, GameInfoOverlayConstant::Height - 50.0f);\nstatic const D2D1_RECT_F actionRectangle = D2D1::RectF(50.0f, GameInfoOverlayConstant::Height - 45.0f, GameInfoOverlayConstant::Width - 50.0f, GameInfoOverlayConstant::Height - 5.0f);\nstatic const int bufferLength = 1000;\nstatic char16 wsbuffer[bufferLength];\n\nGameInfoOverlay::GameInfoOverlay():\n    m_initialized(false),\n    m_visible(false)\n{\n}\n//----------------------------------------------------------------------\nvoid GameInfoOverlay::Initialize(\n    _In_ ID2D1Device*         d2dDevice,\n    _In_ ID2D1DeviceContext*  d2dContext,\n    _In_ IDWriteFactory*      dwriteFactory,\n    _In_ float                dpi)\n{\n    m_initialized = true;\n\n    m_dwriteFactory = dwriteFactory;\n    m_dpi = dpi;\n    m_d2dDevice = d2dDevice;\n    m_d2dContext = d2dContext;\n\n    ComPtr<ID2D1Factory> factory;\n    d2dDevice->GetFactory(&factory);\n\n    DX::ThrowIfFailed(\n        factory.As(&m_d2dFactory)\n        );\n\n    RecreateDirectXResources();\n}\n//----------------------------------------------------------------------\nvoid GameInfoOverlay::SetDpi(float dpi)\n{\n    if (m_initialized)\n    {\n        if (dpi != m_dpi)\n        {\n            m_dpi = dpi;\n            RecreateDpiDependentResources();\n        }\n    }\n}\n//----------------------------------------------------------------------\nvoid GameInfoOverlay::RecreateDirectXResources()\n{\n    if (!m_initialized)\n    {\n        return;\n    }\n\n    // Create D2D resources.\n    DX::ThrowIfFailed(\n        m_dwriteFactory->CreateTextFormat(\n            L\"Segoe UI\",\n            nullptr,\n            DWRITE_FONT_WEIGHT_MEDIUM,\n            DWRITE_FONT_STYLE_NORMAL,\n            DWRITE_FONT_STRETCH_NORMAL,\n            32,         // font size\n            L\"en-us\",   // locale\n            &m_textFormatTitle\n            )\n        );\n\n    DX::ThrowIfFailed(\n        m_dwriteFactory->CreateTextFormat(\n            L\"Segoe UI\",\n            nullptr,\n            DWRITE_FONT_WEIGHT_LIGHT,\n            DWRITE_FONT_STYLE_NORMAL,\n            DWRITE_FONT_STRETCH_NORMAL,\n            24,         // font size\n            L\"en-us\",   // locale\n            &m_textFormatBody\n            )\n        );\n\n    DX::ThrowIfFailed(\n        m_textFormatTitle->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER)\n        );\n    DX::ThrowIfFailed(\n        m_textFormatTitle->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR)\n        );\n    DX::ThrowIfFailed(\n        m_textFormatBody->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING)\n        );\n    DX::ThrowIfFailed(\n        m_textFormatBody->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR)\n        );\n\n    DX::ThrowIfFailed(\n        m_d2dContext->CreateSolidColorBrush(\n            D2D1::ColorF(D2D1::ColorF::White),\n            &m_textBrush\n            )\n        );\n    DX::ThrowIfFailed(\n        m_d2dContext->CreateSolidColorBrush(\n            D2D1::ColorF(D2D1::ColorF::Black),\n            &m_backgroundBrush\n            )\n        );\n     DX::ThrowIfFailed(\n        m_d2dContext->CreateSolidColorBrush(\n            D2D1::ColorF(0xdb7100, 1.0f),\n            &m_actionBrush\n            )\n        );\n\n     RecreateDpiDependentResources();\n}\n//----------------------------------------------------------------------\nvoid GameInfoOverlay::RecreateDpiDependentResources()\n{\n    m_levelBitmap = nullptr;\n\n    // Create a D2D bitmap to be used for Game Info Overlay when waiting to\n    // start a level or when displaying game statistics.\n    D2D1_BITMAP_PROPERTIES1 properties;\n    properties.pixelFormat.format = DXGI_FORMAT_B8G8R8A8_UNORM;\n    properties.pixelFormat.alphaMode = D2D1_ALPHA_MODE_PREMULTIPLIED;\n    properties.dpiX = m_dpi;\n    properties.dpiY = m_dpi;\n    properties.bitmapOptions = D2D1_BITMAP_OPTIONS_TARGET;\n    properties.colorContext = nullptr;\n    DX::ThrowIfFailed(\n        m_d2dContext->CreateBitmap(\n            D2D1::SizeU(\n                static_cast<UINT32>(GameInfoOverlayConstant::Width * m_dpi / 96.0f),\n                static_cast<UINT32>(GameInfoOverlayConstant::Height * m_dpi / 96.0f)\n                ),\n            nullptr,\n            0,\n            &properties,\n            &m_levelBitmap\n            )\n        );\n    m_d2dContext->SetTarget(m_levelBitmap.Get());\n    m_d2dContext->BeginDraw();\n    m_d2dContext->SetTransform(D2D1::Matrix3x2F::Identity());\n    m_d2dContext->Clear(D2D1::ColorF(D2D1::ColorF::Black));\n    HRESULT hr = m_d2dContext->EndDraw();\n    if (hr != D2DERR_RECREATE_TARGET)\n    {\n        // The D2DERR_RECREATE_TARGET indicates there has been a problem with the underlying\n        // D3D device.  All subsequent rendering will be ignored until the device is recreated.\n        // This error will be propagated and the appropriate D3D error will be returned from the\n        // swapchain->Present(...) call.   At that point, the sample will recreate the device\n        // and all associated resources.  As a result, the D2DERR_RECREATE_TARGET doesn't\n        // need to be handled here.\n        DX::ThrowIfFailed(hr);\n    }\n}\n//----------------------------------------------------------------------\nvoid GameInfoOverlay::SetGameLoading(uint32 dots)\n{\n    int length;\n    Platform::String^ string = \"Loading Resources\";\n\n    m_d2dContext->SetTarget(m_levelBitmap.Get());\n    m_d2dContext->BeginDraw();\n    m_d2dContext->SetTransform(D2D1::Matrix3x2F::Identity());\n    m_d2dContext->FillRectangle(&titleRectangle, m_backgroundBrush.Get());\n    m_d2dContext->FillRectangle(&bodyRectangle, m_backgroundBrush.Get());\n    m_d2dContext->FillRectangle(&actionRectangle, m_backgroundBrush.Get());\n\n    m_d2dContext->DrawText(\n        string->Data(),\n        string->Length(),\n        m_textFormatTitle.Get(),\n        titleRectangle,\n        m_textBrush.Get()\n        );\n\n    dots = dots % 10;\n    for (length = 0; length < 25; length++)\n    {\n        wsbuffer[length] = L' ';\n    }\n    for (uint32 i = 0; i < dots; i++)\n    {\n        wsbuffer[length++] = 0x25CF;   // This is a Dot character in the font.\n        wsbuffer[length++] = L' ';\n        wsbuffer[length++] = L' ';\n        wsbuffer[length++] = L' ';\n    }\n\n    m_d2dContext->DrawText(\n        wsbuffer,\n        length,\n        m_textFormatBody.Get(),\n        bodyRectangle,\n        m_actionBrush.Get()\n        );\n\n    HRESULT hr = m_d2dContext->EndDraw();\n    if (hr != D2DERR_RECREATE_TARGET)\n    {\n        // The D2DERR_RECREATE_TARGET indicates there has been a problem with the underlying\n        // D3D device.  All subsequent rendering will be ignored until the device is recreated.\n        // This error will be propagated and the appropriate D3D error will be returned from the\n        // swapchain->Present(...) call.   At that point, the sample will recreate the device\n        // and all associated resources.  As a result, the D2DERR_RECREATE_TARGET doesn't\n        // need to be handled here.\n        DX::ThrowIfFailed(hr);\n    }\n}\n//----------------------------------------------------------------------\nvoid GameInfoOverlay::SetGameStats(int maxLevel, int hitCount, int shotCount)\n{\n    int length;\n    Platform::String^ string;\n\n    m_d2dContext->SetTarget(m_levelBitmap.Get());\n    m_d2dContext->BeginDraw();\n    m_d2dContext->SetTransform(D2D1::Matrix3x2F::Identity());\n    m_d2dContext->FillRectangle(&titleRectangle, m_backgroundBrush.Get());\n    m_d2dContext->FillRectangle(&bodyRectangle, m_backgroundBrush.Get());\n    string = \"High Score\";\n\n    m_d2dContext->DrawText(\n        string->Data(),\n        string->Length(),\n        m_textFormatTitle.Get(),\n        titleRectangle,\n        m_textBrush.Get()\n        );\n    length = swprintf_s(\n        wsbuffer,\n        bufferLength,\n        L\"Levels Completed %d\\nTotal Points %d\\nTotal Shots %d\",\n        maxLevel,\n        hitCount,\n        shotCount\n        );\n    string = ref new Platform::String(wsbuffer, length);\n    m_d2dContext->DrawText(\n        string->Data(),\n        string->Length(),\n        m_textFormatBody.Get(),\n        bodyRectangle,\n        m_textBrush.Get()\n        );\n    HRESULT hr = m_d2dContext->EndDraw();\n    if (hr != D2DERR_RECREATE_TARGET)\n    {\n        // The D2DERR_RECREATE_TARGET indicates there has been a problem with the underlying\n        // D3D device.  All subsequent rendering will be ignored until the device is recreated.\n        // This error will be propagated and the appropriate D3D error will be returned from the\n        // swapchain->Present(...) call.   At that point, the sample will recreate the device\n        // and all associated resources.  As a result, the D2DERR_RECREATE_TARGET doesn't\n        // need to be handled here.\n        DX::ThrowIfFailed(hr);\n    }\n}\n//----------------------------------------------------------------------\nvoid GameInfoOverlay::SetGameOver(bool win, int maxLevel, int hitCount, int shotCount, int highScore)\n{\n    int length;\n    Platform::String^ string;\n\n\n    m_d2dContext->SetTarget(m_levelBitmap.Get());\n    m_d2dContext->BeginDraw();\n    m_d2dContext->SetTransform(D2D1::Matrix3x2F::Identity());\n    m_d2dContext->FillRectangle(&titleRectangle, m_backgroundBrush.Get());\n    m_d2dContext->FillRectangle(&bodyRectangle, m_backgroundBrush.Get());\n    if (win)\n    {\n        string = \"You WON!\";\n    }\n    else\n    {\n        string = \"Game Over\";\n    }\n    m_d2dContext->DrawText(\n        string->Data(),\n        string->Length(),\n        m_textFormatTitle.Get(),\n        titleRectangle,\n        m_textBrush.Get()\n        );\n    length = swprintf_s(\n        wsbuffer,\n        bufferLength,\n        L\"Levels Completed %d\\nTotal Points %d\\nTotal Shots %d\\n\\nHigh Score %d\\n\",\n        maxLevel,\n        hitCount,\n        shotCount,\n        highScore\n        );\n    m_d2dContext->DrawText(\n        wsbuffer,\n        length,\n        m_textFormatBody.Get(),\n        bodyRectangle,\n        m_textBrush.Get()\n        );\n    HRESULT hr = m_d2dContext->EndDraw();\n    if (hr != D2DERR_RECREATE_TARGET)\n    {\n        // The D2DERR_RECREATE_TARGET indicates there has been a problem with the underlying\n        // D3D device.  All subsequent rendering will be ignored until the device is recreated.\n        // This error will be propagated and the appropriate D3D error will be returned from the\n        // swapchain->Present(...) call.   At that point, the sample will recreate the device\n        // and all associated resources.  As a result, the D2DERR_RECREATE_TARGET doesn't\n        // need to be handled here.\n        DX::ThrowIfFailed(hr);\n    }\n}\n//----------------------------------------------------------------------\nvoid GameInfoOverlay::SetLevelStart(int level, Platform::String^ objective, float timeLimit, float bonusTime)\n{\n    int length;\n    Platform::String^ string;\n\n    m_d2dContext->SetTarget(m_levelBitmap.Get());\n    m_d2dContext->BeginDraw();\n    m_d2dContext->SetTransform(D2D1::Matrix3x2F::Identity());\n    m_d2dContext->FillRectangle(&titleRectangle, m_backgroundBrush.Get());\n    m_d2dContext->FillRectangle(&bodyRectangle, m_backgroundBrush.Get());\n    length = swprintf_s(wsbuffer, bufferLength, L\"Level %d\", level);\n    m_d2dContext->DrawText(\n        wsbuffer,\n        length,\n        m_textFormatTitle.Get(),\n        titleRectangle,\n        m_textBrush.Get()\n        );\n\n    if (bonusTime > 0.0f)\n    {\n        length = swprintf_s(\n            wsbuffer,\n            bufferLength,\n            L\"Objective: %s\\nTime  Limit: %6.1f sec\\nBonus Time: %6.1f sec\\n\",\n            objective->Data(),\n            timeLimit,\n            bonusTime\n            );\n    }\n    else\n    {\n        length = swprintf_s(\n            wsbuffer,\n            bufferLength,\n            L\"Objective: %s\\nTime  Limit: %6.1f sec\\n\",\n            objective->Data(),\n            timeLimit\n            );\n    }\n    string = ref new Platform::String(wsbuffer, length);\n    m_d2dContext->DrawText(\n        string->Data(),\n        string->Length(),\n        m_textFormatBody.Get(),\n        bodyRectangle,\n        m_textBrush.Get()\n        );\n    HRESULT hr = m_d2dContext->EndDraw();\n    if (hr != D2DERR_RECREATE_TARGET)\n    {\n        // The D2DERR_RECREATE_TARGET indicates there has been a problem with the underlying\n        // D3D device.  All subsequent rendering will be ignored until the device is recreated.\n        // This error will be propagated and the appropriate D3D error will be returned from the\n        // swapchain->Present(...) call.   At that point, the sample will recreate the device\n        // and all associated resources.  As a result, the D2DERR_RECREATE_TARGET doesn't\n        // need to be handled here.\n        DX::ThrowIfFailed(hr);\n    }\n}\n//----------------------------------------------------------------------\nvoid GameInfoOverlay::SetPause()\n{\n    Platform::String^ string;\n\n    m_d2dContext->SetTarget(m_levelBitmap.Get());\n    m_d2dContext->BeginDraw();\n    m_d2dContext->SetTransform(D2D1::Matrix3x2F::Identity());\n    m_d2dContext->FillRectangle(&titleRectangle, m_backgroundBrush.Get());\n    m_d2dContext->FillRectangle(&bodyRectangle, m_backgroundBrush.Get());\n    string = \"Game Paused\";\n\n    m_d2dContext->DrawText(\n        string->Data(),\n        string->Length(),\n        m_textFormatTitle.Get(),\n        bodyRectangle,\n        m_textBrush.Get()\n        );\n    HRESULT hr = m_d2dContext->EndDraw();\n    if (hr != D2DERR_RECREATE_TARGET)\n    {\n        // The D2DERR_RECREATE_TARGET indicates there has been a problem with the underlying\n        // D3D device.  All subsequent rendering will be ignored until the device is recreated.\n        // This error will be propagated and the appropriate D3D error will be returned from the\n        // swapchain->Present(...) call.   At that point, the sample will recreate the device\n        // and all associated resources.  As a result, the D2DERR_RECREATE_TARGET doesn't\n        // need to be handled here.\n        DX::ThrowIfFailed(hr);\n    }\n}\n//----------------------------------------------------------------------\nvoid GameInfoOverlay::SetAction(GameInfoOverlayCommand action)\n{\n    Platform::String^ string;\n\n    m_d2dContext->SetTarget(m_levelBitmap.Get());\n    m_d2dContext->BeginDraw();\n    m_d2dContext->SetTransform(D2D1::Matrix3x2F::Identity());\n    m_d2dContext->FillRectangle(&actionRectangle, m_backgroundBrush.Get());\n\n    switch (action)\n    {\n    case GameInfoOverlayCommand::PlayAgain:\n        string = \"Tap to play again ...\";\n        break;\n    case GameInfoOverlayCommand::PleaseWait:\n        string = \"Level loading, please wait ...\";\n        break;\n    case GameInfoOverlayCommand::TapToContinue:\n        string = \"Tap to continue ...\";\n        break;\n    default:\n        string = \"\";\n        break;\n    }\n    if (action != GameInfoOverlayCommand::None)\n    {\n        m_d2dContext->DrawText(\n            string->Data(),\n            string->Length(),\n            m_textFormatBody.Get(),\n            actionRectangle,\n            m_actionBrush.Get()\n            );\n    }\n    HRESULT hr = m_d2dContext->EndDraw();\n    if (hr != D2DERR_RECREATE_TARGET)\n    {\n        // The D2DERR_RECREATE_TARGET indicates there has been a problem with the underlying\n        // D3D device.  All subsequent rendering will be ignored until the device is recreated.\n        // This error will be propagated and the appropriate D3D error will be returned from the\n        // swapchain->Present(...) call.   At that point, the sample will recreate the device\n        // and all associated resources.  As a result, the D2DERR_RECREATE_TARGET doesn't\n        // need to be handled here.\n        DX::ThrowIfFailed(hr);\n    }\n}\n```\n\n## Related topics\n\n\n[Create a simple UWP game with DirectX](tutorial--create-your-first-metro-style-directx-game.md)\n\n \n\n \n\n\n\n\n"}