<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="ja-jp" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-00ddeee</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">c760a0245e902429e2efe8d744823bc971716ba6</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\port-the-shader-config.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">a418b3184f4c21df48c698aa758733eacc16456b</mda:meta><mda:meta type="olxliffhash">743b6134f613902bf0bf7a9bfc27f36e08b7030d</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Port the shader objects</source>
					<target>Port the shader objects</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>When porting the simple renderer from OpenGL ES 2.0, the first step is to set up the equivalent vertex and fragment shader objects in Direct3D 11, and to make sure that the main program can communicate with the shader objects after they are compiled.</source>
					<target>When porting the simple renderer from OpenGL ES 2.0, the first step is to set up the equivalent vertex and fragment shader objects in Direct3D 11, and to make sure that the main program can communicate with the shader objects after they are compiled.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Port the shader objects</source>
					<target>Port the shader objects</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Important APIs</source>
					<target>Important APIs</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>ID3D11Device</source>
					<target>ID3D11Device</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>ID3D11DeviceContext</source>
					<target>ID3D11DeviceContext</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>When porting the simple renderer from OpenGL ES 2.0, the first step is to set up the equivalent vertex and fragment shader objects in Direct3D 11, and to make sure that the main program can communicate with the shader objects after they are compiled.</source>
					<target>When porting the simple renderer from OpenGL ES 2.0, the first step is to set up the equivalent vertex and fragment shader objects in Direct3D 11, and to make sure that the main program can communicate with the shader objects after they are compiled.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   Have you created a new Direct3D project?</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   Have you created a new Direct3D project?</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](user-interface.md)</data>
				</originalData>
				<segment state="initial">
					<source>If not, follow the instructions in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Create a new DirectX 11 project for Universal Windows Platform (UWP)</pc>.</source>
					<target>If not, follow the instructions in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Create a new DirectX 11 project for Universal Windows Platform (UWP)</pc>.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>This walkthrough assumes that you have the created the DXGI and Direct3D resources for drawing to the screen, and which are provided in the template.</source>
					<target>This walkthrough assumes that you have the created the DXGI and Direct3D resources for drawing to the screen, and which are provided in the template.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Much like OpenGL ES 2.0, the compiled shaders in Direct3D must be associated with a drawing context.</source>
					<target>Much like OpenGL ES 2.0, the compiled shaders in Direct3D must be associated with a drawing context.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>However, Direct3D does not have the concept of a shader program object per se; instead, you must assign the shaders directly to a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext</pc></pc>.</source>
					<target>However, Direct3D does not have the concept of a shader program object per se; instead, you must assign the shaders directly to a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>This step follows the OpenGL ES 2.0 process for creating and binding shader objects, and provides you with the corresponding API behaviors in Direct3D.</source>
					<target>This step follows the OpenGL ES 2.0 process for creating and binding shader objects, and provides you with the corresponding API behaviors in Direct3D.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Instructions</source>
					<target>Instructions</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Step 1: Compile the shaders</source>
					<target>Step 1: Compile the shaders</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>In this simple OpenGL ES 2.0 sample, the shaders are stored as text files and loaded as string data for run-time compilation.</source>
					<target>In this simple OpenGL ES 2.0 sample, the shaders are stored as text files and loaded as string data for run-time compilation.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>OpenGL ES 2.0: Compile a shader</source>
					<target>OpenGL ES 2.0: Compile a shader</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>In Direct3D, shaders are not compiled during run-time; they are always compiled to CSO files when the rest of the program is compiled.</source>
					<target>In Direct3D, shaders are not compiled during run-time; they are always compiled to CSO files when the rest of the program is compiled.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>When you compile your app with Microsoft Visual Studio, the HLSL files are compiled to CSO (.cso) files that your app must load.</source>
					<target>When you compile your app with Microsoft Visual Studio, the HLSL files are compiled to CSO (.cso) files that your app must load.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>Make sure you include these CSO files with your app when you package it!</source>
					<target>Make sure you include these CSO files with your app when you package it!</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The following example performs the shader loading and compilation asynchronously using the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">auto</pc> keyword and lambda syntax.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The following example performs the shader loading and compilation asynchronously using the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">auto</pc> keyword and lambda syntax.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>ReadDataAsync() is a method implemented for the template that reads in a CSO file as an array of byte data (fileData).</source>
					<target>ReadDataAsync() is a method implemented for the template that reads in a CSO file as an array of byte data (fileData).</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Direct3D 11: Compile a shader</source>
					<target>Direct3D 11: Compile a shader</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Step 2: Create and load the vertex and fragment (pixel) shaders</source>
					<target>Step 2: Create and load the vertex and fragment (pixel) shaders</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>OpenGL ES 2.0 has the notion of a shader "program", which serves as the interface between the main program running on the CPU and the shaders, which are executed on the GPU.</source>
					<target>OpenGL ES 2.0 has the notion of a shader "program", which serves as the interface between the main program running on the CPU and the shaders, which are executed on the GPU.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>Shaders are compiled (or loaded from compiled sources) and associated with a program, which enables execution on the GPU.</source>
					<target>Shaders are compiled (or loaded from compiled sources) and associated with a program, which enables execution on the GPU.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>OpenGL ES 2.0: Loading the vertex and fragment shaders into a shading program</source>
					<target>OpenGL ES 2.0: Loading the vertex and fragment shaders into a shading program</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>Direct3D does not have the concept of a shader program object.</source>
					<target>Direct3D does not have the concept of a shader program object.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476524)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/desktop/ff476513)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>Rather, the shaders are created when one of the shader creation methods on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device</pc></pc> interface (such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11Device::CreateVertexShader</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ID3D11Device::CreatePixelShader</pc></pc>) is called.</source>
					<target>Rather, the shaders are created when one of the shader creation methods on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device</pc></pc> interface (such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11Device::CreateVertexShader</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ID3D11Device::CreatePixelShader</pc></pc>) is called.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>To set the shaders for the current drawing context, we provide them to corresponding <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext</pc></pc> with a set shader method, such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceContext::VSSetShader</pc></pc> for the vertex shader or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ID3D11DeviceContext::PSSetShader</pc></pc> for the fragment shader.</source>
					<target>To set the shaders for the current drawing context, we provide them to corresponding <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext</pc></pc> with a set shader method, such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceContext::VSSetShader</pc></pc> for the vertex shader or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ID3D11DeviceContext::PSSetShader</pc></pc> for the fragment shader.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Direct3D 11: Set the shaders for the graphics device drawing context.</source>
					<target>Direct3D 11: Set the shaders for the graphics device drawing context.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Step 3: Define the data to supply to the shaders</source>
					<target>Step 3: Define the data to supply to the shaders</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In our OpenGL ES 2.0 example, we have one <pc dataRefEnd="id2" dataRefStart="id1" id="p1">uniform</pc> to declare for the shader pipeline:</source>
					<target>In our OpenGL ES 2.0 example, we have one <pc dataRefEnd="id2" dataRefStart="id1" id="p1">uniform</pc> to declare for the shader pipeline:</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">u\_mvpMatrix</pc>: a 4x4 array of floats that represents the final model-view-projection transformation matrix that takes the model coordinates for the cube and transforms them into 2D projection coordinates for scan conversion.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">u\_mvpMatrix</pc>: a 4x4 array of floats that represents the final model-view-projection transformation matrix that takes the model coordinates for the cube and transforms them into 2D projection coordinates for scan conversion.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>And two <pc dataRefEnd="id2" dataRefStart="id1" id="p1">attribute</pc> values for the vertex data:</source>
					<target>And two <pc dataRefEnd="id2" dataRefStart="id1" id="p1">attribute</pc> values for the vertex data:</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">a\_position</pc>: a 4-float vector for the model coordinates of a vertex.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">a\_position</pc>: a 4-float vector for the model coordinates of a vertex.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">a\_color</pc>: A 4-float vector for the RGBA color value associated with the vertex.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">a\_color</pc>: A 4-float vector for the RGBA color value associated with the vertex.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Open GL ES 2.0: GLSL definitions for the uniforms and attributes</source>
					<target>Open GL ES 2.0: GLSL definitions for the uniforms and attributes</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>The corresponding main program variables are defined as fields on the renderer object, in this case.</source>
					<target>The corresponding main program variables are defined as fields on the renderer object, in this case.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](port-a-simple-opengl-es-2-0-renderer-to-directx-11-1.md)</data>
				</originalData>
				<segment state="initial">
					<source>(Refer to the header in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11</pc>.) Once we've done that, we need to specify the locations in memory where the main program will supply these values for the shader pipeline, which we typically do right before a draw call:</source>
					<target>(Refer to the header in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11</pc>.) Once we've done that, we need to specify the locations in memory where the main program will supply these values for the shader pipeline, which we typically do right before a draw call:</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>OpenGL ES 2.0: Marking the location of the uniform and attribute data</source>
					<target>OpenGL ES 2.0: Marking the location of the uniform and attribute data</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>Direct3D does not have the concept of an "attribute" or a "uniform" in the same sense (or, at least, it does not share this syntax).</source>
					<target>Direct3D does not have the concept of an "attribute" or a "uniform" in the same sense (or, at least, it does not share this syntax).</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>Rather, it has constant buffers, represented as Direct3D subresources -- resources that are shared between the main program and the shader programs.</source>
					<target>Rather, it has constant buffers, represented as Direct3D subresources -- resources that are shared between the main program and the shader programs.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>Some of these subresources, such as vertex positions and colors, are described as HLSL semantics.</source>
					<target>Some of these subresources, such as vertex positions and colors, are described as HLSL semantics.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](porting-uniforms-and-attributes.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info on constant buffers and HLSL semantics as they relate to OpenGL ES 2.0 concepts, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Port frame buffer objects, uniforms, and attributes</pc>.</source>
					<target>For more info on constant buffers and HLSL semantics as they relate to OpenGL ES 2.0 concepts, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Port frame buffer objects, uniforms, and attributes</pc>.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When moving this process to Direct3D, we convert the uniform to a Direct3D constant buffer (cbuffer) and assign it a register for lookup with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">register</pc> HLSL semantic.</source>
					<target>When moving this process to Direct3D, we convert the uniform to a Direct3D constant buffer (cbuffer) and assign it a register for lookup with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">register</pc> HLSL semantic.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb205574)</data>
				</originalData>
				<segment state="initial">
					<source>The two vertex attributes are handled as input elements to the shader pipeline stages, and are also assigned <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HLSL semantics</pc> (POSITION and COLOR0) that inform the shaders.</source>
					<target>The two vertex attributes are handled as input elements to the shader pipeline stages, and are also assigned <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HLSL semantics</pc> (POSITION and COLOR0) that inform the shaders.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>The pixel shader takes an SV\_POSITION, with the SV\_ prefix indicating that it is a system value generated by the GPU.</source>
					<target>The pixel shader takes an SV\_POSITION, with the SV\_ prefix indicating that it is a system value generated by the GPU.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](port-the-vertex-buffers-and-data-config.md)</data>
				</originalData>
				<segment state="initial">
					<source>(In this case, it is a pixel position generated during scan conversion.) VertexShaderInput and PixelShaderInput are not declared as constant buffers because the former will be used to define the vertex buffer (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Port the vertex buffers and data</pc>), and the data for the latter is generated as the result of a previous stage in the pipeline, which in this case is the vertex shader.</source>
					<target>(In this case, it is a pixel position generated during scan conversion.) VertexShaderInput and PixelShaderInput are not declared as constant buffers because the former will be used to define the vertex buffer (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Port the vertex buffers and data</pc>), and the data for the latter is generated as the result of a previous stage in the pipeline, which in this case is the vertex shader.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>Direct3D: HLSL definitions for the constant buffers and vertex data</source>
					<target>Direct3D: HLSL definitions for the constant buffers and vertex data</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](porting-uniforms-and-attributes.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info on porting to constant buffers and the application of HLSL semantics, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Port frame buffer objects, uniforms, and attributes</pc>.</source>
					<target>For more info on porting to constant buffers and the application of HLSL semantics, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Port frame buffer objects, uniforms, and attributes</pc>.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Here are the structures for the layout of the data passed to the shader pipeline with a constant or vertex buffer.</source>
					<target>Here are the structures for the layout of the data passed to the shader pipeline with a constant or vertex buffer.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Direct3D 11: Declaring the constant and vertex buffers layout</source>
					<target>Direct3D 11: Declaring the constant and vertex buffers layout</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Use the DirectXMath XM\* types for your constant buffer elements, since they provide proper packing and alignment for the contents when they are sent to the shader pipeline.</source>
					<target>Use the DirectXMath XM\* types for your constant buffer elements, since they provide proper packing and alignment for the contents when they are sent to the shader pipeline.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>If you use standard Windows platform float types and arrays, you must perform the packing and alignment yourself.</source>
					<target>If you use standard Windows platform float types and arrays, you must perform the packing and alignment yourself.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/jj151620)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>To bind a constant buffer, create a layout description as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CD3D11\_BUFFER\_DESC</pc></pc> structure, and pass it to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3DDevice::CreateBuffer</pc></pc>.</source>
					<target>To bind a constant buffer, create a layout description as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CD3D11\_BUFFER\_DESC</pc></pc> structure, and pass it to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3DDevice::CreateBuffer</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476486)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Then, in your render method, pass the constant buffer to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext::UpdateSubresource</pc></pc> before drawing.</source>
					<target>Then, in your render method, pass the constant buffer to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext::UpdateSubresource</pc></pc> before drawing.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>Direct3D 11: Bind the constant buffer</source>
					<target>Direct3D 11: Bind the constant buffer</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](port-the-vertex-buffers-and-data-config.md)</data>
				</originalData>
				<segment state="initial">
					<source>The vertex buffer is created and updated similarly, and is discussed in the next step, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Port the vertex buffers and data</pc>.</source>
					<target>The vertex buffer is created and updated similarly, and is discussed in the next step, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Port the vertex buffers and data</pc>.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>Next step</source>
					<target>Next step</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>Port the vertex buffers and data</source>
					<target>Port the vertex buffers and data</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
					<target>Related topics</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11</source>
					<target>How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>Port the vertex buffers and data</source>
					<target>Port the vertex buffers and data</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Port the GLSL</source>
					<target>Port the GLSL</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>Draw to the screen</source>
					<target>Draw to the screen</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>