{"nodes":[{"pos":[11,46],"content":"Render the scene with depth testing","needQuote":true,"needEscape":true,"nodes":[{"content":"Render the scene with depth testing","pos":[0,35]}]},{"pos":[60,165],"content":"Create a shadow effect by adding depth testing to your vertex (or geometry) shader and your pixel shader.","needQuote":true,"needEscape":true,"nodes":[{"content":"Create a shadow effect by adding depth testing to your vertex (or geometry) shader and your pixel shader.","pos":[0,105]}]},{"content":"Render the scene with depth testing","pos":[222,257]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[260,298]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[299,394],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Create a shadow effect by adding depth testing to your vertex (or geometry) shader and your pixel shader.","pos":[397,502]},{"content":"Part 3 of <bpt id=\"p1\">[</bpt>Walkthrough: Implement shadow volumes using depth buffers in Direct3D 11<ept id=\"p1\">](implementing-depth-buffers-for-shadow-mapping.md)</ept>.","pos":[503,638],"source":" Part 3 of [Walkthrough: Implement shadow volumes using depth buffers in Direct3D 11](implementing-depth-buffers-for-shadow-mapping.md)."},{"content":"Include transformation for light frustum","pos":[643,683]},{"content":"Your vertex shader needs to compute the transformed light space position for each vertex.","pos":[686,775]},{"content":"Provide the light space model, view, and projection matrices using a constant buffer.","pos":[776,861]},{"content":"You can also use this constant buffer to provide the light position and normal for lighting calculations.","pos":[862,967]},{"content":"The transformed position in light space will be used during the depth test.","pos":[968,1043]},{"content":"Next, the pixel shader will use the interpolated light space position provided by the vertex shader to test whether the pixel is in shadow.","pos":[2062,2201]},{"content":"Test whether the position is in the light frustum","pos":[2206,2255]},{"content":"First, check that the pixel is in the view frustum of the light by normalizing the X and Y coordinates.","pos":[2258,2361]},{"content":"If they are both within the range \\[0, 1\\] then it's possible for the pixel to be in shadow.","pos":[2362,2454]},{"content":"Otherwise you can skip the depth test.","pos":[2455,2493]},{"content":"A shader can test for this quickly by calling <bpt id=\"p1\">[</bpt>Saturate<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh447231)</ept> and comparing the result against the original value.","pos":[2494,2664],"source":" A shader can test for this quickly by calling [Saturate](https://msdn.microsoft.com/library/windows/desktop/hh447231) and comparing the result against the original value."},{"content":"Depth test against the shadow map","pos":[3293,3326]},{"content":"Use a sample comparison function (either <bpt id=\"p1\">[</bpt>SampleCmp<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509696)</ept> or <bpt id=\"p2\">[</bpt>SampleCmpLevelZero<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/bb509697)</ept>) to test the pixel's depth in light space against the depth map.","pos":[3329,3592],"source":"Use a sample comparison function (either [SampleCmp](https://msdn.microsoft.com/library/windows/desktop/bb509696) or [SampleCmpLevelZero](https://msdn.microsoft.com/library/windows/desktop/bb509697)) to test the pixel's depth in light space against the depth map."},{"content":"Compute the normalized light space depth value, which is <ph id=\"ph1\">`z / w`</ph>, and pass the value to the comparison function.","pos":[3593,3705],"source":" Compute the normalized light space depth value, which is `z / w`, and pass the value to the comparison function."},{"content":"Since we use a LessOrEqual comparison test for the sampler, the intrinsic function returns zero when the comparison test passes; this indicates that the pixel is in shadow.","pos":[3706,3878]},{"content":"Compute lighting in or out of shadow","pos":[4754,4790]},{"content":"If the pixel is not in shadow, the pixel shader should compute direct lighting and add it to the pixel value.","pos":[4793,4902]},{"content":"Otherwise, the pixel shader should compute the pixel value using ambient lighting.","pos":[5612,5694]},{"pos":[5751,5878],"content":"In the next part of this walkthrough, learn how to <bpt id=\"p1\">[</bpt>Support shadow maps on a range of hardware<ept id=\"p1\">](target-a-range-of-hardware.md)</ept>.","source":"In the next part of this walkthrough, learn how to [Support shadow maps on a range of hardware](target-a-range-of-hardware.md)."}],"content":"---\ntitle: Render the scene with depth testing\ndescription: Create a shadow effect by adding depth testing to your vertex (or geometry) shader and your pixel shader.\nms.assetid: bf496dfb-d7f5-af6b-d588-501164608560\n---\n\n# Render the scene with depth testing\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\nCreate a shadow effect by adding depth testing to your vertex (or geometry) shader and your pixel shader. Part 3 of [Walkthrough: Implement shadow volumes using depth buffers in Direct3D 11](implementing-depth-buffers-for-shadow-mapping.md).\n\n## Include transformation for light frustum\n\n\nYour vertex shader needs to compute the transformed light space position for each vertex. Provide the light space model, view, and projection matrices using a constant buffer. You can also use this constant buffer to provide the light position and normal for lighting calculations. The transformed position in light space will be used during the depth test.\n\n```cpp\nPixelShaderInput main(VertexShaderInput input)\n{\n    PixelShaderInput output;\n    float4 pos = float4(input.pos, 1.0f);\n\n    // Transform the vertex position into projected space.\n    float4 modelPos = mul(pos, model);\n    pos = mul(modelPos, view);\n    pos = mul(pos, projection);\n    output.pos = pos;\n\n    // Transform the vertex position into projected space from the POV of the light.\n    float4 lightSpacePos = mul(modelPos, lView);\n    lightSpacePos = mul(lightSpacePos, lProjection);\n    output.lightSpacePos = lightSpacePos;\n\n    // Light ray\n    float3 lRay = lPos.xyz - modelPos.xyz;\n    output.lRay = lRay;\n    \n    // Camera ray\n    output.view = eyePos.xyz - modelPos.xyz;\n\n    // Transform the vertex normal into world space.\n    float4 norm = float4(input.norm, 1.0f);\n    norm = mul(norm, model);\n    output.norm = norm.xyz;\n    \n    // Pass through the color and texture coordinates without modification.\n    output.color = input.color;\n    output.tex = input.tex;\n\n    return output;\n}\n```\n\nNext, the pixel shader will use the interpolated light space position provided by the vertex shader to test whether the pixel is in shadow.\n\n## Test whether the position is in the light frustum\n\n\nFirst, check that the pixel is in the view frustum of the light by normalizing the X and Y coordinates. If they are both within the range \\[0, 1\\] then it's possible for the pixel to be in shadow. Otherwise you can skip the depth test. A shader can test for this quickly by calling [Saturate](https://msdn.microsoft.com/library/windows/desktop/hh447231) and comparing the result against the original value.\n\n```cpp\n// Compute texture coordinates for the current point's location on the shadow map.\nfloat2 shadowTexCoords;\nshadowTexCoords.x = 0.5f + (input.lightSpacePos.x / input.lightSpacePos.w * 0.5f);\nshadowTexCoords.y = 0.5f - (input.lightSpacePos.y / input.lightSpacePos.w * 0.5f);\nfloat pixelDepth = input.lightSpacePos.z / input.lightSpacePos.w;\n\nfloat lighting = 1;\n\n// Check if the pixel texture coordinate is in the view frustum of the \n// light before doing any shadow work.\nif ((saturate(shadowTexCoords.x) == shadowTexCoords.x) &&\n    (saturate(shadowTexCoords.y) == shadowTexCoords.y) &&\n    (pixelDepth > 0))\n{\n```\n\n## Depth test against the shadow map\n\n\nUse a sample comparison function (either [SampleCmp](https://msdn.microsoft.com/library/windows/desktop/bb509696) or [SampleCmpLevelZero](https://msdn.microsoft.com/library/windows/desktop/bb509697)) to test the pixel's depth in light space against the depth map. Compute the normalized light space depth value, which is `z / w`, and pass the value to the comparison function. Since we use a LessOrEqual comparison test for the sampler, the intrinsic function returns zero when the comparison test passes; this indicates that the pixel is in shadow.\n\n```cpp\n// Use an offset value to mitigate shadow artifacts due to imprecise \n// floating-point values (shadow acne).\n//\n// This is an approximation of epsilon * tan(acos(saturate(NdotL))):\nfloat margin = acos(saturate(NdotL));\n#ifdef LINEAR\n// The offset can be slightly smaller with smoother shadow edges.\nfloat epsilon = 0.0005 / margin;\n#else\nfloat epsilon = 0.001 / margin;\n#endif\n// Clamp epsilon to a fixed range so it doesn't go overboard.\nepsilon = clamp(epsilon, 0, 0.1);\n\n// Use the SampleCmpLevelZero Texture2D method (or SampleCmp) to sample from \n// the shadow map, just as you would with Direct3D feature level 10_0 and\n// higher.  Feature level 9_1 only supports LessOrEqual, which returns 0 if\n// the pixel is in the shadow.\nlighting = float(shadowMap.SampleCmpLevelZero(\n    shadowSampler,\n    shadowTexCoords,\n    pixelDepth + epsilon\n    )\n    );\n```\n\n## Compute lighting in or out of shadow\n\n\nIf the pixel is not in shadow, the pixel shader should compute direct lighting and add it to the pixel value.\n\n```cpp\nreturn float4(input.color * (ambient + DplusS(N, L, NdotL, input.view)), 1.f);\n```\n\n```cpp\nfloat3 DplusS(float3 N, float3 L, float NdotL, float3 view)\n{\n    const float3 Kdiffuse = float3(.5f, .5f, .4f);\n    const float3 Kspecular = float3(.2f, .2f, .3f);\n    const float exponent = 3.f;\n\n    // Compute the diffuse coefficient.\n    float diffuseConst = saturate(NdotL);\n\n    // Compute the diffuse lighting value.\n    float3 diffuse = Kdiffuse * diffuseConst;\n\n    // Compute the specular highlight.\n    float3 R = reflect(-L, N);\n    float3 V = normalize(view);\n    float3 RdotV = dot(R, V);\n    float3 specular = Kspecular * pow(saturate(RdotV), exponent);\n\n    return (diffuse + specular);\n}\n```\n\nOtherwise, the pixel shader should compute the pixel value using ambient lighting.\n\n```cpp\nreturn float4(input.color * ambient, 1.f);\n```\n\nIn the next part of this walkthrough, learn how to [Support shadow maps on a range of hardware](target-a-range-of-hardware.md).\n\n \n\n \n\n\n\n\n"}