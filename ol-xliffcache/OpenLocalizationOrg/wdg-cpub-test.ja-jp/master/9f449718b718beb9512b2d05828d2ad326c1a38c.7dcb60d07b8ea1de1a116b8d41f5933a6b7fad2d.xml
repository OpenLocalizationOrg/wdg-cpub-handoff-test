{"nodes":[{"pos":[17,169],"content":"Receive, process, and manage input data from pointing devices, such as touch, mouse, pen/stylus, and touchpad, in Universal Windows Platform (UWP) apps.","needQuote":true,"needEscape":true,"nodes":[{"content":"Receive, process, and manage input data from pointing devices, such as touch, mouse, pen/stylus, and touchpad, in Universal Windows Platform (UWP) apps.","pos":[0,152]}]},{"pos":[177,197],"content":"Handle pointer input","needQuote":true,"needEscape":true,"nodes":[{"content":"Handle pointer input","pos":[0,20]}]},{"content":"Handle pointer input","pos":[303,323]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[326,364]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[365,460],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Receive, process, and manage input data from pointing devices, such as touch, mouse, pen/stylus, and touchpad, in Universal Windows Platform (UWP) apps.","pos":[463,615]},{"content":"Important APIs","pos":[619,633]},{"content":"Windows.Devices.Input","pos":[644,665]},{"content":"Windows.UI.Input","pos":[734,750]},{"content":"Windows.UI.Xaml.Input","pos":[819,840]},{"content":"Important","pos":[906,915]},{"content":"If you implement your own interaction support, keep in mind that users expect an intuitive experience involving direct interaction with the UI elements in your app.","pos":[920,1084]},{"content":"We recommend that you model your custom interactions on the <bpt id=\"p1\">[</bpt>Controls list<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt185406)</ept> to keep things consistent and discoverable.","pos":[1085,1262],"source":" We recommend that you model your custom interactions on the [Controls list](https://msdn.microsoft.com/library/windows/apps/mt185406) to keep things consistent and discoverable."},{"content":"The platform controls provide the full Universal Windows Platform (UWP) user interaction experience, including standard interactions, animated physics effects, visual feedback, and accessibility.","pos":[1263,1458]},{"content":"Create custom interactions only if there is a clear, well-defined requirement and basic interactions don't support your scenario.","pos":[1459,1588]},{"pos":[1675,1683],"content":"Pointers"},{"content":"Many interaction experiences involve the user identifying the object they want to interact with by pointing at it using input devices such as touch, mouse, pen/stylus, and touchpad.","pos":[1686,1867]},{"content":"Because the raw Human Interface Device (HID) data provided by these input devices includes many common properties, the info is promoted into a unified input stack and exposed as consolidated, device-agnostic pointer data.","pos":[1868,2089]},{"content":"Your UWP apps can then consume this data without worrying about the input device being used.","pos":[2090,2182]},{"pos":[2184,2281],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  Device-specific info is also promoted from the raw HID data should your app require it.","source":"**Note**  Device-specific info is also promoted from the raw HID data should your app require it."},{"content":"Each input point (or contact) on the input stack is represented by a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Pointer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227968)</ept> object exposed through the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>PointerRoutedEventArgs<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh943076)</ept> parameter provided by various pointer events.","pos":[2286,2586],"source":"Each input point (or contact) on the input stack is represented by a [**Pointer**](https://msdn.microsoft.com/library/windows/apps/br227968) object exposed through the [**PointerRoutedEventArgs**](https://msdn.microsoft.com/library/windows/apps/hh943076) parameter provided by various pointer events."},{"content":"In the case of multi-pen or multi-touch input, each contact is treated as a unique input point.","pos":[2587,2682]},{"pos":[2786,2800],"content":"Pointer events"},{"content":"Pointer events expose basic info such as detection state (in range or in contact) and device type, and extended info such as location, pressure, and contact geometry.","pos":[2803,2969]},{"content":"In addition, specific device properties such as which mouse button a user pressed or whether the pen eraser tip is being used are also available.","pos":[2970,3115]},{"content":"If your app needs to differentiate between input devices and their capabilities, see <bpt id=\"p1\">[</bpt>Identify input devices<ept id=\"p1\">](identify-input-devices.md)</ept>.","pos":[3116,3253],"source":" If your app needs to differentiate between input devices and their capabilities, see [Identify input devices](identify-input-devices.md)."},{"content":"UWP apps can listen for the following pointer events:","pos":[3255,3308]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  Call <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>CapturePointer<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208918)</ept> to constrain pointer input to a specific UI element.","pos":[3310,3456],"source":"**Note**  Call [**CapturePointer**](https://msdn.microsoft.com/library/windows/apps/br208918) to constrain pointer input to a specific UI element."},{"content":"When a pointer is captured by an element, only that object receives the pointer input events, even when the pointer moves outside the bounding area of the object.","pos":[3457,3619]},{"content":"You typically capture the pointer within a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerPressed<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208971)</ept> event handler as <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>IsInContact<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227976)</ept> (mouse button pressed, touch or stylus in contact) must be true for <bpt id=\"p5\">**</bpt>CapturePointer<ept id=\"p5\">**</ept> to be successful.","pos":[3620,3939],"source":" You typically capture the pointer within a [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208971) event handler as [**IsInContact**](https://msdn.microsoft.com/library/windows/apps/br227976) (mouse button pressed, touch or stylus in contact) must be true for **CapturePointer** to be successful."},{"content":"Event","pos":[4060,4065]},{"content":"Description","pos":[4088,4099]},{"content":"[<ph id=\"ph1\">&lt;strong&gt;</ph>PointerCanceled<ph id=\"ph2\">&lt;/strong&gt;</ph>](https://msdn.microsoft.com/library/windows/apps/br208964)","pos":[4267,4359],"source":"[<strong>PointerCanceled</strong>](https://msdn.microsoft.com/library/windows/apps/br208964)"},{"content":"Occurs when a pointer is canceled by the platform.","pos":[4389,4439]},{"content":"Touch pointers are canceled when a pen is detected within range of the input surface.","pos":[4453,4538]},{"content":"An active contact is not detected for more than 100 ms.","pos":[4548,4603]},{"content":"Monitor/display is changed (resolution, settings, multi-mon configuration).","pos":[4613,4688]},{"content":"The desktop is locked or the user has logged off.","pos":[4698,4747]},{"content":"The number of simultaneous contacts exceeded the number supported by the device.","pos":[4757,4837]},{"content":"[<ph id=\"ph1\">&lt;strong&gt;</ph>PointerCaptureLost<ph id=\"ph2\">&lt;/strong&gt;</ph>](https://msdn.microsoft.com/library/windows/apps/br208965)","pos":[5009,5104],"source":"[<strong>PointerCaptureLost</strong>](https://msdn.microsoft.com/library/windows/apps/br208965)"},{"content":"Occurs when another UI element captures the pointer, the pointer was released, or another pointer was programmatically captured.","pos":[5134,5262]},{"content":"Note<ph id=\"ph1\">&lt;/strong&gt;</ph>  There is no corresponding pointer capture event.","pos":[5295,5358],"source":"Note</strong>  There is no corresponding pointer capture event."},{"content":"[<ph id=\"ph1\">&lt;strong&gt;</ph>PointerEntered<ph id=\"ph2\">&lt;/strong&gt;</ph>](https://msdn.microsoft.com/library/windows/apps/br208968)","pos":[5528,5619],"source":"[<strong>PointerEntered</strong>](https://msdn.microsoft.com/library/windows/apps/br208968)"},{"content":"Occurs when a pointer enters the bounding area of an element.","pos":[5649,5710]},{"content":"This can happen in slightly different ways for touch, touchpad, mouse, and pen input.","pos":[5711,5796]},{"content":"Touch requires a finger contact to fire this event, either from a direct touch down on the element or from moving into the bounding area of the element.","pos":[5810,5962]},{"content":"Mouse and touchpad both have an on-screen cursor that is always visible and fires this event even if no mouse or touchpad button is pressed.","pos":[5972,6112]},{"content":"Like touch, pen fires this event with a direct pen down on the element or from moving into the bounding area of the element.","pos":[6122,6246]},{"content":"However, pen also has a hover state ([<ph id=\"ph1\">&lt;strong&gt;</ph>IsInRange<ph id=\"ph2\">&lt;/strong&gt;</ph>](https://msdn.microsoft.com/library/windows/apps/br227977)) that, when true, fires this event.","pos":[6247,6406],"source":" However, pen also has a hover state ([<strong>IsInRange</strong>](https://msdn.microsoft.com/library/windows/apps/br227977)) that, when true, fires this event."},{"content":"[<ph id=\"ph1\">&lt;strong&gt;</ph>PointerExited<ph id=\"ph2\">&lt;/strong&gt;</ph>](https://msdn.microsoft.com/library/windows/apps/br208969)","pos":[6563,6653],"source":"[<strong>PointerExited</strong>](https://msdn.microsoft.com/library/windows/apps/br208969)"},{"content":"Occurs when a pointer leaves the bounding area of an element.","pos":[6683,6744]},{"content":"This can happen in slightly different ways for touch, touchpad, mouse, and pen input.","pos":[6745,6830]},{"content":"Touch requires a finger contact and fires this event when the pointer moves out of the bounding area of the element.","pos":[6844,6960]},{"content":"Mouse and touchpad both have an on-screen cursor that is always visible and fires this event even if no mouse or touchpad button is pressed.","pos":[6970,7110]},{"content":"Like touch, pen fires this event when moving out of the bounding area of the element.","pos":[7120,7205]},{"content":"However, pen also has a hover state ([<ph id=\"ph1\">&lt;strong&gt;</ph>IsInRange<ph id=\"ph2\">&lt;/strong&gt;</ph>](https://msdn.microsoft.com/library/windows/apps/br227977)) that fires this event when the state changes from true to false.","pos":[7206,7395],"source":" However, pen also has a hover state ([<strong>IsInRange</strong>](https://msdn.microsoft.com/library/windows/apps/br227977)) that fires this event when the state changes from true to false."},{"content":"[<ph id=\"ph1\">&lt;strong&gt;</ph>PointerMoved<ph id=\"ph2\">&lt;/strong&gt;</ph>](https://msdn.microsoft.com/library/windows/apps/br208970)","pos":[7548,7637],"source":"[<strong>PointerMoved</strong>](https://msdn.microsoft.com/library/windows/apps/br208970)"},{"content":"Occurs when a pointer changes coordinates, button state, pressure, tilt, or contact geometry (for example, width and height) within the bounding area of an element.","pos":[7667,7831]},{"content":"This can happen in slightly different ways for touch, touchpad, mouse, and pen input.","pos":[7832,7917]},{"content":"Touch requires a finger contact and fires this event only when in contact within the bounding area of the element.","pos":[7931,8045]},{"content":"Mouse and touchpad both have an on-screen cursor that is always visible and fires this event even if no mouse or touchpad button is pressed.","pos":[8055,8195]},{"content":"Like touch, pen fires this event when in contact within the bounding area of the element.","pos":[8205,8294]},{"content":"However, pen also has a hover state ([<ph id=\"ph1\">&lt;strong&gt;</ph>IsInRange<ph id=\"ph2\">&lt;/strong&gt;</ph>](https://msdn.microsoft.com/library/windows/apps/br227977)) that, when true and within the bounding area of the element, fires this event.","pos":[8295,8498],"source":" However, pen also has a hover state ([<strong>IsInRange</strong>](https://msdn.microsoft.com/library/windows/apps/br227977)) that, when true and within the bounding area of the element, fires this event."},{"content":"[<ph id=\"ph1\">&lt;strong&gt;</ph>PointerPressed<ph id=\"ph2\">&lt;/strong&gt;</ph>](https://msdn.microsoft.com/library/windows/apps/br208971)","pos":[8658,8749],"source":"[<strong>PointerPressed</strong>](https://msdn.microsoft.com/library/windows/apps/br208971)"},{"content":"Occurs when the pointer indicates a press action (such as a touch down, mouse button down, pen down, or touchpad button down) within the bounding area of an element.","pos":[8779,8944]},{"content":"[<ph id=\"ph1\">&lt;strong&gt;</ph>CapturePointer<ph id=\"ph2\">&lt;/strong&gt;</ph>](https://msdn.microsoft.com/library/windows/apps/br208918) must be called from the handler for this event.","pos":[8952,9091],"source":"[<strong>CapturePointer</strong>](https://msdn.microsoft.com/library/windows/apps/br208918) must be called from the handler for this event."},{"content":"[<ph id=\"ph1\">&lt;strong&gt;</ph>PointerReleased<ph id=\"ph2\">&lt;/strong&gt;</ph>](https://msdn.microsoft.com/library/windows/apps/br208972)","pos":[9246,9338],"source":"[<strong>PointerReleased</strong>](https://msdn.microsoft.com/library/windows/apps/br208972)"},{"content":"Occurs when the pointer indicates a release action (such as a touch up, mouse button up, pen up, or touchpad button up) within the bounding area of an element or, if the pointer is captured, outside the bounding area.","pos":[9368,9585]},{"content":"[<ph id=\"ph1\">&lt;strong&gt;</ph>PointerWheelChanged<ph id=\"ph2\">&lt;/strong&gt;</ph>](https://msdn.microsoft.com/library/windows/apps/br208973)","pos":[9753,9849],"source":"[<strong>PointerWheelChanged</strong>](https://msdn.microsoft.com/library/windows/apps/br208973)"},{"content":"Occurs when the mouse wheel is rotated.","pos":[9879,9918]},{"content":"Mouse input is associated with a single pointer assigned when mouse input is first detected.","pos":[9926,10018]},{"content":"Clicking a mouse button (left, wheel, or right) creates a secondary association between the pointer and that button through the [<ph id=\"ph1\">&lt;strong&gt;</ph>PointerMoved<ph id=\"ph2\">&lt;/strong&gt;</ph>](https://msdn.microsoft.com/library/windows/apps/br208970) event.","pos":[10019,10243],"source":" Clicking a mouse button (left, wheel, or right) creates a secondary association between the pointer and that button through the [<strong>PointerMoved</strong>](https://msdn.microsoft.com/library/windows/apps/br208970) event."},{"pos":[10362,10369],"content":"Example"},{"content":"Here's some code examples from a basic pointer tracking app that show how to listen for and handle pointer events and get various properties for active pointers.","pos":[10372,10533]},{"pos":[10635,10648],"content":"Create the UI"},{"content":"For this example, we use a rectangle (<ph id=\"ph1\">`targetContainer`</ph>) as the target object for pointer input.","pos":[10650,10746],"source":"For this example, we use a rectangle (`targetContainer`) as the target object for pointer input."},{"content":"The color of the target changes when the pointer status changes.","pos":[10747,10811]},{"content":"Details for each pointer are displayed in a floating text block that moves with the pointer.","pos":[10813,10905]},{"content":"The pointer events themselves are displayed to the left of the rectangle (for reporting event sequence).","pos":[10906,11010]},{"content":"This is the Extensible Application Markup Language (XAML) for this example.","pos":[11012,11087]},{"pos":[13158,13183],"content":"Listen for pointer events"},{"pos":[13185,13359],"content":"In most cases, we recommend that you get pointer info through the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerRoutedEventArgs<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh943076)</ept> of the event handler.","source":"In most cases, we recommend that you get pointer info through the [**PointerRoutedEventArgs**](https://msdn.microsoft.com/library/windows/apps/hh943076) of the event handler."},{"pos":[13361,13829],"content":"If the event argument doesn't expose the pointer details required, you can get access to extended <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerPoint<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242038)</ept> info exposed through the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>GetCurrentPoint<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh943077)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>GetIntermediatePoints<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/hh943078)</ept> methods of <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>PointerRoutedEventArgs<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/hh943076)</ept>.","source":"If the event argument doesn't expose the pointer details required, you can get access to extended [**PointerPoint**](https://msdn.microsoft.com/library/windows/apps/br242038) info exposed through the [**GetCurrentPoint**](https://msdn.microsoft.com/library/windows/apps/hh943077) and [**GetIntermediatePoints**](https://msdn.microsoft.com/library/windows/apps/hh943078) methods of [**PointerRoutedEventArgs**](https://msdn.microsoft.com/library/windows/apps/hh943076)."},{"content":"For this example, we use a rectangle (<ph id=\"ph1\">`targetContainer`</ph>) as the target object for pointer input.","pos":[13831,13927],"source":"For this example, we use a rectangle (`targetContainer`) as the target object for pointer input."},{"content":"The color of the target changes when the pointer status changes.","pos":[13928,13992]},{"content":"The following code sets up the target object, declares global variables, and identifies the various pointer event listeners for the target.","pos":[13994,14133]},{"pos":[16229,16250],"content":"Handle pointer events"},{"content":"Next, we use UI feedback to demonstrate basic pointer event handlers.","pos":[16252,16321]},{"content":"This handler manages a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerPressed<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208971)</ept> event.","pos":[16327,16435],"source":"This handler manages a [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208971) event."},{"content":"We add the event to the event log, add the pointer to the pointer array used for tracking the pointers of interest, and display the pointer details.","pos":[16436,16584]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>PointerPressed<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208971)</ept> and <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>PointerReleased<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br208972)</ept> events do not always occur in pairs.","pos":[16590,16799],"source":"**Note**  [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208971) and [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208972) events do not always occur in pairs."},{"content":"Your app should listen for and handle any event that might conclude a pointer down action (such as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerExited<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208969)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>PointerCanceled<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208964)</ept>, and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>PointerCaptureLost<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208965)</ept>).","pos":[16800,17147],"source":" Your app should listen for and handle any event that might conclude a pointer down action (such as [**PointerExited**](https://msdn.microsoft.com/library/windows/apps/br208969), [**PointerCanceled**](https://msdn.microsoft.com/library/windows/apps/br208964), and [**PointerCaptureLost**](https://msdn.microsoft.com/library/windows/apps/br208965))."},{"content":"This handler manages a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerEntered<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208968)</ept> event.","pos":[18949,19057],"source":"This handler manages a [**PointerEntered**](https://msdn.microsoft.com/library/windows/apps/br208968) event."},{"content":"We add the event to the event log, add the pointer to the pointer collection, and display the pointer details.","pos":[19058,19168]},{"content":"This handler manages a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerMoved<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208970)</ept> event.","pos":[20272,20378],"source":"This handler manages a [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208970) event."},{"content":"We add the event to the event log and update the pointer details.","pos":[20379,20444]},{"content":"<bpt id=\"p1\">**</bpt>Important<ept id=\"p1\">**</ept>  Mouse input is associated with a single pointer assigned when mouse input is first detected.","pos":[20450,20557],"source":"**Important**  Mouse input is associated with a single pointer assigned when mouse input is first detected."},{"content":"Clicking a mouse button (left, wheel, or right) creates a secondary association between the pointer and that button through the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerPressed<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208971)</ept> event.","pos":[20558,20771],"source":" Clicking a mouse button (left, wheel, or right) creates a secondary association between the pointer and that button through the [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208971) event."},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerReleased<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208972)</ept> event is fired only when that same mouse button is released (no other button can be associated with the pointer until this event is complete).","pos":[20772,20998],"source":" The [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208972) event is fired only when that same mouse button is released (no other button can be associated with the pointer until this event is complete)."},{"content":"Because of this exclusive association, other mouse button clicks are routed through the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerMoved<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208970)</ept> event.","pos":[20999,21170],"source":" Because of this exclusive association, other mouse button clicks are routed through the [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208970) event."},{"content":"This handler manages a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerWheelChanged<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208973)</ept> event.","pos":[23088,23201],"source":"This handler manages a [**PointerWheelChanged**](https://msdn.microsoft.com/library/windows/apps/br208973) event."},{"content":"We add the event to the event log, add the pointer to the pointer array (if necessary), and display the pointer details.","pos":[23202,23322]},{"content":"This handler manages a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerReleased<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208972)</ept> event where contact with the digitizer is terminated.","pos":[24057,24213],"source":"This handler manages a [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208972) event where contact with the digitizer is terminated."},{"content":"We add the event to the event log, remove the pointer from the pointer collection, and update the pointer details.","pos":[24214,24328]},{"content":"This handler manages a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerExited<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208969)</ept> event where contact with the digitizer is maintained.","pos":[25802,25956],"source":"This handler manages a [**PointerExited**](https://msdn.microsoft.com/library/windows/apps/br208969) event where contact with the digitizer is maintained."},{"content":"We add the event to the event log, remove the pointer from the pointer array, and update the pointer details.","pos":[25957,26066]},{"content":"This handler manages a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerCanceled<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208964)</ept> event.","pos":[26891,27000],"source":"This handler manages a [**PointerCanceled**](https://msdn.microsoft.com/library/windows/apps/br208964) event."},{"content":"We add the event to the event log, remove the pointer from the pointer array, and update the pointer details.","pos":[27001,27110]},{"content":"This handler manages a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerCaptureLost<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208965)</ept> event.","pos":[28245,28357],"source":"This handler manages a [**PointerCaptureLost**](https://msdn.microsoft.com/library/windows/apps/br208965) event."},{"content":"We add the event to the event log, remove the pointer from the pointer array, and update the pointer details.","pos":[28358,28467]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>PointerCaptureLost<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208965)</ept> can occur instead of <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>PointerReleased<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br208972)</ept>.","pos":[28473,28667],"source":"**Note**  [**PointerCaptureLost**](https://msdn.microsoft.com/library/windows/apps/br208965) can occur instead of [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208972)."},{"content":"Pointer capture can be lost for various reasons.","pos":[28668,28716]},{"pos":[29880,29902],"content":"Get pointer properties"},{"pos":[29904,30360],"content":"As stated earlier, you must get most extended pointer info from a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.UI.Input.PointerPoint<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242038)</ept> object obtained through the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>GetCurrentPoint<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh943077)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>GetIntermediatePoints<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/hh943078)</ept> methods of <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>PointerRoutedEventArgs<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/hh943076)</ept>.","source":"As stated earlier, you must get most extended pointer info from a [**Windows.UI.Input.PointerPoint**](https://msdn.microsoft.com/library/windows/apps/br242038) object obtained through the [**GetCurrentPoint**](https://msdn.microsoft.com/library/windows/apps/hh943077) and [**GetIntermediatePoints**](https://msdn.microsoft.com/library/windows/apps/hh943078) methods of [**PointerRoutedEventArgs**](https://msdn.microsoft.com/library/windows/apps/hh943076)."},{"pos":[30366,30480],"content":"First, we create a new <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TextBlock<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209652)</ept> for each pointer.","source":"First, we create a new [**TextBlock**](https://msdn.microsoft.com/library/windows/apps/br209652) for each pointer."},{"pos":[31207,31374],"content":"Then we provide a way to update the pointer info in an existing <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TextBlock<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209652)</ept> associated with that pointer.","source":"Then we provide a way to update the pointer info in an existing [**TextBlock**](https://msdn.microsoft.com/library/windows/apps/br209652) associated with that pointer."},{"content":"Finally, we query various pointer properties.","pos":[32588,32633]},{"pos":[34880,34896],"content":"Complete example"},{"content":"The following is the C# code for this example.","pos":[34898,34944]},{"content":"For links to more complex samples, see Related articles at the bottom of this page .","pos":[34945,35029]},{"pos":[52304,52320],"content":"Related articles"},{"content":"Samples","pos":[52325,52332]},{"content":"Basic input sample","pos":[52338,52356]},{"content":"Low latency input sample","pos":[52410,52434]},{"content":"User interaction mode sample","pos":[52488,52516]},{"pos":[52569,52660],"content":"<bpt id=\"p1\">[</bpt>Focus visuals sample<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=619895)</ept><ph id=\"ph1\">\n</ph><bpt id=\"p2\">**</bpt>Archive samples<ept id=\"p2\">**</ept>","source":"[Focus visuals sample](http://go.microsoft.com/fwlink/p/?LinkID=619895)\n**Archive samples**"},{"content":"Input: XAML user input events sample","pos":[52664,52700]},{"content":"Input: Device capabilities sample","pos":[52754,52787]},{"content":"Input: Manipulations and gestures (C++) sample","pos":[52841,52887]},{"content":"Input: Touch hit testing sample","pos":[52941,52972]},{"content":"XAML scrolling, panning, and zooming sample","pos":[53026,53069]},{"content":"Input: Simplified ink sample","pos":[53123,53151]}],"content":"---\nDescription: Receive, process, and manage input data from pointing devices, such as touch, mouse, pen/stylus, and touchpad, in Universal Windows Platform (UWP) apps.\ntitle: Handle pointer input\nms.assetid: BDBC9E33-4037-4671-9596-471DCF855C82\nlabel: Handle pointer input\ntemplate: detail.hbs\n---\n\n# Handle pointer input\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\nReceive, process, and manage input data from pointing devices, such as touch, mouse, pen/stylus, and touchpad, in Universal Windows Platform (UWP) apps.\n\n**Important APIs**\n\n-   [**Windows.Devices.Input**](https://msdn.microsoft.com/library/windows/apps/br225648)\n-   [**Windows.UI.Input**](https://msdn.microsoft.com/library/windows/apps/br208383)\n-   [**Windows.UI.Xaml.Input**](https://msdn.microsoft.com/library/windows/apps/br242084)\n\n\n**Important**  \nIf you implement your own interaction support, keep in mind that users expect an intuitive experience involving direct interaction with the UI elements in your app. We recommend that you model your custom interactions on the [Controls list](https://msdn.microsoft.com/library/windows/apps/mt185406) to keep things consistent and discoverable. The platform controls provide the full Universal Windows Platform (UWP) user interaction experience, including standard interactions, animated physics effects, visual feedback, and accessibility. Create custom interactions only if there is a clear, well-defined requirement and basic interactions don't support your scenario.\n\n\n## <span id=\"Pointers\"></span><span id=\"pointers\"></span><span id=\"POINTERS\"></span>Pointers\n\n\nMany interaction experiences involve the user identifying the object they want to interact with by pointing at it using input devices such as touch, mouse, pen/stylus, and touchpad. Because the raw Human Interface Device (HID) data provided by these input devices includes many common properties, the info is promoted into a unified input stack and exposed as consolidated, device-agnostic pointer data. Your UWP apps can then consume this data without worrying about the input device being used.\n\n**Note**  Device-specific info is also promoted from the raw HID data should your app require it.\n\n \n\nEach input point (or contact) on the input stack is represented by a [**Pointer**](https://msdn.microsoft.com/library/windows/apps/br227968) object exposed through the [**PointerRoutedEventArgs**](https://msdn.microsoft.com/library/windows/apps/hh943076) parameter provided by various pointer events. In the case of multi-pen or multi-touch input, each contact is treated as a unique input point.\n\n## <span id=\"Pointer_events\"></span><span id=\"pointer_events\"></span><span id=\"POINTER_EVENTS\"></span>Pointer events\n\n\nPointer events expose basic info such as detection state (in range or in contact) and device type, and extended info such as location, pressure, and contact geometry. In addition, specific device properties such as which mouse button a user pressed or whether the pen eraser tip is being used are also available. If your app needs to differentiate between input devices and their capabilities, see [Identify input devices](identify-input-devices.md).\n\nUWP apps can listen for the following pointer events:\n\n**Note**  Call [**CapturePointer**](https://msdn.microsoft.com/library/windows/apps/br208918) to constrain pointer input to a specific UI element. When a pointer is captured by an element, only that object receives the pointer input events, even when the pointer moves outside the bounding area of the object. You typically capture the pointer within a [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208971) event handler as [**IsInContact**](https://msdn.microsoft.com/library/windows/apps/br227976) (mouse button pressed, touch or stylus in contact) must be true for **CapturePointer** to be successful.\n\n \n\n<table>\n<colgroup>\n<col width=\"50%\" />\n<col width=\"50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th align=\"left\">Event</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td align=\"left\"><p><span id=\"PointerCanceled\"></span><span id=\"pointercanceled\"></span><span id=\"POINTERCANCELED\"></span>[<strong>PointerCanceled</strong>](https://msdn.microsoft.com/library/windows/apps/br208964)</p></td>\n<td align=\"left\"><p>Occurs when a pointer is canceled by the platform.</p>\n<ul>\n<li>Touch pointers are canceled when a pen is detected within range of the input surface.</li>\n<li>An active contact is not detected for more than 100 ms.</li>\n<li>Monitor/display is changed (resolution, settings, multi-mon configuration).</li>\n<li>The desktop is locked or the user has logged off.</li>\n<li>The number of simultaneous contacts exceeded the number supported by the device.</li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p><span id=\"PointerCaptureLost\"></span><span id=\"pointercapturelost\"></span><span id=\"POINTERCAPTURELOST\"></span>[<strong>PointerCaptureLost</strong>](https://msdn.microsoft.com/library/windows/apps/br208965)</p></td>\n<td align=\"left\"><p>Occurs when another UI element captures the pointer, the pointer was released, or another pointer was programmatically captured.</p>\n<div class=\"alert\">\n<strong>Note</strong>  There is no corresponding pointer capture event.\n</div>\n<div>\n \n</div></td>\n</tr>\n<tr class=\"odd\">\n<td align=\"left\"><p><span id=\"PointerEntered\"></span><span id=\"pointerentered\"></span><span id=\"POINTERENTERED\"></span>[<strong>PointerEntered</strong>](https://msdn.microsoft.com/library/windows/apps/br208968)</p></td>\n<td align=\"left\"><p>Occurs when a pointer enters the bounding area of an element. This can happen in slightly different ways for touch, touchpad, mouse, and pen input.</p>\n<ul>\n<li>Touch requires a finger contact to fire this event, either from a direct touch down on the element or from moving into the bounding area of the element.</li>\n<li>Mouse and touchpad both have an on-screen cursor that is always visible and fires this event even if no mouse or touchpad button is pressed.</li>\n<li>Like touch, pen fires this event with a direct pen down on the element or from moving into the bounding area of the element. However, pen also has a hover state ([<strong>IsInRange</strong>](https://msdn.microsoft.com/library/windows/apps/br227977)) that, when true, fires this event.</li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p><span id=\"PointerExited\"></span><span id=\"pointerexited\"></span><span id=\"POINTEREXITED\"></span>[<strong>PointerExited</strong>](https://msdn.microsoft.com/library/windows/apps/br208969)</p></td>\n<td align=\"left\"><p>Occurs when a pointer leaves the bounding area of an element. This can happen in slightly different ways for touch, touchpad, mouse, and pen input.</p>\n<ul>\n<li>Touch requires a finger contact and fires this event when the pointer moves out of the bounding area of the element.</li>\n<li>Mouse and touchpad both have an on-screen cursor that is always visible and fires this event even if no mouse or touchpad button is pressed.</li>\n<li>Like touch, pen fires this event when moving out of the bounding area of the element. However, pen also has a hover state ([<strong>IsInRange</strong>](https://msdn.microsoft.com/library/windows/apps/br227977)) that fires this event when the state changes from true to false.</li>\n</ul></td>\n</tr>\n<tr class=\"odd\">\n<td align=\"left\"><p><span id=\"PointerMoved\"></span><span id=\"pointermoved\"></span><span id=\"POINTERMOVED\"></span>[<strong>PointerMoved</strong>](https://msdn.microsoft.com/library/windows/apps/br208970)</p></td>\n<td align=\"left\"><p>Occurs when a pointer changes coordinates, button state, pressure, tilt, or contact geometry (for example, width and height) within the bounding area of an element. This can happen in slightly different ways for touch, touchpad, mouse, and pen input.</p>\n<ul>\n<li>Touch requires a finger contact and fires this event only when in contact within the bounding area of the element.</li>\n<li>Mouse and touchpad both have an on-screen cursor that is always visible and fires this event even if no mouse or touchpad button is pressed.</li>\n<li>Like touch, pen fires this event when in contact within the bounding area of the element. However, pen also has a hover state ([<strong>IsInRange</strong>](https://msdn.microsoft.com/library/windows/apps/br227977)) that, when true and within the bounding area of the element, fires this event.</li>\n</ul></td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p><span id=\"PointerPressed\"></span><span id=\"pointerpressed\"></span><span id=\"POINTERPRESSED\"></span>[<strong>PointerPressed</strong>](https://msdn.microsoft.com/library/windows/apps/br208971)</p></td>\n<td align=\"left\"><p>Occurs when the pointer indicates a press action (such as a touch down, mouse button down, pen down, or touchpad button down) within the bounding area of an element.</p>\n<p>[<strong>CapturePointer</strong>](https://msdn.microsoft.com/library/windows/apps/br208918) must be called from the handler for this event.</p></td>\n</tr>\n<tr class=\"odd\">\n<td align=\"left\"><p><span id=\"PointerReleased\"></span><span id=\"pointerreleased\"></span><span id=\"POINTERRELEASED\"></span>[<strong>PointerReleased</strong>](https://msdn.microsoft.com/library/windows/apps/br208972)</p></td>\n<td align=\"left\"><p>Occurs when the pointer indicates a release action (such as a touch up, mouse button up, pen up, or touchpad button up) within the bounding area of an element or, if the pointer is captured, outside the bounding area.</p></td>\n</tr>\n<tr class=\"even\">\n<td align=\"left\"><p><span id=\"PointerWheelChanged\"></span><span id=\"pointerwheelchanged\"></span><span id=\"POINTERWHEELCHANGED\"></span>[<strong>PointerWheelChanged</strong>](https://msdn.microsoft.com/library/windows/apps/br208973)</p></td>\n<td align=\"left\"><p>Occurs when the mouse wheel is rotated.</p>\n<p>Mouse input is associated with a single pointer assigned when mouse input is first detected. Clicking a mouse button (left, wheel, or right) creates a secondary association between the pointer and that button through the [<strong>PointerMoved</strong>](https://msdn.microsoft.com/library/windows/apps/br208970) event.</p></td>\n</tr>\n</tbody>\n</table>\n\n \n\n## <span id=\"Example\"></span><span id=\"example\"></span><span id=\"EXAMPLE\"></span>Example\n\n\nHere's some code examples from a basic pointer tracking app that show how to listen for and handle pointer events and get various properties for active pointers.\n\n### <span id=\"Create_the_UI\"></span><span id=\"create_the_ui\"></span><span id=\"CREATE_THE_UI\"></span>Create the UI\n\nFor this example, we use a rectangle (`targetContainer`) as the target object for pointer input. The color of the target changes when the pointer status changes.\n\nDetails for each pointer are displayed in a floating text block that moves with the pointer. The pointer events themselves are displayed to the left of the rectangle (for reporting event sequence).\n\nThis is the Extensible Application Markup Language (XAML) for this example.\n\n```XAML\n<Page\n    x:Class=\"PointerInput.MainPage\"\n    IsTabStop=\"false\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:PointerInput\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"d\"\n    Name=\"page\">\n\n    <Grid Background=\"{StaticResource ApplicationForegroundThemeBrush}\">\n        <Grid.ColumnDefinitions>\n            <ColumnDefinition Width=\"*\" />\n            <ColumnDefinition Width=\"69.458\" />\n            <ColumnDefinition Width=\"80.542\"/>\n        </Grid.ColumnDefinitions>\n        <Grid.RowDefinitions>\n            <RowDefinition Height=\"*\" />\n            <RowDefinition Height=\"320\" />\n            <RowDefinition Height=\"*\"/>\n        </Grid.RowDefinitions>\n        <Canvas Name=\"Container\" \n                Grid.Column=\"0\"\n                Grid.Row=\"1\"\n                HorizontalAlignment=\"Center\" \n                VerticalAlignment=\"Center\" \n                Margin=\"245,0\" \n                Height=\"320\"  Width=\"640\">\n            <Rectangle Name=\"Target\" \n                       Fill=\"#FF0000\" \n                       Stroke=\"Black\" \n                       StrokeThickness=\"0\"\n                       Height=\"320\" Width=\"640\" />\n        </Canvas>\n        <Button Name=\"buttonClear\"\n                Foreground=\"White\"\n                Width=\"100\"\n                Height=\"100\">\n            clear\n        </Button>\n        <TextBox Name=\"eventLog\" \n                 Grid.Column=\"1\"\n                 Grid.Row=\"0\"\n                 Grid.RowSpan=\"3\" \n                 Background=\"#000000\" \n                 TextWrapping=\"Wrap\" \n                 Foreground=\"#FFFFFF\" \n                 ScrollViewer.VerticalScrollBarVisibility=\"Visible\" \n                 BorderThickness=\"0\" Grid.ColumnSpan=\"2\"/>\n    </Grid>\n</Page>\n```\n\n### <span id=\"Listen_for_pointer_events\"></span><span id=\"listen_for_pointer_events\"></span><span id=\"LISTEN_FOR_POINTER_EVENTS\"></span>Listen for pointer events\n\nIn most cases, we recommend that you get pointer info through the [**PointerRoutedEventArgs**](https://msdn.microsoft.com/library/windows/apps/hh943076) of the event handler.\n\nIf the event argument doesn't expose the pointer details required, you can get access to extended [**PointerPoint**](https://msdn.microsoft.com/library/windows/apps/br242038) info exposed through the [**GetCurrentPoint**](https://msdn.microsoft.com/library/windows/apps/hh943077) and [**GetIntermediatePoints**](https://msdn.microsoft.com/library/windows/apps/hh943078) methods of [**PointerRoutedEventArgs**](https://msdn.microsoft.com/library/windows/apps/hh943076).\n\nFor this example, we use a rectangle (`targetContainer`) as the target object for pointer input. The color of the target changes when the pointer status changes.\n\nThe following code sets up the target object, declares global variables, and identifies the various pointer event listeners for the target.\n\n```CSharp\n        // For this example, we track simultaneous contacts in case the \n        // number of contacts has reached the maximum supported by the device.\n        // Depending on the device, additional contacts might be ignored \n        // (PointerPressed not fired). \n        uint numActiveContacts;\n        Windows.Devices.Input.TouchCapabilities touchCapabilities = new Windows.Devices.Input.TouchCapabilities();\n\n        // Dictionary to maintain information about each active contact. \n        // An entry is added during PointerPressed/PointerEntered events and removed \n        // during PointerReleased/PointerCaptureLost/PointerCanceled/PointerExited events.\n        Dictionary<uint, Windows.UI.Xaml.Input.Pointer> contacts;\n\n        public MainPage()\n        {\n            this.InitializeComponent();\n            numActiveContacts = 0;\n            // Initialize the dictionary.\n            contacts = new Dictionary<uint, Windows.UI.Xaml.Input.Pointer>((int)touchCapabilities.Contacts);\n            // Declare the pointer event handlers.\n            Target.PointerPressed += new PointerEventHandler(Target_PointerPressed);\n            Target.PointerEntered += new PointerEventHandler(Target_PointerEntered);\n            Target.PointerReleased += new PointerEventHandler(Target_PointerReleased);\n            Target.PointerExited += new PointerEventHandler(Target_PointerExited);\n            Target.PointerCanceled += new PointerEventHandler(Target_PointerCanceled);\n            Target.PointerCaptureLost += new PointerEventHandler(Target_PointerCaptureLost);\n            Target.PointerMoved += new PointerEventHandler(Target_PointerMoved);\n            Target.PointerWheelChanged += new PointerEventHandler(Target_PointerWheelChanged);\n\n            buttonClear.Click += new RoutedEventHandler(ButtonClear_Click);\n        }\n\n        private void ButtonClear_Click(object sender, RoutedEventArgs e)\n        {\n            eventLog.Text = \"\";\n        }\n\n```\n\n### <span id=\"Handle_pointer_events\"></span><span id=\"handle_pointer_events\"></span><span id=\"HANDLE_POINTER_EVENTS\"></span>Handle pointer events\n\nNext, we use UI feedback to demonstrate basic pointer event handlers.\n\n-   This handler manages a [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208971) event. We add the event to the event log, add the pointer to the pointer array used for tracking the pointers of interest, and display the pointer details.\n\n    **Note**  [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208971) and [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208972) events do not always occur in pairs. Your app should listen for and handle any event that might conclude a pointer down action (such as [**PointerExited**](https://msdn.microsoft.com/library/windows/apps/br208969), [**PointerCanceled**](https://msdn.microsoft.com/library/windows/apps/br208964), and [**PointerCaptureLost**](https://msdn.microsoft.com/library/windows/apps/br208965)).\n\n     \n\n```    CSharp\n        // PointerPressed and PointerReleased events do not always occur in pairs. \n            // Your app should listen for and handle any event that might conclude a pointer down action \n            // (such as PointerExited, PointerCanceled, and PointerCaptureLost).\n            // For this example, we track the number of contacts in case the \n            // number of contacts has reached the maximum supported by the device.\n            // Depending on the device, additional contacts might be ignored \n            // (PointerPressed not fired). \n            void Target_PointerPressed(object sender, PointerRoutedEventArgs e)\n            {\n                Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n                // Update event sequence.\n                eventLog.Text += \"\\nDown: \" + ptr.PointerId;\n\n                // Change background color of target when pointer contact detected.\n                Target.Fill = new SolidColorBrush(Windows.UI.Colors.Green);\n\n                // Prevent most handlers along the event route from handling the same event again.\n                e.Handled = true;\n\n                // Lock the pointer to the target.\n                Target.CapturePointer(e.Pointer);\n\n                // Update event sequence.\n                eventLog.Text += \"\\nPointer captured: \" + ptr.PointerId;\n\n                // Check if pointer already exists (for example, enter occurred prior to press).\n                if (contacts.ContainsKey(ptr.PointerId))\n                {\n                    return;\n                }\n                // Add contact to dictionary.\n                contacts[ptr.PointerId] = ptr;\n                ++numActiveContacts;\n\n                // Display pointer details.\n                createInfoPop(e);\n            }\n```\n\n-   This handler manages a [**PointerEntered**](https://msdn.microsoft.com/library/windows/apps/br208968) event. We add the event to the event log, add the pointer to the pointer collection, and display the pointer details.\n\n```    CSharp\n        private void Target_PointerEntered(object sender, PointerRoutedEventArgs e)\n            {\n                Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n                // Update event sequence.\n                eventLog.Text += \"\\nEntered: \" + ptr.PointerId;\n\n                if (contacts.Count == 0)\n                {\n                    // Change background color of target when pointer contact detected.\n                    Target.Fill = new SolidColorBrush(Windows.UI.Colors.Blue);\n                }\n\n                // Check if pointer already exists (if enter occurred prior to down).\n                if (contacts.ContainsKey(ptr.PointerId))\n                {\n                    return;\n                }\n\n                // Add contact to dictionary.\n                contacts[ptr.PointerId] = ptr;\n                ++numActiveContacts;\n\n                // Prevent most handlers along the event route from handling the same event again.\n                e.Handled = true;\n\n                // Display pointer details.\n                createInfoPop(e);\n            }\n```\n\n-   This handler manages a [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208970) event. We add the event to the event log and update the pointer details.\n\n    **Important**  Mouse input is associated with a single pointer assigned when mouse input is first detected. Clicking a mouse button (left, wheel, or right) creates a secondary association between the pointer and that button through the [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208971) event. The [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208972) event is fired only when that same mouse button is released (no other button can be associated with the pointer until this event is complete). Because of this exclusive association, other mouse button clicks are routed through the [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208970) event.\n\n     \n\n```    CSharp\nprivate void Target_PointerMoved(object sender, PointerRoutedEventArgs e)\n    {\n        Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n        // Multiple, simultaneous mouse button inputs are processed here.\n        // Mouse input is associated with a single pointer assigned when \n        // mouse input is first detected. \n        // Clicking additional mouse buttons (left, wheel, or right) during \n        // the interaction creates secondary associations between those buttons \n        // and the pointer through the pointer pressed event. \n        // The pointer released event is fired only when the last mouse button \n        // associated with the interaction (not necessarily the initial button) \n        // is released. \n        // Because of this exclusive association, other mouse button clicks are \n        // routed through the pointer move event.          \n        if (ptr.PointerDeviceType == Windows.Devices.Input.PointerDeviceType.Mouse)\n        {\n            // To get mouse state, we need extended pointer details.\n            // We get the pointer info through the getCurrentPoint method\n            // of the event argument. \n            Windows.UI.Input.PointerPoint ptrPt = e.GetCurrentPoint(Target);\n            if (ptrPt.Properties.IsLeftButtonPressed)\n            {\n                eventLog.Text += \"\\nLeft button: \" + ptrPt.PointerId;\n            }\n            if (ptrPt.Properties.IsMiddleButtonPressed)\n            {\n                eventLog.Text += \"\\nWheel button: \" + ptrPt.PointerId;\n            }\n            if (ptrPt.Properties.IsRightButtonPressed)\n            {\n                eventLog.Text += \"\\nRight button: \" + ptrPt.PointerId;\n            }\n        }\n\n        // Prevent most handlers along the event route from handling the same event again.\n        e.Handled = true;\n\n        // Display pointer details.\n        updateInfoPop(e);\n    }\n```\n\n-   This handler manages a [**PointerWheelChanged**](https://msdn.microsoft.com/library/windows/apps/br208973) event. We add the event to the event log, add the pointer to the pointer array (if necessary), and display the pointer details.\n\n```    CSharp\nprivate void Target_PointerWheelChanged(object sender, PointerRoutedEventArgs e)\n    {\n        Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n        // Update event sequence.\n        eventLog.Text += \"\\nMouse wheel: \" + ptr.PointerId;\n\n        // Check if pointer already exists (for example, enter occurred prior to wheel).\n        if (contacts.ContainsKey(ptr.PointerId))\n        {\n            return;\n        }\n\n        // Add contact to dictionary.\n        contacts[ptr.PointerId] = ptr;\n        ++numActiveContacts;\n\n        // Prevent most handlers along the event route from handling the same event again.\n        e.Handled = true;\n\n        // Display pointer details.\n        createInfoPop(e);\n    }\n```\n\n-   This handler manages a [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208972) event where contact with the digitizer is terminated. We add the event to the event log, remove the pointer from the pointer collection, and update the pointer details.\n\n```    CSharp\nvoid Target_PointerReleased(object sender, PointerRoutedEventArgs e)\n    {\n        Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n        // Update event sequence.\n        eventLog.Text += \"\\nUp: \" + ptr.PointerId;\n\n        // If event source is mouse or touchpad and the pointer is still \n        // over the target, retain pointer and pointer details.\n        // Return without removing pointer from pointers dictionary.\n        // For this example, we assume a maximum of one mouse pointer.\n        if (ptr.PointerDeviceType != Windows.Devices.Input.PointerDeviceType.Mouse)\n        {\n            // Update target UI.\n            Target.Fill = new SolidColorBrush(Windows.UI.Colors.Red);\n\n            destroyInfoPop(ptr);\n\n            // Remove contact from dictionary.\n            if (contacts.ContainsKey(ptr.PointerId))\n            {\n                contacts[ptr.PointerId] = null;\n                contacts.Remove(ptr.PointerId);\n                --numActiveContacts;\n            }\n\n            // Release the pointer from the target.\n            Target.ReleasePointerCapture(e.Pointer);\n\n            // Update event sequence.\n            eventLog.Text += \"\\nPointer released: \" + ptr.PointerId;\n\n            // Prevent most handlers along the event route from handling the same event again.\n            e.Handled = true;\n        }\n        else\n        {\n            Target.Fill = new SolidColorBrush(Windows.UI.Colors.Blue);\n        }\n\n    }\n```\n\n-   This handler manages a [**PointerExited**](https://msdn.microsoft.com/library/windows/apps/br208969) event where contact with the digitizer is maintained. We add the event to the event log, remove the pointer from the pointer array, and update the pointer details.\n\n```    CSharp\nprivate void Target_PointerExited(object sender, PointerRoutedEventArgs e)\n    {\n        Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n        // Update event sequence.\n        eventLog.Text += \"\\nPointer exited: \" + ptr.PointerId;\n\n        // Remove contact from dictionary.\n        if (contacts.ContainsKey(ptr.PointerId))\n        {\n            contacts[ptr.PointerId] = null;\n            contacts.Remove(ptr.PointerId);\n            --numActiveContacts;\n        }\n\n        // Update the UI and pointer details.\n        destroyInfoPop(ptr);\n\n        if (contacts.Count == 0)\n        {\n            Target.Fill = new SolidColorBrush(Windows.UI.Colors.Red);\n        }\n        \n        // Prevent most handlers along the event route from handling the same event again.\n        e.Handled = true;\n    }\n```\n\n-   This handler manages a [**PointerCanceled**](https://msdn.microsoft.com/library/windows/apps/br208964) event. We add the event to the event log, remove the pointer from the pointer array, and update the pointer details.\n\n```    CSharp\n// Fires for for various reasons, including: \n    //    - Touch contact canceled by pen coming into range of the surface.\n    //    - The device doesn&#39;t report an active contact for more than 100ms.\n    //    - The desktop is locked or the user logged off. \n    //    - The number of simultaneous contacts exceeded the number supported by the device.\n    private void Target_PointerCanceled(object sender, PointerRoutedEventArgs e)\n    {\n        Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n        // Update event sequence.\n        eventLog.Text += \"\\nPointer canceled: \" + ptr.PointerId;\n\n        // Remove contact from dictionary.\n        if (contacts.ContainsKey(ptr.PointerId))\n        {\n            contacts[ptr.PointerId] = null;\n            contacts.Remove(ptr.PointerId);\n            --numActiveContacts;\n        }\n\n        destroyInfoPop(ptr);\n\n        if (contacts.Count == 0)\n        {\n            Target.Fill = new SolidColorBrush(Windows.UI.Colors.Black);\n        }\n        // Prevent most handlers along the event route from handling the same event again.\n        e.Handled = true;\n    }\n```\n\n-   This handler manages a [**PointerCaptureLost**](https://msdn.microsoft.com/library/windows/apps/br208965) event. We add the event to the event log, remove the pointer from the pointer array, and update the pointer details.\n\n    **Note**  [**PointerCaptureLost**](https://msdn.microsoft.com/library/windows/apps/br208965) can occur instead of [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208972). Pointer capture can be lost for various reasons.\n\n     \n\n```    CSharp\n// Fires for for various reasons, including: \n    //    - User interactions\n    //    - Programmatic capture of another pointer\n    //    - Captured pointer was deliberately released\n    // PointerCaptureLost can fire instead of PointerReleased. \n    private void Target_PointerCaptureLost(object sender, PointerRoutedEventArgs e)\n    {\n        Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n        // Update event sequence.\n        eventLog.Text += \"\\nPointer capture lost: \" + ptr.PointerId;\n\n        // Remove contact from dictionary.\n        if (contacts.ContainsKey(ptr.PointerId))\n        {\n            contacts[ptr.PointerId] = null;\n            contacts.Remove(ptr.PointerId);\n            --numActiveContacts;\n        }\n\n        destroyInfoPop(ptr);\n\n        if (contacts.Count == 0)\n        {\n            Target.Fill = new SolidColorBrush(Windows.UI.Colors.Black);\n        }\n        // Prevent most handlers along the event route from handling the same event again.\n        e.Handled = true;\n    }\n```\n\n### <span id=\"Get_pointer_properties\"></span><span id=\"get_pointer_properties\"></span><span id=\"GET_POINTER_PROPERTIES\"></span>Get pointer properties\n\nAs stated earlier, you must get most extended pointer info from a [**Windows.UI.Input.PointerPoint**](https://msdn.microsoft.com/library/windows/apps/br242038) object obtained through the [**GetCurrentPoint**](https://msdn.microsoft.com/library/windows/apps/hh943077) and [**GetIntermediatePoints**](https://msdn.microsoft.com/library/windows/apps/hh943078) methods of [**PointerRoutedEventArgs**](https://msdn.microsoft.com/library/windows/apps/hh943076).\n\n-   First, we create a new [**TextBlock**](https://msdn.microsoft.com/library/windows/apps/br209652) for each pointer.\n\n```    CSharp\n        void createInfoPop(PointerRoutedEventArgs e)\n            {\n                TextBlock pointerDetails = new TextBlock();\n                Windows.UI.Input.PointerPoint ptrPt = e.GetCurrentPoint(Target);\n                pointerDetails.Name = ptrPt.PointerId.ToString();\n                pointerDetails.Foreground = new SolidColorBrush(Windows.UI.Colors.White);\n                pointerDetails.Text = queryPointer(ptrPt);\n\n                TranslateTransform x = new TranslateTransform();\n                x.X = ptrPt.Position.X + 20;\n                x.Y = ptrPt.Position.Y + 20;\n                pointerDetails.RenderTransform = x;\n\n                Container.Children.Add(pointerDetails);\n            }\n```\n\n-   Then we provide a way to update the pointer info in an existing [**TextBlock**](https://msdn.microsoft.com/library/windows/apps/br209652) associated with that pointer.\n\n```    CSharp\n        void updateInfoPop(PointerRoutedEventArgs e)\n            {\n                foreach (var pointerDetails in Container.Children)\n                {\n                    if (pointerDetails.GetType().ToString() == \"Windows.UI.Xaml.Controls.TextBlock\")\n                    {\n                        TextBlock _TextBlock = (TextBlock)pointerDetails;\n                        if (_TextBlock.Name == e.Pointer.PointerId.ToString())\n                        {\n                            // To get pointer location details, we need extended pointer info.\n                            // We get the pointer info through the getCurrentPoint method\n                            // of the event argument. \n                            Windows.UI.Input.PointerPoint ptrPt = e.GetCurrentPoint(Target);\n                            TranslateTransform x = new TranslateTransform();\n                            x.X = ptrPt.Position.X + 20;\n                            x.Y = ptrPt.Position.Y + 20;\n                            pointerDetails.RenderTransform = x;\n                            _TextBlock.Text = queryPointer(ptrPt);\n                        }\n                    }\n                }\n            }\n```\n\n-   Finally, we query various pointer properties.\n\n```    CSharp\n         String queryPointer(PointerPoint ptrPt)\n             {\n                 String details = \"\";\n\n                 switch (ptrPt.PointerDevice.PointerDeviceType)\n                 {\n                     case Windows.Devices.Input.PointerDeviceType.Mouse:\n                         details += \"\\nPointer type: mouse\";\n                         break;\n                     case Windows.Devices.Input.PointerDeviceType.Pen:\n                         details += \"\\nPointer type: pen\";\n                         if (ptrPt.IsInContact)\n                         {\n                             details += \"\\nPressure: \" + ptrPt.Properties.Pressure;\n                             details += \"\\nrotation: \" + ptrPt.Properties.Orientation;\n                             details += \"\\nTilt X: \" + ptrPt.Properties.XTilt;\n                             details += \"\\nTilt Y: \" + ptrPt.Properties.YTilt;\n                             details += \"\\nBarrel button pressed: \" + ptrPt.Properties.IsBarrelButtonPressed;\n                         }\n                         break;\n                     case Windows.Devices.Input.PointerDeviceType.Touch:\n                         details += \"\\nPointer type: touch\";\n                         details += \"\\nrotation: \" + ptrPt.Properties.Orientation;\n                         details += \"\\nTilt X: \" + ptrPt.Properties.XTilt;\n                         details += \"\\nTilt Y: \" + ptrPt.Properties.YTilt;\n                         break;\n                     default:\n                         details += \"\\nPointer type: n/a\";\n                         break;\n                 }\n\n                 GeneralTransform gt = Target.TransformToVisual(page);\n                 Point screenPoint;\n\n                 screenPoint = gt.TransformPoint(new Point(ptrPt.Position.X, ptrPt.Position.Y));\n                 details += \"\\nPointer Id: \" + ptrPt.PointerId.ToString() +\n                     \"\\nPointer location (parent): \" + ptrPt.Position.X + \", \" + ptrPt.Position.Y +\n                     \"\\nPointer location (screen): \" + screenPoint.X + \", \" + screenPoint.Y;\n                 return details;\n             }\n```\n\n### <span id=\"Complete_example\"></span><span id=\"complete_example\"></span><span id=\"COMPLETE_EXAMPLE\"></span>Complete example\n\nThe following is the C# code for this example. For links to more complex samples, see Related articles at the bottom of this page .\n\n```CSharp\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Windows.Foundation;\nusing Windows.Foundation.Collections;\nusing Windows.UI.Input;\nusing Windows.UI.Xaml;\nusing Windows.UI.Xaml.Controls;\nusing Windows.UI.Xaml.Controls.Primitives;\nusing Windows.UI.Xaml.Data;\nusing Windows.UI.Xaml.Input;\nusing Windows.UI.Xaml.Media;\nusing Windows.UI.Xaml.Navigation;\n\n// The Blank Page item template is documented at http://go.microsoft.com/fwlink/?LinkId=234238\n\nnamespace PointerInput\n{\n    /// <summary>\n    /// An empty page that can be used on its own or navigated to within a Frame.\n    /// </summary>\n    public sealed partial class MainPage : Page\n    {\n        // For this example, we track simultaneous contacts in case the \n        // number of contacts has reached the maximum supported by the device.\n        // Depending on the device, additional contacts might be ignored \n        // (PointerPressed not fired). \n        uint numActiveContacts;\n        Windows.Devices.Input.TouchCapabilities touchCapabilities = new Windows.Devices.Input.TouchCapabilities();\n\n        // Dictionary to maintain information about each active contact. \n        // An entry is added during PointerPressed/PointerEntered events and removed \n        // during PointerReleased/PointerCaptureLost/PointerCanceled/PointerExited events.\n        Dictionary<uint, Windows.UI.Xaml.Input.Pointer> contacts;\n\n        public MainPage()\n        {\n            this.InitializeComponent();\n            numActiveContacts = 0;\n            // Initialize the dictionary.\n            contacts = new Dictionary<uint, Windows.UI.Xaml.Input.Pointer>((int)touchCapabilities.Contacts);\n            // Declare the pointer event handlers.\n            Target.PointerPressed += new PointerEventHandler(Target_PointerPressed);\n            Target.PointerEntered += new PointerEventHandler(Target_PointerEntered);\n            Target.PointerReleased += new PointerEventHandler(Target_PointerReleased);\n            Target.PointerExited += new PointerEventHandler(Target_PointerExited);\n            Target.PointerCanceled += new PointerEventHandler(Target_PointerCanceled);\n            Target.PointerCaptureLost += new PointerEventHandler(Target_PointerCaptureLost);\n            Target.PointerMoved += new PointerEventHandler(Target_PointerMoved);\n            Target.PointerWheelChanged += new PointerEventHandler(Target_PointerWheelChanged);\n\n            buttonClear.Click += new RoutedEventHandler(ButtonClear_Click);\n        }\n\n        private void ButtonClear_Click(object sender, RoutedEventArgs e)\n        {\n            eventLog.Text = \"\";\n        }\n\n\n        // PointerPressed and PointerReleased events do not always occur in pairs. \n        // Your app should listen for and handle any event that might conclude a pointer down action \n        // (such as PointerExited, PointerCanceled, and PointerCaptureLost).\n        // For this example, we track the number of contacts in case the \n        // number of contacts has reached the maximum supported by the device.\n        // Depending on the device, additional contacts might be ignored \n        // (PointerPressed not fired). \n        void Target_PointerPressed(object sender, PointerRoutedEventArgs e)\n        {\n            Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n            // Update event sequence.\n            eventLog.Text += \"\\nDown: \" + ptr.PointerId;\n\n            // Change background color of target when pointer contact detected.\n            Target.Fill = new SolidColorBrush(Windows.UI.Colors.Green);\n\n            // Prevent most handlers along the event route from handling the same event again.\n            e.Handled = true;\n\n            // Lock the pointer to the target.\n            Target.CapturePointer(e.Pointer);\n\n            // Update event sequence.\n            eventLog.Text += \"\\nPointer captured: \" + ptr.PointerId;\n\n            // Check if pointer already exists (for example, enter occurred prior to press).\n            if (contacts.ContainsKey(ptr.PointerId))\n            {\n                return;\n            }\n            // Add contact to dictionary.\n            contacts[ptr.PointerId] = ptr;\n            ++numActiveContacts;\n\n            // Display pointer details.\n            createInfoPop(e);\n        }\n\n        void Target_PointerReleased(object sender, PointerRoutedEventArgs e)\n        {\n            Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n            // Update event sequence.\n            eventLog.Text += \"\\nUp: \" + ptr.PointerId;\n\n            // If event source is mouse or touchpad and the pointer is still \n            // over the target, retain pointer and pointer details.\n            // Return without removing pointer from pointers dictionary.\n            // For this example, we assume a maximum of one mouse pointer.\n            if (ptr.PointerDeviceType != Windows.Devices.Input.PointerDeviceType.Mouse)\n            {\n                // Update target UI.\n                Target.Fill = new SolidColorBrush(Windows.UI.Colors.Red);\n\n                destroyInfoPop(ptr);\n\n                // Remove contact from dictionary.\n                if (contacts.ContainsKey(ptr.PointerId))\n                {\n                    contacts[ptr.PointerId] = null;\n                    contacts.Remove(ptr.PointerId);\n                    --numActiveContacts;\n                }\n\n                // Release the pointer from the target.\n                Target.ReleasePointerCapture(e.Pointer);\n\n                // Update event sequence.\n                eventLog.Text += \"\\nPointer released: \" + ptr.PointerId;\n\n                // Prevent most handlers along the event route from handling the same event again.\n                e.Handled = true;\n            }\n            else\n            {\n                Target.Fill = new SolidColorBrush(Windows.UI.Colors.Blue);\n            }\n\n        }\n\n        private void Target_PointerMoved(object sender, PointerRoutedEventArgs e)\n        {\n            Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n            // Multiple, simultaneous mouse button inputs are processed here.\n            // Mouse input is associated with a single pointer assigned when \n            // mouse input is first detected. \n            // Clicking additional mouse buttons (left, wheel, or right) during \n            // the interaction creates secondary associations between those buttons \n            // and the pointer through the pointer pressed event. \n            // The pointer released event is fired only when the last mouse button \n            // associated with the interaction (not necessarily the initial button) \n            // is released. \n            // Because of this exclusive association, other mouse button clicks are \n            // routed through the pointer move event.          \n            if (ptr.PointerDeviceType == Windows.Devices.Input.PointerDeviceType.Mouse)\n            {\n                // To get mouse state, we need extended pointer details.\n                // We get the pointer info through the getCurrentPoint method\n                // of the event argument. \n                Windows.UI.Input.PointerPoint ptrPt = e.GetCurrentPoint(Target);\n                if (ptrPt.Properties.IsLeftButtonPressed)\n                {\n                    eventLog.Text += \"\\nLeft button: \" + ptrPt.PointerId;\n                }\n                if (ptrPt.Properties.IsMiddleButtonPressed)\n                {\n                    eventLog.Text += \"\\nWheel button: \" + ptrPt.PointerId;\n                }\n                if (ptrPt.Properties.IsRightButtonPressed)\n                {\n                    eventLog.Text += \"\\nRight button: \" + ptrPt.PointerId;\n                }\n            }\n\n            // Prevent most handlers along the event route from handling the same event again.\n            e.Handled = true;\n\n            // Display pointer details.\n            updateInfoPop(e);\n        }\n\n        private void Target_PointerEntered(object sender, PointerRoutedEventArgs e)\n        {\n            Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n            // Update event sequence.\n            eventLog.Text += \"\\nEntered: \" + ptr.PointerId;\n\n            if (contacts.Count == 0)\n            {\n                // Change background color of target when pointer contact detected.\n                Target.Fill = new SolidColorBrush(Windows.UI.Colors.Blue);\n            }\n\n            // Check if pointer already exists (if enter occurred prior to down).\n            if (contacts.ContainsKey(ptr.PointerId))\n            {\n                return;\n            }\n\n            // Add contact to dictionary.\n            contacts[ptr.PointerId] = ptr;\n            ++numActiveContacts;\n\n            // Prevent most handlers along the event route from handling the same event again.\n            e.Handled = true;\n\n            // Display pointer details.\n            createInfoPop(e);\n        }\n\n        private void Target_PointerWheelChanged(object sender, PointerRoutedEventArgs e)\n        {\n            Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n            // Update event sequence.\n            eventLog.Text += \"\\nMouse wheel: \" + ptr.PointerId;\n\n            // Check if pointer already exists (for example, enter occurred prior to wheel).\n            if (contacts.ContainsKey(ptr.PointerId))\n            {\n                return;\n            }\n\n            // Add contact to dictionary.\n            contacts[ptr.PointerId] = ptr;\n            ++numActiveContacts;\n\n            // Prevent most handlers along the event route from handling the same event again.\n            e.Handled = true;\n\n            // Display pointer details.\n            createInfoPop(e);\n        }\n\n        // Fires for for various reasons, including: \n        //    - User interactions\n        //    - Programmatic capture of another pointer\n        //    - Captured pointer was deliberately released\n        // PointerCaptureLost can fire instead of PointerReleased. \n        private void Target_PointerCaptureLost(object sender, PointerRoutedEventArgs e)\n        {\n            Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n            // Update event sequence.\n            eventLog.Text += \"\\nPointer capture lost: \" + ptr.PointerId;\n\n            // Remove contact from dictionary.\n            if (contacts.ContainsKey(ptr.PointerId))\n            {\n                contacts[ptr.PointerId] = null;\n                contacts.Remove(ptr.PointerId);\n                --numActiveContacts;\n            }\n\n            destroyInfoPop(ptr);\n\n            if (contacts.Count == 0)\n            {\n                Target.Fill = new SolidColorBrush(Windows.UI.Colors.Black);\n            }\n            // Prevent most handlers along the event route from handling the same event again.\n            e.Handled = true;\n        }\n\n        // Fires for for various reasons, including: \n        //    - Touch contact canceled by pen coming into range of the surface.\n        //    - The device doesn&#39;t report an active contact for more than 100ms.\n        //    - The desktop is locked or the user logged off. \n        //    - The number of simultaneous contacts exceeded the number supported by the device.\n        private void Target_PointerCanceled(object sender, PointerRoutedEventArgs e)\n        {\n            Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n            // Update event sequence.\n            eventLog.Text += \"\\nPointer canceled: \" + ptr.PointerId;\n\n            // Remove contact from dictionary.\n            if (contacts.ContainsKey(ptr.PointerId))\n            {\n                contacts[ptr.PointerId] = null;\n                contacts.Remove(ptr.PointerId);\n                --numActiveContacts;\n            }\n\n            destroyInfoPop(ptr);\n\n            if (contacts.Count == 0)\n            {\n                Target.Fill = new SolidColorBrush(Windows.UI.Colors.Black);\n            }\n            // Prevent most handlers along the event route from handling the same event again.\n            e.Handled = true;\n        }\n\n        private void Target_PointerExited(object sender, PointerRoutedEventArgs e)\n        {\n            Windows.UI.Xaml.Input.Pointer ptr = e.Pointer;\n\n            // Update event sequence.\n            eventLog.Text += \"\\nPointer exited: \" + ptr.PointerId;\n\n            // Remove contact from dictionary.\n            if (contacts.ContainsKey(ptr.PointerId))\n            {\n                contacts[ptr.PointerId] = null;\n                contacts.Remove(ptr.PointerId);\n                --numActiveContacts;\n            }\n\n            // Update the UI and pointer details.\n            destroyInfoPop(ptr);\n\n            if (contacts.Count == 0)\n            {\n                Target.Fill = new SolidColorBrush(Windows.UI.Colors.Red);\n            }\n            \n            // Prevent most handlers along the event route from handling the same event again.\n            e.Handled = true;\n        }\n\n        void createInfoPop(PointerRoutedEventArgs e)\n        {\n            TextBlock pointerDetails = new TextBlock();\n            Windows.UI.Input.PointerPoint ptrPt = e.GetCurrentPoint(Target);\n            pointerDetails.Name = ptrPt.PointerId.ToString();\n            pointerDetails.Foreground = new SolidColorBrush(Windows.UI.Colors.White);\n            pointerDetails.Text = queryPointer(ptrPt);\n\n            TranslateTransform x = new TranslateTransform();\n            x.X = ptrPt.Position.X + 20;\n            x.Y = ptrPt.Position.Y + 20;\n            pointerDetails.RenderTransform = x;\n\n            Container.Children.Add(pointerDetails);\n        }\n\n        void destroyInfoPop(Windows.UI.Xaml.Input.Pointer ptr)\n        {\n            foreach (var pointerDetails in Container.Children)\n            {\n                if (pointerDetails.GetType().ToString() == \"Windows.UI.Xaml.Controls.TextBlock\")\n                {\n                    TextBlock _TextBlock = (TextBlock)pointerDetails;\n                    if (_TextBlock.Name == ptr.PointerId.ToString())\n                    {\n                        Container.Children.Remove(pointerDetails);\n                    }\n                }\n            }\n        }\n\n        void updateInfoPop(PointerRoutedEventArgs e)\n        {\n            foreach (var pointerDetails in Container.Children)\n            {\n                if (pointerDetails.GetType().ToString() == \"Windows.UI.Xaml.Controls.TextBlock\")\n                {\n                    TextBlock _TextBlock = (TextBlock)pointerDetails;\n                    if (_TextBlock.Name == e.Pointer.PointerId.ToString())\n                    {\n                        // To get pointer location details, we need extended pointer info.\n                        // We get the pointer info through the getCurrentPoint method\n                        // of the event argument. \n                        Windows.UI.Input.PointerPoint ptrPt = e.GetCurrentPoint(Target);\n                        TranslateTransform x = new TranslateTransform();\n                        x.X = ptrPt.Position.X + 20;\n                        x.Y = ptrPt.Position.Y + 20;\n                        pointerDetails.RenderTransform = x;\n                        _TextBlock.Text = queryPointer(ptrPt);\n                    }\n                }\n            }\n        }\n\n         String queryPointer(PointerPoint ptrPt)\n         {\n             String details = \"\";\n\n             switch (ptrPt.PointerDevice.PointerDeviceType)\n             {\n                 case Windows.Devices.Input.PointerDeviceType.Mouse:\n                     details += \"\\nPointer type: mouse\";\n                     break;\n                 case Windows.Devices.Input.PointerDeviceType.Pen:\n                     details += \"\\nPointer type: pen\";\n                     if (ptrPt.IsInContact)\n                     {\n                         details += \"\\nPressure: \" + ptrPt.Properties.Pressure;\n                         details += \"\\nrotation: \" + ptrPt.Properties.Orientation;\n                         details += \"\\nTilt X: \" + ptrPt.Properties.XTilt;\n                         details += \"\\nTilt Y: \" + ptrPt.Properties.YTilt;\n                         details += \"\\nBarrel button pressed: \" + ptrPt.Properties.IsBarrelButtonPressed;\n                     }\n                     break;\n                 case Windows.Devices.Input.PointerDeviceType.Touch:\n                     details += \"\\nPointer type: touch\";\n                     details += \"\\nrotation: \" + ptrPt.Properties.Orientation;\n                     details += \"\\nTilt X: \" + ptrPt.Properties.XTilt;\n                     details += \"\\nTilt Y: \" + ptrPt.Properties.YTilt;\n                     break;\n                 default:\n                     details += \"\\nPointer type: n/a\";\n                     break;\n             }\n\n             GeneralTransform gt = Target.TransformToVisual(page);\n             Point screenPoint;\n\n             screenPoint = gt.TransformPoint(new Point(ptrPt.Position.X, ptrPt.Position.Y));\n             details += \"\\nPointer Id: \" + ptrPt.PointerId.ToString() +\n                 \"\\nPointer location (parent): \" + ptrPt.Position.X + \", \" + ptrPt.Position.Y +\n                 \"\\nPointer location (screen): \" + screenPoint.X + \", \" + screenPoint.Y;\n             return details;\n         }\n    }\n}\n```\n\n## <span id=\"related_topics\"></span>Related articles\n\n\n**Samples**\n* [Basic input sample](http://go.microsoft.com/fwlink/p/?LinkID=620302)\n* [Low latency input sample](http://go.microsoft.com/fwlink/p/?LinkID=620304)\n* [User interaction mode sample](http://go.microsoft.com/fwlink/p/?LinkID=619894)\n* [Focus visuals sample](http://go.microsoft.com/fwlink/p/?LinkID=619895)\n**Archive samples**\n* [Input: XAML user input events sample](http://go.microsoft.com/fwlink/p/?linkid=226855)\n* [Input: Device capabilities sample](http://go.microsoft.com/fwlink/p/?linkid=231530)\n* [Input: Manipulations and gestures (C++) sample](http://go.microsoft.com/fwlink/p/?linkid=231605)\n* [Input: Touch hit testing sample](http://go.microsoft.com/fwlink/p/?linkid=231590)\n* [XAML scrolling, panning, and zooming sample](http://go.microsoft.com/fwlink/p/?linkid=251717)\n* [Input: Simplified ink sample](http://go.microsoft.com/fwlink/p/?linkid=246570)\n \n\n \n\n\n\n\n"}