{"nodes":[{"pos":[11,48],"content":"Create shaders and drawing primitives","needQuote":true,"needEscape":true,"nodes":[{"content":"Create shaders and drawing primitives","pos":[0,37]}]},{"pos":[62,195],"content":"Here, we show you how to use HLSL source files to compile and create shaders that you can then use to draw primitives on the display.","needQuote":true,"needEscape":true,"nodes":[{"content":"Here, we show you how to use HLSL source files to compile and create shaders that you can then use to draw primitives on the display.","pos":[0,133]}]},{"content":"Create shaders and drawing primitives","pos":[252,289]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[292,330]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[331,426],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Here, we show you how to use HLSL source files to compile and create shaders that you can then use to draw primitives on the display.","pos":[428,561]},{"content":"We create and draw a yellow triangle by using vertex and pixel shaders.","pos":[563,634]},{"content":"After we create the Direct3D device, the swap chain, and the render-target view, we read data from binary shader object files on the disk.","pos":[635,773]},{"pos":[775,831],"content":"<bpt id=\"p1\">**</bpt>Objective:<ept id=\"p1\">**</ept> To create shaders and to draw primitives.","source":"**Objective:** To create shaders and to draw primitives."},{"content":"Prerequisites","pos":[836,849]},{"content":"We assume that you are familiar with C++.","pos":[852,893]},{"content":"You also need basic experience with graphics programming concepts.","pos":[894,960]},{"pos":[962,1099],"content":"We also assume that you went through <bpt id=\"p1\">[</bpt>Quickstart: setting up DirectX resources and displaying an image<ept id=\"p1\">](setting-up-directx-resources.md)</ept>.","source":"We also assume that you went through [Quickstart: setting up DirectX resources and displaying an image](setting-up-directx-resources.md)."},{"pos":[1101,1134],"content":"<bpt id=\"p1\">**</bpt>Time to complete:<ept id=\"p1\">**</ept> 20 minutes.","source":"**Time to complete:** 20 minutes."},{"content":"Instructions","pos":[1139,1151]},{"content":"1. Compiling HLSL source files","pos":[1157,1187]},{"content":"Microsoft Visual Studio uses the <bpt id=\"p1\">[</bpt>fxc.exe<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb232919)</ept> HLSL code compiler to compile the .hlsl source files (SimpleVertexShader.hlsl and SimplePixelShader.hlsl) into .cso binary shader object files (SimpleVertexShader.cso and SimplePixelShader.cso).","pos":[1189,1487],"source":"Microsoft Visual Studio uses the [fxc.exe](https://msdn.microsoft.com/library/windows/desktop/bb232919) HLSL code compiler to compile the .hlsl source files (SimpleVertexShader.hlsl and SimplePixelShader.hlsl) into .cso binary shader object files (SimpleVertexShader.cso and SimplePixelShader.cso)."},{"content":"For more info about the HLSL code compiler, see Effect-Compiler Tool.","pos":[1488,1557]},{"content":"For more info about compiling shader code, see <bpt id=\"p1\">[</bpt>Compiling Shaders<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509633)</ept>.","pos":[1558,1686],"source":" For more info about compiling shader code, see [Compiling Shaders](https://msdn.microsoft.com/library/windows/desktop/bb509633)."},{"content":"Here is the code in SimpleVertexShader.hlsl:","pos":[1688,1732]},{"content":"Here is the code in SimplePixelShader.hlsl:","pos":[2167,2210]},{"content":"2. Reading data from disk","pos":[2437,2462]},{"content":"We use the DX::ReadDataAsync function from DirectXHelper.h in the DirectX 11 App (Universal Windows) template to asynchronously read data from a file on the disk.","pos":[2464,2626]},{"content":"3. Creating vertex and pixel shaders","pos":[2632,2668]},{"content":"We read data from the SimpleVertexShader.cso file and assign the data to the <bpt id=\"p1\">*</bpt>vertexShaderBytecode<ept id=\"p1\">*</ept> byte array.","pos":[2670,2781],"source":"We read data from the SimpleVertexShader.cso file and assign the data to the *vertexShaderBytecode* byte array."},{"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device::CreateVertexShader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476524)</ept> with the byte array to create the vertex shader (<bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11VertexShader<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476641)</ept>).","pos":[2782,3026],"source":" We call [**ID3D11Device::CreateVertexShader**](https://msdn.microsoft.com/library/windows/desktop/ff476524) with the byte array to create the vertex shader ([**ID3D11VertexShader**](https://msdn.microsoft.com/library/windows/desktop/ff476641))."},{"content":"We set the vertex depth value to 0.5 in the SimpleVertexShader.hlsl source to guarantee that our triangle is drawn.","pos":[3027,3142]},{"content":"We populate an array of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11\\_INPUT\\_ELEMENT\\_DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476180)</ept> structures to describe the layout of the vertex shader code and then call <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11Device::CreateInputLayout<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476512)</ept> to create the layout.","pos":[3143,3456],"source":" We populate an array of [**D3D11\\_INPUT\\_ELEMENT\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476180) structures to describe the layout of the vertex shader code and then call [**ID3D11Device::CreateInputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476512) to create the layout."},{"content":"The array has one layout element that defines the vertex position.","pos":[3457,3523]},{"content":"We read data from the SimplePixelShader.cso file and assign the data to the <bpt id=\"p1\">*</bpt>pixelShaderBytecode<ept id=\"p1\">*</ept> byte array.","pos":[3524,3633],"source":" We read data from the SimplePixelShader.cso file and assign the data to the *pixelShaderBytecode* byte array."},{"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device::CreatePixelShader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476513)</ept> with the byte array to create the pixel shader (<bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11PixelShader<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476576)</ept>).","pos":[3634,3875],"source":" We call [**ID3D11Device::CreatePixelShader**](https://msdn.microsoft.com/library/windows/desktop/ff476513) with the byte array to create the pixel shader ([**ID3D11PixelShader**](https://msdn.microsoft.com/library/windows/desktop/ff476576))."},{"content":"We set the pixel value to (1,1,1,1) in the SimplePixelShader.hlsl source to make our triangle yellow.","pos":[3876,3977]},{"content":"You can change the color by changing this value.","pos":[3978,4026]},{"content":"We create vertex and index buffers that define a simple triangle.","pos":[4028,4093]},{"content":"To do this, we first define the triangle, next describe the vertex and index buffers (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11\\_BUFFER\\_DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>D3D11\\_SUBRESOURCE\\_DATA<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept>) using the triangle definition, and finally call <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ID3D11Device::CreateBuffer<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept> once for each buffer.","pos":[4094,4527],"source":" To do this, we first define the triangle, next describe the vertex and index buffers ([**D3D11\\_BUFFER\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476092) and [**D3D11\\_SUBRESOURCE\\_DATA**](https://msdn.microsoft.com/library/windows/desktop/ff476220)) using the triangle definition, and finally call [**ID3D11Device::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501) once for each buffer."},{"content":"We use the vertex and pixel shaders, the vertex shader layout, and the vertex and index buffers to draw a yellow triangle.","pos":[8654,8776]},{"content":"4. Drawing the triangle and presenting the rendered image","pos":[8782,8839]},{"content":"We enter an endless loop to continually render and display the scene.","pos":[8841,8910]},{"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::OMSetRenderTargets<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476464)</ept> to specify the render target as the output target.","pos":[8911,9076],"source":" We call [**ID3D11DeviceContext::OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464) to specify the render target as the output target."},{"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::ClearRenderTargetView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476388)</ept> with { 0.071f, 0.04f, 0.561f, 1.0f } to clear the render target to a solid blue color.","pos":[9077,9281],"source":" We call [**ID3D11DeviceContext::ClearRenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476388) with { 0.071f, 0.04f, 0.561f, 1.0f } to clear the render target to a solid blue color."},{"content":"In the endless loop, we draw a yellow triangle on the blue surface.","pos":[9283,9350]},{"content":"To draw a yellow triangle","pos":[9354,9379]},{"pos":[9387,9585],"content":"First, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::IASetInputLayout<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476454)</ept> to describe how vertex buffer data is streamed into the input-assembler stage.","source":"First, we call [**ID3D11DeviceContext::IASetInputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476454) to describe how vertex buffer data is streamed into the input-assembler stage."},{"pos":[9590,9886],"content":"Next, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::IASetVertexBuffers<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476456)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext::IASetIndexBuffer<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476453)</ept> to bind the vertex and index buffers to the input-assembler stage.","source":"Next, we call [**ID3D11DeviceContext::IASetVertexBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476456) and [**ID3D11DeviceContext::IASetIndexBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476453) to bind the vertex and index buffers to the input-assembler stage."},{"pos":[9891,10269],"content":"Next, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::IASetPrimitiveTopology<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476455)</ept> with the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>D3D11\\_PRIMITIVE\\_TOPOLOGY\\_TRIANGLESTRIP<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476189#D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP)</ept> value to specify for the input-assembler stage to interpret the vertex data as a triangle strip.","source":"Next, we call [**ID3D11DeviceContext::IASetPrimitiveTopology**](https://msdn.microsoft.com/library/windows/desktop/ff476455) with the [**D3D11\\_PRIMITIVE\\_TOPOLOGY\\_TRIANGLESTRIP**](https://msdn.microsoft.com/library/windows/desktop/ff476189#D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP) value to specify for the input-assembler stage to interpret the vertex data as a triangle strip."},{"pos":[10274,10622],"content":"Next, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::VSSetShader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</ept> to initialize the vertex shader stage with the vertex shader code and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext::PSSetShader<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</ept> to initialize the pixel shader stage with the pixel shader code.","source":"Next, we call [**ID3D11DeviceContext::VSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476493) to initialize the vertex shader stage with the vertex shader code and [**ID3D11DeviceContext::PSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476472) to initialize the pixel shader stage with the pixel shader code."},{"pos":[10627,10805],"content":"Finally, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::DrawIndexed<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476409)</ept> to draw the triangle and submit it to the rendering pipeline.","source":"Finally, we call [**ID3D11DeviceContext::DrawIndexed**](https://msdn.microsoft.com/library/windows/desktop/ff476409) to draw the triangle and submit it to the rendering pipeline."},{"pos":[10807,10950],"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain::Present<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb174576)</ept> to present the rendered image to the window.","source":"We call [**IDXGISwapChain::Present**](https://msdn.microsoft.com/library/windows/desktop/bb174576) to present the rendered image to the window."},{"content":"Summary and next steps","pos":[13116,13138]},{"content":"We created and drew a yellow triangle by using vertex and pixel shaders.","pos":[13141,13213]},{"content":"Next, we create an orbiting 3D cube and apply lighting effects to it.","pos":[13215,13284]},{"content":"Using depth and effects on primitives","pos":[13287,13324]}],"content":"---\ntitle: Create shaders and drawing primitives\ndescription: Here, we show you how to use HLSL source files to compile and create shaders that you can then use to draw primitives on the display.\nms.assetid: 91113bbe-96c9-4ef9-6482-39f1ff1a70f4\n---\n\n# Create shaders and drawing primitives\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nHere, we show you how to use HLSL source files to compile and create shaders that you can then use to draw primitives on the display.\n\nWe create and draw a yellow triangle by using vertex and pixel shaders. After we create the Direct3D device, the swap chain, and the render-target view, we read data from binary shader object files on the disk.\n\n**Objective:** To create shaders and to draw primitives.\n\n## Prerequisites\n\n\nWe assume that you are familiar with C++. You also need basic experience with graphics programming concepts.\n\nWe also assume that you went through [Quickstart: setting up DirectX resources and displaying an image](setting-up-directx-resources.md).\n\n**Time to complete:** 20 minutes.\n\n## Instructions\n\n### 1. Compiling HLSL source files\n\nMicrosoft Visual Studio uses the [fxc.exe](https://msdn.microsoft.com/library/windows/desktop/bb232919) HLSL code compiler to compile the .hlsl source files (SimpleVertexShader.hlsl and SimplePixelShader.hlsl) into .cso binary shader object files (SimpleVertexShader.cso and SimplePixelShader.cso). For more info about the HLSL code compiler, see Effect-Compiler Tool. For more info about compiling shader code, see [Compiling Shaders](https://msdn.microsoft.com/library/windows/desktop/bb509633).\n\nHere is the code in SimpleVertexShader.hlsl:\n\n```hlsl\nstruct VertexShaderInput\n{\n    DirectX::XMFLOAT2 pos : POSITION;\n};\n\nstruct PixelShaderInput\n{\n    float4 pos : SV_POSITION;\n};\n\nPixelShaderInput SimpleVertexShader(VertexShaderInput input)\n{\n    PixelShaderInput vertexShaderOutput;\n\n    // For this lesson, set the vertex depth value to 0.5, so it is guaranteed to be drawn.\n    vertexShaderOutput.pos = float4(input.pos, 0.5f, 1.0f);\n\n    return vertexShaderOutput;\n}\n```\n\nHere is the code in SimplePixelShader.hlsl:\n\n```hlsl\nstruct PixelShaderInput\n{\n    float4 pos : SV_POSITION;\n};\n\nfloat4 SimplePixelShader(PixelShaderInput input) : SV_TARGET\n{\n    // Draw the entire triangle yellow.\n    return float4(1.0f, 1.0f, 0.0f, 1.0f);\n}\n```\n\n### 2. Reading data from disk\n\nWe use the DX::ReadDataAsync function from DirectXHelper.h in the DirectX 11 App (Universal Windows) template to asynchronously read data from a file on the disk.\n\n### 3. Creating vertex and pixel shaders\n\nWe read data from the SimpleVertexShader.cso file and assign the data to the *vertexShaderBytecode* byte array. We call [**ID3D11Device::CreateVertexShader**](https://msdn.microsoft.com/library/windows/desktop/ff476524) with the byte array to create the vertex shader ([**ID3D11VertexShader**](https://msdn.microsoft.com/library/windows/desktop/ff476641)). We set the vertex depth value to 0.5 in the SimpleVertexShader.hlsl source to guarantee that our triangle is drawn. We populate an array of [**D3D11\\_INPUT\\_ELEMENT\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476180) structures to describe the layout of the vertex shader code and then call [**ID3D11Device::CreateInputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476512) to create the layout. The array has one layout element that defines the vertex position. We read data from the SimplePixelShader.cso file and assign the data to the *pixelShaderBytecode* byte array. We call [**ID3D11Device::CreatePixelShader**](https://msdn.microsoft.com/library/windows/desktop/ff476513) with the byte array to create the pixel shader ([**ID3D11PixelShader**](https://msdn.microsoft.com/library/windows/desktop/ff476576)). We set the pixel value to (1,1,1,1) in the SimplePixelShader.hlsl source to make our triangle yellow. You can change the color by changing this value.\n\nWe create vertex and index buffers that define a simple triangle. To do this, we first define the triangle, next describe the vertex and index buffers ([**D3D11\\_BUFFER\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476092) and [**D3D11\\_SUBRESOURCE\\_DATA**](https://msdn.microsoft.com/library/windows/desktop/ff476220)) using the triangle definition, and finally call [**ID3D11Device::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501) once for each buffer.\n\n```cpp\n        auto loadVSTask = DX::ReadDataAsync(L\"SimpleVertexShader.cso\");\n        auto loadPSTask = DX::ReadDataAsync(L\"SimplePixelShader.cso\");\n        \n        // Load the raw vertex shader bytecode from disk and create a vertex shader with it.\n        auto createVSTask = loadVSTask.then([this](const std::vector<byte>& vertexShaderBytecode) {\n\n\n          ComPtr<ID3D11VertexShader> vertexShader;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateVertexShader(\n                  vertexShaderBytecode->Data,\n                  vertexShaderBytecode->Length,\n                  nullptr,\n                  &vertexShader\n                  )\n              );\n\n          // Create an input layout that matches the layout defined in the vertex shader code.\n          // For this lesson, this is simply a DirectX::XMFLOAT2 vector defining the vertex position.\n          const D3D11_INPUT_ELEMENT_DESC basicVertexLayoutDesc[] =\n          {\n              { \"POSITION\", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },\n          };\n\n          ComPtr<ID3D11InputLayout> inputLayout;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateInputLayout(\n                  basicVertexLayoutDesc,\n                  ARRAYSIZE(basicVertexLayoutDesc),\n                  vertexShaderBytecode->Data,\n                  vertexShaderBytecode->Length,\n                  &inputLayout\n                  )\n              );\n        });\n        \n        // Load the raw pixel shader bytecode from disk and create a pixel shader with it.\n        auto createPSTask = loadPSTask.then([this](const std::vector<byte>& pixelShaderBytecode) {\n          ComPtr<ID3D11PixelShader> pixelShader;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreatePixelShader(\n                  pixelShaderBytecode->Data,\n                  pixelShaderBytecode->Length,\n                  nullptr,\n                  &pixelShader\n                  )\n              );\n        });\n\n        // Create vertex and index buffers that define a simple triangle.\n        auto createTriangleTask = (createPSTask && createVSTask).then([this] () {\n\n          DirectX::XMFLOAT2 triangleVertices[] =\n          {\n              float2(-0.5f, -0.5f),\n              float2( 0.0f,  0.5f),\n              float2( 0.5f, -0.5f),\n          };\n\n          unsigned short triangleIndices[] =\n          {\n              0, 1, 2,\n          };\n\n          D3D11_BUFFER_DESC vertexBufferDesc = {0};\n          vertexBufferDesc.ByteWidth = sizeof(float2) * ARRAYSIZE(triangleVertices);\n          vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;\n          vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;\n          vertexBufferDesc.CPUAccessFlags = 0;\n          vertexBufferDesc.MiscFlags = 0;\n          vertexBufferDesc.StructureByteStride = 0;\n\n          D3D11_SUBRESOURCE_DATA vertexBufferData;\n          vertexBufferData.pSysMem = triangleVertices;\n          vertexBufferData.SysMemPitch = 0;\n          vertexBufferData.SysMemSlicePitch = 0;\n\n          ComPtr<ID3D11Buffer> vertexBuffer;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateBuffer(\n                  &vertexBufferDesc,\n                  &vertexBufferData,\n                  &vertexBuffer\n                  )\n              );\n\n          D3D11_BUFFER_DESC indexBufferDesc;\n          indexBufferDesc.ByteWidth = sizeof(unsigned short) * ARRAYSIZE(triangleIndices);\n          indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;\n          indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;\n          indexBufferDesc.CPUAccessFlags = 0;\n          indexBufferDesc.MiscFlags = 0;\n          indexBufferDesc.StructureByteStride = 0;\n\n          D3D11_SUBRESOURCE_DATA indexBufferData;\n          indexBufferData.pSysMem = triangleIndices;\n          indexBufferData.SysMemPitch = 0;\n          indexBufferData.SysMemSlicePitch = 0;\n\n          ComPtr<ID3D11Buffer> indexBuffer;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateBuffer(\n                  &indexBufferDesc,\n                  &indexBufferData,\n                  &indexBuffer\n                  )\n              );\n        });\n```\n\nWe use the vertex and pixel shaders, the vertex shader layout, and the vertex and index buffers to draw a yellow triangle.\n\n### 4. Drawing the triangle and presenting the rendered image\n\nWe enter an endless loop to continually render and display the scene. We call [**ID3D11DeviceContext::OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464) to specify the render target as the output target. We call [**ID3D11DeviceContext::ClearRenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476388) with { 0.071f, 0.04f, 0.561f, 1.0f } to clear the render target to a solid blue color.\n\nIn the endless loop, we draw a yellow triangle on the blue surface.\n\n**To draw a yellow triangle**\n\n1.  First, we call [**ID3D11DeviceContext::IASetInputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476454) to describe how vertex buffer data is streamed into the input-assembler stage.\n2.  Next, we call [**ID3D11DeviceContext::IASetVertexBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476456) and [**ID3D11DeviceContext::IASetIndexBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476453) to bind the vertex and index buffers to the input-assembler stage.\n3.  Next, we call [**ID3D11DeviceContext::IASetPrimitiveTopology**](https://msdn.microsoft.com/library/windows/desktop/ff476455) with the [**D3D11\\_PRIMITIVE\\_TOPOLOGY\\_TRIANGLESTRIP**](https://msdn.microsoft.com/library/windows/desktop/ff476189#D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP) value to specify for the input-assembler stage to interpret the vertex data as a triangle strip.\n4.  Next, we call [**ID3D11DeviceContext::VSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476493) to initialize the vertex shader stage with the vertex shader code and [**ID3D11DeviceContext::PSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476472) to initialize the pixel shader stage with the pixel shader code.\n5.  Finally, we call [**ID3D11DeviceContext::DrawIndexed**](https://msdn.microsoft.com/library/windows/desktop/ff476409) to draw the triangle and submit it to the rendering pipeline.\n\nWe call [**IDXGISwapChain::Present**](https://msdn.microsoft.com/library/windows/desktop/bb174576) to present the rendered image to the window.\n\n```cpp\n            // Specify the render target we created as the output target.\n            m_d3dDeviceContext->OMSetRenderTargets(\n                1,\n                m_renderTargetView.GetAddressOf(),\n                nullptr // Use no depth stencil.\n                );\n\n            // Clear the render target to a solid color.\n            const float clearColor[4] = { 0.071f, 0.04f, 0.561f, 1.0f };\n            m_d3dDeviceContext->ClearRenderTargetView(\n                m_renderTargetView.Get(),\n                clearColor\n                );\n\n            m_d3dDeviceContext->IASetInputLayout(inputLayout.Get());\n\n            // Set the vertex and index buffers, and specify the way they define geometry.\n            UINT stride = sizeof(float2);\n            UINT offset = 0;\n            m_d3dDeviceContext->IASetVertexBuffers(\n                0,\n                1,\n                vertexBuffer.GetAddressOf(),\n                &stride,\n                &offset\n                );\n\n            m_d3dDeviceContext->IASetIndexBuffer(\n                indexBuffer.Get(),\n                DXGI_FORMAT_R16_UINT,\n                0\n                );\n\n            m_d3dDeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n\n            // Set the vertex and pixel shader stage state.\n            m_d3dDeviceContext->VSSetShader(\n                vertexShader.Get(),\n                nullptr,\n                0\n                );\n\n            m_d3dDeviceContext->PSSetShader(\n                pixelShader.Get(),\n                nullptr,\n                0\n                );\n\n            // Draw the cube.\n            m_d3dDeviceContext->DrawIndexed(\n                ARRAYSIZE(triangleIndices),\n                0,\n                0\n                );\n\n            // Present the rendered image to the window.  Because the maximum frame latency is set to 1,\n            // the render loop will generally be throttled to the screen refresh rate, typically around\n            // 60 Hz, by sleeping the application on Present until the screen is refreshed.\n            DX::ThrowIfFailed(\n                m_swapChain->Present(1, 0)\n                );\n```\n\n## Summary and next steps\n\n\nWe created and drew a yellow triangle by using vertex and pixel shaders.\n\nNext, we create an orbiting 3D cube and apply lighting effects to it.\n\n[Using depth and effects on primitives](using-depth-and-effects-on-primitives.md)\n\n \n\n \n\n\n\n\n"}