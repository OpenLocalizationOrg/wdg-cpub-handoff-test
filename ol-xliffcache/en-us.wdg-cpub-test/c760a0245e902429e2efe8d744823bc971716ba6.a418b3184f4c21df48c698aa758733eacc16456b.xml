{"nodes":[{"pos":[11,34],"content":"Port the shader objects","needQuote":true,"needEscape":true,"nodes":[{"content":"Port the shader objects","pos":[0,23]}]},{"pos":[48,298],"content":"When porting the simple renderer from OpenGL ES 2.0, the first step is to set up the equivalent vertex and fragment shader objects in Direct3D 11, and to make sure that the main program can communicate with the shader objects after they are compiled.","needQuote":true,"needEscape":true,"nodes":[{"content":"When porting the simple renderer from OpenGL ES 2.0, the first step is to set up the equivalent vertex and fragment shader objects in Direct3D 11, and to make sure that the main program can communicate with the shader objects after they are compiled.","pos":[0,250]}]},{"content":"Port the shader objects","pos":[355,378]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[381,419]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[420,515],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Important APIs","pos":[520,534]},{"content":"ID3D11Device","pos":[545,557]},{"content":"ID3D11DeviceContext","pos":[629,648]},{"content":"When porting the simple renderer from OpenGL ES 2.0, the first step is to set up the equivalent vertex and fragment shader objects in Direct3D 11, and to make sure that the main program can communicate with the shader objects after they are compiled.","pos":[714,964]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   Have you created a new Direct3D project?","pos":[968,1019],"source":"**Note**   Have you created a new Direct3D project?"},{"content":"If not, follow the instructions in <bpt id=\"p1\">[</bpt>Create a new DirectX 11 project for Universal Windows Platform (UWP)<ept id=\"p1\">](user-interface.md)</ept>.","pos":[1020,1145],"source":" If not, follow the instructions in [Create a new DirectX 11 project for Universal Windows Platform (UWP)](user-interface.md)."},{"content":"This walkthrough assumes that you have the created the DXGI and Direct3D resources for drawing to the screen, and which are provided in the template.","pos":[1146,1295]},{"content":"Much like OpenGL ES 2.0, the compiled shaders in Direct3D must be associated with a drawing context.","pos":[1300,1400]},{"content":"However, Direct3D does not have the concept of a shader program object per se; instead, you must assign the shaders directly to a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept>.","pos":[1401,1618],"source":" However, Direct3D does not have the concept of a shader program object per se; instead, you must assign the shaders directly to a [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385)."},{"content":"This step follows the OpenGL ES 2.0 process for creating and binding shader objects, and provides you with the corresponding API behaviors in Direct3D.","pos":[1619,1770]},{"content":"Instructions","pos":[1772,1784]},{"content":"Step 1: Compile the shaders","pos":[1803,1830]},{"content":"In this simple OpenGL ES 2.0 sample, the shaders are stored as text files and loaded as string data for run-time compilation.","pos":[1832,1957]},{"content":"OpenGL ES 2.0: Compile a shader","pos":[1959,1990]},{"content":"In Direct3D, shaders are not compiled during run-time; they are always compiled to CSO files when the rest of the program is compiled.","pos":[2890,3024]},{"content":"When you compile your app with Microsoft Visual Studio, the HLSL files are compiled to CSO (.cso) files that your app must load.","pos":[3025,3153]},{"content":"Make sure you include these CSO files with your app when you package it!","pos":[3154,3226]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   The following example performs the shader loading and compilation asynchronously using the <bpt id=\"p2\">**</bpt>auto<ept id=\"p2\">**</ept> keyword and lambda syntax.","pos":[3230,3367],"source":"**Note**   The following example performs the shader loading and compilation asynchronously using the **auto** keyword and lambda syntax."},{"content":"ReadDataAsync() is a method implemented for the template that reads in a CSO file as an array of byte data (fileData).","pos":[3368,3486]},{"content":"Direct3D 11: Compile a shader","pos":[3491,3520]},{"content":"Step 2: Create and load the vertex and fragment (pixel) shaders","pos":[4070,4133]},{"content":"OpenGL ES 2.0 has the notion of a shader \"program\", which serves as the interface between the main program running on the CPU and the shaders, which are executed on the GPU.","pos":[4135,4308]},{"content":"Shaders are compiled (or loaded from compiled sources) and associated with a program, which enables execution on the GPU.","pos":[4309,4430]},{"content":"OpenGL ES 2.0: Loading the vertex and fragment shaders into a shading program","pos":[4432,4509]},{"content":"Direct3D does not have the concept of a shader program object.","pos":[6205,6267]},{"content":"Rather, the shaders are created when one of the shader creation methods on the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</ept> interface (such as <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11Device::CreateVertexShader<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476524)</ept> or <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ID3D11Device::CreatePixelShader<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ff476513)</ept>) is called.","pos":[6268,6659],"source":" Rather, the shaders are created when one of the shader creation methods on the [**ID3D11Device**](https://msdn.microsoft.com/library/windows/desktop/ff476379) interface (such as [**ID3D11Device::CreateVertexShader**](https://msdn.microsoft.com/library/windows/desktop/ff476524) or [**ID3D11Device::CreatePixelShader**](https://msdn.microsoft.com/library/windows/desktop/ff476513)) is called."},{"content":"To set the shaders for the current drawing context, we provide them to corresponding <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept> with a set shader method, such as <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext::VSSetShader<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</ept> for the vertex shader or <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ID3D11DeviceContext::PSSetShader<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</ept> for the fragment shader.","pos":[6660,7115],"source":" To set the shaders for the current drawing context, we provide them to corresponding [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385) with a set shader method, such as [**ID3D11DeviceContext::VSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476493) for the vertex shader or [**ID3D11DeviceContext::PSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476472) for the fragment shader."},{"content":"Direct3D 11: Set the shaders for the graphics device drawing context.","pos":[7117,7186]},{"content":"Step 3: Define the data to supply to the shaders","pos":[7344,7392]},{"pos":[7394,7483],"content":"In our OpenGL ES 2.0 example, we have one <bpt id=\"p1\">**</bpt>uniform<ept id=\"p1\">**</ept> to declare for the shader pipeline:","source":"In our OpenGL ES 2.0 example, we have one **uniform** to declare for the shader pipeline:"},{"pos":[7489,7716],"content":"<bpt id=\"p1\">**</bpt>u\\_mvpMatrix<ept id=\"p1\">**</ept>: a 4x4 array of floats that represents the final model-view-projection transformation matrix that takes the model coordinates for the cube and transforms them into 2D projection coordinates for scan conversion.","source":"**u\\_mvpMatrix**: a 4x4 array of floats that represents the final model-view-projection transformation matrix that takes the model coordinates for the cube and transforms them into 2D projection coordinates for scan conversion."},{"pos":[7718,7767],"content":"And two <bpt id=\"p1\">**</bpt>attribute<ept id=\"p1\">**</ept> values for the vertex data:","source":"And two **attribute** values for the vertex data:"},{"pos":[7773,7845],"content":"<bpt id=\"p1\">**</bpt>a\\_position<ept id=\"p1\">**</ept>: a 4-float vector for the model coordinates of a vertex.","source":"**a\\_position**: a 4-float vector for the model coordinates of a vertex."},{"pos":[7850,7933],"content":"<bpt id=\"p1\">**</bpt>a\\_color<ept id=\"p1\">**</ept>: A 4-float vector for the RGBA color value associated with the vertex.","source":"**a\\_color**: A 4-float vector for the RGBA color value associated with the vertex."},{"content":"Open GL ES 2.0: GLSL definitions for the uniforms and attributes","pos":[7935,7999]},{"content":"The corresponding main program variables are defined as fields on the renderer object, in this case.","pos":[8094,8194]},{"content":"(Refer to the header in <bpt id=\"p1\">[</bpt>How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11<ept id=\"p1\">](port-a-simple-opengl-es-2-0-renderer-to-directx-11-1.md)</ept>.) Once we've done that, we need to specify the locations in memory where the main program will supply these values for the shader pipeline, which we typically do right before a draw call:","pos":[8195,8525],"source":" (Refer to the header in [How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11](port-a-simple-opengl-es-2-0-renderer-to-directx-11-1.md).) Once we've done that, we need to specify the locations in memory where the main program will supply these values for the shader pipeline, which we typically do right before a draw call:"},{"content":"OpenGL ES 2.0: Marking the location of the uniform and attribute data","pos":[8527,8596]},{"content":"Direct3D does not have the concept of an \"attribute\" or a \"uniform\" in the same sense (or, at least, it does not share this syntax).","pos":[9171,9303]},{"content":"Rather, it has constant buffers, represented as Direct3D subresources -- resources that are shared between the main program and the shader programs.","pos":[9304,9452]},{"content":"Some of these subresources, such as vertex positions and colors, are described as HLSL semantics.","pos":[9453,9550]},{"content":"For more info on constant buffers and HLSL semantics as they relate to OpenGL ES 2.0 concepts, read <bpt id=\"p1\">[</bpt>Port frame buffer objects, uniforms, and attributes<ept id=\"p1\">](porting-uniforms-and-attributes.md)</ept>.","pos":[9551,9741],"source":" For more info on constant buffers and HLSL semantics as they relate to OpenGL ES 2.0 concepts, read [Port frame buffer objects, uniforms, and attributes](porting-uniforms-and-attributes.md)."},{"content":"When moving this process to Direct3D, we convert the uniform to a Direct3D constant buffer (cbuffer) and assign it a register for lookup with the <bpt id=\"p1\">**</bpt>register<ept id=\"p1\">**</ept> HLSL semantic.","pos":[9743,9916],"source":"When moving this process to Direct3D, we convert the uniform to a Direct3D constant buffer (cbuffer) and assign it a register for lookup with the **register** HLSL semantic."},{"content":"The two vertex attributes are handled as input elements to the shader pipeline stages, and are also assigned <bpt id=\"p1\">[</bpt>HLSL semantics<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb205574)</ept> (POSITION and COLOR0) that inform the shaders.","pos":[9917,10150],"source":" The two vertex attributes are handled as input elements to the shader pipeline stages, and are also assigned [HLSL semantics](https://msdn.microsoft.com/library/windows/desktop/bb205574) (POSITION and COLOR0) that inform the shaders."},{"content":"The pixel shader takes an SV\\_POSITION, with the SV\\_ prefix indicating that it is a system value generated by the GPU.","pos":[10151,10270]},{"content":"(In this case, it is a pixel position generated during scan conversion.) VertexShaderInput and PixelShaderInput are not declared as constant buffers because the former will be used to define the vertex buffer (see <bpt id=\"p1\">[</bpt>Port the vertex buffers and data<ept id=\"p1\">](port-the-vertex-buffers-and-data-config.md)</ept>), and the data for the latter is generated as the result of a previous stage in the pipeline, which in this case is the vertex shader.","pos":[10271,10698],"source":" (In this case, it is a pixel position generated during scan conversion.) VertexShaderInput and PixelShaderInput are not declared as constant buffers because the former will be used to define the vertex buffer (see [Port the vertex buffers and data](port-the-vertex-buffers-and-data-config.md)), and the data for the latter is generated as the result of a previous stage in the pipeline, which in this case is the vertex shader."},{"content":"Direct3D: HLSL definitions for the constant buffers and vertex data","pos":[10700,10767]},{"pos":[11138,11317],"content":"For more info on porting to constant buffers and the application of HLSL semantics, read <bpt id=\"p1\">[</bpt>Port frame buffer objects, uniforms, and attributes<ept id=\"p1\">](porting-uniforms-and-attributes.md)</ept>.","source":"For more info on porting to constant buffers and the application of HLSL semantics, read [Port frame buffer objects, uniforms, and attributes](porting-uniforms-and-attributes.md)."},{"content":"Here are the structures for the layout of the data passed to the shader pipeline with a constant or vertex buffer.","pos":[11319,11433]},{"content":"Direct3D 11: Declaring the constant and vertex buffers layout","pos":[11435,11496]},{"content":"Use the DirectXMath XM\\* types for your constant buffer elements, since they provide proper packing and alignment for the contents when they are sent to the shader pipeline.","pos":[11809,11982]},{"content":"If you use standard Windows platform float types and arrays, you must perform the packing and alignment yourself.","pos":[11983,12096]},{"content":"To bind a constant buffer, create a layout description as a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CD3D11\\_BUFFER\\_DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/jj151620)</ept> structure, and pass it to <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3DDevice::CreateBuffer<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept>.","pos":[12098,12364],"source":"To bind a constant buffer, create a layout description as a [**CD3D11\\_BUFFER\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/jj151620) structure, and pass it to [**ID3DDevice::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501)."},{"content":"Then, in your render method, pass the constant buffer to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::UpdateSubresource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476486)</ept> before drawing.","pos":[12365,12543],"source":" Then, in your render method, pass the constant buffer to [**ID3D11DeviceContext::UpdateSubresource**](https://msdn.microsoft.com/library/windows/desktop/ff476486) before drawing."},{"content":"Direct3D 11: Bind the constant buffer","pos":[12545,12582]},{"pos":[12983,13149],"content":"The vertex buffer is created and updated similarly, and is discussed in the next step, <bpt id=\"p1\">[</bpt>Port the vertex buffers and data<ept id=\"p1\">](port-the-vertex-buffers-and-data-config.md)</ept>.","source":"The vertex buffer is created and updated similarly, and is discussed in the next step, [Port the vertex buffers and data](port-the-vertex-buffers-and-data-config.md)."},{"content":"Next step","pos":[13151,13160]},{"content":"Port the vertex buffers and data","pos":[13173,13205]},{"content":"Related topics","pos":[13254,13268]},{"content":"How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11","pos":[13272,13331]},{"content":"Port the vertex buffers and data","pos":[13392,13424]},{"content":"Port the GLSL","pos":[13472,13485]},{"content":"Draw to the screen","pos":[13507,13525]}],"content":"---\ntitle: Port the shader objects\ndescription: When porting the simple renderer from OpenGL ES 2.0, the first step is to set up the equivalent vertex and fragment shader objects in Direct3D 11, and to make sure that the main program can communicate with the shader objects after they are compiled.\nms.assetid: 0383b774-bc1b-910e-8eb6-cc969b3dcc08\n---\n\n# Port the shader objects\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\n**Important APIs**\n\n-   [**ID3D11Device**](https://msdn.microsoft.com/library/windows/desktop/ff476379)\n-   [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385)\n\nWhen porting the simple renderer from OpenGL ES 2.0, the first step is to set up the equivalent vertex and fragment shader objects in Direct3D 11, and to make sure that the main program can communicate with the shader objects after they are compiled.\n\n> **Note**   Have you created a new Direct3D project? If not, follow the instructions in [Create a new DirectX 11 project for Universal Windows Platform (UWP)](user-interface.md). This walkthrough assumes that you have the created the DXGI and Direct3D resources for drawing to the screen, and which are provided in the template.\n\n \n\nMuch like OpenGL ES 2.0, the compiled shaders in Direct3D must be associated with a drawing context. However, Direct3D does not have the concept of a shader program object per se; instead, you must assign the shaders directly to a [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385). This step follows the OpenGL ES 2.0 process for creating and binding shader objects, and provides you with the corresponding API behaviors in Direct3D.\n\nInstructions\n------------\n\n### Step 1: Compile the shaders\n\nIn this simple OpenGL ES 2.0 sample, the shaders are stored as text files and loaded as string data for run-time compilation.\n\nOpenGL ES 2.0: Compile a shader\n\n``` syntax\nGLuint __cdecl CompileShader (GLenum shaderType, const char *shaderSrcStr)\n// shaderType can be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. Returns 0 if compilation fails.\n{\n  GLuint shaderHandle;\n  GLint compiledShaderHandle;\n   \n  // Create an empty shader object.\n  shaderHandle = glCreateShader(shaderType);\n\n  if (shaderHandle == 0)\n  return 0;\n\n  // Load the GLSL shader source as a string value. You could obtain it from\n  // from reading a text file or hardcoded.\n  glShaderSource(shaderHandle, 1, &shaderSrcStr, NULL);\n   \n  // Compile the shader.\n  glCompileShader(shaderHandle);\n\n  // Check the compile status\n  glGetShaderiv(shaderHandle, GL_COMPILE_STATUS, &compiledShaderHandle);\n\n  if (!compiledShaderHandle) // error in compilation occurred\n  {\n    // Handle any errors here.\n              \n    glDeleteShader(shaderHandle);\n    return 0;\n  }\n\n  return shaderHandle;\n\n}\n```\n\nIn Direct3D, shaders are not compiled during run-time; they are always compiled to CSO files when the rest of the program is compiled. When you compile your app with Microsoft Visual Studio, the HLSL files are compiled to CSO (.cso) files that your app must load. Make sure you include these CSO files with your app when you package it!\n\n> **Note**   The following example performs the shader loading and compilation asynchronously using the **auto** keyword and lambda syntax. ReadDataAsync() is a method implemented for the template that reads in a CSO file as an array of byte data (fileData).\n\n \n\nDirect3D 11: Compile a shader\n\n``` syntax\nauto loadVSTask = DX::ReadDataAsync(m_projectDir + \"SimpleVertexShader.cso\");\nauto loadPSTask = DX::ReadDataAsync(m_projectDir + \"SimplePixelShader.cso\");\n\nauto createVSTask = loadVSTask.then([this](Platform::Array<byte>^ fileData) {\n\nm_d3dDevice->CreateVertexShader(\n  fileData->Data,\n  fileData->Length,\n  nullptr,\n  &m_vertexShader);\n\nauto createPSTask = loadPSTask.then([this](Platform::Array<byte>^ fileData) {\n  m_d3dDevice->CreatePixelShader(\n    fileData->Data,\n    fileData->Length,\n    nullptr,\n    &m_pixelShader;\n};\n```\n\n### Step 2: Create and load the vertex and fragment (pixel) shaders\n\nOpenGL ES 2.0 has the notion of a shader \"program\", which serves as the interface between the main program running on the CPU and the shaders, which are executed on the GPU. Shaders are compiled (or loaded from compiled sources) and associated with a program, which enables execution on the GPU.\n\nOpenGL ES 2.0: Loading the vertex and fragment shaders into a shading program\n\n``` syntax\nGLuint __cdecl LoadShaderProgram (const char *vertShaderSrcStr, const char *fragShaderSrcStr)\n{\n  GLuint programObject, vertexShaderHandle, fragmentShaderHandle;\n  GLint linkStatusCode;\n\n  // Load the vertex shader and compile it to an internal executable format.\n  vertexShaderHandle = CompileShader(GL_VERTEX_SHADER, vertShaderSrcStr);\n  if (vertexShaderHandle == 0)\n  {\n    glDeleteShader(vertexShaderHandle);\n    return 0;\n  }\n\n   // Load the fragment/pixel shader and compile it to an internal executable format.\n  fragmentShaderHandle = CompileShader(GL_FRAGMENT_SHADER, fragShaderSrcStr);\n  if (fragmentShaderHandle == 0)\n  {\n    glDeleteShader(fragmentShaderHandle);\n    return 0;\n  }\n\n  // Create the program object proper.\n  programObject = glCreateProgram();\n   \n  if (programObject == 0)    return 0;\n\n  // Attach the compiled shaders\n  glAttachShader(programObject, vertexShaderHandle);\n  glAttachShader(programObject, fragmentShaderHandle);\n\n  // Compile the shaders into binary executables in memory and link them to the program object..\n  glLinkProgram(programObject);\n\n  // Check the project object link status and determine if the program is available.\n  glGetProgramiv(programObject, GL_LINK_STATUS, &linkStatusCode);\n\n  if (!linkStatusCode) // if link status <> 0\n  {\n    // Linking failed; delete the program object and return a failure code (0).\n\n    glDeleteProgram (programObject);\n    return 0;\n  }\n\n  // Deallocate the unused shader resources. The actual executables are part of the program object.\n  glDeleteShader(vertexShaderHandle);\n  glDeleteShader(fragmentShaderHandle);\n\n  return programObject;\n}\n\n// ...\n\nglUseProgram(renderer->programObject);\n```\n\nDirect3D does not have the concept of a shader program object. Rather, the shaders are created when one of the shader creation methods on the [**ID3D11Device**](https://msdn.microsoft.com/library/windows/desktop/ff476379) interface (such as [**ID3D11Device::CreateVertexShader**](https://msdn.microsoft.com/library/windows/desktop/ff476524) or [**ID3D11Device::CreatePixelShader**](https://msdn.microsoft.com/library/windows/desktop/ff476513)) is called. To set the shaders for the current drawing context, we provide them to corresponding [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385) with a set shader method, such as [**ID3D11DeviceContext::VSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476493) for the vertex shader or [**ID3D11DeviceContext::PSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476472) for the fragment shader.\n\nDirect3D 11: Set the shaders for the graphics device drawing context.\n\n``` syntax\nm_d3dContext->VSSetShader(\n  m_vertexShader.Get(),\n  nullptr,\n  0);\n\nm_d3dContext->PSSetShader(\n  m_pixelShader.Get(),\n  nullptr,\n  0);\n```\n\n### Step 3: Define the data to supply to the shaders\n\nIn our OpenGL ES 2.0 example, we have one **uniform** to declare for the shader pipeline:\n\n-   **u\\_mvpMatrix**: a 4x4 array of floats that represents the final model-view-projection transformation matrix that takes the model coordinates for the cube and transforms them into 2D projection coordinates for scan conversion.\n\nAnd two **attribute** values for the vertex data:\n\n-   **a\\_position**: a 4-float vector for the model coordinates of a vertex.\n-   **a\\_color**: A 4-float vector for the RGBA color value associated with the vertex.\n\nOpen GL ES 2.0: GLSL definitions for the uniforms and attributes\n\n``` syntax\nuniform mat4 u_mvpMatrix;\nattribute vec4 a_position;\nattribute vec4 a_color;\n```\n\nThe corresponding main program variables are defined as fields on the renderer object, in this case. (Refer to the header in [How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11](port-a-simple-opengl-es-2-0-renderer-to-directx-11-1.md).) Once we've done that, we need to specify the locations in memory where the main program will supply these values for the shader pipeline, which we typically do right before a draw call:\n\nOpenGL ES 2.0: Marking the location of the uniform and attribute data\n\n``` syntax\n\n// Inform the shader of the attribute locations\nloc = glGetAttribLocation(renderer->programObject, \"a_position\");\nglVertexAttribPointer(loc, 3, GL_FLOAT, GL_FALSE, \n    sizeof(Vertex), 0);\nglEnableVertexAttribArray(loc);\n\nloc = glGetAttribLocation(renderer->programObject, \"a_color\");\nglVertexAttribPointer(loc, 4, GL_FLOAT, GL_FALSE, \n    sizeof(Vertex), (GLvoid*) (sizeof(float) * 3));\nglEnableVertexAttribArray(loc);\n\n\n// Inform the shader program of the uniform location\nrenderer->mvpLoc = glGetUniformLocation(renderer->programObject, \"u_mvpMatrix\");\n```\n\nDirect3D does not have the concept of an \"attribute\" or a \"uniform\" in the same sense (or, at least, it does not share this syntax). Rather, it has constant buffers, represented as Direct3D subresources -- resources that are shared between the main program and the shader programs. Some of these subresources, such as vertex positions and colors, are described as HLSL semantics. For more info on constant buffers and HLSL semantics as they relate to OpenGL ES 2.0 concepts, read [Port frame buffer objects, uniforms, and attributes](porting-uniforms-and-attributes.md).\n\nWhen moving this process to Direct3D, we convert the uniform to a Direct3D constant buffer (cbuffer) and assign it a register for lookup with the **register** HLSL semantic. The two vertex attributes are handled as input elements to the shader pipeline stages, and are also assigned [HLSL semantics](https://msdn.microsoft.com/library/windows/desktop/bb205574) (POSITION and COLOR0) that inform the shaders. The pixel shader takes an SV\\_POSITION, with the SV\\_ prefix indicating that it is a system value generated by the GPU. (In this case, it is a pixel position generated during scan conversion.) VertexShaderInput and PixelShaderInput are not declared as constant buffers because the former will be used to define the vertex buffer (see [Port the vertex buffers and data](port-the-vertex-buffers-and-data-config.md)), and the data for the latter is generated as the result of a previous stage in the pipeline, which in this case is the vertex shader.\n\nDirect3D: HLSL definitions for the constant buffers and vertex data\n\n``` syntax\ncbuffer ModelViewProjectionConstantBuffer : register(b0)\n{\n  matrix mvp;\n};\n\n// Per-vertex data used as input to the vertex shader.\nstruct VertexShaderInput\n{\n  float4 pos : POSITION;\n  float4 color : COLOR0;\n};\n\n// Per-vertex color data passed through the pixel shader.\nstruct PixelShaderInput\n{\n  float4 pos : SV_POSITION;\n  float3 color : COLOR0;\n};\n```\n\nFor more info on porting to constant buffers and the application of HLSL semantics, read [Port frame buffer objects, uniforms, and attributes](porting-uniforms-and-attributes.md).\n\nHere are the structures for the layout of the data passed to the shader pipeline with a constant or vertex buffer.\n\nDirect3D 11: Declaring the constant and vertex buffers layout\n\n``` syntax\n// Constant buffer used to send MVP matrices to the vertex shader.\nstruct ModelViewProjectionConstantBuffer\n{\n  DirectX::XMFLOAT4X4 modelViewProjection;\n};\n\n// Used to send per-vertex data to the vertex shader.\nstruct VertexPositionColor\n{\n  DirectX::XMFLOAT4 pos;\n  DirectX::XMFLOAT4 color;\n};\n```\n\nUse the DirectXMath XM\\* types for your constant buffer elements, since they provide proper packing and alignment for the contents when they are sent to the shader pipeline. If you use standard Windows platform float types and arrays, you must perform the packing and alignment yourself.\n\nTo bind a constant buffer, create a layout description as a [**CD3D11\\_BUFFER\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/jj151620) structure, and pass it to [**ID3DDevice::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501). Then, in your render method, pass the constant buffer to [**ID3D11DeviceContext::UpdateSubresource**](https://msdn.microsoft.com/library/windows/desktop/ff476486) before drawing.\n\nDirect3D 11: Bind the constant buffer\n\n``` syntax\nCD3D11_BUFFER_DESC constantBufferDesc(sizeof(ModelViewProjectionConstantBuffer), D3D11_BIND_CONSTANT_BUFFER);\n\nm_d3dDevice->CreateBuffer(\n  &constantBufferDesc,\n  nullptr,\n  &m_constantBuffer);\n\n// ...\n\n// Only update shader resources that have changed since the last frame.\nm_d3dContext->UpdateSubresource(\n  m_constantBuffer.Get(),\n  0,\n  NULL,\n  &m_constantBufferData,\n  0,\n  0);\n```\n\nThe vertex buffer is created and updated similarly, and is discussed in the next step, [Port the vertex buffers and data](port-the-vertex-buffers-and-data-config.md).\n\nNext step\n---------\n\n[Port the vertex buffers and data](port-the-vertex-buffers-and-data-config.md)\n## Related topics\n\n\n[How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11](port-a-simple-opengl-es-2-0-renderer-to-directx-11-1.md)\n\n[Port the vertex buffers and data](port-the-vertex-buffers-and-data-config.md)\n\n[Port the GLSL](port-the-glsl.md)\n\n[Draw to the screen](draw-to-the-screen.md)\n\n \n\n \n\n\n\n\n"}