{"nodes":[{"pos":[11,46],"content":"Use depth and effects on primitives","needQuote":true,"needEscape":true,"nodes":[{"content":"Use depth and effects on primitives","pos":[0,35]}]},{"pos":[60,148],"content":"Here, we show you how to use depth, perspective, color, and other effects on primitives.","needQuote":true,"needEscape":true,"nodes":[{"content":"Here, we show you how to use depth, perspective, color, and other effects on primitives.","pos":[0,88]}]},{"content":"Use depth and effects on primitives","pos":[205,240]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[243,281]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[282,377],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Here, we show you how to use depth, perspective, color, and other effects on primitives.","pos":[379,467]},{"pos":[469,557],"content":"<bpt id=\"p1\">**</bpt>Objective:<ept id=\"p1\">**</ept> To create a 3D object and apply basic vertex lighting and coloring to it.","source":"**Objective:** To create a 3D object and apply basic vertex lighting and coloring to it."},{"content":"Prerequisites","pos":[562,575]},{"content":"We assume that you are familiar with C++.","pos":[578,619]},{"content":"You also need basic experience with graphics programming concepts.","pos":[620,686]},{"pos":[688,915],"content":"We also assume that you went through <bpt id=\"p1\">[</bpt>Quickstart: setting up DirectX resources and displaying an image<ept id=\"p1\">](setting-up-directx-resources.md)</ept> and <bpt id=\"p2\">[</bpt>Creating shaders and drawing primitives<ept id=\"p2\">](creating-shaders-and-drawing-primitives.md)</ept>.","source":"We also assume that you went through [Quickstart: setting up DirectX resources and displaying an image](setting-up-directx-resources.md) and [Creating shaders and drawing primitives](creating-shaders-and-drawing-primitives.md)."},{"pos":[917,950],"content":"<bpt id=\"p1\">**</bpt>Time to complete:<ept id=\"p1\">**</ept> 20 minutes.","source":"**Time to complete:** 20 minutes."},{"content":"Instructions","pos":[952,964]},{"content":"1. Defining cube variables","pos":[983,1009]},{"content":"First, we need to define the <bpt id=\"p1\">**</bpt>SimpleCubeVertex<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>ConstantBuffer<ept id=\"p2\">**</ept> structures for the cube.","pos":[1011,1108],"source":"First, we need to define the **SimpleCubeVertex** and **ConstantBuffer** structures for the cube."},{"content":"These structures specify the vertex positions and colors for the cube and how the cube will be viewed.","pos":[1109,1211]},{"content":"We declare <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DepthStencilView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476377)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11Buffer<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476351)</ept> with <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ComPtr<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br244983.aspx)</ept> and declare an instance of <bpt id=\"p7\">**</bpt>ConstantBuffer<ept id=\"p7\">**</ept>.","pos":[1212,1524],"source":" We declare [**ID3D11DepthStencilView**](https://msdn.microsoft.com/library/windows/desktop/ff476377) and [**ID3D11Buffer**](https://msdn.microsoft.com/library/windows/desktop/ff476351) with [**ComPtr**](https://msdn.microsoft.com/library/windows/apps/br244983.aspx) and declare an instance of **ConstantBuffer**."},{"content":"2. Creating a depth stencil view","pos":[2270,2302]},{"content":"In addition to creating the render-target view, we also create a depth-stencil view.","pos":[2304,2388]},{"content":"The depth-stencil view enables Direct3D to efficiently render objects closer to the camera in front of objects further from the camera.","pos":[2389,2524]},{"content":"Before we can create a view to a depth-stencil buffer, we must create the depth-stencil buffer.","pos":[2525,2620]},{"content":"We populate a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11\\_TEXTURE2D\\_DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476253)</ept> to describe the depth-stencil buffer and then call <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11Device::CreateTexture2D<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476521)</ept> to create the depth-stencil buffer.","pos":[2621,2908],"source":" We populate a [**D3D11\\_TEXTURE2D\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476253) to describe the depth-stencil buffer and then call [**ID3D11Device::CreateTexture2D**](https://msdn.microsoft.com/library/windows/desktop/ff476521) to create the depth-stencil buffer."},{"content":"To create the depth-stencil view, we populate a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11\\_DEPTH\\_STENCIL\\_VIEW\\_DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476112)</ept> to describe the depth-stencil view and pass the depth-stencil view description and the depth-stencil buffer to <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11Device::CreateDepthStencilView<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476507)</ept>.","pos":[2909,3273],"source":" To create the depth-stencil view, we populate a [**D3D11\\_DEPTH\\_STENCIL\\_VIEW\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476112) to describe the depth-stencil view and pass the depth-stencil view description and the depth-stencil buffer to [**ID3D11Device::CreateDepthStencilView**](https://msdn.microsoft.com/library/windows/desktop/ff476507)."},{"content":"3. Updating perspective with the window","pos":[4963,5002]},{"content":"We update the perspective projection parameters for the constant buffer depending on the window dimensions.","pos":[5004,5111]},{"content":"We fix the parameters to a 70-degree field of view with a depth range of 0.01 to 100.","pos":[5112,5197]},{"content":"4. Creating vertex and pixel shaders with color elements","pos":[6261,6317]},{"content":"In this app, we create more complex vertex and pixel shaders than what we described in the previous tutorial, <bpt id=\"p1\">[</bpt>Creating shaders and drawing primitives<ept id=\"p1\">](creating-shaders-and-drawing-primitives.md)</ept>.","pos":[6319,6515],"source":"In this app, we create more complex vertex and pixel shaders than what we described in the previous tutorial, [Creating shaders and drawing primitives](creating-shaders-and-drawing-primitives.md)."},{"content":"The app's vertex shader transforms each vertex position into projection space and passes the vertex color through to the pixel shader.","pos":[6516,6650]},{"pos":[6652,6933],"content":"The app's array of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11\\_INPUT\\_ELEMENT\\_DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476180)</ept> structures that describe the layout of the vertex shader code has two layout elements: one element defines the vertex position and the other element defines the color.","source":"The app's array of [**D3D11\\_INPUT\\_ELEMENT\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476180) structures that describe the layout of the vertex shader code has two layout elements: one element defines the vertex position and the other element defines the color."},{"content":"We create vertex, index, and constant buffers to define an orbiting cube.","pos":[6935,7008]},{"content":"To define an orbiting cube","pos":[7012,7038]},{"content":"First, we define the cube.","pos":[7046,7072]},{"content":"We assign each vertex a color in addition to a position.","pos":[7073,7129]},{"content":"This allows the pixel shader to color each face differently so the face can be distinguished.","pos":[7130,7223]},{"content":"Next, we describe the vertex and index buffers (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11\\_BUFFER\\_DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>D3D11\\_SUBRESOURCE\\_DATA<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept>) using the cube definition.","pos":[7228,7486],"source":"Next, we describe the vertex and index buffers ([**D3D11\\_BUFFER\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476092) and [**D3D11\\_SUBRESOURCE\\_DATA**](https://msdn.microsoft.com/library/windows/desktop/ff476220)) using the cube definition."},{"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device::CreateBuffer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept> once for each buffer.","pos":[7487,7610],"source":" We call [**ID3D11Device::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501) once for each buffer."},{"content":"Next, we create a constant buffer (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11\\_BUFFER\\_DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept>) for passing model, view, and projection matrices to the vertex shader.","pos":[7615,7808],"source":"Next, we create a constant buffer ([**D3D11\\_BUFFER\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476092)) for passing model, view, and projection matrices to the vertex shader."},{"content":"We can later use the constant buffer to rotate the cube and apply a perspective projection to it.","pos":[7809,7906]},{"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device::CreateBuffer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept> to create the constant buffer.","pos":[7907,8039],"source":" We call [**ID3D11Device::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501) to create the constant buffer."},{"content":"Next, we specify the view transform that corresponds to a camera position of X = 0, Y = 1, Z = 2.","pos":[8044,8141]},{"pos":[8146,8250],"content":"Finally, we declare a <bpt id=\"p1\">*</bpt>degree<ept id=\"p1\">*</ept> variable that we will use to animate the cube by rotating it every frame.","source":"Finally, we declare a *degree* variable that we will use to animate the cube by rotating it every frame."},{"content":"5. Rotating and drawing the cube and presenting the rendered image","pos":[15010,15076]},{"content":"We enter an endless loop to continually render and display the scene.","pos":[15078,15147]},{"content":"We call the <bpt id=\"p1\">**</bpt>rotationY<ept id=\"p1\">**</ept> inline function (BasicMath.h) with a rotation amount to set values that will rotate the cube’s model matrix around the Y axis.","pos":[15148,15300],"source":" We call the **rotationY** inline function (BasicMath.h) with a rotation amount to set values that will rotate the cube’s model matrix around the Y axis."},{"content":"We then call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::UpdateSubresource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476486)</ept> to update the constant buffer and rotate the cube model.","pos":[15301,15476],"source":" We then call [**ID3D11DeviceContext::UpdateSubresource**](https://msdn.microsoft.com/library/windows/desktop/ff476486) to update the constant buffer and rotate the cube model."},{"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::OMSetRenderTargets<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476464)</ept> to specify the render target as the output target.","pos":[15477,15642],"source":" We call [**ID3D11DeviceContext::OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464) to specify the render target as the output target."},{"content":"In this <bpt id=\"p1\">**</bpt>OMSetRenderTargets<ept id=\"p1\">**</ept> call, we pass the depth-stencil view.","pos":[15643,15711],"source":" In this **OMSetRenderTargets** call, we pass the depth-stencil view."},{"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::ClearRenderTargetView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476388)</ept> to clear the render target to a solid blue color and call <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext::ClearDepthStencilView<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476387)</ept> to clear the depth buffer.","pos":[15712,16024],"source":" We call [**ID3D11DeviceContext::ClearRenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476388) to clear the render target to a solid blue color and call [**ID3D11DeviceContext::ClearDepthStencilView**](https://msdn.microsoft.com/library/windows/desktop/ff476387) to clear the depth buffer."},{"content":"In the endless loop, we also draw the cube on the blue surface.","pos":[16026,16089]},{"content":"To draw the cube","pos":[16093,16109]},{"pos":[16117,16315],"content":"First, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::IASetInputLayout<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476454)</ept> to describe how vertex buffer data is streamed into the input-assembler stage.","source":"First, we call [**ID3D11DeviceContext::IASetInputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476454) to describe how vertex buffer data is streamed into the input-assembler stage."},{"pos":[16320,16616],"content":"Next, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::IASetVertexBuffers<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476456)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext::IASetIndexBuffer<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476453)</ept> to bind the vertex and index buffers to the input-assembler stage.","source":"Next, we call [**ID3D11DeviceContext::IASetVertexBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476456) and [**ID3D11DeviceContext::IASetIndexBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476453) to bind the vertex and index buffers to the input-assembler stage."},{"pos":[16621,16999],"content":"Next, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::IASetPrimitiveTopology<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476455)</ept> with the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>D3D11\\_PRIMITIVE\\_TOPOLOGY\\_TRIANGLESTRIP<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476189#D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP)</ept> value to specify for the input-assembler stage to interpret the vertex data as a triangle strip.","source":"Next, we call [**ID3D11DeviceContext::IASetPrimitiveTopology**](https://msdn.microsoft.com/library/windows/desktop/ff476455) with the [**D3D11\\_PRIMITIVE\\_TOPOLOGY\\_TRIANGLESTRIP**](https://msdn.microsoft.com/library/windows/desktop/ff476189#D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP) value to specify for the input-assembler stage to interpret the vertex data as a triangle strip."},{"pos":[17004,17352],"content":"Next, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::VSSetShader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</ept> to initialize the vertex shader stage with the vertex shader code and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext::PSSetShader<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</ept> to initialize the pixel shader stage with the pixel shader code.","source":"Next, we call [**ID3D11DeviceContext::VSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476493) to initialize the vertex shader stage with the vertex shader code and [**ID3D11DeviceContext::PSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476472) to initialize the pixel shader stage with the pixel shader code."},{"pos":[17357,17556],"content":"Next, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::VSSetConstantBuffers<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476491)</ept> to set the constant buffer that is used by the vertex shader pipeline stage.","source":"Next, we call [**ID3D11DeviceContext::VSSetConstantBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476491) to set the constant buffer that is used by the vertex shader pipeline stage."},{"pos":[17561,17735],"content":"Finally, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::DrawIndexed<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476409)</ept> to draw the cube and submit it to the rendering pipeline.","source":"Finally, we call [**ID3D11DeviceContext::DrawIndexed**](https://msdn.microsoft.com/library/windows/desktop/ff476409) to draw the cube and submit it to the rendering pipeline."},{"pos":[17737,17880],"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain::Present<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb174576)</ept> to present the rendered image to the window.","source":"We call [**IDXGISwapChain::Present**](https://msdn.microsoft.com/library/windows/desktop/bb174576) to present the rendered image to the window."},{"content":"Summary and next steps","pos":[20840,20862]},{"content":"We used depth, perspective, color, and other effects on primitives.","pos":[20865,20932]},{"content":"Next, we apply textures to primitives.","pos":[20934,20972]},{"content":"Applying textures to primitives","pos":[20975,21006]}],"content":"---\ntitle: Use depth and effects on primitives\ndescription: Here, we show you how to use depth, perspective, color, and other effects on primitives.\nms.assetid: 71ef34c5-b4a3-adae-5266-f86ba257482a\n---\n\n# Use depth and effects on primitives\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nHere, we show you how to use depth, perspective, color, and other effects on primitives.\n\n**Objective:** To create a 3D object and apply basic vertex lighting and coloring to it.\n\n## Prerequisites\n\n\nWe assume that you are familiar with C++. You also need basic experience with graphics programming concepts.\n\nWe also assume that you went through [Quickstart: setting up DirectX resources and displaying an image](setting-up-directx-resources.md) and [Creating shaders and drawing primitives](creating-shaders-and-drawing-primitives.md).\n\n**Time to complete:** 20 minutes.\n\nInstructions\n------------\n\n### 1. Defining cube variables\n\nFirst, we need to define the **SimpleCubeVertex** and **ConstantBuffer** structures for the cube. These structures specify the vertex positions and colors for the cube and how the cube will be viewed. We declare [**ID3D11DepthStencilView**](https://msdn.microsoft.com/library/windows/desktop/ff476377) and [**ID3D11Buffer**](https://msdn.microsoft.com/library/windows/desktop/ff476351) with [**ComPtr**](https://msdn.microsoft.com/library/windows/apps/br244983.aspx) and declare an instance of **ConstantBuffer**.\n\n```cpp\nstruct SimpleCubeVertex\n{\n    DirectX::XMFLOAT3 pos;   // Position\n    DirectX::XMFLOAT3 color; // Color\n};\n\nstruct ConstantBuffer\n{\n    DirectX::XMFLOAT4X4 model;\n    DirectX::XMFLOAT4X4 view;\n    DirectX::XMFLOAT4X4 projection;\n};\n\n// This class defines the application as a whole.\nref class Direct3DTutorialFrameworkView : public IFrameworkView\n{\nprivate:\n    Platform::Agile<CoreWindow> m_window;\n    ComPtr<IDXGISwapChain1> m_swapChain;\n    ComPtr<ID3D11Device1> m_d3dDevice;\n    ComPtr<ID3D11DeviceContext1> m_d3dDeviceContext;\n    ComPtr<ID3D11RenderTargetView> m_renderTargetView;\n    ComPtr<ID3D11DepthStencilView> m_depthStencilView;\n    ComPtr<ID3D11Buffer> m_constantBuffer;\n    ConstantBuffer m_constantBufferData;\n```\n\n### 2. Creating a depth stencil view\n\nIn addition to creating the render-target view, we also create a depth-stencil view. The depth-stencil view enables Direct3D to efficiently render objects closer to the camera in front of objects further from the camera. Before we can create a view to a depth-stencil buffer, we must create the depth-stencil buffer. We populate a [**D3D11\\_TEXTURE2D\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476253) to describe the depth-stencil buffer and then call [**ID3D11Device::CreateTexture2D**](https://msdn.microsoft.com/library/windows/desktop/ff476521) to create the depth-stencil buffer. To create the depth-stencil view, we populate a [**D3D11\\_DEPTH\\_STENCIL\\_VIEW\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476112) to describe the depth-stencil view and pass the depth-stencil view description and the depth-stencil buffer to [**ID3D11Device::CreateDepthStencilView**](https://msdn.microsoft.com/library/windows/desktop/ff476507).\n\n```cpp\n        // Once the render target view is created, create a depth stencil view.  This\n        // allows Direct3D to efficiently render objects closer to the camera in front\n        // of objects further from the camera.\n\n        D3D11_TEXTURE2D_DESC backBufferDesc = {0};\n        backBuffer->GetDesc(&backBufferDesc);\n\n        D3D11_TEXTURE2D_DESC depthStencilDesc;\n        depthStencilDesc.Width = backBufferDesc.Width;\n        depthStencilDesc.Height = backBufferDesc.Height;\n        depthStencilDesc.MipLevels = 1;\n        depthStencilDesc.ArraySize = 1;\n        depthStencilDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;\n        depthStencilDesc.SampleDesc.Count = 1;\n        depthStencilDesc.SampleDesc.Quality = 0;\n        depthStencilDesc.Usage = D3D11_USAGE_DEFAULT;\n        depthStencilDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;\n        depthStencilDesc.CPUAccessFlags = 0;\n        depthStencilDesc.MiscFlags = 0;\n        ComPtr<ID3D11Texture2D> depthStencil;\n        DX::ThrowIfFailed(\n            m_d3dDevice->CreateTexture2D(\n                &depthStencilDesc,\n                nullptr,\n                &depthStencil\n                )\n            );\n\n        D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;\n        depthStencilViewDesc.Format = depthStencilDesc.Format;\n        depthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;\n        depthStencilViewDesc.Flags = 0;\n        depthStencilViewDesc.Texture2D.MipSlice = 0;\n        DX::ThrowIfFailed(\n            m_d3dDevice->CreateDepthStencilView(\n                depthStencil.Get(),\n                &depthStencilViewDesc,\n                &m_depthStencilView\n                )\n            );\n```\n\n### 3. Updating perspective with the window\n\nWe update the perspective projection parameters for the constant buffer depending on the window dimensions. We fix the parameters to a 70-degree field of view with a depth range of 0.01 to 100.\n\n```cpp\n        // Finally, update the constant buffer perspective projection parameters\n        // to account for the size of the application window.  In this sample,\n        // the parameters are fixed to a 70-degree field of view, with a depth\n        // range of 0.01 to 100.  For a generalized camera class, see Lesson 5.\n\n        float xScale = 1.42814801f;\n        float yScale = 1.42814801f;\n        if (backBufferDesc.Width > backBufferDesc.Height)\n        {\n            xScale = yScale *\n                static_cast<float>(backBufferDesc.Height) /\n                static_cast<float>(backBufferDesc.Width);\n        }\n        else\n        {\n            yScale = xScale *\n                static_cast<float>(backBufferDesc.Width) /\n                static_cast<float>(backBufferDesc.Height);\n        }\n\n        m_constantBufferData.projection = DirectX::XMFLOAT4X4(\n            xScale, 0.0f,    0.0f,  0.0f,\n            0.0f,   yScale,  0.0f,  0.0f,\n            0.0f,   0.0f,   -1.0f, -0.01f,\n            0.0f,   0.0f,   -1.0f,  0.0f\n            );\n```\n\n### 4. Creating vertex and pixel shaders with color elements\n\nIn this app, we create more complex vertex and pixel shaders than what we described in the previous tutorial, [Creating shaders and drawing primitives](creating-shaders-and-drawing-primitives.md). The app's vertex shader transforms each vertex position into projection space and passes the vertex color through to the pixel shader.\n\nThe app's array of [**D3D11\\_INPUT\\_ELEMENT\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476180) structures that describe the layout of the vertex shader code has two layout elements: one element defines the vertex position and the other element defines the color.\n\nWe create vertex, index, and constant buffers to define an orbiting cube.\n\n**To define an orbiting cube**\n\n1.  First, we define the cube. We assign each vertex a color in addition to a position. This allows the pixel shader to color each face differently so the face can be distinguished.\n2.  Next, we describe the vertex and index buffers ([**D3D11\\_BUFFER\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476092) and [**D3D11\\_SUBRESOURCE\\_DATA**](https://msdn.microsoft.com/library/windows/desktop/ff476220)) using the cube definition. We call [**ID3D11Device::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501) once for each buffer.\n3.  Next, we create a constant buffer ([**D3D11\\_BUFFER\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476092)) for passing model, view, and projection matrices to the vertex shader. We can later use the constant buffer to rotate the cube and apply a perspective projection to it. We call [**ID3D11Device::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501) to create the constant buffer.\n4.  Next, we specify the view transform that corresponds to a camera position of X = 0, Y = 1, Z = 2.\n5.  Finally, we declare a *degree* variable that we will use to animate the cube by rotating it every frame.\n\n```cpp\n        \n        auto loadVSTask = DX::ReadDataAsync(L\"SimpleVertexShader.cso\");\n        auto loadPSTask = DX::ReadDataAsync(L\"SimplePixelShader.cso\");\n        \n        \n        auto createVSTask = loadVSTask.then([this](const std::vector<byte>& vertexShaderBytecode) {        \n          ComPtr<ID3D11VertexShader> vertexShader;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateVertexShader(\n                  vertexShaderBytecode->Data,\n                  vertexShaderBytecode->Length,\n                  nullptr,\n                  &vertexShader\n                  )\n              );\n\n          // Create an input layout that matches the layout defined in the vertex shader code.\n          // For this lesson, this is simply a DirectX::XMFLOAT3 vector defining the vertex position, and\n          // a DirectX::XMFLOAT3 vector defining the vertex color.\n          const D3D11_INPUT_ELEMENT_DESC basicVertexLayoutDesc[] =\n          {\n              { \"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,  0, D3D11_INPUT_PER_VERTEX_DATA, 0 },\n              { \"COLOR\",    0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },\n          };\n\n          ComPtr<ID3D11InputLayout> inputLayout;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateInputLayout(\n                  basicVertexLayoutDesc,\n                  ARRAYSIZE(basicVertexLayoutDesc),\n                  vertexShaderBytecode->Data,\n                  vertexShaderBytecode->Length,\n                  &inputLayout\n                  )\n              );\n        });\n        \n        \n        // Load the raw pixel shader bytecode from disk and create a pixel shader with it.\n        auto createPSTask = loadPSTask.then([this](const std::vector<byte>& pixelShaderBytecode) {\n          ComPtr<ID3D11PixelShader> pixelShader;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreatePixelShader(\n                  pixelShaderBytecode->Data,\n                  pixelShaderBytecode->Length,\n                  nullptr,\n                  &pixelShader\n                  )\n              );\n        });\n        \n        \n        // Create vertex and index buffers that define a simple unit cube.\n        auto createCubeTask = (createPSTask && createVSTask).then([this] () {\n\n          // In the array below, which will be used to initialize the cube vertex buffers,\n          // each vertex is assigned a color in addition to a position.  This will allow\n          // the pixel shader to color each face differently, enabling them to be distinguished.\n          SimpleCubeVertex cubeVertices[] =\n          {\n              { float3(-0.5f, 0.5f, -0.5f), float3(0.0f, 1.0f, 0.0f) }, // +Y (top face)\n              { float3( 0.5f, 0.5f, -0.5f), float3(1.0f, 1.0f, 0.0f) },\n              { float3( 0.5f, 0.5f,  0.5f), float3(1.0f, 1.0f, 1.0f) },\n              { float3(-0.5f, 0.5f,  0.5f), float3(0.0f, 1.0f, 1.0f) },\n\n              { float3(-0.5f, -0.5f,  0.5f), float3(0.0f, 0.0f, 1.0f) }, // -Y (bottom face)\n              { float3( 0.5f, -0.5f,  0.5f), float3(1.0f, 0.0f, 1.0f) },\n              { float3( 0.5f, -0.5f, -0.5f), float3(1.0f, 0.0f, 0.0f) },\n              { float3(-0.5f, -0.5f, -0.5f), float3(0.0f, 0.0f, 0.0f) },\n          };\n\n          unsigned short cubeIndices[] =\n          {\n              0, 1, 2,\n              0, 2, 3,\n\n              4, 5, 6,\n              4, 6, 7,\n\n              3, 2, 5,\n              3, 5, 4,\n\n              2, 1, 6,\n              2, 6, 5,\n\n              1, 7, 6,\n              1, 0, 7,\n\n              0, 3, 4,\n              0, 4, 7\n          };\n\n          D3D11_BUFFER_DESC vertexBufferDesc = {0};\n          vertexBufferDesc.ByteWidth = sizeof(SimpleCubeVertex) * ARRAYSIZE(cubeVertices);\n          vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;\n          vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;\n          vertexBufferDesc.CPUAccessFlags = 0;\n          vertexBufferDesc.MiscFlags = 0;\n          vertexBufferDesc.StructureByteStride = 0;\n\n          D3D11_SUBRESOURCE_DATA vertexBufferData;\n          vertexBufferData.pSysMem = cubeVertices;\n          vertexBufferData.SysMemPitch = 0;\n          vertexBufferData.SysMemSlicePitch = 0;\n\n          ComPtr<ID3D11Buffer> vertexBuffer;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateBuffer(\n                  &vertexBufferDesc,\n                  &vertexBufferData,\n                  &vertexBuffer\n                  )\n              );\n\n          D3D11_BUFFER_DESC indexBufferDesc;\n          indexBufferDesc.ByteWidth = sizeof(unsigned short) * ARRAYSIZE(cubeIndices);\n          indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;\n          indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;\n          indexBufferDesc.CPUAccessFlags = 0;\n          indexBufferDesc.MiscFlags = 0;\n          indexBufferDesc.StructureByteStride = 0;\n\n          D3D11_SUBRESOURCE_DATA indexBufferData;\n          indexBufferData.pSysMem = cubeIndices;\n          indexBufferData.SysMemPitch = 0;\n          indexBufferData.SysMemSlicePitch = 0;\n\n          ComPtr<ID3D11Buffer> indexBuffer;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateBuffer(\n                  &indexBufferDesc,\n                  &indexBufferData,\n                  &indexBuffer\n                  )\n              );\n\n\n          // Create a constant buffer for passing model, view, and projection matrices\n          // to the vertex shader.  This will allow us to rotate the cube and apply\n          // a perspective projection to it.\n\n          D3D11_BUFFER_DESC constantBufferDesc = {0};\n          constantBufferDesc.ByteWidth = sizeof(m_constantBufferData);\n          constantBufferDesc.Usage = D3D11_USAGE_DEFAULT;\n          constantBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;\n          constantBufferDesc.CPUAccessFlags = 0;\n          constantBufferDesc.MiscFlags = 0;\n          constantBufferDesc.StructureByteStride = 0;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateBuffer(\n                  &constantBufferDesc,\n                  nullptr,\n                  &m_constantBuffer\n                  )\n              );\n\n          // Specify the view transform corresponding to a camera position of\n          // X = 0, Y = 1, Z = 2.  For a generalized camera class, see Lesson 5.\n\n          m_constantBufferData.view = DirectX::XMFLOAT4X4(\n              -1.00000000f, 0.00000000f,  0.00000000f,  0.00000000f,\n               0.00000000f, 0.89442718f,  0.44721359f,  0.00000000f,\n               0.00000000f, 0.44721359f, -0.89442718f, -2.23606800f,\n               0.00000000f, 0.00000000f,  0.00000000f,  1.00000000f\n              );\n\n        });\n        \n        // This value will be used to animate the cube by rotating it every frame.\n        float degree = 0.0f;\n        \n```\n\n### 5. Rotating and drawing the cube and presenting the rendered image\n\nWe enter an endless loop to continually render and display the scene. We call the **rotationY** inline function (BasicMath.h) with a rotation amount to set values that will rotate the cube’s model matrix around the Y axis. We then call [**ID3D11DeviceContext::UpdateSubresource**](https://msdn.microsoft.com/library/windows/desktop/ff476486) to update the constant buffer and rotate the cube model. We call [**ID3D11DeviceContext::OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464) to specify the render target as the output target. In this **OMSetRenderTargets** call, we pass the depth-stencil view. We call [**ID3D11DeviceContext::ClearRenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476388) to clear the render target to a solid blue color and call [**ID3D11DeviceContext::ClearDepthStencilView**](https://msdn.microsoft.com/library/windows/desktop/ff476387) to clear the depth buffer.\n\nIn the endless loop, we also draw the cube on the blue surface.\n\n**To draw the cube**\n\n1.  First, we call [**ID3D11DeviceContext::IASetInputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476454) to describe how vertex buffer data is streamed into the input-assembler stage.\n2.  Next, we call [**ID3D11DeviceContext::IASetVertexBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476456) and [**ID3D11DeviceContext::IASetIndexBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476453) to bind the vertex and index buffers to the input-assembler stage.\n3.  Next, we call [**ID3D11DeviceContext::IASetPrimitiveTopology**](https://msdn.microsoft.com/library/windows/desktop/ff476455) with the [**D3D11\\_PRIMITIVE\\_TOPOLOGY\\_TRIANGLESTRIP**](https://msdn.microsoft.com/library/windows/desktop/ff476189#D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP) value to specify for the input-assembler stage to interpret the vertex data as a triangle strip.\n4.  Next, we call [**ID3D11DeviceContext::VSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476493) to initialize the vertex shader stage with the vertex shader code and [**ID3D11DeviceContext::PSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476472) to initialize the pixel shader stage with the pixel shader code.\n5.  Next, we call [**ID3D11DeviceContext::VSSetConstantBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476491) to set the constant buffer that is used by the vertex shader pipeline stage.\n6.  Finally, we call [**ID3D11DeviceContext::DrawIndexed**](https://msdn.microsoft.com/library/windows/desktop/ff476409) to draw the cube and submit it to the rendering pipeline.\n\nWe call [**IDXGISwapChain::Present**](https://msdn.microsoft.com/library/windows/desktop/bb174576) to present the rendered image to the window.\n\n```cpp\n            // Update the constant buffer to rotate the cube model.\n            m_constantBufferData.model = XMMatrixRotationY(-degree);\n            degree += 1.0f;\n\n            m_d3dDeviceContext->UpdateSubresource(\n                m_constantBuffer.Get(),\n                0,\n                nullptr,\n                &m_constantBufferData,\n                0,\n                0\n                );\n\n            // Specify the render target and depth stencil we created as the output target.\n            m_d3dDeviceContext->OMSetRenderTargets(\n                1,\n                m_renderTargetView.GetAddressOf(),\n                m_depthStencilView.Get()\n                );\n\n            // Clear the render target to a solid color, and reset the depth stencil.\n            const float clearColor[4] = { 0.071f, 0.04f, 0.561f, 1.0f };\n            m_d3dDeviceContext->ClearRenderTargetView(\n                m_renderTargetView.Get(),\n                clearColor\n                );\n\n            m_d3dDeviceContext->ClearDepthStencilView(\n                m_depthStencilView.Get(),\n                D3D11_CLEAR_DEPTH,\n                1.0f,\n                0\n                );\n\n            m_d3dDeviceContext->IASetInputLayout(inputLayout.Get());\n\n            // Set the vertex and index buffers, and specify the way they define geometry.\n            UINT stride = sizeof(SimpleCubeVertex);\n            UINT offset = 0;\n            m_d3dDeviceContext->IASetVertexBuffers(\n                0,\n                1,\n                vertexBuffer.GetAddressOf(),\n                &stride,\n                &offset\n                );\n\n            m_d3dDeviceContext->IASetIndexBuffer(\n                indexBuffer.Get(),\n                DXGI_FORMAT_R16_UINT,\n                0\n                );\n\n            m_d3dDeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n\n            // Set the vertex and pixel shader stage state.\n            m_d3dDeviceContext->VSSetShader(\n                vertexShader.Get(),\n                nullptr,\n                0\n                );\n\n            m_d3dDeviceContext->VSSetConstantBuffers(\n                0,\n                1,\n                m_constantBuffer.GetAddressOf()\n                );\n\n            m_d3dDeviceContext->PSSetShader(\n                pixelShader.Get(),\n                nullptr,\n                0\n                );\n\n            // Draw the cube.\n            m_d3dDeviceContext->DrawIndexed(\n                ARRAYSIZE(cubeIndices),\n                0,\n                0\n                );\n\n            // Present the rendered image to the window.  Because the maximum frame latency is set to 1,\n            // the render loop will generally be throttled to the screen refresh rate, typically around\n            // 60 Hz, by sleeping the application on Present until the screen is refreshed.\n            DX::ThrowIfFailed(\n                m_swapChain->Present(1, 0)\n                );\n```\n\n## Summary and next steps\n\n\nWe used depth, perspective, color, and other effects on primitives.\n\nNext, we apply textures to primitives.\n\n[Applying textures to primitives](applying-textures-to-primitives.md)\n\n \n\n \n\n\n\n\n"}