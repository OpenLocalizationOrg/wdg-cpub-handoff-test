{"nodes":[{"content":"MVVM and language performance tips","pos":[2,36]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[38,76]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[77,172],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"This topic discusses some performance considerations related to your choice of software design patterns, and programming language.","pos":[174,304]},{"content":"The Model-View-ViewModel (MVVM) pattern","pos":[309,348]},{"content":"The Model-View-ViewModel (MVVM) pattern is common in a lot of XAML apps.","pos":[350,422]},{"content":"(MVVM is very similar to Fowler’s description of the Model-View-Presenter pattern, but it is tailored to XAML).","pos":[423,534]},{"content":"The issue with the MVVM pattern is that it can inadvertently lead to apps that have too many layers and too many allocations.","pos":[535,660]},{"content":"The motivations for MVVM are these.","pos":[661,696]},{"content":"<bpt id=\"p1\">**</bpt>Separation of concerns<ept id=\"p1\">**</ept>.","pos":[702,729],"source":"**Separation of concerns**."},{"content":"It’s always helpful to divide a problem into smaller pieces, and a pattern like MVVM or MVC is a way to divide an app (or even a single control) into smaller pieces: the actual view, a logical model of the view (view-model), and the view-independent app logic (the model).","pos":[730,1002]},{"content":"In particular, it’s a popular workflow to have designers own the view using one tool, developers own the model using another tool, and design integrators own the view-model using both tools.","pos":[1003,1193]},{"content":"<bpt id=\"p1\">**</bpt>Unit testing<ept id=\"p1\">**</ept>.","pos":[1198,1215],"source":"**Unit testing**."},{"content":"You can unit test the view-model (and consequently the model) independent of the view, thereby not relying on creating windows, driving input, and so on.","pos":[1216,1369]},{"content":"By keeping the view small, you can test a large portion of your app without ever having to create a window.","pos":[1370,1477]},{"content":"<bpt id=\"p1\">**</bpt>Agility to user experience changes<ept id=\"p1\">**</ept>.","pos":[1482,1521],"source":"**Agility to user experience changes**."},{"content":"The view tends to see the most frequent changes, and the most late changes, as the user experience is tweaked based on end-user feedback.","pos":[1522,1659]},{"content":"By keeping the view separate, these changes can be accommodated more quickly and with less churn to the app.","pos":[1660,1768]},{"content":"There are multiple concrete definitions of the MVVM pattern, and 3rd party frameworks that help implement it.","pos":[1770,1879]},{"content":"But strict adherence to any variation of the pattern can lead to apps with a lot more overhead than can be justified.","pos":[1880,1997]},{"content":"XAML data binding (the {Binding} markup extension) was designed in part to enable model/view patterns.","pos":[2003,2105]},{"content":"But {Binding} brings with it non-trivial working set and CPU overhead.","pos":[2106,2176]},{"content":"Creating a {Binding} causes a series of allocations, and updating a binding target can cause reflection and boxing.","pos":[2177,2292]},{"content":"These problems are being addressed with the {x:Bind} markup extension, which compiles the bindings at build time.","pos":[2293,2406]},{"content":"<bpt id=\"p1\">**</bpt>Recommendation:<ept id=\"p1\">**</ept> use {x:Bind}.","pos":[2407,2440],"source":"**Recommendation:** use {x:Bind}."},{"content":"It’s popular in MVVM to connect Button.Click to the view-model using an ICommand, such as the common DelegateCommand or RelayCommand helpers.","pos":[2445,2586]},{"content":"Those commands are extra allocations, though, including the CanExecuteChanged event listener, adding to the working set, and adding to the startup/navigation time for the page.","pos":[2587,2763]},{"content":"<bpt id=\"p1\">**</bpt>Recommendation:<ept id=\"p1\">**</ept> As an alternative to using the convenient ICommand interface, consider putting event handlers in your code-behind and attaching them to the view events and call a command on your view-model when those events are raised.","pos":[2764,3003],"source":"**Recommendation:** As an alternative to using the convenient ICommand interface, consider putting event handlers in your code-behind and attaching them to the view events and call a command on your view-model when those events are raised."},{"content":"You'll also need to add extra code to disable the Button when the command is unavailable.","pos":[3004,3093]},{"content":"It’s popular in MVVM to create a Page with all possible configurations of the UI, then collapse parts of the tree by binding the Visibility property to properties in the VM.","pos":[3098,3271]},{"content":"This adds unnecessarily to startup time and possibly to working set (because some parts of the tree may never become visible).","pos":[3272,3398]},{"content":"<bpt id=\"p1\">**</bpt>Recommendations:<ept id=\"p1\">**</ept> Use the x:DeferLoadStrategy feature to defer unnecessary portions of the tree out of startup.","pos":[3399,3513],"source":"**Recommendations:** Use the x:DeferLoadStrategy feature to defer unnecessary portions of the tree out of startup."},{"content":"Also, create separate user controls for the different modes of the page and use code-behind to keep only the necessary controls loaded.","pos":[3514,3649]},{"content":"C++/CX recommendations","pos":[3654,3676]},{"content":"<bpt id=\"p1\">**</bpt>Use the latest version<ept id=\"p1\">**</ept>.","pos":[3682,3709],"source":"**Use the latest version**."},{"content":"There are continual performance improvements made to the C++/CX compiler.","pos":[3710,3783]},{"content":"Ensure your app is building using the latest toolset.","pos":[3784,3837]},{"content":"<bpt id=\"p1\">**</bpt>Disable RTTI (/GR-)<ept id=\"p1\">**</ept>.","pos":[3842,3866],"source":"**Disable RTTI (/GR-)**."},{"content":"RTTI is on by default in the compiler so, unless your build environment switches it off, you’re probably using it.","pos":[3867,3981]},{"content":"RTTI has significant overhead, and unless your code has a deep dependency on it, you should turn it off.","pos":[3982,4086]},{"content":"The XAML framework has no requirement that your code use RTTI.","pos":[4087,4149]},{"content":"<bpt id=\"p1\">**</bpt>Avoid heavy use of ppltasks<ept id=\"p1\">**</ept>.","pos":[4154,4186],"source":"**Avoid heavy use of ppltasks**."},{"content":"Ppltasks are very convenient when calling async WinRT APIs, but they come with significant code size overhead.","pos":[4187,4297]},{"content":"The C++/CX team is working on a language feature – await – that will provide much better performance.","pos":[4298,4399]},{"content":"In the meantime, balance your use of ppltasks in the hot paths of your code.","pos":[4400,4476]},{"content":"<bpt id=\"p1\">**</bpt>Avoid use of C++/CX in the “business logic” of your app<ept id=\"p1\">**</ept>.","pos":[4481,4541],"source":"**Avoid use of C++/CX in the “business logic” of your app**."},{"content":"C++/CX is designed to be a convenient way to access WinRT APIs from C++ apps.","pos":[4542,4619]},{"content":"It makes use of wrappers that have overhead.","pos":[4620,4664]},{"content":"You should avoid C++/CX inside the business logic/model of your class, and reserve it for use at the boundaries between your code and WinRT.","pos":[4665,4805]}],"content":"# MVVM and language performance tips\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nThis topic discusses some performance considerations related to your choice of software design patterns, and programming language.\n\n## The Model-View-ViewModel (MVVM) pattern\n\nThe Model-View-ViewModel (MVVM) pattern is common in a lot of XAML apps. (MVVM is very similar to Fowler’s description of the Model-View-Presenter pattern, but it is tailored to XAML). The issue with the MVVM pattern is that it can inadvertently lead to apps that have too many layers and too many allocations. The motivations for MVVM are these.\n\n-   **Separation of concerns**. It’s always helpful to divide a problem into smaller pieces, and a pattern like MVVM or MVC is a way to divide an app (or even a single control) into smaller pieces: the actual view, a logical model of the view (view-model), and the view-independent app logic (the model). In particular, it’s a popular workflow to have designers own the view using one tool, developers own the model using another tool, and design integrators own the view-model using both tools.\n-   **Unit testing**. You can unit test the view-model (and consequently the model) independent of the view, thereby not relying on creating windows, driving input, and so on. By keeping the view small, you can test a large portion of your app without ever having to create a window.\n-   **Agility to user experience changes**. The view tends to see the most frequent changes, and the most late changes, as the user experience is tweaked based on end-user feedback. By keeping the view separate, these changes can be accommodated more quickly and with less churn to the app.\n\nThere are multiple concrete definitions of the MVVM pattern, and 3rd party frameworks that help implement it. But strict adherence to any variation of the pattern can lead to apps with a lot more overhead than can be justified.\n\n-   XAML data binding (the {Binding} markup extension) was designed in part to enable model/view patterns. But {Binding} brings with it non-trivial working set and CPU overhead. Creating a {Binding} causes a series of allocations, and updating a binding target can cause reflection and boxing. These problems are being addressed with the {x:Bind} markup extension, which compiles the bindings at build time. **Recommendation:** use {x:Bind}.\n-   It’s popular in MVVM to connect Button.Click to the view-model using an ICommand, such as the common DelegateCommand or RelayCommand helpers. Those commands are extra allocations, though, including the CanExecuteChanged event listener, adding to the working set, and adding to the startup/navigation time for the page. **Recommendation:** As an alternative to using the convenient ICommand interface, consider putting event handlers in your code-behind and attaching them to the view events and call a command on your view-model when those events are raised. You'll also need to add extra code to disable the Button when the command is unavailable.\n-   It’s popular in MVVM to create a Page with all possible configurations of the UI, then collapse parts of the tree by binding the Visibility property to properties in the VM. This adds unnecessarily to startup time and possibly to working set (because some parts of the tree may never become visible). **Recommendations:** Use the x:DeferLoadStrategy feature to defer unnecessary portions of the tree out of startup. Also, create separate user controls for the different modes of the page and use code-behind to keep only the necessary controls loaded.\n\n## C++/CX recommendations\n\n-   **Use the latest version**. There are continual performance improvements made to the C++/CX compiler. Ensure your app is building using the latest toolset.\n-   **Disable RTTI (/GR-)**. RTTI is on by default in the compiler so, unless your build environment switches it off, you’re probably using it. RTTI has significant overhead, and unless your code has a deep dependency on it, you should turn it off. The XAML framework has no requirement that your code use RTTI.\n-   **Avoid heavy use of ppltasks**. Ppltasks are very convenient when calling async WinRT APIs, but they come with significant code size overhead. The C++/CX team is working on a language feature – await – that will provide much better performance. In the meantime, balance your use of ppltasks in the hot paths of your code.\n-   **Avoid use of C++/CX in the “business logic” of your app**. C++/CX is designed to be a convenient way to access WinRT APIs from C++ apps. It makes use of wrappers that have overhead. You should avoid C++/CX inside the business logic/model of your class, and reserve it for use at the boundaries between your code and WinRT.\n\n \n\n \n\n\n\n"}