<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="en-us" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-c5d768e</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">7927b24c44f0c2941884d94f27576d4d1d90e4a3</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\security\cryptographic-keys.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">4e681c1ef8c8df0c45c34ab10276f4d5da4ccf4d</mda:meta><mda:meta type="olxliffhash">9aafe7fa375f9a0bc716c05b30e78609bdaee12a</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Cryptographic keys</source>
					<target>Cryptographic keys</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>This article shows how to use standard key derivation functions to derive keys and how to encrypt content using symmetric and asymmetric keys.</source>
					<target>This article shows how to use standard key derivation functions to derive keys and how to encrypt content using symmetric and asymmetric keys.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Cryptographic keys</source>
					<target>Cryptographic keys</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>This article shows how to use standard key derivation functions to derive keys and how to encrypt content using symmetric and asymmetric keys.</source>
					<target>This article shows how to use standard key derivation functions to derive keys and how to encrypt content using symmetric and asymmetric keys.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Symmetric keys</source>
					<target>Symmetric keys</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>Symmetric key encryption, also called secret key encryption, requires that the key used for encryption also be used for decryption.</source>
					<target>Symmetric key encryption, also called secret key encryption, requires that the key used for encryption also be used for decryption.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241537)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SymmetricKeyAlgorithmProvider</pc></pc> class to specify a symmetric algorithm and create or import a key.</source>
					<target>You can use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SymmetricKeyAlgorithmProvider</pc></pc> class to specify a symmetric algorithm and create or import a key.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241490)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use static methods on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CryptographicEngine</pc></pc> class to encrypt and decrypt data by using the algorithm and key.</source>
					<target>You can use static methods on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CryptographicEngine</pc></pc> class to encrypt and decrypt data by using the algorithm and key.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>Symmetric key encryption typically uses block ciphers and block cipher modes.</source>
					<target>Symmetric key encryption typically uses block ciphers and block cipher modes.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>A block cipher is a symmetric encryption function that operates on fixed size blocks.</source>
					<target>A block cipher is a symmetric encryption function that operates on fixed size blocks.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>If the message you want to encrypt is longer than the block length, you must use a block cipher mode.</source>
					<target>If the message you want to encrypt is longer than the block length, you must use a block cipher mode.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>A block cipher mode is a symmetric encryption function built by using a block cipher.</source>
					<target>A block cipher mode is a symmetric encryption function built by using a block cipher.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>It encrypts plaintext as a series of fixed size blocks.</source>
					<target>It encrypts plaintext as a series of fixed size blocks.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>The following modes are supported for apps:</source>
					<target>The following modes are supported for apps:</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>The ECB (electronic codebook) mode encrypts each block of the message separately.</source>
					<target>The ECB (electronic codebook) mode encrypts each block of the message separately.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>This is not considered a secure encryption mode.</source>
					<target>This is not considered a secure encryption mode.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>The CBC (cipher block chaining) mode uses the previous ciphertext block to obfuscate the current block.</source>
					<target>The CBC (cipher block chaining) mode uses the previous ciphertext block to obfuscate the current block.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>You must determine what value to use for the first block.</source>
					<target>You must determine what value to use for the first block.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>This value is called the initialization vector (IV).</source>
					<target>This value is called the initialization vector (IV).</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>The CCM (counter with CBC-MAC) mode combines the CBC block cipher mode with a message authentication code (MAC).</source>
					<target>The CCM (counter with CBC-MAC) mode combines the CBC block cipher mode with a message authentication code (MAC).</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>The GCM (Galois counter mode) mode combines the counter encryption mode with the Galois authentication mode.</source>
					<target>The GCM (Galois counter mode) mode combines the counter encryption mode with the Galois authentication mode.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Some modes such as CBC require that you use an initialization vector (IV) for the first ciphertext block.</source>
					<target>Some modes such as CBC require that you use an initialization vector (IV) for the first ciphertext block.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>The following are common initialization vectors.</source>
					<target>The following are common initialization vectors.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241494)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You specify the IV when calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CryptographicEngine.Encrypt</pc></pc>.</source>
					<target>You specify the IV when calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CryptographicEngine.Encrypt</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>For most cases it is important that the IV never be reused with the same key.</source>
					<target>For most cases it is important that the IV never be reused with the same key.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>Fixed uses the same IV for all messages to be encrypted.</source>
					<target>Fixed uses the same IV for all messages to be encrypted.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>This leaks information and its use is not recommended.</source>
					<target>This leaks information and its use is not recommended.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>Counter increments the IV for each block.</source>
					<target>Counter increments the IV for each block.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Random creates a pseudorandom IV.</source>
					<target>Random creates a pseudorandom IV.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241392)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CryptographicBuffer.GenerateRandom</pc></pc> to create the IV.</source>
					<target>You can use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CryptographicBuffer.GenerateRandom</pc></pc> to create the IV.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Nonce-Generated uses a unique number for each message to be encrypted.</source>
					<target>Nonce-Generated uses a unique number for each message to be encrypted.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Typically, the nonce is a modified message or transaction identifier.</source>
					<target>Typically, the nonce is a modified message or transaction identifier.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>The nonce does not have to be kept secret, but it should never be reused under the same key.</source>
					<target>The nonce does not have to be kept secret, but it should never be reused under the same key.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>Most modes require that the length of the plaintext be an exact multiple of the block size.</source>
					<target>Most modes require that the length of the plaintext be an exact multiple of the block size.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>This usually requires that you pad the plaintext to obtain the appropriate length.</source>
					<target>This usually requires that you pad the plaintext to obtain the appropriate length.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>While block ciphers encrypt fixed size blocks of data, stream ciphers are symmetric encryption functions that combine plaintext bits with a pseudorandom bit stream (called a key stream) to generate the ciphertext.</source>
					<target>While block ciphers encrypt fixed size blocks of data, stream ciphers are symmetric encryption functions that combine plaintext bits with a pseudorandom bit stream (called a key stream) to generate the ciphertext.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>Some block cipher modes such as output feedback mode (OTF) and counter mode (CTR) effectively turn a block cipher into a stream cipher.</source>
					<target>Some block cipher modes such as output feedback mode (OTF) and counter mode (CTR) effectively turn a block cipher into a stream cipher.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Actual stream ciphers such as RC4, however, typically operate at higher speeds than block cipher modes are capable of achieving.</source>
					<target>Actual stream ciphers such as RC4, however, typically operate at higher speeds than block cipher modes are capable of achieving.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241537)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SymmetricKeyAlgorithmProvider</pc></pc> class to create a symmetric key and use it to encrypt and decrypt data.</source>
					<target>The following example shows how to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SymmetricKeyAlgorithmProvider</pc></pc> class to create a symmetric key and use it to encrypt and decrypt data.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>Asymmetric keys</source>
					<target>Asymmetric keys</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>Asymmetric key cryptography, also called public key cryptography, uses a public key and a private key to perform encryption and decryption.</source>
					<target>Asymmetric key cryptography, also called public key cryptography, uses a public key and a private key to perform encryption and decryption.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>The keys are different but mathematically related.</source>
					<target>The keys are different but mathematically related.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>Typically the private key is kept secret and is used to encrypt data while the public key is distributed to interested parties and is used to decrypt data.</source>
					<target>Typically the private key is kept secret and is used to encrypt data while the public key is distributed to interested parties and is used to decrypt data.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>Asymmetric cryptography is also useful for signing data.</source>
					<target>Asymmetric cryptography is also useful for signing data.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Because asymmetric cryptography is much slower than symmetric cryptography, it is seldom used to encrypt large amounts of data directly.</source>
					<target>Because asymmetric cryptography is much slower than symmetric cryptography, it is seldom used to encrypt large amounts of data directly.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Instead, it is typically used in the following manner to encrypt keys.</source>
					<target>Instead, it is typically used in the following manner to encrypt keys.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>Alice requires that Bob send her only encrypted messages.</source>
					<target>Alice requires that Bob send her only encrypted messages.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>Alice creates a private/public key pair, keeps her private key secret and publishes her public key.</source>
					<target>Alice creates a private/public key pair, keeps her private key secret and publishes her public key.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Bob has a message he wants to send to Alice.</source>
					<target>Bob has a message he wants to send to Alice.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>Bob creates a symmetric key.</source>
					<target>Bob creates a symmetric key.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>Bob uses his new symmetric key to encrypt his message to Alice.</source>
					<target>Bob uses his new symmetric key to encrypt his message to Alice.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Bob uses Alice’s public key to encrypt his symmetric key.</source>
					<target>Bob uses Alice’s public key to encrypt his symmetric key.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Bob sends the encrypted message and the encrypted symmetric key to Alice (enveloped).</source>
					<target>Bob sends the encrypted message and the encrypted symmetric key to Alice (enveloped).</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Alice uses her private key (from the private/public pair) to decrypt Bob’s symmetric key.</source>
					<target>Alice uses her private key (from the private/public pair) to decrypt Bob’s symmetric key.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>Alice uses Bob’s symmetric key to decrypt the message.</source>
					<target>Alice uses Bob’s symmetric key to decrypt the message.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241478)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AsymmetricKeyAlgorithmProvider</pc></pc> object to specify an asymmetric algorithm or a signing algorithm, to create or import an ephemeral key pair, or to import the public key portion of a key pair.</source>
					<target>You can use an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AsymmetricKeyAlgorithmProvider</pc></pc> object to specify an asymmetric algorithm or a signing algorithm, to create or import an ephemeral key pair, or to import the public key portion of a key pair.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>Deriving keys</source>
					<target>Deriving keys</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>It is often necessary to derive additional keys from a shared secret.</source>
					<target>It is often necessary to derive additional keys from a shared secret.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241518)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br241524)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyDerivationAlgorithmProvider</pc></pc> class and one of the following specialized methods in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyDerivationParameters</pc></pc> class to derive keys.</source>
					<target>You can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyDerivationAlgorithmProvider</pc></pc> class and one of the following specialized methods in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyDerivationParameters</pc></pc> class to derive keys.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>Object</source>
					<target>Object</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>Description</source>
					<target>Description</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>BuildForPbkdf2</source>
					<target>BuildForPbkdf2</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>Creates a KeyDerivationParameters object for use in the password-based key derivation function 2 (PBKDF2).</source>
					<target>Creates a KeyDerivationParameters object for use in the password-based key derivation function 2 (PBKDF2).</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>BuildForSP800108</source>
					<target>BuildForSP800108</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Creates a KeyDerivationParameters object for use in a counter mode, hash-based message authentication code (HMAC) key derivation function.</source>
					<target>Creates a KeyDerivationParameters object for use in a counter mode, hash-based message authentication code (HMAC) key derivation function.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>BuildForSP80056a</source>
					<target>BuildForSP80056a</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>Creates a KeyDerivationParameters object for use in the SP800-56A key derivation function.</source>
					<target>Creates a KeyDerivationParameters object for use in the SP800-56A key derivation function.</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>