{"nodes":[{"pos":[11,45],"content":"Complete code for DDSTextureLoader","needQuote":true,"needEscape":true,"nodes":[{"content":"Complete code for DDSTextureLoader","pos":[0,34]}]},{"pos":[59,133],"content":"Complete code for a class and method that loads a DDS texture from memory.","needQuote":true,"needEscape":true,"nodes":[{"content":"Complete code for a class and method that loads a DDS texture from memory.","pos":[0,74]}]},{"content":"Complete code for DDSTextureLoader","pos":[190,224]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[227,265]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[266,361],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Complete code for a class and method that loads a DDS texture from memory.","pos":[363,437]},{"content":"This topic contains these sections:","pos":[439,474]},{"content":"Technologies","pos":[481,493]},{"content":"Requirements","pos":[515,527]},{"content":"View the code (C++)","pos":[549,568]},{"content":"Download location","pos":[593,610]},{"content":"This sample is not available for download.","pos":[613,655]},{"content":"Technologies","pos":[660,672]},{"content":"Programming languages","pos":[764,785]},{"content":"C++","pos":[788,791]},{"content":"Programming models","pos":[808,826]},{"content":"Windows Runtime","pos":[832,847]},{"content":"Requirements","pos":[854,866]},{"content":"Minimum supported client","pos":[870,894]},{"content":"Windows 10","pos":[897,907]},{"content":"Minimum supported server","pos":[1008,1032]},{"content":"Windows Server 2016 Technical Preview","pos":[1035,1072]},{"content":"Minimum required SDK","pos":[1077,1097]},{"content":"View the code (C++)","pos":[1149,1168]},{"content":"DDSTextureLoader.h","pos":[1174,1192]},{"content":"DDSTextureLoader.cpp","pos":[2321,2341]}],"content":"---\ntitle: Complete code for DDSTextureLoader\ndescription: Complete code for a class and method that loads a DDS texture from memory.\nms.assetid: ebaf4111-6235-0316-46cf-bc8643851493\n---\n\n# Complete code for DDSTextureLoader\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nComplete code for a class and method that loads a DDS texture from memory.\n\nThis topic contains these sections:\n\n-   [Technologies](#technologies)\n-   [Requirements](#requirements)\n-   [View the code (C++)](#view-the-code-c)\n\n\n## Download location\n\n\nThis sample is not available for download.\n\n## Technologies\n\n|                       |                 |\n|-----------------------|-----------------|\n| Programming languages | C++             |\n| Programming models    | Windows Runtime |\n\n## Requirements\n\n| Minimum supported client | Windows 10                            |\n|--------------------------|---------------------------------------|\n| Minimum supported server | Windows Server 2016 Technical Preview |\n| Minimum required SDK     |                                       |\n\n\n## View the code (C++)\n\n\n## DDSTextureLoader.h\n\n\n```cpp\n//--------------------------------------------------------------------------------------\n// File: DDSTextureLoader.h\n//\n// Function for loading a DDS texture and creating a Direct3D 11 runtime resource for it\n//\n// Note this function is useful as a light-weight runtime loader for DDS files. For\n// a full-featured DDS file reader, writer, and texture processing pipeline, see\n// the 'Texconv' sample and the 'DirectXTex' library.\n//\n// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF\n// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A\n// PARTICULAR PURPOSE.\n//\n// Copyright (c) Microsoft Corporation. All rights reserved.\n//--------------------------------------------------------------------------------------\n\n#pragma once\n\nvoid CreateDDSTextureFromMemory(\n    _In_ ID3D11Device* d3dDevice,\n    _In_reads_bytes_(ddsDataSize) const byte* ddsData,\n    _In_ size_t ddsDataSize,\n    _Out_opt_ ID3D11Resource** texture,\n    _Out_opt_ ID3D11ShaderResourceView** textureView,\n    _In_ size_t maxsize = 0\n    );\n```\n\n## DDSTextureLoader.cpp\n\n\n```cpp\n//--------------------------------------------------------------------------------------\n// File: DDSTextureLoader.cpp\n//\n// Function for loading a DDS texture and creating a Direct3D 11 runtime resource for it\n//\n// Note this function is useful as a light-weight runtime loader for DDS files. For\n// a full-featured DDS file reader, writer, and texture processing pipeline, see\n// the 'Texconv' sample and the 'DirectXTex' library.\n//\n// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF\n// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A\n// PARTICULAR PURPOSE.\n//\n// Copyright (c) Microsoft Corporation. All rights reserved.\n//--------------------------------------------------------------------------------------\n\n#include \"pch.h\"\n#include <dxgiformat.h>\n#include <assert.h>\n#include <memory>\n#include <algorithm>\n#include \"DDSTextureLoader.h\"\n#include \"DirectXSample.h\"\n\nusing namespace Microsoft::WRL;\n\n//--------------------------------------------------------------------------------------\n// Macros\n//--------------------------------------------------------------------------------------\n#ifndef MAKEFOURCC\n    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \\\n                ((uint32)(byte)(ch0) | ((uint32)(byte)(ch1) << 8) |       \\\n                ((uint32)(byte)(ch2) << 16) | ((uint32)(byte)(ch3) << 24))\n#endif /* defined(MAKEFOURCC) */\n\n//--------------------------------------------------------------------------------------\n// DDS file structure definitions\n//\n// See DDS.h in the 'Texconv' sample and the 'DirectXTex' library.\n//--------------------------------------------------------------------------------------\n#pragma pack(push, 1)\n\n#define DDS_MAGIC 0x20534444 // \"DDS \"\n\nstruct DDS_PIXELFORMAT\n{\n    uint32  size;\n    uint32  flags;\n    uint32  fourCC;\n    uint32  RGBBitCount;\n    uint32  RBitMask;\n    uint32  GBitMask;\n    uint32  BBitMask;\n    uint32  ABitMask;\n};\n\n#define DDS_FOURCC      0x00000004  // DDPF_FOURCC\n#define DDS_RGB         0x00000040  // DDPF_RGB\n#define DDS_RGBA        0x00000041  // DDPF_RGB | DDPF_ALPHAPIXELS\n#define DDS_LUMINANCE   0x00020000  // DDPF_LUMINANCE\n#define DDS_LUMINANCEA  0x00020001  // DDPF_LUMINANCE | DDPF_ALPHAPIXELS\n#define DDS_ALPHA       0x00000002  // DDPF_ALPHA\n#define DDS_PAL8        0x00000020  // DDPF_PALETTEINDEXED8\n\n#define DDS_HEADER_FLAGS_TEXTURE        0x00001007  // DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT\n#define DDS_HEADER_FLAGS_MIPMAP         0x00020000  // DDSD_MIPMAPCOUNT\n#define DDS_HEADER_FLAGS_VOLUME         0x00800000  // DDSD_DEPTH\n#define DDS_HEADER_FLAGS_PITCH          0x00000008  // DDSD_PITCH\n#define DDS_HEADER_FLAGS_LINEARSIZE     0x00080000  // DDSD_LINEARSIZE\n\n#define DDS_HEIGHT 0x00000002 // DDSD_HEIGHT\n#define DDS_WIDTH  0x00000004 // DDSD_WIDTH\n\n#define DDS_SURFACE_FLAGS_TEXTURE 0x00001000 // DDSCAPS_TEXTURE\n#define DDS_SURFACE_FLAGS_MIPMAP  0x00400008 // DDSCAPS_COMPLEX | DDSCAPS_MIPMAP\n#define DDS_SURFACE_FLAGS_CUBEMAP 0x00000008 // DDSCAPS_COMPLEX\n\n#define DDS_CUBEMAP_POSITIVEX 0x00000600 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX\n#define DDS_CUBEMAP_NEGATIVEX 0x00000a00 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX\n#define DDS_CUBEMAP_POSITIVEY 0x00001200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY\n#define DDS_CUBEMAP_NEGATIVEY 0x00002200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY\n#define DDS_CUBEMAP_POSITIVEZ 0x00004200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ\n#define DDS_CUBEMAP_NEGATIVEZ 0x00008200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ\n\n#define DDS_CUBEMAP_ALLFACES (DDS_CUBEMAP_POSITIVEX | DDS_CUBEMAP_NEGATIVEX |\\\n                              DDS_CUBEMAP_POSITIVEY | DDS_CUBEMAP_NEGATIVEY |\\\n                              DDS_CUBEMAP_POSITIVEZ | DDS_CUBEMAP_NEGATIVEZ)\n\n#define DDS_CUBEMAP 0x00000200 // DDSCAPS2_CUBEMAP\n\n#define DDS_FLAGS_VOLUME 0x00200000 // DDSCAPS2_VOLUME\n\ntypedef struct\n{\n    uint32          size;\n    uint32          flags;\n    uint32          height;\n    uint32          width;\n    uint32          pitchOrLinearSize;\n    uint32          depth; // only if DDS_HEADER_FLAGS_VOLUME is set in flags\n    uint32          mipMapCount;\n    uint32          reserved1[11];\n    DDS_PIXELFORMAT ddspf;\n    uint32          caps;\n    uint32          caps2;\n    uint32          caps3;\n    uint32          caps4;\n    uint32          reserved2;\n} DDS_HEADER;\n\ntypedef struct\n{\n    DXGI_FORMAT dxgiFormat;\n    uint32      resourceDimension;\n    uint32      miscFlag; // See D3D11_RESOURCE_MISC_FLAG\n    uint32      arraySize;\n    uint32      reserved;\n} DDS_HEADER_DXT10;\n\n#pragma pack(pop)\n\n//--------------------------------------------------------------------------------------\n// Return the BPP for a particular format.\n//--------------------------------------------------------------------------------------\nstatic size_t BitsPerPixel(_In_ DXGI_FORMAT fmt)\n{\n    switch (fmt)\n    {\n    case DXGI_FORMAT_R32G32B32A32_TYPELESS:\n    case DXGI_FORMAT_R32G32B32A32_FLOAT:\n    case DXGI_FORMAT_R32G32B32A32_UINT:\n    case DXGI_FORMAT_R32G32B32A32_SINT:\n        return 128;\n\n    case DXGI_FORMAT_R32G32B32_TYPELESS:\n    case DXGI_FORMAT_R32G32B32_FLOAT:\n    case DXGI_FORMAT_R32G32B32_UINT:\n    case DXGI_FORMAT_R32G32B32_SINT:\n        return 96;\n\n    case DXGI_FORMAT_R16G16B16A16_TYPELESS:\n    case DXGI_FORMAT_R16G16B16A16_FLOAT:\n    case DXGI_FORMAT_R16G16B16A16_UNORM:\n    case DXGI_FORMAT_R16G16B16A16_UINT:\n    case DXGI_FORMAT_R16G16B16A16_SNORM:\n    case DXGI_FORMAT_R16G16B16A16_SINT:\n    case DXGI_FORMAT_R32G32_TYPELESS:\n    case DXGI_FORMAT_R32G32_FLOAT:\n    case DXGI_FORMAT_R32G32_UINT:\n    case DXGI_FORMAT_R32G32_SINT:\n    case DXGI_FORMAT_R32G8X24_TYPELESS:\n    case DXGI_FORMAT_D32_FLOAT_S8X24_UINT:\n    case DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS:\n    case DXGI_FORMAT_X32_TYPELESS_G8X24_UINT:\n        return 64;\n\n    case DXGI_FORMAT_R10G10B10A2_TYPELESS:\n    case DXGI_FORMAT_R10G10B10A2_UNORM:\n    case DXGI_FORMAT_R10G10B10A2_UINT:\n    case DXGI_FORMAT_R11G11B10_FLOAT:\n    case DXGI_FORMAT_R8G8B8A8_TYPELESS:\n    case DXGI_FORMAT_R8G8B8A8_UNORM:\n    case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:\n    case DXGI_FORMAT_R8G8B8A8_UINT:\n    case DXGI_FORMAT_R8G8B8A8_SNORM:\n    case DXGI_FORMAT_R8G8B8A8_SINT:\n    case DXGI_FORMAT_R16G16_TYPELESS:\n    case DXGI_FORMAT_R16G16_FLOAT:\n    case DXGI_FORMAT_R16G16_UNORM:\n    case DXGI_FORMAT_R16G16_UINT:\n    case DXGI_FORMAT_R16G16_SNORM:\n    case DXGI_FORMAT_R16G16_SINT:\n    case DXGI_FORMAT_R32_TYPELESS:\n    case DXGI_FORMAT_D32_FLOAT:\n    case DXGI_FORMAT_R32_FLOAT:\n    case DXGI_FORMAT_R32_UINT:\n    case DXGI_FORMAT_R32_SINT:\n    case DXGI_FORMAT_R24G8_TYPELESS:\n    case DXGI_FORMAT_D24_UNORM_S8_UINT:\n    case DXGI_FORMAT_R24_UNORM_X8_TYPELESS:\n    case DXGI_FORMAT_X24_TYPELESS_G8_UINT:\n    case DXGI_FORMAT_R9G9B9E5_SHAREDEXP:\n    case DXGI_FORMAT_R8G8_B8G8_UNORM:\n    case DXGI_FORMAT_G8R8_G8B8_UNORM:\n    case DXGI_FORMAT_B8G8R8A8_UNORM:\n    case DXGI_FORMAT_B8G8R8X8_UNORM:\n    case DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM:\n    case DXGI_FORMAT_B8G8R8A8_TYPELESS:\n    case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:\n    case DXGI_FORMAT_B8G8R8X8_TYPELESS:\n    case DXGI_FORMAT_B8G8R8X8_UNORM_SRGB:\n        return 32;\n\n    case DXGI_FORMAT_R8G8_TYPELESS:\n    case DXGI_FORMAT_R8G8_UNORM:\n    case DXGI_FORMAT_R8G8_UINT:\n    case DXGI_FORMAT_R8G8_SNORM:\n    case DXGI_FORMAT_R8G8_SINT:\n    case DXGI_FORMAT_R16_TYPELESS:\n    case DXGI_FORMAT_R16_FLOAT:\n    case DXGI_FORMAT_D16_UNORM:\n    case DXGI_FORMAT_R16_UNORM:\n    case DXGI_FORMAT_R16_UINT:\n    case DXGI_FORMAT_R16_SNORM:\n    case DXGI_FORMAT_R16_SINT:\n    case DXGI_FORMAT_B5G6R5_UNORM:\n    case DXGI_FORMAT_B5G5R5A1_UNORM:\n    case DXGI_FORMAT_B4G4R4A4_UNORM:\n        return 16;\n\n    case DXGI_FORMAT_R8_TYPELESS:\n    case DXGI_FORMAT_R8_UNORM:\n    case DXGI_FORMAT_R8_UINT:\n    case DXGI_FORMAT_R8_SNORM:\n    case DXGI_FORMAT_R8_SINT:\n    case DXGI_FORMAT_A8_UNORM:\n        return 8;\n\n    case DXGI_FORMAT_R1_UNORM:\n        return 1;\n\n    case DXGI_FORMAT_BC1_TYPELESS:\n    case DXGI_FORMAT_BC1_UNORM:\n    case DXGI_FORMAT_BC1_UNORM_SRGB:\n    case DXGI_FORMAT_BC4_TYPELESS:\n    case DXGI_FORMAT_BC4_UNORM:\n    case DXGI_FORMAT_BC4_SNORM:\n        return 4;\n\n    case DXGI_FORMAT_BC2_TYPELESS:\n    case DXGI_FORMAT_BC2_UNORM:\n    case DXGI_FORMAT_BC2_UNORM_SRGB:\n    case DXGI_FORMAT_BC3_TYPELESS:\n    case DXGI_FORMAT_BC3_UNORM:\n    case DXGI_FORMAT_BC3_UNORM_SRGB:\n    case DXGI_FORMAT_BC5_TYPELESS:\n    case DXGI_FORMAT_BC5_UNORM:\n    case DXGI_FORMAT_BC5_SNORM:\n    case DXGI_FORMAT_BC6H_TYPELESS:\n    case DXGI_FORMAT_BC6H_UF16:\n    case DXGI_FORMAT_BC6H_SF16:\n    case DXGI_FORMAT_BC7_TYPELESS:\n    case DXGI_FORMAT_BC7_UNORM:\n    case DXGI_FORMAT_BC7_UNORM_SRGB:\n        return 8;\n\n    default:\n        return 0;\n    }\n}\n\n\n//--------------------------------------------------------------------------------------\n// Get surface information for a particular format.\n//--------------------------------------------------------------------------------------\nstatic void GetSurfaceInfo(\n    _In_ size_t width,\n    _In_ size_t height,\n    _In_ DXGI_FORMAT fmt,\n    _Out_opt_ size_t* outNumBytes,\n    _Out_opt_ size_t* outRowBytes,\n    _Out_opt_ size_t* outNumRows\n    )\n{\n    size_t numBytes = 0;\n    size_t rowBytes = 0;\n    size_t numRows = 0;\n\n    bool bc = false;\n    bool packed  = false;\n    size_t bcnumBytesPerBlock = 0;\n    switch (fmt)\n    {\n    case DXGI_FORMAT_BC1_TYPELESS:\n    case DXGI_FORMAT_BC1_UNORM:\n    case DXGI_FORMAT_BC1_UNORM_SRGB:\n    case DXGI_FORMAT_BC4_TYPELESS:\n    case DXGI_FORMAT_BC4_UNORM:\n    case DXGI_FORMAT_BC4_SNORM:\n        bc = true;\n        bcnumBytesPerBlock = 8;\n        break;\n\n    case DXGI_FORMAT_BC2_TYPELESS:\n    case DXGI_FORMAT_BC2_UNORM:\n    case DXGI_FORMAT_BC2_UNORM_SRGB:\n    case DXGI_FORMAT_BC3_TYPELESS:\n    case DXGI_FORMAT_BC3_UNORM:\n    case DXGI_FORMAT_BC3_UNORM_SRGB:\n    case DXGI_FORMAT_BC5_TYPELESS:\n    case DXGI_FORMAT_BC5_UNORM:\n    case DXGI_FORMAT_BC5_SNORM:\n    case DXGI_FORMAT_BC6H_TYPELESS:\n    case DXGI_FORMAT_BC6H_UF16:\n    case DXGI_FORMAT_BC6H_SF16:\n    case DXGI_FORMAT_BC7_TYPELESS:\n    case DXGI_FORMAT_BC7_UNORM:\n    case DXGI_FORMAT_BC7_UNORM_SRGB:\n        bc = true;\n        bcnumBytesPerBlock = 16;\n        break;\n\n    case DXGI_FORMAT_R8G8_B8G8_UNORM:\n    case DXGI_FORMAT_G8R8_G8B8_UNORM:\n        packed = true;\n        break;\n    }\n\n    if (bc)\n    {\n        size_t numBlocksWide = 0;\n        if (width > 0)\n        {\n            numBlocksWide = std::max<size_t>(1, (width + 3) / 4);\n        }\n        size_t numBlocksHigh = 0;\n        if (height > 0)\n        {\n            numBlocksHigh = std::max<size_t>(1, (height + 3) / 4);\n        }\n        rowBytes = numBlocksWide * bcnumBytesPerBlock;\n        numRows = numBlocksHigh;\n    }\n    else if (packed)\n    {\n        rowBytes = ((width + 1) >> 1) * 4;\n        numRows = height;\n    }\n    else\n    {\n        size_t bpp = BitsPerPixel(fmt);\n        rowBytes = (width * bpp + 7) / 8; // Round up to the nearest byte.\n        numRows = height;\n    }\n\n    numBytes = rowBytes * numRows;\n    if (outNumBytes)\n    {\n        *outNumBytes = numBytes;\n    }\n    if (outRowBytes)\n    {\n        *outRowBytes = rowBytes;\n    }\n    if (outNumRows)\n    {\n        *outNumRows = numRows;\n    }\n}\n\n\n//--------------------------------------------------------------------------------------\n#define ISBITMASK(r, g, b, a) (ddpf.RBitMask == r && ddpf.GBitMask == g && ddpf.BBitMask == b && ddpf.ABitMask == a)\n\nstatic DXGI_FORMAT GetDXGIFormat(const DDS_PIXELFORMAT& ddpf)\n{\n    if (ddpf.flags & DDS_RGB)\n    {\n        // Note that sRGB formats are written using the \"DX10\" extended header.\n\n        switch (ddpf.RGBBitCount)\n        {\n        case 32:\n            if (ISBITMASK(0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000))\n            {\n                return DXGI_FORMAT_R8G8B8A8_UNORM;\n            }\n\n            if (ISBITMASK(0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000))\n            {\n                return DXGI_FORMAT_B8G8R8A8_UNORM;\n            }\n\n            if (ISBITMASK(0x00ff0000, 0x0000ff00, 0x000000ff, 0x00000000))\n            {\n                return DXGI_FORMAT_B8G8R8X8_UNORM;\n            }\n\n            // No DXGI format maps to ISBITMASK(0x000000ff, 0x0000ff00, 0x00ff0000, 0x00000000) aka D3DFMT_X8B8G8R8\n\n            // Note that many common DDS reader/writers (including D3DX) swap the\n            // the RED/BLUE masks for 10:10:10:2 formats. We assumme\n            // below that the 'backwards' header mask is being used since it is most\n            // likely written by D3DX. The more robust solution is to use the 'DX10'\n            // header extension and specify the DXGI_FORMAT_R10G10B10A2_UNORM format directly\n\n            // For 'correct' writers, this should be 0x000003ff, 0x000ffc00, 0x3ff00000 for RGB data\n            if (ISBITMASK(0x3ff00000, 0x000ffc00, 0x000003ff, 0xc0000000))\n            {\n                return DXGI_FORMAT_R10G10B10A2_UNORM;\n            }\n\n            // No DXGI format maps to ISBITMASK(0x000003ff, 0x000ffc00, 0x3ff00000, 0xc0000000) aka D3DFMT_A2R10G10B10\n\n            if (ISBITMASK(0x0000ffff, 0xffff0000, 0x00000000, 0x00000000))\n            {\n                return DXGI_FORMAT_R16G16_UNORM;\n            }\n\n            if (ISBITMASK(0xffffffff, 0x00000000, 0x00000000, 0x00000000))\n            {\n                // Only 32-bit color channel format in D3D9 was R32F.\n                return DXGI_FORMAT_R32_FLOAT; // D3DX writes this out as a FourCC of 114.\n            }\n            break;\n\n        case 24:\n            // No 24bpp DXGI formats aka D3DFMT_R8G8B8\n            break;\n\n        case 16:\n            if (ISBITMASK(0x7c00, 0x03e0, 0x001f, 0x8000))\n            {\n                return DXGI_FORMAT_B5G5R5A1_UNORM;\n            }\n            if (ISBITMASK(0xf800, 0x07e0, 0x001f, 0x0000))\n            {\n                return DXGI_FORMAT_B5G6R5_UNORM;\n            }\n\n            // No DXGI format maps to ISBITMASK(0x7c00, 0x03e0, 0x001f, 0x0000) aka D3DFMT_X1R5G5B5.\n            if (ISBITMASK(0x0f00, 0x00f0, 0x000f, 0xf000))\n            {\n                return DXGI_FORMAT_B4G4R4A4_UNORM;\n            }\n\n            // No DXGI format maps to ISBITMASK(0x0f00, 0x00f0, 0x000f, 0x0000) aka D3DFMT_X4R4G4B4.\n\n            // No 3:3:2, 3:3:2:8, or paletted DXGI formats aka D3DFMT_A8R3G3B2, D3DFMT_R3G3B2, D3DFMT_P8, D3DFMT_A8P8, etc.\n            break;\n        }\n    }\n    else if (ddpf.flags & DDS_LUMINANCE)\n    {\n        if (8 == ddpf.RGBBitCount)\n        {\n            if (ISBITMASK(0x000000ff, 0x00000000, 0x00000000, 0x00000000))\n            {\n                return DXGI_FORMAT_R8_UNORM; // D3DX10/11 writes this out as DX10 extension\n            }\n\n            // No DXGI format maps to ISBITMASK(0x0f, 0x00, 0x00, 0xf0) aka D3DFMT_A4L4.\n        }\n\n        if (16 == ddpf.RGBBitCount)\n        {\n            if (ISBITMASK(0x0000ffff, 0x00000000, 0x00000000, 0x00000000))\n            {\n                return DXGI_FORMAT_R16_UNORM; // D3DX10/11 writes this out as DX10 extension.\n            }\n            if (ISBITMASK(0x000000ff, 0x00000000, 0x00000000, 0x0000ff00))\n            {\n                return DXGI_FORMAT_R8G8_UNORM; // D3DX10/11 writes this out as DX10 extension.\n            }\n        }\n    }\n    else if (ddpf.flags & DDS_ALPHA)\n    {\n        if (8 == ddpf.RGBBitCount)\n        {\n            return DXGI_FORMAT_A8_UNORM;\n        }\n    }\n    else if (ddpf.flags & DDS_FOURCC)\n    {\n        if (MAKEFOURCC('D', 'X', 'T', '1') == ddpf.fourCC)\n        {\n            return DXGI_FORMAT_BC1_UNORM;\n        }\n        if (MAKEFOURCC('D', 'X', 'T', '3') == ddpf.fourCC)\n        {\n            return DXGI_FORMAT_BC2_UNORM;\n        }\n        if (MAKEFOURCC('D', 'X', 'T', '5') == ddpf.fourCC)\n        {\n            return DXGI_FORMAT_BC3_UNORM;\n        }\n\n        // While pre-mulitplied alpha isn't directly supported by the DXGI formats,\n        // they are basically the same as these BC formats so they can be mapped\n        if (MAKEFOURCC('D', 'X', 'T', '2') == ddpf.fourCC)\n        {\n            return DXGI_FORMAT_BC2_UNORM;\n        }\n        if (MAKEFOURCC('D', 'X', 'T', '4') == ddpf.fourCC)\n        {\n            return DXGI_FORMAT_BC3_UNORM;\n        }\n\n        if (MAKEFOURCC('A', 'T', 'I', '1') == ddpf.fourCC)\n        {\n            return DXGI_FORMAT_BC4_UNORM;\n        }\n        if (MAKEFOURCC('B', 'C', '4', 'U') == ddpf.fourCC)\n        {\n            return DXGI_FORMAT_BC4_UNORM;\n        }\n        if (MAKEFOURCC('B', 'C', '4', 'S') == ddpf.fourCC)\n        {\n            return DXGI_FORMAT_BC4_SNORM;\n        }\n\n        if (MAKEFOURCC('A', 'T', 'I', '2') == ddpf.fourCC)\n        {\n            return DXGI_FORMAT_BC5_UNORM;\n        }\n        if (MAKEFOURCC('B', 'C', '5', 'U') == ddpf.fourCC)\n        {\n            return DXGI_FORMAT_BC5_UNORM;\n        }\n        if (MAKEFOURCC('B', 'C', '5', 'S') == ddpf.fourCC)\n        {\n            return DXGI_FORMAT_BC5_SNORM;\n        }\n\n        // BC6H and BC7 are written using the \"DX10\" extended header\n\n        if (MAKEFOURCC('R', 'G', 'B', 'G') == ddpf.fourCC)\n        {\n            return DXGI_FORMAT_R8G8_B8G8_UNORM;\n        }\n        if (MAKEFOURCC('G', 'R', 'G', 'B') == ddpf.fourCC)\n        {\n            return DXGI_FORMAT_G8R8_G8B8_UNORM;\n        }\n\n        // Check for D3DFORMAT enums being set here.\n        switch (ddpf.fourCC)\n        {\n        case 36: // D3DFMT_A16B16G16R16\n            return DXGI_FORMAT_R16G16B16A16_UNORM;\n\n        case 110: // D3DFMT_Q16W16V16U16\n            return DXGI_FORMAT_R16G16B16A16_SNORM;\n\n        case 111: // D3DFMT_R16F\n            return DXGI_FORMAT_R16_FLOAT;\n\n        case 112: // D3DFMT_G16R16F\n            return DXGI_FORMAT_R16G16_FLOAT;\n\n        case 113: // D3DFMT_A16B16G16R16F\n            return DXGI_FORMAT_R16G16B16A16_FLOAT;\n\n        case 114: // D3DFMT_R32F\n            return DXGI_FORMAT_R32_FLOAT;\n\n        case 115: // D3DFMT_G32R32F\n            return DXGI_FORMAT_R32G32_FLOAT;\n\n        case 116: // D3DFMT_A32B32G32R32F\n            return DXGI_FORMAT_R32G32B32A32_FLOAT;\n        }\n    }\n\n    return DXGI_FORMAT_UNKNOWN;\n}\n\n\n//--------------------------------------------------------------------------------------\nstatic void FillInitData(\n    _In_ size_t width,\n    _In_ size_t height,\n    _In_ size_t depth,\n    _In_ size_t mipCount,\n    _In_ size_t arraySize,\n    _In_ DXGI_FORMAT format,\n    _In_ size_t maxsize,\n    _In_ size_t bitSize,\n    _In_reads_bytes_(bitSize) const byte* bitData,\n    _Out_ size_t& twidth,\n    _Out_ size_t& theight,\n    _Out_ size_t& tdepth,\n    _Out_ size_t& skipMip,\n    _Out_writes_(mipCount*arraySize) D3D11_SUBRESOURCE_DATA* initData\n    )\n{\n    if (!bitData || !initData)\n    {\n        throw ref new Platform::InvalidArgumentException();\n    }\n\n    skipMip = 0;\n    twidth = 0;\n    theight = 0;\n    tdepth = 0;\n\n    size_t NumBytes = 0;\n    size_t RowBytes = 0;\n    size_t NumRows = 0;\n    const byte* pSrcBits = bitData;\n    const byte* pEndBits = bitData + bitSize;\n\n    size_t index = 0;\n    for (size_t j = 0; j < arraySize; j++)\n    {\n        size_t w = width;\n        size_t h = height;\n        size_t d = depth;\n        for (size_t i = 0; i < mipCount; i++)\n        {\n            GetSurfaceInfo(w, h, format, &NumBytes, &RowBytes, &NumRows);\n\n            if ((mipCount <= 1) || !maxsize || (w <= maxsize && h <= maxsize && d <= maxsize))\n            {\n                if (!twidth)\n                {\n                    twidth = w;\n                    theight = h;\n                    tdepth = d;\n                }\n\n                initData[index].pSysMem = (const void*)pSrcBits;\n                initData[index].SysMemPitch = static_cast<UINT>(RowBytes);\n                initData[index].SysMemSlicePitch = static_cast<UINT>(NumBytes);\n                ++index;\n            }\n            else\n            {\n                ++skipMip;\n            }\n\n            if (pSrcBits + (NumBytes*d) > pEndBits)\n            {\n                throw ref new Platform::OutOfBoundsException();\n            }\n\n            pSrcBits += NumBytes * d;\n\n            w = w >> 1;\n            h = h >> 1;\n            d = d >> 1;\n            if (w == 0)\n            {\n                w = 1;\n            }\n            if (h == 0)\n            {\n                h = 1;\n            }\n            if (d == 0)\n            {\n                d = 1;\n            }\n        }\n    }\n\n    if (!index)\n    {\n        throw ref new Platform::FailureException();\n    }\n}\n\n\n//--------------------------------------------------------------------------------------\nstatic HRESULT CreateD3DResources(\n    _In_ ID3D11Device* d3dDevice,\n    _In_ uint32 resDim,\n    _In_ size_t width,\n    _In_ size_t height,\n    _In_ size_t depth,\n    _In_ size_t mipCount,\n    _In_ size_t arraySize,\n    _In_ DXGI_FORMAT format,\n    _In_ bool isCubeMap,\n    _In_reads_(mipCount*arraySize) D3D11_SUBRESOURCE_DATA* initData,\n    _Out_opt_ ID3D11Resource** texture,\n    _Out_opt_ ID3D11ShaderResourceView** textureView\n    )\n{\n    if (!d3dDevice || !initData)\n    {\n        return E_INVALIDARG;\n    }\n\n    HRESULT hr = E_FAIL;\n\n    switch (resDim)\n    {\n        case D3D11_RESOURCE_DIMENSION_TEXTURE1D:\n            {\n                D3D11_TEXTURE1D_DESC desc;\n                desc.Width = static_cast<UINT>(width);\n                desc.MipLevels = static_cast<UINT>(mipCount);\n                desc.ArraySize = static_cast<UINT>(arraySize);\n                desc.Format = format;\n                desc.Usage = D3D11_USAGE_DEFAULT;\n                desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;\n                desc.CPUAccessFlags = 0;\n                desc.MiscFlags = 0;\n\n                ID3D11Texture1D* tex = nullptr;\n                hr = d3dDevice->CreateTexture1D(&desc, initData, &tex);\n\n                if (SUCCEEDED(hr) && tex != 0)\n                {\n                    if (textureView != 0)\n                    {\n                        D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc;\n                        memset(&SRVDesc, 0, sizeof(SRVDesc));\n                        SRVDesc.Format = format;\n\n                        if (arraySize > 1)\n                        {\n                            SRVDesc.ViewDimension = D3D_SRV_DIMENSION_TEXTURE1DARRAY;\n                            SRVDesc.Texture1DArray.MipLevels = desc.MipLevels;\n                            SRVDesc.Texture1DArray.ArraySize = static_cast<UINT>(arraySize);\n                        }\n                        else\n                        {\n                            SRVDesc.ViewDimension = D3D_SRV_DIMENSION_TEXTURE1D;\n                            SRVDesc.Texture1D.MipLevels = desc.MipLevels;\n                        }\n\n                        hr = d3dDevice->CreateShaderResourceView(tex, &SRVDesc, textureView);\n\n                        if (FAILED(hr))\n                        {\n                            tex->Release();\n                            return hr;\n                        }\n                    }\n\n                    if (texture != 0)\n                    {\n                        *texture = tex;\n                    }\n                    else\n                    {\n                        tex->Release();\n                    }\n                }\n            }\n            break;\n\n        case D3D11_RESOURCE_DIMENSION_TEXTURE2D:\n            {\n                D3D11_TEXTURE2D_DESC desc;\n                desc.Width = static_cast<UINT>(width);\n                desc.Height = static_cast<UINT>(height);\n                desc.MipLevels = static_cast<UINT>(mipCount);\n                desc.ArraySize = static_cast<UINT>(arraySize);\n                desc.Format = format;\n                desc.SampleDesc.Count = 1;\n                desc.SampleDesc.Quality = 0;\n                desc.Usage = D3D11_USAGE_DEFAULT;\n                desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;\n                desc.CPUAccessFlags = 0;\n                desc.MiscFlags = (isCubeMap) ? D3D11_RESOURCE_MISC_TEXTURECUBE : 0;\n\n                ID3D11Texture2D* tex = nullptr;\n                hr = d3dDevice->CreateTexture2D(&desc, initData, &tex);\n\n                if (SUCCEEDED(hr) && tex != 0)\n                {\n                    if (textureView != 0)\n                    {\n                        D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc;\n                        memset(&SRVDesc, 0, sizeof(SRVDesc));\n                        SRVDesc.Format = format;\n\n                        if (isCubeMap)\n                        {\n                            if (arraySize > 6)\n                            {\n                                SRVDesc.ViewDimension = D3D_SRV_DIMENSION_TEXTURECUBEARRAY;\n                                SRVDesc.TextureCubeArray.MipLevels = desc.MipLevels;\n\n                                // Earlier, we set arraySize to (NumCubes * 6).\n                                SRVDesc.TextureCubeArray.NumCubes = static_cast<UINT>(arraySize / 6);\n                            }\n                            else\n                            {\n                                SRVDesc.ViewDimension = D3D_SRV_DIMENSION_TEXTURECUBE;\n                                SRVDesc.TextureCube.MipLevels = desc.MipLevels;\n                            }\n                        }\n                        else if (arraySize > 1)\n                        {\n                            SRVDesc.ViewDimension = D3D_SRV_DIMENSION_TEXTURE2DARRAY;\n                            SRVDesc.Texture2DArray.MipLevels = desc.MipLevels;\n                            SRVDesc.Texture2DArray.ArraySize = static_cast<UINT>(arraySize);\n                        }\n                        else\n                        {\n                            SRVDesc.ViewDimension = D3D_SRV_DIMENSION_TEXTURE2D;\n                            SRVDesc.Texture2D.MipLevels = desc.MipLevels;\n                        }\n\n                        hr = d3dDevice->CreateShaderResourceView(tex, &SRVDesc, textureView);\n\n                        if (FAILED(hr))\n                        {\n                            tex->Release();\n                            return hr;\n                        }\n                    }\n\n                    if (texture != 0)\n                    {\n                        *texture = tex;\n                    }\n                    else\n                    {\n                        tex->Release();\n                    }\n                }\n            }\n            break;\n\n        case D3D11_RESOURCE_DIMENSION_TEXTURE3D:\n            {\n                D3D11_TEXTURE3D_DESC desc;\n                desc.Width = static_cast<UINT>(width);\n                desc.Height = static_cast<UINT>(height);\n                desc.Depth = static_cast<UINT>(depth);\n                desc.MipLevels = static_cast<UINT>(mipCount);\n                desc.Format = format;\n                desc.Usage = D3D11_USAGE_DEFAULT;\n                desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;\n                desc.CPUAccessFlags = 0;\n                desc.MiscFlags = 0;\n\n                ID3D11Texture3D* tex = nullptr;\n                hr = d3dDevice->CreateTexture3D(&desc, initData, &tex);\n\n                if (SUCCEEDED(hr) && tex != 0)\n                {\n                    if (textureView != 0)\n                    {\n                        D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc;\n                        memset(&SRVDesc, 0, sizeof(SRVDesc));\n                        SRVDesc.Format = format;\n                        SRVDesc.ViewDimension = D3D_SRV_DIMENSION_TEXTURE3D;\n                        SRVDesc.Texture3D.MipLevels = desc.MipLevels;\n\n                        hr = d3dDevice->CreateShaderResourceView(tex, &SRVDesc, textureView);\n\n                        if (FAILED(hr))\n                        {\n                            tex->Release();\n                            return hr;\n                        }\n                    }\n\n                    if (texture != 0)\n                    {\n                        *texture = tex;\n                    }\n                    else\n                    {\n                        tex->Release();\n                    }\n                }\n            }\n            break;\n    }\n\n    return hr;\n}\n\n\n//--------------------------------------------------------------------------------------\nstatic void CreateTextureFromDDS(\n    _In_ ID3D11Device* d3dDevice,\n    _In_ const DDS_HEADER* header,\n    _In_reads_bytes_(bitSize) const byte* bitData,\n    _In_ size_t bitSize,\n    _Out_opt_ ID3D11Resource** texture,\n    _Out_opt_ ID3D11ShaderResourceView** textureView,\n    _In_ size_t maxsize\n    )\n{\n    HRESULT hr = S_OK;\n\n    size_t width = header->width;\n    size_t height = header->height;\n    size_t depth = header->depth;\n\n    uint32 resDim = D3D11_RESOURCE_DIMENSION_UNKNOWN;\n    size_t arraySize = 1;\n    DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN;\n    bool isCubeMap = false;\n\n    size_t mipCount = header->mipMapCount;\n    if (0 == mipCount)\n    {\n        mipCount = 1;\n    }\n\n    if ((header->ddspf.flags & DDS_FOURCC) &&\n        (MAKEFOURCC('D', 'X', '1', '0') == header->ddspf.fourCC))\n    {\n        const DDS_HEADER_DXT10* d3d10ext = reinterpret_cast<const DDS_HEADER_DXT10*>((const char*)header + sizeof(DDS_HEADER));\n\n        arraySize = d3d10ext->arraySize;\n        if (arraySize == 0)\n        {\n            throw ref new Platform::FailureException();\n        }\n\n        if (BitsPerPixel(d3d10ext->dxgiFormat) == 0)\n        {\n            throw ref new Platform::FailureException();\n        }\n\n        format = d3d10ext->dxgiFormat;\n\n        switch (d3d10ext->resourceDimension)\n        {\n        case D3D11_RESOURCE_DIMENSION_TEXTURE1D:\n            // D3DX writes 1D textures with a fixed Height of 1.\n            if ((header->flags & DDS_HEIGHT) && height != 1)\n            {\n                throw ref new Platform::FailureException();\n            }\n            height = depth = 1;\n            break;\n\n        case D3D11_RESOURCE_DIMENSION_TEXTURE2D:\n            if (d3d10ext->miscFlag & D3D11_RESOURCE_MISC_TEXTURECUBE)\n            {\n                arraySize *= 6;\n                isCubeMap = true;\n            }\n            depth = 1;\n            break;\n\n        case D3D11_RESOURCE_DIMENSION_TEXTURE3D:\n            if (!(header->flags & DDS_HEADER_FLAGS_VOLUME))\n            {\n                throw ref new Platform::FailureException();\n            }\n\n            if (arraySize > 1)\n            {\n                throw ref new Platform::FailureException();\n            }\n            break;\n\n        default:\n            return throw ref new Platform::FailureException();\n        }\n\n        resDim = d3d10ext->resourceDimension;\n    }\n    else\n    {\n        format = GetDXGIFormat(header->ddspf);\n\n        if (format == DXGI_FORMAT_UNKNOWN)\n        {\n            return throw ref new Platform::FailureException();\n        }\n\n        if (header->flags & DDS_HEADER_FLAGS_VOLUME)\n        {\n            resDim = D3D11_RESOURCE_DIMENSION_TEXTURE3D;\n        }\n        else\n        {\n            if (header->caps2 & DDS_CUBEMAP)\n            {\n                // We require all six faces to be defined.\n                if ((header->caps2 & DDS_CUBEMAP_ALLFACES) != DDS_CUBEMAP_ALLFACES)\n                {\n                    return throw ref new Platform::FailureException();\n                }\n\n                arraySize = 6;\n                isCubeMap = true;\n            }\n\n            depth = 1;\n            resDim = D3D11_RESOURCE_DIMENSION_TEXTURE2D;\n\n            // Note there's no way for a legacy Direct3D 9 DDS to express a '1D' texture.\n        }\n\n        assert(BitsPerPixel(format) != 0);\n    }\n\n    // Bound sizes (For security purposes, we don't trust DDS file metadata larger than the D3D 11.x hardware requirements.)\n    if (mipCount > D3D11_REQ_MIP_LEVELS)\n    {\n        return throw ref new Platform::FailureException();\n    }\n\n    switch (resDim)\n    {\n        case D3D11_RESOURCE_DIMENSION_TEXTURE1D:\n            if ((arraySize > D3D11_REQ_TEXTURE1D_ARRAY_AXIS_DIMENSION) ||\n                (width > D3D11_REQ_TEXTURE1D_U_DIMENSION))\n            {\n                return throw ref new Platform::FailureException();\n            }\n            break;\n\n        case D3D11_RESOURCE_DIMENSION_TEXTURE2D:\n            if (isCubeMap)\n            {\n                // This is the right bound because we set arraySize to (NumCubes*6) above.\n                if ((arraySize > D3D11_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION) ||\n                    (width > D3D11_REQ_TEXTURECUBE_DIMENSION) ||\n                    (height > D3D11_REQ_TEXTURECUBE_DIMENSION))\n                {\n                    return throw ref new Platform::FailureException();\n                }\n            }\n            else if ((arraySize > D3D11_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION) ||\n                    (width > D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION) ||\n                    (height > D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION))\n            {\n                return throw ref new Platform::FailureException();\n            }\n            break;\n\n        case D3D11_RESOURCE_DIMENSION_TEXTURE3D:\n            if ((arraySize > 1) ||\n                (width > D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION) ||\n                (height > D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION) ||\n                (depth > D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION))\n            {\n                return throw ref new Platform::FailureException();\n            }\n            break;\n    }\n\n    // Create the texture.\n    std::unique_ptr<D3D11_SUBRESOURCE_DATA> initData(new D3D11_SUBRESOURCE_DATA[mipCount * arraySize]);\n\n    size_t skipMip = 0;\n    size_t twidth = 0;\n    size_t theight = 0;\n    size_t tdepth = 0;\n    FillInitData(width, height, depth, mipCount, arraySize, format, maxsize, bitSize, bitData, twidth, theight, tdepth, skipMip, initData.get());\n\n    hr = CreateD3DResources(d3dDevice, resDim, twidth, theight, tdepth, mipCount - skipMip, arraySize, format, isCubeMap, initData.get(), texture, textureView);\n\n    if (FAILED(hr) && !maxsize && (mipCount > 1))\n    {\n        // Retry with a maxsize determined by feature level.\n        switch (d3dDevice->GetFeatureLevel())\n        {\n        case D3D_FEATURE_LEVEL_9_1:\n        case D3D_FEATURE_LEVEL_9_2:\n            if (isCubeMap)\n            {\n                maxsize = D3D_FL9_1_REQ_TEXTURECUBE_DIMENSION;\n            }\n            else\n            {\n                maxsize = (resDim == D3D11_RESOURCE_DIMENSION_TEXTURE3D)\n                    ? D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION\n                    : D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION;\n            }\n            break;\n\n        case D3D_FEATURE_LEVEL_9_3:\n            maxsize = (resDim == D3D11_RESOURCE_DIMENSION_TEXTURE3D)\n                ? D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION\n                : D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION;\n            break;\n\n        default: // D3D_FEATURE_LEVEL_10_0 & D3D_FEATURE_LEVEL_10_1\n            maxsize = (resDim == D3D11_RESOURCE_DIMENSION_TEXTURE3D)\n                ? D3D10_REQ_TEXTURE3D_U_V_OR_W_DIMENSION\n                : D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION;\n            break;\n        }\n\n        FillInitData(width, height, depth, mipCount, arraySize, format, maxsize, bitSize, bitData, twidth, theight, tdepth, skipMip, initData.get());\n\n        hr = CreateD3DResources(d3dDevice, resDim, twidth, theight, tdepth, mipCount - skipMip, arraySize, format, isCubeMap, initData.get(), texture, textureView);\n    }\n\n    DX::ThrowIfFailed(hr);\n}\n\n//--------------------------------------------------------------------------------------\nvoid CreateDDSTextureFromMemory(\n    _In_ ID3D11Device* d3dDevice,\n    _In_reads_bytes_(ddsDataSize) const byte* ddsData,\n    _In_ size_t ddsDataSize,\n    _Out_opt_ ID3D11Resource** texture,\n    _Out_opt_ ID3D11ShaderResourceView** textureView,\n    _In_ size_t maxsize\n    )\n{\n    if (!d3dDevice || !ddsData || (!texture && !textureView))\n    {\n        throw ref new Platform::InvalidArgumentException();\n    }\n\n    // Validate DDS file in memory.\n    if (ddsDataSize < (sizeof(uint32) + sizeof(DDS_HEADER)))\n    {\n        throw ref new Platform::FailureException();\n    }\n\n    uint32 dwMagicNumber = *(const uint32*)(ddsData);\n    if (dwMagicNumber != DDS_MAGIC)\n    {\n        throw ref new Platform::FailureException();\n    }\n\n    const DDS_HEADER* header = reinterpret_cast<const DDS_HEADER*>(ddsData + sizeof(uint32));\n\n    // Verify the header to validate the DDS file.\n    if (header->size != sizeof(DDS_HEADER) ||\n        header->ddspf.size != sizeof(DDS_PIXELFORMAT))\n    {\n        throw ref new Platform::FailureException();\n    }\n\n    // Check for the DX10 extension.\n    bool bDXT10Header = false;\n    if ((header->ddspf.flags & DDS_FOURCC) &&\n        (MAKEFOURCC('D', 'X', '1', '0') == header->ddspf.fourCC))\n    {\n        // Must be long enough for both headers and magic value\n        if (ddsDataSize < (sizeof(DDS_HEADER) + sizeof(uint32) + sizeof(DDS_HEADER_DXT10)))\n        {\n            throw ref new Platform::FailureException();\n        }\n\n        bDXT10Header = true;\n    }\n\n    ptrdiff_t offset = sizeof(uint32) + sizeof(DDS_HEADER) + (bDXT10Header ? sizeof(DDS_HEADER_DXT10) : 0);\n\n    CreateTextureFromDDS(d3dDevice, header, ddsData + offset, ddsDataSize - offset, texture, textureView, maxsize);\n}\n```\n\n \n\n \n\n\n\n\n"}