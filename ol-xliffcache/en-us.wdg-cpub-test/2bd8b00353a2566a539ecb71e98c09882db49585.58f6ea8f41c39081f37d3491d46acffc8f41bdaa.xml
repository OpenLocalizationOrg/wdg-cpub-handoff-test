{"nodes":[{"pos":[11,39],"content":"Move-look controls for games","needQuote":true,"needEscape":true,"nodes":[{"content":"Move-look controls for games","pos":[0,28]}]},{"pos":[53,176],"content":"Learn how to add traditional mouse and keyboard move-look controls (also known as mouselook controls) to your DirectX game.","needQuote":true,"needEscape":true,"nodes":[{"content":"Learn how to add traditional mouse and keyboard move-look controls (also known as mouselook controls) to your DirectX game.","pos":[0,123]}]},{"pos":[319,347],"content":"Move-look controls for games"},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[350,388]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[389,484],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Learn how to add traditional mouse and keyboard move-look controls (also known as mouselook controls) to your DirectX game.","pos":[486,609]},{"content":"We also discuss move-look support for touch devices, with the move controller defined as the lower-left section of the screen that behaves like a directional input, and the look controller defined for the remainder of the screen, with the camera centering on the last place the player touched in that area.","pos":[611,917]},{"content":"If this is an unfamiliar control concept to you, think of it this way: the keyboard (or the touch-based directional input box) controls your legs in this 3D space, and behaves as if your legs were only capable of moving forward or backward, or strafing left and right.","pos":[919,1187]},{"content":"The mouse (or touch pointer) controls your head.","pos":[1188,1236]},{"content":"You use your head to look in a direction -- left or right, up or down, or somewhere in that plane.","pos":[1237,1335]},{"content":"If there is a target in your view, you would use the mouse to center your camera view on that target, and then press the forward key to move towards it, or back to move away from it.","pos":[1336,1518]},{"content":"To circle the target, you would keep the camera view centered on the target, and move left or right at the same time.","pos":[1519,1636]},{"content":"You can see how this is a very effective control method for navigating 3D environments!","pos":[1637,1724]},{"content":"These controls are commonly known as WASD controls in gaming, where the W, A, S, and D keys are used for x-z plane fixed camera movement, and the mouse is used to control camera rotation around the x and y axes.","pos":[1726,1937]},{"content":"Objectives","pos":[1942,1952]},{"content":"Add basic move-look controls to your DirectX game for both mouse and keyboard, and touch screens.","pos":[1959,2056]},{"content":"Implement a first-person camera used to navigate a 3D environment.","pos":[2061,2127]},{"content":"A note on touch control implementations","pos":[2132,2171]},{"content":"For touch controls, we implement two controllers: the move controller, which handles movement in the x-z plane relative to the camera's look point; and the look controller, which aims the camera's look point.","pos":[2174,2382]},{"content":"Our move controller maps to the keyboard WASD buttons, and the look controller maps to the mouse.","pos":[2383,2480]},{"content":"But for touch controls, we need to define a region of the screen that serves as the directional inputs, or the virtual WASD buttons, with the remainder of the screen serving as the input space for the look controls.","pos":[2481,2696]},{"content":"Our screen looks like this.","pos":[2698,2725]},{"content":"the move-look controller layout","pos":[2729,2760]},{"content":"When you move the touch pointer (not the mouse!) in the lower left of the screen, any movement upwards will make the camera move forward.","pos":[2790,2927]},{"content":"Any movement downwards will make the camera move backwards.","pos":[2928,2987]},{"content":"The same holds for left and right movement inside the move controller's pointer space.","pos":[2988,3074]},{"content":"Outside of that space, and it becomes a look controller -- you just touch or drag the camera to where you'd like it to face.","pos":[3075,3199]},{"content":"Set up the basic input event infrastructure","pos":[3204,3247]},{"content":"First, we must create our control class that we use to handle input events from the mouse and keyboard, and update the camera perspective based on that input.","pos":[3250,3408]},{"content":"Because we're implementing move-look controls, we call it <bpt id=\"p1\">**</bpt>MoveLookController<ept id=\"p1\">**</ept>.","pos":[3409,3490],"source":" Because we're implementing move-look controls, we call it **MoveLookController**."},{"content":"Now, let's create a header that defines the state of the move-look controller and its first-person camera, plus the basic methods and event handlers that implement the controls and that update the state of the camera.","pos":[3784,4001]},{"content":"Our code contains 4 groups of private fields.","pos":[6735,6780]},{"content":"Let's review the purpose of each one.","pos":[6781,6818]},{"content":"First, we define some useful fields that hold our updated info about our camera view.","pos":[6820,6905]},{"pos":[6911,7028],"content":"<bpt id=\"p1\">**</bpt>m\\_position<ept id=\"p1\">**</ept> is the position of the camera (and therefore the viewplane) in the 3D scene, using scene coordinates.","source":"**m\\_position** is the position of the camera (and therefore the viewplane) in the 3D scene, using scene coordinates."},{"pos":[7033,7140],"content":"<bpt id=\"p1\">**</bpt>m\\_pitch<ept id=\"p1\">**</ept> is the pitch of the camera, or its up-down rotation around the viewplane's x-axis, in radians.","source":"**m\\_pitch** is the pitch of the camera, or its up-down rotation around the viewplane's x-axis, in radians."},{"pos":[7145,7251],"content":"<bpt id=\"p1\">**</bpt>m\\_yaw<ept id=\"p1\">**</ept> is the yaw of the camera, or its left-right rotation around the viewplane's y-axis, in radians.","source":"**m\\_yaw** is the yaw of the camera, or its left-right rotation around the viewplane's y-axis, in radians."},{"content":"Now, let's define the fields that we use to store info about the status and position of our controllers.","pos":[7253,7357]},{"content":"First, we'll define the fields we need for our touch-based move controller.","pos":[7358,7433]},{"content":"(There's nothing special needed for the keyboard implementation of the move controller.","pos":[7434,7521]},{"content":"We just read keyboard events with specific handlers.)","pos":[7522,7575]},{"pos":[7581,7646],"content":"<bpt id=\"p1\">**</bpt>m\\_moveInUse<ept id=\"p1\">**</ept> indicates whether the move controller is in use.","source":"**m\\_moveInUse** indicates whether the move controller is in use."},{"content":"<bpt id=\"p1\">**</bpt>m\\_movePointerID<ept id=\"p1\">**</ept> is the unique ID for the current move pointer.","pos":[7651,7718],"source":"**m\\_movePointerID** is the unique ID for the current move pointer."},{"content":"We use it to differentiate between the look pointer and the move pointer when we check the pointer ID value.","pos":[7719,7827]},{"content":"<bpt id=\"p1\">**</bpt>m\\_moveFirstDown<ept id=\"p1\">**</ept> is the point on the screen where the player first touched the move controller pointer area.","pos":[7832,7944],"source":"**m\\_moveFirstDown** is the point on the screen where the player first touched the move controller pointer area."},{"content":"We use this value later to set a dead zone to keep tiny movements from jittering the view.","pos":[7945,8035]},{"content":"<bpt id=\"p1\">**</bpt>m\\_movePointerPosition<ept id=\"p1\">**</ept> is the point on the screen the player has currently moved the pointer to.","pos":[8040,8140],"source":"**m\\_movePointerPosition** is the point on the screen the player has currently moved the pointer to."},{"content":"We use it to determine what direction the player wanted to move by examining it relative to <bpt id=\"p1\">**</bpt>m\\_moveFirstDown<ept id=\"p1\">**</ept>.","pos":[8141,8254],"source":" We use it to determine what direction the player wanted to move by examining it relative to **m\\_moveFirstDown**."},{"pos":[8259,8375],"content":"<bpt id=\"p1\">**</bpt>m\\_moveCommand<ept id=\"p1\">**</ept> is the final computed command for the move controller: up (forward), down (back), left, or right.","source":"**m\\_moveCommand** is the final computed command for the move controller: up (forward), down (back), left, or right."},{"content":"Now, we define the fields we use for our look controller, both the mouse and touch implementations.","pos":[8377,8476]},{"pos":[8482,8544],"content":"<bpt id=\"p1\">**</bpt>m\\_lookInUse<ept id=\"p1\">**</ept> indicates whether the look control is in use.","source":"**m\\_lookInUse** indicates whether the look control is in use."},{"content":"<bpt id=\"p1\">**</bpt>m\\_lookPointerID<ept id=\"p1\">**</ept> is the unique ID for the current look pointer.","pos":[8549,8616],"source":"**m\\_lookPointerID** is the unique ID for the current look pointer."},{"content":"We use it to differentiate between the look pointer and the move pointer when we check the pointer ID value.","pos":[8617,8725]},{"pos":[8730,8832],"content":"<bpt id=\"p1\">**</bpt>m\\_lookLastPoint<ept id=\"p1\">**</ept> is the last point, in scene coordinates, that was captured in the previous frame.","source":"**m\\_lookLastPoint** is the last point, in scene coordinates, that was captured in the previous frame."},{"pos":[8837,8946],"content":"<bpt id=\"p1\">**</bpt>m\\_lookLastDelta<ept id=\"p1\">**</ept> is the computed difference between the current <bpt id=\"p2\">**</bpt>m\\_position<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>m\\_lookLastPoint<ept id=\"p3\">**</ept>.","source":"**m\\_lookLastDelta** is the computed difference between the current **m\\_position** and **m\\_lookLastPoint**."},{"content":"Finally, we define 6 Boolean values for the 6 degrees of movement, which we use to indicate the current state of each directional move action (on or off):","pos":[8948,9102]},{"pos":[9108,9190],"content":"<bpt id=\"p1\">**</bpt>m\\_forward<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>m\\_back<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>m\\_left<ept id=\"p3\">**</ept>, <bpt id=\"p4\">**</bpt>m\\_right<ept id=\"p4\">**</ept>, <bpt id=\"p5\">**</bpt>m\\_up<ept id=\"p5\">**</ept> and <bpt id=\"p6\">**</bpt>m\\_down<ept id=\"p6\">**</ept>.","source":"**m\\_forward**, **m\\_back**, **m\\_left**, **m\\_right**, **m\\_up** and **m\\_down**."},{"content":"We use the 6 event handlers to capture the input data we use to update the state of our controllers:","pos":[9192,9292]},{"content":"<bpt id=\"p1\">**</bpt>OnPointerPressed<ept id=\"p1\">**</ept>.","pos":[9298,9319],"source":"**OnPointerPressed**."},{"content":"The player pressed the left mouse button with the pointer in our game screen, or touched the screen.","pos":[9320,9420]},{"content":"<bpt id=\"p1\">**</bpt>OnPointerMoved<ept id=\"p1\">**</ept>.","pos":[9425,9444],"source":"**OnPointerMoved**."},{"content":"The player moved the mouse with the pointer in our game screen, or dragged the touch pointer on the screen.","pos":[9445,9552]},{"content":"<bpt id=\"p1\">**</bpt>OnPointerReleased<ept id=\"p1\">**</ept>.","pos":[9557,9579],"source":"**OnPointerReleased**."},{"content":"The player released the left mouse button with the pointer in our game screen, or stopped touching the screen.","pos":[9580,9690]},{"content":"<bpt id=\"p1\">**</bpt>OnKeyDown<ept id=\"p1\">**</ept>.","pos":[9695,9709],"source":"**OnKeyDown**."},{"content":"The player pressed a key.","pos":[9710,9735]},{"content":"<bpt id=\"p1\">**</bpt>OnKeyUp<ept id=\"p1\">**</ept>.","pos":[9740,9752],"source":"**OnKeyUp**."},{"content":"The player released a key.","pos":[9753,9779]},{"content":"And finally, we use these methods and properties to initialize, access, and update the controllers' state info.","pos":[9781,9892]},{"content":"<bpt id=\"p1\">**</bpt>Initialize<ept id=\"p1\">**</ept>.","pos":[9898,9913],"source":"**Initialize**."},{"content":"Our app calls this event handler to initialize the controls and attach them to the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> object that describes our display window.","pos":[9914,10113],"source":" Our app calls this event handler to initialize the controls and attach them to the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) object that describes our display window."},{"content":"<bpt id=\"p1\">**</bpt>SetPosition<ept id=\"p1\">**</ept>.","pos":[10118,10134],"source":"**SetPosition**."},{"content":"Our app calls this method to set the (x, y, and z) coordinates of our controls in the scene space.","pos":[10135,10233]},{"content":"<bpt id=\"p1\">**</bpt>SetOrientation<ept id=\"p1\">**</ept>.","pos":[10238,10257],"source":"**SetOrientation**."},{"content":"Our app calls this method to set the pitch and yaw of the camera.","pos":[10258,10323]},{"content":"<bpt id=\"p1\">**</bpt>get\\_Position<ept id=\"p1\">**</ept>.","pos":[10328,10346],"source":"**get\\_Position**."},{"content":"Our app accesses this property to get the current position of the camera in the scene space.","pos":[10347,10439]},{"content":"You use this property as the method of communicating the current camera position to the app.","pos":[10440,10532]},{"content":"<bpt id=\"p1\">**</bpt>get\\_LookPoint<ept id=\"p1\">**</ept>.","pos":[10537,10556],"source":"**get\\_LookPoint**."},{"content":"Our app accesses this property to get the current point toward which the controller camera is facing.","pos":[10557,10658]},{"content":"<bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept>.","pos":[10663,10674],"source":"**Update**."},{"content":"Reads the state of the move and look controllers and updates the camera position.","pos":[10675,10756]},{"content":"You continually call this method from the app's main loop to refresh the camera controller data and the camera position in the scene space.","pos":[10757,10896]},{"content":"Now, you have here all the components you need to implement your move-look controls.","pos":[10898,10982]},{"content":"So, let's connect these pieces together.","pos":[10983,11023]},{"content":"Create the basic input events","pos":[11028,11057]},{"pos":[11060,11179],"content":"The Windows Runtime event dispatcher provides 5 events we want instances of the <bpt id=\"p1\">**</bpt>MoveLookController<ept id=\"p1\">**</ept> class to handle:","source":"The Windows Runtime event dispatcher provides 5 events we want instances of the **MoveLookController** class to handle:"},{"content":"PointerPressed","pos":[11188,11202]},{"content":"PointerMoved","pos":[11271,11283]},{"content":"PointerReleased","pos":[11352,11367]},{"content":"KeyUp","pos":[11436,11441]},{"content":"KeyDown","pos":[11510,11517]},{"content":"These events are implemented on the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> type.","pos":[11580,11696],"source":"These events are implemented on the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) type."},{"content":"We assume that you have a <bpt id=\"p1\">**</bpt>CoreWindow<ept id=\"p1\">**</ept> object to work with.","pos":[11697,11758],"source":" We assume that you have a **CoreWindow** object to work with."},{"content":"If you don't know how to obtain one, see <bpt id=\"p1\">[</bpt>How to set up your Universal Windows Platform (UWP) C++ app to display a DirectX view<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh465077)</ept>.","pos":[11759,11946],"source":" If you don't know how to obtain one, see [How to set up your Universal Windows Platform (UWP) C++ app to display a DirectX view](https://msdn.microsoft.com/library/windows/apps/hh465077)."},{"content":"As these events fire while our app is running, the handlers update the controllers' state info defined in our private fields.","pos":[11948,12073]},{"content":"First, let's populate the mouse and touch pointer event handlers.","pos":[12075,12140]},{"content":"In the first event handler, <bpt id=\"p1\">**</bpt>OnPointerPressed()<ept id=\"p1\">**</ept>, we get the x-y coordinates of the pointer from the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>CoreWindow<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> that manages our display when the user clicks the mouse or touches the screen in the look controller region.","pos":[12141,12427],"source":" In the first event handler, **OnPointerPressed()**, we get the x-y coordinates of the pointer from the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) that manages our display when the user clicks the mouse or touches the screen in the look controller region."},{"content":"OnPointerPressed","pos":[12431,12447]},{"content":"This event handler checks whether the pointer is not the mouse (for the purposes of this sample, which supports both mouse and touch) and if it is in the move controller area.","pos":[14270,14445]},{"content":"If both criteria are true, it checks whether the pointer was just pressed, specifically, whether this click is unrelated to a previous move or look input, by testing if <bpt id=\"p1\">**</bpt>m\\_moveInUse<ept id=\"p1\">**</ept> is false.","pos":[14446,14641],"source":" If both criteria are true, it checks whether the pointer was just pressed, specifically, whether this click is unrelated to a previous move or look input, by testing if **m\\_moveInUse** is false."},{"content":"If so, the handler captures the point in the move controller area where the press happened and sets <bpt id=\"p1\">**</bpt>m\\_moveInUse<ept id=\"p1\">**</ept> to true, so that when this handler is called again, it won't overwrite the start position of the move controller input interaction.","pos":[14642,14890],"source":" If so, the handler captures the point in the move controller area where the press happened and sets **m\\_moveInUse** to true, so that when this handler is called again, it won't overwrite the start position of the move controller input interaction."},{"content":"It also updates the move controller pointer ID to the current pointer's ID.","pos":[14891,14966]},{"content":"If the pointer is the mouse or if the touch pointer isn't in the move controller area, it must be in the look controller area.","pos":[14968,15094]},{"content":"It sets <bpt id=\"p1\">**</bpt>m\\_lookLastPoint<ept id=\"p1\">**</ept> to the current position where the user pressed the mouse button or touched and pressed, resets the delta, and updates the look controller's pointer ID to the current pointer ID.","pos":[15095,15301],"source":" It sets **m\\_lookLastPoint** to the current position where the user pressed the mouse button or touched and pressed, resets the delta, and updates the look controller's pointer ID to the current pointer ID."},{"content":"It also sets the state of the look controller to active.","pos":[15302,15358]},{"content":"OnPointerMoved","pos":[15362,15376]},{"content":"The <bpt id=\"p1\">**</bpt>OnPointerMoved<ept id=\"p1\">**</ept> event handler fires whenever the pointer moves (in this case, if a touch screen pointer is being dragged, or if the mouse pointer is being moved while the left button is pressed).","pos":[17057,17259],"source":"The **OnPointerMoved** event handler fires whenever the pointer moves (in this case, if a touch screen pointer is being dragged, or if the mouse pointer is being moved while the left button is pressed)."},{"content":"If the pointer ID is the same as the move controller pointer's ID, then it's the move pointer; otherwise, we check if it's the look controller that's the active pointer.","pos":[17260,17429]},{"content":"If it's the move controller, we just update the pointer position.","pos":[17431,17496]},{"content":"We keep updating it as long the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerMoved<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208276)</ept> event keeps firing, because we want to compare the final position with the first one we captured with the <bpt id=\"p3\">**</bpt>OnPointerPressed<ept id=\"p3\">**</ept> event handler.","pos":[17497,17747],"source":" We keep updating it as long the [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208276) event keeps firing, because we want to compare the final position with the first one we captured with the **OnPointerPressed** event handler."},{"content":"If it's the look controller, things are a little more complicated.","pos":[17749,17815]},{"content":"We need to calculate a new look point and center the camera on it, so we calculate the delta between the last look point and the current screen position, and then we multiply versus our scale factor, which we can tweak to make the look movements smaller or larger relative to the distance of the screen movement.","pos":[17816,18128]},{"content":"Using that value, we calculate the pitch and the yaw.","pos":[18129,18182]},{"content":"Finally, we need to deactivate the move or look controller behaviors when the player stops moving the mouse or touching the screen.","pos":[18184,18315]},{"content":"We use <bpt id=\"p1\">**</bpt>OnPointerReleased<ept id=\"p1\">**</ept>, which we call when <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>PointerReleased<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208279)</ept> is fired, to set <bpt id=\"p4\">**</bpt>m\\_moveInUse<ept id=\"p4\">**</ept> or <bpt id=\"p5\">**</bpt>m\\_lookInUse<ept id=\"p5\">**</ept> to FALSE and turn off the camera pan movement, and to zero out the pointer ID.","pos":[18316,18577],"source":" We use **OnPointerReleased**, which we call when [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279) is fired, to set **m\\_moveInUse** or **m\\_lookInUse** to FALSE and turn off the camera pan movement, and to zero out the pointer ID."},{"content":"OnPointerReleased","pos":[18581,18598]},{"content":"So far, we handled all the touch screen events.","pos":[19177,19224]},{"content":"Now, let's handle the key input events for a keyboard-based move controller.","pos":[19225,19301]},{"content":"OnKeyDown","pos":[19305,19314]},{"content":"As long as one of these keys is pressed, this event handler sets the corresponding directional move state to true.","pos":[19882,19996]},{"content":"OnKeyUp","pos":[20000,20007]},{"content":"And when the key is released, this event handler sets it back to false.","pos":[20572,20643]},{"content":"When we call <bpt id=\"p1\">**</bpt>Update<ept id=\"p1\">**</ept>, it checks these directional move states, and move the camera accordingly.","pos":[20644,20742],"source":" When we call **Update**, it checks these directional move states, and move the camera accordingly."},{"content":"This is a bit simpler than the touch implementation!","pos":[20743,20795]},{"content":"Initialize the touch controls and the controller state","pos":[20800,20854]},{"content":"Let's hook up the events now, and initialize all the controller state fields.","pos":[20857,20934]},{"content":"Initialize","pos":[20938,20948]},{"content":"<bpt id=\"p1\">**</bpt>Initialize<ept id=\"p1\">**</ept> takes a reference to the app's <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>CoreWindow<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> instance as a parameter and registers the event handlers we developed to the appropriate events on that <bpt id=\"p4\">**</bpt>CoreWindow<ept id=\"p4\">**</ept>.","pos":[22344,22584],"source":"**Initialize** takes a reference to the app's [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) instance as a parameter and registers the event handlers we developed to the appropriate events on that **CoreWindow**."},{"content":"It initializes the move and look pointer's IDs, sets the command vector for our touch screen move controller implementation to zero, and sets the camera looking straight ahead when the app starts.","pos":[22585,22781]},{"content":"Getting and setting the position and orientation of the camera","pos":[22786,22848]},{"content":"Let's define some methods to get and set the position of the camera with respect to the viewport.","pos":[22851,22948]},{"content":"Updating the controller state info","pos":[23881,23915]},{"content":"Now, we perform our calculations that convert the pointer coordinate info tracked in <bpt id=\"p1\">**</bpt>m\\_movePointerPosition<ept id=\"p1\">**</ept> into new coordinate information respective of our world coordinate system.","pos":[23918,24104],"source":"Now, we perform our calculations that convert the pointer coordinate info tracked in **m\\_movePointerPosition** into new coordinate information respective of our world coordinate system."},{"content":"Our app calls this method every time we refresh the main app loop.","pos":[24105,24171]},{"content":"So, it is here that we compute the new look point position info we want to pass to the app for updating the view matrix before projection into the viewport.","pos":[24172,24328]},{"content":"Because we don't want jittery movement when the player uses our touch-based move controller, we set a virtual dead zone around the pointer with a diameter of 32 pixels.","pos":[26777,26945]},{"content":"We also add velocity, which is the command value plus a movement gain rate.","pos":[26946,27021]},{"content":"(You can adjust this behavior to your liking, to slow down or speed up the rate of movement based on the distance the pointer moves in the move controller area.)","pos":[27022,27183]},{"content":"When we compute the velocity, we also translate the coordinates received from the move and look controllers into the movement of the actual look point we send to the method that computes our view matrix for the scene.","pos":[27185,27402]},{"content":"First, we invert the x coordinate, because if we click-move or drag left or right with the look controller, the look point rotates in the opposite direction in the scene, as a camera might swing about its central axis.","pos":[27403,27621]},{"content":"Then, we swap the y and z axes, because an up/down key press or touch drag motion (read as a y-axis behavior) on the move controller should translate into a camera action that moves the look point into or out of the screen (the z-axis).","pos":[27622,27858]},{"content":"The final position of the look point for the player is the last position plus the calculated velocity, and this is what is read by the renderer when it calls the <bpt id=\"p1\">**</bpt>get\\_Position<ept id=\"p1\">**</ept> method (most likely during the setup for each frame).","pos":[27860,28093],"source":"The final position of the look point for the player is the last position plus the calculated velocity, and this is what is read by the renderer when it calls the **get\\_Position** method (most likely during the setup for each frame)."},{"content":"After that, we reset the move command to zero.","pos":[28094,28140]},{"content":"Updating the view matrix with the new camera position","pos":[28145,28198]},{"content":"We can obtain a scene space coordinate that our camera is focused on, and which is updated whenever you tell your app to do so (every 60 seconds in the main app loop, for example).","pos":[28201,28381]},{"content":"This pseudocode suggests the calling behavior you can implement:","pos":[28382,28446]},{"content":"Congratulations!","pos":[28866,28882]},{"content":"You've implemented basic move-look controls for both touch screens and keyboard/mouse input touch controls in your game!","pos":[28883,29003]},{"content":"Note","pos":[29009,29013]},{"content":"This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.","pos":[29018,29106]},{"content":"If you’re developing for Windows 8.x or Windows Phone 8.x, see the <bpt id=\"p1\">[</bpt>archived documentation<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>.","pos":[29107,29248],"source":" If you’re developing for Windows 8.x or Windows Phone 8.x, see the [archived documentation](http://go.microsoft.com/fwlink/p/?linkid=619132)."}],"content":"---\ntitle: Move-look controls for games\ndescription: Learn how to add traditional mouse and keyboard move-look controls (also known as mouselook controls) to your DirectX game.\nms.assetid: 4b4d967c-3de9-8a97-ae68-0327f00cc933\n---\n\n# <span id=\"dev_gaming.tutorial__adding_move-look_controls_to_your_directx_game\"></span>Move-look controls for games\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nLearn how to add traditional mouse and keyboard move-look controls (also known as mouselook controls) to your DirectX game.\n\nWe also discuss move-look support for touch devices, with the move controller defined as the lower-left section of the screen that behaves like a directional input, and the look controller defined for the remainder of the screen, with the camera centering on the last place the player touched in that area.\n\nIf this is an unfamiliar control concept to you, think of it this way: the keyboard (or the touch-based directional input box) controls your legs in this 3D space, and behaves as if your legs were only capable of moving forward or backward, or strafing left and right. The mouse (or touch pointer) controls your head. You use your head to look in a direction -- left or right, up or down, or somewhere in that plane. If there is a target in your view, you would use the mouse to center your camera view on that target, and then press the forward key to move towards it, or back to move away from it. To circle the target, you would keep the camera view centered on the target, and move left or right at the same time. You can see how this is a very effective control method for navigating 3D environments!\n\nThese controls are commonly known as WASD controls in gaming, where the W, A, S, and D keys are used for x-z plane fixed camera movement, and the mouse is used to control camera rotation around the x and y axes.\n\n## Objectives\n\n\n-   Add basic move-look controls to your DirectX game for both mouse and keyboard, and touch screens.\n-   Implement a first-person camera used to navigate a 3D environment.\n\n## A note on touch control implementations\n\n\nFor touch controls, we implement two controllers: the move controller, which handles movement in the x-z plane relative to the camera's look point; and the look controller, which aims the camera's look point. Our move controller maps to the keyboard WASD buttons, and the look controller maps to the mouse. But for touch controls, we need to define a region of the screen that serves as the directional inputs, or the virtual WASD buttons, with the remainder of the screen serving as the input space for the look controls.\n\nOur screen looks like this.\n\n![the move-look controller layout](images/movelook-touch.png)\n\nWhen you move the touch pointer (not the mouse!) in the lower left of the screen, any movement upwards will make the camera move forward. Any movement downwards will make the camera move backwards. The same holds for left and right movement inside the move controller's pointer space. Outside of that space, and it becomes a look controller -- you just touch or drag the camera to where you'd like it to face.\n\n## Set up the basic input event infrastructure\n\n\nFirst, we must create our control class that we use to handle input events from the mouse and keyboard, and update the camera perspective based on that input. Because we're implementing move-look controls, we call it **MoveLookController**.\n\n```cpp\nusing namespace Windows::UI::Core;\nusing namespace Windows::System;\nusing namespace Windows::Foundation;\nusing namespace Windows::Devices::Input;\n#include <DirectXMath.h>\n\n// Methods to get input from the UI pointers\nref class MoveLookController\n{\n};  // class MoveLookController\n```\n\nNow, let's create a header that defines the state of the move-look controller and its first-person camera, plus the basic methods and event handlers that implement the controls and that update the state of the camera.\n\n```cpp\n#define ROTATION_GAIN 0.004f    // Sensitivity adjustment for the look controller\n#define MOVEMENT_GAIN 0.1f      // Sensitivity adjustment for the move controller\n\nref class MoveLookController\n{\nprivate:\n    // Properties of the controller object\n    DirectX::XMFLOAT3 m_position;               // The position of the controller\n    float m_pitch, m_yaw;           // Orientation euler angles in radians\n\n    // Properties of the Move control\n    bool m_moveInUse;               // Specifies whether the move control is in use\n    uint32 m_movePointerID;         // Id of the pointer in this control\n    DirectX::XMFLOAT2 m_moveFirstDown;          // Point where initial contact occurred\n    DirectX::XMFLOAT2 m_movePointerPosition;   // Point where the move pointer is currently located\n    DirectX::XMFLOAT3 m_moveCommand;            // The net command from the move control\n\n    // Properties of the Look control\n    bool m_lookInUse;               // Specifies whether the look control is in use\n    uint32 m_lookPointerID;         // Id of the pointer in this control\n    DirectX::XMFLOAT2 m_lookLastPoint;          // Last point (from last frame)\n    DirectX::XMFLOAT2 m_lookLastDelta;          // For smoothing\n\n    bool m_forward, m_back;         // States for movement\n    bool m_left, m_right;\n    bool m_up, m_down;\n\n\npublic:\n\n    // Methods to get input from the UI pointers\n    void OnPointerPressed(\n        _In_ Windows::UI::Core::CoreWindow^ sender,\n        _In_ Windows::UI::Core::PointerEventArgs^ args\n        );\n\n    void OnPointerMoved(\n        _In_ Windows::UI::Core::CoreWindow^ sender,\n        _In_ Windows::UI::Core::PointerEventArgs^ args\n        );\n\n    void OnPointerReleased(\n        _In_ Windows::UI::Core::CoreWindow^ sender,\n        _In_ Windows::UI::Core::PointerEventArgs^ args\n        );\n\n    void OnKeyDown(\n        _In_ Windows::UI::Core::CoreWindow^ sender,\n        _In_ Windows::UI::Core::KeyEventArgs^ args\n        );\n\n    void OnKeyUp(\n        _In_ Windows::UI::Core::CoreWindow^ sender,\n        _In_ Windows::UI::Core::KeyEventArgs^ args\n        );\n\n    // Set up the Controls that this controller supports\n    void Initialize( _In_ Windows::UI::Core::CoreWindow^ window );\n\n    void Update( Windows::UI::Core::CoreWindow ^window );\n    \ninternal:\n    // Accessor to set position of controller\n    void SetPosition( _In_ DirectX::XMFLOAT3 pos );\n\n    // Accessor to set position of controller\n    void SetOrientation( _In_ float pitch, _In_ float yaw );\n\n    // Returns the position of the controller object\n    DirectX::XMFLOAT3 get_Position();\n\n    // Returns the point  which the controller is facing\n    DirectX::XMFLOAT3 get_LookPoint();\n\n\n};  // class MoveLookController\n```\n\nOur code contains 4 groups of private fields. Let's review the purpose of each one.\n\nFirst, we define some useful fields that hold our updated info about our camera view.\n\n-   **m\\_position** is the position of the camera (and therefore the viewplane) in the 3D scene, using scene coordinates.\n-   **m\\_pitch** is the pitch of the camera, or its up-down rotation around the viewplane's x-axis, in radians.\n-   **m\\_yaw** is the yaw of the camera, or its left-right rotation around the viewplane's y-axis, in radians.\n\nNow, let's define the fields that we use to store info about the status and position of our controllers. First, we'll define the fields we need for our touch-based move controller. (There's nothing special needed for the keyboard implementation of the move controller. We just read keyboard events with specific handlers.)\n\n-   **m\\_moveInUse** indicates whether the move controller is in use.\n-   **m\\_movePointerID** is the unique ID for the current move pointer. We use it to differentiate between the look pointer and the move pointer when we check the pointer ID value.\n-   **m\\_moveFirstDown** is the point on the screen where the player first touched the move controller pointer area. We use this value later to set a dead zone to keep tiny movements from jittering the view.\n-   **m\\_movePointerPosition** is the point on the screen the player has currently moved the pointer to. We use it to determine what direction the player wanted to move by examining it relative to **m\\_moveFirstDown**.\n-   **m\\_moveCommand** is the final computed command for the move controller: up (forward), down (back), left, or right.\n\nNow, we define the fields we use for our look controller, both the mouse and touch implementations.\n\n-   **m\\_lookInUse** indicates whether the look control is in use.\n-   **m\\_lookPointerID** is the unique ID for the current look pointer. We use it to differentiate between the look pointer and the move pointer when we check the pointer ID value.\n-   **m\\_lookLastPoint** is the last point, in scene coordinates, that was captured in the previous frame.\n-   **m\\_lookLastDelta** is the computed difference between the current **m\\_position** and **m\\_lookLastPoint**.\n\nFinally, we define 6 Boolean values for the 6 degrees of movement, which we use to indicate the current state of each directional move action (on or off):\n\n-   **m\\_forward**, **m\\_back**, **m\\_left**, **m\\_right**, **m\\_up** and **m\\_down**.\n\nWe use the 6 event handlers to capture the input data we use to update the state of our controllers:\n\n-   **OnPointerPressed**. The player pressed the left mouse button with the pointer in our game screen, or touched the screen.\n-   **OnPointerMoved**. The player moved the mouse with the pointer in our game screen, or dragged the touch pointer on the screen.\n-   **OnPointerReleased**. The player released the left mouse button with the pointer in our game screen, or stopped touching the screen.\n-   **OnKeyDown**. The player pressed a key.\n-   **OnKeyUp**. The player released a key.\n\nAnd finally, we use these methods and properties to initialize, access, and update the controllers' state info.\n\n-   **Initialize**. Our app calls this event handler to initialize the controls and attach them to the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) object that describes our display window.\n-   **SetPosition**. Our app calls this method to set the (x, y, and z) coordinates of our controls in the scene space.\n-   **SetOrientation**. Our app calls this method to set the pitch and yaw of the camera.\n-   **get\\_Position**. Our app accesses this property to get the current position of the camera in the scene space. You use this property as the method of communicating the current camera position to the app.\n-   **get\\_LookPoint**. Our app accesses this property to get the current point toward which the controller camera is facing.\n-   **Update**. Reads the state of the move and look controllers and updates the camera position. You continually call this method from the app's main loop to refresh the camera controller data and the camera position in the scene space.\n\nNow, you have here all the components you need to implement your move-look controls. So, let's connect these pieces together.\n\n## Create the basic input events\n\n\nThe Windows Runtime event dispatcher provides 5 events we want instances of the **MoveLookController** class to handle:\n\n-   [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208278)\n-   [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208276)\n-   [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279)\n-   [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208271)\n-   [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208270)\n\nThese events are implemented on the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) type. We assume that you have a **CoreWindow** object to work with. If you don't know how to obtain one, see [How to set up your Universal Windows Platform (UWP) C++ app to display a DirectX view](https://msdn.microsoft.com/library/windows/apps/hh465077).\n\nAs these events fire while our app is running, the handlers update the controllers' state info defined in our private fields.\n\nFirst, let's populate the mouse and touch pointer event handlers. In the first event handler, **OnPointerPressed()**, we get the x-y coordinates of the pointer from the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) that manages our display when the user clicks the mouse or touches the screen in the look controller region.\n\n**OnPointerPressed**\n\n```cpp\nvoid MoveLookController::OnPointerPressed(\n_In_ CoreWindow^ sender,\n_In_ PointerEventArgs^ args)\n{\n    // Get the current pointer position.\n    uint32 pointerID = args->CurrentPoint->PointerId;\n    DirectX::XMFLOAT2 position = DirectX::XMFLOAT2( args->CurrentPoint->Position.X, args->CurrentPoint->Position.Y );\n\n    auto device = args->CurrentPoint->PointerDevice;\n    auto deviceType = device->PointerDeviceType;\n    if ( deviceType == PointerDeviceType::Mouse )\n    {\n        // Action, Jump, or Fire\n    }\n\n    // Check  if this pointer is in the move control.\n    // Change the values  to percentages of the preferred screen resolution.\n    // You can set the x value to <preferred resolution> * <percentage of width>\n    // for example, ( position.x < (screenResolution.x * 0.15) ).\n\n    if (( position.x < 300 && position.y > 380 ) && ( deviceType != PointerDeviceType::Mouse ))\n    {\n        if ( !m_moveInUse ) // if no pointer is in this control yet\n        {\n            // Process a DPad touch down event.\n            m_moveFirstDown = position;                 // Save the location of the initial contact.\n            m_movePointerPosition = position;\n            m_movePointerID = pointerID;                // Store the id of the pointer using this control.\n            m_moveInUse = TRUE;\n        }\n    }\n    else // This pointer must be in the look control.\n    {\n        if ( !m_lookInUse ) // If no pointer is in this control yet...\n        {\n            m_lookLastPoint = position;                         // save the point for later move\n            m_lookPointerID = args->CurrentPoint->PointerId;  // store the id of pointer using this control\n            m_lookLastDelta.x = m_lookLastDelta.y = 0;          // these are for smoothing\n            m_lookInUse = TRUE;\n        }\n    }\n}\n```\n\nThis event handler checks whether the pointer is not the mouse (for the purposes of this sample, which supports both mouse and touch) and if it is in the move controller area. If both criteria are true, it checks whether the pointer was just pressed, specifically, whether this click is unrelated to a previous move or look input, by testing if **m\\_moveInUse** is false. If so, the handler captures the point in the move controller area where the press happened and sets **m\\_moveInUse** to true, so that when this handler is called again, it won't overwrite the start position of the move controller input interaction. It also updates the move controller pointer ID to the current pointer's ID.\n\nIf the pointer is the mouse or if the touch pointer isn't in the move controller area, it must be in the look controller area. It sets **m\\_lookLastPoint** to the current position where the user pressed the mouse button or touched and pressed, resets the delta, and updates the look controller's pointer ID to the current pointer ID. It also sets the state of the look controller to active.\n\n**OnPointerMoved**\n\n```cpp\nvoid MoveLookController::OnPointerMoved(\n    _In_ CoreWindow ^sender,\n    _In_ PointerEventArgs ^args)\n{\n    uint32 pointerID = args->CurrentPoint->PointerId;\n    DirectX::XMFLOAT2 position = DirectX::XMFLOAT2(args->CurrentPoint->Position.X, args->CurrentPoint->Position.Y);\n\n    // Decide which control this pointer is operating.\n    if (pointerID == m_movePointerID)           // This is the move pointer.\n    {\n        // Move control\n        m_movePointerPosition = position;       // Save the current position.\n\n    }\n    else if (pointerID == m_lookPointerID)      // This is the look pointer.\n    {\n        // Look control\n\n        DirectX::XMFLOAT2 pointerDelta;\n        pointerDelta.x = position.x - m_lookLastPoint.x;        // How far did pointer move\n        pointerDelta.y = position.y - m_lookLastPoint.y;\n\n        DirectX::XMFLOAT2 rotationDelta;\n        rotationDelta.x = pointerDelta.x * ROTATION_GAIN;   // Scale for control sensitivity.\n        rotationDelta.y = pointerDelta.y * ROTATION_GAIN;\n\n        m_lookLastPoint = position;                     // Save for the next time through.\n\n                                                        // Update our orientation based on the command.\n        m_pitch -= rotationDelta.y;                     // Mouse y increases down, but pitch increases up.\n        m_yaw -= rotationDelta.x;                       // Yaw is defined as CCW around the y-axis.\n\n                                                        // Limit the pitch to straight up or straight down.\n        m_pitch = (float)__max(-DirectX::XM_PI / 2.0f, m_pitch);\n        m_pitch = (float)__min(+DirectX::XM_PI / 2.0f, m_pitch);\n    }\n}\n```\n\nThe **OnPointerMoved** event handler fires whenever the pointer moves (in this case, if a touch screen pointer is being dragged, or if the mouse pointer is being moved while the left button is pressed). If the pointer ID is the same as the move controller pointer's ID, then it's the move pointer; otherwise, we check if it's the look controller that's the active pointer.\n\nIf it's the move controller, we just update the pointer position. We keep updating it as long the [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/br208276) event keeps firing, because we want to compare the final position with the first one we captured with the **OnPointerPressed** event handler.\n\nIf it's the look controller, things are a little more complicated. We need to calculate a new look point and center the camera on it, so we calculate the delta between the last look point and the current screen position, and then we multiply versus our scale factor, which we can tweak to make the look movements smaller or larger relative to the distance of the screen movement. Using that value, we calculate the pitch and the yaw.\n\nFinally, we need to deactivate the move or look controller behaviors when the player stops moving the mouse or touching the screen. We use **OnPointerReleased**, which we call when [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/br208279) is fired, to set **m\\_moveInUse** or **m\\_lookInUse** to FALSE and turn off the camera pan movement, and to zero out the pointer ID.\n\n**OnPointerReleased**\n\n```cpp\nvoid MoveLookController::OnPointerReleased(\n_In_ CoreWindow ^sender,\n_In_ PointerEventArgs ^args)\n{\n    uint32 pointerID = args->CurrentPoint->PointerId;\n    DirectX::XMFLOAT2 position = DirectX::XMFLOAT2( args->CurrentPoint->Position.X, args->CurrentPoint->Position.Y );\n\n\n    if ( pointerID == m_movePointerID )    // This was the move pointer.\n    {\n        m_moveInUse = FALSE;\n        m_movePointerID = 0;\n    }\n    else if (pointerID == m_lookPointerID ) // This was the look pointer.\n    {\n        m_lookInUse = FALSE;\n        m_lookPointerID = 0;\n    }\n}\n```\n\nSo far, we handled all the touch screen events. Now, let's handle the key input events for a keyboard-based move controller.\n\n**OnKeyDown**\n\n```cpp\nvoid MoveLookController::OnKeyDown(\n                                   __in CoreWindow^ sender,\n                                   __in KeyEventArgs^ args )\n{\n    Windows::System::VirtualKey Key;\n    Key = args->VirtualKey;\n\n    // Figure out the command from the keyboard.\n    if ( Key == VirtualKey::W )     // Forward\n        m_forward = true;\n    if ( Key == VirtualKey::S )     // Back\n        m_back = true;\n    if ( Key == VirtualKey::A )     // Left\n        m_left = true;\n    if ( Key == VirtualKey::D )     // Right\n        m_right = true;\n}\n```\n\nAs long as one of these keys is pressed, this event handler sets the corresponding directional move state to true.\n\n**OnKeyUp**\n\n```cpp\nvoid MoveLookController::OnKeyUp(\n                                 __in CoreWindow^ sender,\n                                 __in KeyEventArgs^ args)\n{\n    Windows::System::VirtualKey Key;\n    Key = args->VirtualKey;\n\n    // Figure out the command from the keyboard.\n    if ( Key == VirtualKey::W )     // forward\n        m_forward = false;\n    if ( Key == VirtualKey::S )     // back\n        m_back = false;\n    if ( Key == VirtualKey::A )     // left\n        m_left = false;\n    if ( Key == VirtualKey::D )     // right\n        m_right = false;\n}\n```\n\nAnd when the key is released, this event handler sets it back to false. When we call **Update**, it checks these directional move states, and move the camera accordingly. This is a bit simpler than the touch implementation!\n\n## Initialize the touch controls and the controller state\n\n\nLet's hook up the events now, and initialize all the controller state fields.\n\n**Initialize**\n\n```cpp\nvoid MoveLookController::Initialize( _In_ CoreWindow^ window )\n{\n\n    // Opt in to recieve touch/mouse events.\n    window->PointerPressed += \n    ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerPressed);\n\n    window->PointerMoved += \n    ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerMoved);\n\n    window->PointerReleased += \n    ref new TypedEventHandler<CoreWindow^, PointerEventArgs^>(this, &MoveLookController::OnPointerReleased);\n\n    window->CharacterReceived +=\n    ref new TypedEventHandler<CoreWindow^, CharacterReceivedEventArgs^>(this, &MoveLookController::OnCharacterReceived);\n\n    window->KeyDown += \n    ref new TypedEventHandler<CoreWindow^, KeyEventArgs^>(this, &MoveLookController::OnKeyDown);\n\n    window->KeyUp += \n    ref new TypedEventHandler<CoreWindow^, KeyEventArgs^>(this, &MoveLookController::OnKeyUp);\n\n    // Initialize the state of the controller.\n    m_moveInUse = FALSE;                // No pointer is in the Move control.\n    m_movePointerID = 0;\n\n    m_lookInUse = FALSE;                // No pointer is in the Look control.\n    m_lookPointerID = 0;\n\n    //  Need to init this as it is reset every frame.\n    m_moveCommand = DirectX::XMFLOAT3( 0.0f, 0.0f, 0.0f );\n\n    SetOrientation( 0, 0 );             // Look straight ahead when the app starts.\n\n}\n```\n\n**Initialize** takes a reference to the app's [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) instance as a parameter and registers the event handlers we developed to the appropriate events on that **CoreWindow**. It initializes the move and look pointer's IDs, sets the command vector for our touch screen move controller implementation to zero, and sets the camera looking straight ahead when the app starts.\n\n## Getting and setting the position and orientation of the camera\n\n\nLet's define some methods to get and set the position of the camera with respect to the viewport.\n\n```cpp\nvoid MoveLookController::SetPosition( _In_ DirectX::XMFLOAT3 pos )\n{\n    m_position = pos;\n}\n\n// Accessor to set the position of the controller.\nvoid MoveLookController::SetOrientation( _In_ float pitch, _In_ float yaw )\n{\n    m_pitch = pitch;\n    m_yaw = yaw;\n}\n\n// Returns the position of the controller object.\nDirectX::XMFLOAT3 MoveLookController::get_Position()\n{\n    return m_position;\n}\n\n// Returns the point at which the camera controller is facing.\nDirectX::XMFLOAT3 MoveLookController::get_LookPoint()\n{\n    float y = sinf(m_pitch);        // Vertical\n    float r = cosf(m_pitch);        // In the plane\n    float z = r*cosf(m_yaw);        // Fwd-back\n    float x = r*sinf(m_yaw);        // Left-right\n    DirectX::XMFLOAT3 result(x,y,z);\n    result.x += m_position.x;\n    result.y += m_position.y;\n    result.z += m_position.z;\n\n    // Return m_position + DirectX::XMFLOAT3(x, y, z);\n    return result;\n}\n```\n\n## Updating the controller state info\n\n\nNow, we perform our calculations that convert the pointer coordinate info tracked in **m\\_movePointerPosition** into new coordinate information respective of our world coordinate system. Our app calls this method every time we refresh the main app loop. So, it is here that we compute the new look point position info we want to pass to the app for updating the view matrix before projection into the viewport.\n\n```cpp\nvoid MoveLookController::Update(CoreWindow ^window)\n{\n    // Check for input from the Move control.\n    if (m_moveInUse)\n    {\n        DirectX::XMFLOAT2 pointerDelta(m_movePointerPosition);\n        pointerDelta.x -= m_moveFirstDown.x;\n        pointerDelta.y -= m_moveFirstDown.y;\n\n        // Figure out the command from the touch-based virtual joystick.\n        if (pointerDelta.x > 16.0f)      // Leave 32 pixel-wide dead spot for being still.\n            m_moveCommand.x = 1.0f;\n        else\n            if (pointerDelta.x < -16.0f)\n            m_moveCommand.x = -1.0f;\n\n        if (pointerDelta.y > 16.0f)      // Joystick y is up, so change sign.\n            m_moveCommand.y = -1.0f;\n        else\n            if (pointerDelta.y < -16.0f)\n            m_moveCommand.y = 1.0f;\n    }\n\n    // Poll our state bits that are set by the keyboard input events.\n    if (m_forward)\n        m_moveCommand.y += 1.0f;\n    if (m_back)\n        m_moveCommand.y -= 1.0f;\n\n    if (m_left)\n        m_moveCommand.x -= 1.0f;\n    if (m_right)\n        m_moveCommand.x += 1.0f;\n\n    if (m_up)\n        m_moveCommand.z += 1.0f;\n    if (m_down)\n        m_moveCommand.z -= 1.0f;\n\n    // Make sure that 45 degree cases are not faster.\n    DirectX::XMFLOAT3 command = m_moveCommand;\n    DirectX::XMVECTOR vector;\n    vector = DirectX::XMLoadFloat3(&command);\n\n    if (fabsf(command.x) > 0.1f || fabsf(command.y) > 0.1f || fabsf(command.z) > 0.1f)\n    {\n        vector = DirectX::XMVector3Normalize(vector);\n        DirectX::XMStoreFloat3(&command, vector);\n    }\n    \n\n    // Rotate command to align with our direction (world coordinates).\n    DirectX::XMFLOAT3 wCommand;\n    wCommand.x = command.x*cosf(m_yaw) - command.y*sinf(m_yaw);\n    wCommand.y = command.x*sinf(m_yaw) + command.y*cosf(m_yaw);\n    wCommand.z = command.z;\n\n    // Scale for sensitivity adjustment.\n    wCommand.x = wCommand.x * MOVEMENT_GAIN;\n    wCommand.y = wCommand.y * MOVEMENT_GAIN;\n    wCommand.z = wCommand.z * MOVEMENT_GAIN;\n\n    // Our velocity is based on the command.\n    // Also note that y is the up-down axis. \n    DirectX::XMFLOAT3 Velocity;\n    Velocity.x = -wCommand.x;\n    Velocity.z = wCommand.y;\n    Velocity.y = wCommand.z;\n\n    // Integrate\n    m_position.x += Velocity.x;\n    m_position.y += Velocity.y;\n    m_position.z += Velocity.z;\n\n    // Clear movement input accumulator for use during the next frame.\n    m_moveCommand = DirectX::XMFLOAT3(0.0f, 0.0f, 0.0f);\n\n}\n```\n\nBecause we don't want jittery movement when the player uses our touch-based move controller, we set a virtual dead zone around the pointer with a diameter of 32 pixels. We also add velocity, which is the command value plus a movement gain rate. (You can adjust this behavior to your liking, to slow down or speed up the rate of movement based on the distance the pointer moves in the move controller area.)\n\nWhen we compute the velocity, we also translate the coordinates received from the move and look controllers into the movement of the actual look point we send to the method that computes our view matrix for the scene. First, we invert the x coordinate, because if we click-move or drag left or right with the look controller, the look point rotates in the opposite direction in the scene, as a camera might swing about its central axis. Then, we swap the y and z axes, because an up/down key press or touch drag motion (read as a y-axis behavior) on the move controller should translate into a camera action that moves the look point into or out of the screen (the z-axis).\n\nThe final position of the look point for the player is the last position plus the calculated velocity, and this is what is read by the renderer when it calls the **get\\_Position** method (most likely during the setup for each frame). After that, we reset the move command to zero.\n\n## Updating the view matrix with the new camera position\n\n\nWe can obtain a scene space coordinate that our camera is focused on, and which is updated whenever you tell your app to do so (every 60 seconds in the main app loop, for example). This pseudocode suggests the calling behavior you can implement:\n\n```cpp\nmyMoveLookController->Update( m_window );   \n\n// Update the view matrix based on the camera position.\nmyFirstPersonCamera->SetViewParameters(\n                 myMoveLookController->get_Position(),       // Point we are at\n                 myMoveLookController->get_LookPoint(),      // Point to look towards\n                 DirectX::XMFLOAT3( 0, 1, 0 )                   // Up-vector\n                 ); \n```\n\nCongratulations! You've implemented basic move-look controls for both touch screens and keyboard/mouse input touch controls in your game!\n\n> **Note**  \nThis article is for Windows 10 developers writing Universal Windows Platform (UWP) apps. If you’re developing for Windows 8.x or Windows Phone 8.x, see the [archived documentation](http://go.microsoft.com/fwlink/p/?linkid=619132).\n\n \n\n \n\n \n\n\n\n\n"}