{"nodes":[{"pos":[11,42],"content":"Marble Maze sample fundamentals","needQuote":true,"needEscape":true,"nodes":[{"content":"Marble Maze sample fundamentals","pos":[0,31]}]},{"pos":[56,266],"content":"This document describes the fundamental characteristics of the Marble Maze project, for example, how it uses Visual C++ in the Windows Runtime environment, how it is created and structured, and how it is built.","needQuote":true,"needEscape":true,"nodes":[{"content":"This document describes the fundamental characteristics of the Marble Maze project, for example, how it uses Visual C++ in the Windows Runtime environment, how it is created and structured, and how it is built.","pos":[0,210]}]},{"content":"Marble Maze sample fundamentals","pos":[323,354]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[357,395]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[396,491],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"This document describes the fundamental characteristics of the Marble Maze project, for example, how it uses Visual C++ in the Windows Runtime environment, how it is created and structured, and how it is built.","pos":[494,704]},{"content":"The document also describes several of the conventions that are used in the code.","pos":[705,786]},{"pos":[790,948],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   The sample code that corresponds to this document is found in the <bpt id=\"p2\">[</bpt>DirectX Marble Maze game sample<ept id=\"p2\">](http://go.microsoft.com/fwlink/?LinkId=624011)</ept>.","source":"**Note**   The sample code that corresponds to this document is found in the [DirectX Marble Maze game sample](http://go.microsoft.com/fwlink/?LinkId=624011)."},{"content":"Here are some of the key points that this document discusses for when you plan and develop your Universal Windows Platform (UWP) game.","pos":[956,1090]},{"content":"Use the <bpt id=\"p1\">**</bpt>DirectX 11 App (Universal Windows)<ept id=\"p1\">**</ept> template in a C++ application to create your DirectX UWP game.","pos":[1096,1205],"source":"Use the **DirectX 11 App (Universal Windows)** template in a C++ application to create your DirectX UWP game."},{"content":"Use Visual Studio to build a UWP app project as you would build a standard project.","pos":[1206,1289]},{"content":"The Windows Runtime provides classes and interfaces so that you can develop UWP apps in a more modern, object-oriented manner.","pos":[1294,1420]},{"pos":[1425,1897],"content":"Use object references with the hat (^) symbol to manage the lifetime of Windows Runtime variables, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Microsoft::WRL::ComPtr<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br244983.aspx)</ept> to manage the lifetime of COM objects, and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>std::shared\\_ptr<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/bb982026.aspx)</ept> or <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>std::unique\\_ptr<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/ee410601.aspx)</ept> to manage the lifetime of all other heap-allocated C++ objects.","source":"Use object references with the hat (^) symbol to manage the lifetime of Windows Runtime variables, [**Microsoft::WRL::ComPtr**](https://msdn.microsoft.com/library/windows/apps/br244983.aspx) to manage the lifetime of COM objects, and [**std::shared\\_ptr**](https://msdn.microsoft.com/library/windows/apps/bb982026.aspx) or [**std::unique\\_ptr**](https://msdn.microsoft.com/library/windows/apps/ee410601.aspx) to manage the lifetime of all other heap-allocated C++ objects."},{"content":"In most cases, use exception handling, instead of result codes, to deal with unexpected errors.","pos":[1902,1997]},{"content":"Use SAL annotations together with code analysis tools to help discover errors in your app.","pos":[2002,2092]},{"content":"Creating the Visual Studio project","pos":[2097,2131]},{"content":"If you've downloaded and extracted the sample, you can open the MarbleMaze.sln solution file in Visual Studio, and you'll have the code in front of you.","pos":[2134,2286]},{"content":"You can also view the source on the <bpt id=\"p1\">[</bpt>DirectX Marble Maze game sample<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=624011)</ept> MSDN Samples Gallery page by selecting the <bpt id=\"p2\">**</bpt>Browse Code<ept id=\"p2\">**</ept> tab.","pos":[2287,2467],"source":" You can also view the source on the [DirectX Marble Maze game sample](http://go.microsoft.com/fwlink/?LinkId=624011) MSDN Samples Gallery page by selecting the **Browse Code** tab."},{"content":"When we created the Visual Studio project for Marble Maze, we started with an existing project.","pos":[2469,2564]},{"content":"However, if you do not already have an existing project that provides the basic functionality that your DirectX UWP game requires, we recommend that you create a project based on the Visual Studio <bpt id=\"p1\">**</bpt>DirectX 11 App (Universal Windows)<ept id=\"p1\">**</ept> template because it provides a basic working 3-D application.","pos":[2565,2862],"source":" However, if you do not already have an existing project that provides the basic functionality that your DirectX UWP game requires, we recommend that you create a project based on the Visual Studio **DirectX 11 App (Universal Windows)** template because it provides a basic working 3-D application."},{"content":"One important project setting in the <bpt id=\"p1\">**</bpt>DirectX 11 App (Universal Windows)<ept id=\"p1\">**</ept> template is the <bpt id=\"p2\">**</bpt>/ZW<ept id=\"p2\">**</ept> option, which enables the program to use the Windows Runtime language extensions.","pos":[2864,3045],"source":"One important project setting in the **DirectX 11 App (Universal Windows)** template is the **/ZW** option, which enables the program to use the Windows Runtime language extensions."},{"content":"This option is enabled by default when you use the Visual Studio template.","pos":[3046,3120]},{"pos":[3124,3345],"content":"<bpt id=\"p1\">**</bpt>Caution<ept id=\"p1\">**</ept>   The <bpt id=\"p2\">**</bpt>/ZW<ept id=\"p2\">**</ept> option is not compatible with options such as <bpt id=\"p3\">**</bpt>/clr<ept id=\"p3\">**</ept>.In the case of <bpt id=\"p4\">**</bpt>/clr<ept id=\"p4\">**</ept>, this means that you cannot target both the .NET Framework and the Windows Runtime from the same Visual C++ project.","source":"**Caution**   The **/ZW** option is not compatible with options such as **/clr**.In the case of **/clr**, this means that you cannot target both the .NET Framework and the Windows Runtime from the same Visual C++ project."},{"content":"Every UWP app that you acquire from the Windows Store comes in the form of an app package.","pos":[3350,3440]},{"content":"An app package contains a package manifest, which contains information about your app.","pos":[3441,3527]},{"content":"For example, you can specify the capabilities (that is, the required access to protected system resources or user data) of your app.","pos":[3528,3660]},{"content":"If you determine that your app requires certain capabilities, use the package manifest to declare the required capabilities.","pos":[3661,3785]},{"content":"The manifest also lets you specify project properties such as supported device rotations, tile images, and the splash screen.","pos":[3786,3911]},{"content":"For more info about app packages, see <bpt id=\"p1\">[</bpt>Packaging apps<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt270969)</ept>.","pos":[3912,4025],"source":" For more info about app packages, see [Packaging apps](https://msdn.microsoft.com/library/windows/apps/mt270969)."},{"content":"Building, deploying, and running the game","pos":[4031,4072]},{"content":"Build a UWP app project as you would build a standard project.","pos":[4075,4137]},{"content":"(On the menu bar, choose <bpt id=\"p1\">**</bpt>Build, Build Solution<ept id=\"p1\">**</ept>.) The build step compiles the code and also packages it for use as a UWP app.","pos":[4138,4266],"source":" (On the menu bar, choose **Build, Build Solution**.) The build step compiles the code and also packages it for use as a UWP app."},{"pos":[4268,4449],"content":"After you build the project, you must deploy it.(On the menu bar, choose <bpt id=\"p1\">**</bpt>Build, Deploy Solution<ept id=\"p1\">**</ept>.) Visual Studio also deploys the project when you run the game from the debugger.","source":"After you build the project, you must deploy it.(On the menu bar, choose **Build, Deploy Solution**.) Visual Studio also deploys the project when you run the game from the debugger."},{"content":"After you deploy the project, pick the Marble Maze tile to run the game.","pos":[4451,4523]},{"content":"Alternatively, from Visual Studio, on the menu bar, choose <bpt id=\"p1\">**</bpt>Debug, Start Debugging<ept id=\"p1\">**</ept>.","pos":[4524,4610],"source":" Alternatively, from Visual Studio, on the menu bar, choose **Debug, Start Debugging**."},{"content":"Controlling the game","pos":[4617,4637]},{"content":"You can use touch, the accelerometer, the Xbox 360 controller, or the mouse to control Marble Maze.","pos":[4639,4738]},{"content":"Use the directional pad on the controller to change the active menu item.","pos":[4744,4817]},{"content":"Use touch, the A button, the Start button, or the mouse to pick a menu item.","pos":[4822,4898]},{"content":"Use touch, the accelerometer, the left thumbstick, or the mouse to tilt the maze.","pos":[4903,4984]},{"content":"Use touch, the A button, the Start button, or the mouse to close menus such as the high score table.","pos":[4989,5089]},{"content":"Use the Start button or the P key to pause or resume the game.","pos":[5094,5156]},{"content":"Use the Back button on the controller or the Home key on the keyboard to restart the game.","pos":[5161,5251]},{"content":"When the high-score table is visible, use the Back button or Home key to clear all scores.","pos":[5256,5346]},{"content":"Code conventions","pos":[5352,5368]},{"content":"The Windows Runtime is a programming interface that you can use to create UWP apps that run only in a special application environment.","pos":[5371,5505]},{"content":"Such apps use authorized functions, data types, and devices, and are distributed from the Windows Store.","pos":[5506,5610]},{"content":"At the lowest level, the Windows Runtime consists of an Application Binary Interface (ABI).","pos":[5611,5702]},{"content":"The ABI is a low-level binary contract that makes Windows Runtime APIs accessible to multiple programming languages such as JavaScript, the .NET languages, and Visual C++.","pos":[5703,5874]},{"content":"In order to call Windows Runtime APIs from JavaScript and .NET, those languages require projections that are specific to each language environment.","pos":[5876,6023]},{"content":"When you call a Windows Runtime API from JavaScript or .NET, you are invoking the projection, which in turn calls the underlying ABI function.","pos":[6024,6166]},{"content":"Although you can call the ABI functions directly in C++, Microsoft provides projections for C++ as well, because they make it much simpler to consume the Windows Runtime APIs, while still maintaining high performance.","pos":[6167,6384]},{"content":"Microsoft also provides language extensions to Visual C++ that specifically support the Windows Runtime projections.","pos":[6385,6501]},{"content":"Many of these language extensions resemble the syntax for the C++/CLI language.","pos":[6502,6581]},{"content":"However, instead of targeting the common language runtime (CLR), native apps use this syntax to target the Windows Runtime.","pos":[6582,6705]},{"content":"The object reference, or hat (^), modifier is an important part of this new syntax because it enables the automatic deletion of runtime objects by means of reference counting.","pos":[6706,6881]},{"content":"Instead of calling methods such as <bpt id=\"p1\">**</bpt>AddRef<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Release<ept id=\"p2\">**</ept> to manage the lifetime of a Windows Runtime object, the runtime deletes the object when no other component references it, for example, when it leaves scope or you set all references to <bpt id=\"p3\">**</bpt>nullptr<ept id=\"p3\">**</ept>.","pos":[6882,7141],"source":" Instead of calling methods such as **AddRef** and **Release** to manage the lifetime of a Windows Runtime object, the runtime deletes the object when no other component references it, for example, when it leaves scope or you set all references to **nullptr**."},{"content":"Another important part of using Visual C++ to create UWP apps is the <bpt id=\"p1\">**</bpt>ref new<ept id=\"p1\">**</ept> keyword.","pos":[7142,7231],"source":" Another important part of using Visual C++ to create UWP apps is the **ref new** keyword."},{"content":"Use <bpt id=\"p1\">**</bpt>ref new<ept id=\"p1\">**</ept> instead of <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> to create reference-counted Windows Runtime objects.","pos":[7232,7319],"source":" Use **ref new** instead of **new** to create reference-counted Windows Runtime objects."},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Type System (C++/CX)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh755822)</ept>.","pos":[7320,7420],"source":" For more info, see [Type System (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh755822)."},{"content":"Important","pos":[7426,7435]},{"content":"You only have to use <bpt id=\"p1\">**</bpt><ph id=\"ph1\">^</ph><ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>ref new<ept id=\"p2\">**</ept> when you create Windows Runtime objects or create Windows Runtime components.","pos":[7440,7560],"source":"You only have to use **^** and **ref new** when you create Windows Runtime objects or create Windows Runtime components."},{"content":"You can use the standard C++ syntax when you write core application code that does not use the Windows Runtime.","pos":[7561,7672]},{"content":"Marble Maze uses <bpt id=\"p1\">**</bpt><ph id=\"ph1\">^</ph><ept id=\"p1\">**</ept> together with <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Microsoft::WRL::ComPtr<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br244983.aspx)</ept> to manage heap-allocated objects and minimize memory leaks.","pos":[7674,7862],"source":"Marble Maze uses **^** together with [**Microsoft::WRL::ComPtr**](https://msdn.microsoft.com/library/windows/apps/br244983.aspx) to manage heap-allocated objects and minimize memory leaks."},{"content":"We recommend that you use ^ to manage the lifetime of Windows Runtime variables, <bpt id=\"p1\">**</bpt>ComPtr<ept id=\"p1\">**</ept> to manage the lifetime of COM variables (such as when you use DirectX), and std::<bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>std::shared\\_ptr<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/bb982026)</ept> or <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>std::unique\\_ptr<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/ee410601)</ept> to manage the lifetime of all other heap-allocated C++ objects.","pos":[7863,8264],"source":" We recommend that you use ^ to manage the lifetime of Windows Runtime variables, **ComPtr** to manage the lifetime of COM variables (such as when you use DirectX), and std::[**std::shared\\_ptr**](https://msdn.microsoft.com/library/windows/apps/bb982026) or [**std::unique\\_ptr**](https://msdn.microsoft.com/library/windows/apps/ee410601) to manage the lifetime of all other heap-allocated C++ objects."},{"pos":[8269,8453],"content":"For more info about the language extensions that are available to a C++ UWP app, see <bpt id=\"p1\">[</bpt>Visual C++ Language Reference (C++/CX)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh699871)</ept>.","source":"For more info about the language extensions that are available to a C++ UWP app, see [Visual C++ Language Reference (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh699871)."},{"content":"Error handling","pos":[8460,8474]},{"content":"Marble Maze uses exception handling as the primary way to deal with unexpected errors.","pos":[8476,8562]},{"content":"Although game code traditionally uses logging or error codes, such as <bpt id=\"p1\">**</bpt>HRESULT<ept id=\"p1\">**</ept> values, to indicate errors, exception handling has two main advantages.","pos":[8563,8716],"source":" Although game code traditionally uses logging or error codes, such as **HRESULT** values, to indicate errors, exception handling has two main advantages."},{"content":"First, it can make the code easier to read and maintain.","pos":[8717,8773]},{"content":"From a code perspective, exception handling is a more efficient way to propagate an error to a routine that can handle that error.","pos":[8774,8904]},{"content":"The use of error codes typically requires each function to explicitly propagate errors.","pos":[8905,8992]},{"content":"A second advantage is that you can configure the Visual Studio debugger to break when an exception occurs so that you can stop immediately at the location and context of the error.","pos":[8993,9173]},{"content":"The Windows Runtime also uses exception handling extensively.","pos":[9174,9235]},{"content":"Therefore, by using exception handling in your code, you can combine all error handling into one model.","pos":[9236,9339]},{"content":"We recommend that you use the following conventions in your error handling model:","pos":[9341,9422]},{"content":"Use exceptions to communicate unexpected errors.","pos":[9428,9476]},{"content":"Do not use exceptions to control the flow of code.","pos":[9481,9531]},{"content":"Catch only the exceptions that you can safely handle and recover from.","pos":[9536,9606]},{"content":"Otherwise, do not catch the exception and allow the app to terminate.","pos":[9607,9676]},{"content":"When you call a DirectX routine that returns <bpt id=\"p1\">**</bpt>HRESULT<ept id=\"p1\">**</ept>, use the <bpt id=\"p2\">**</bpt>DX::ThrowIfFailed<ept id=\"p2\">**</ept> function.","pos":[9681,9778],"source":"When you call a DirectX routine that returns **HRESULT**, use the **DX::ThrowIfFailed** function."},{"content":"This function is defined in DirectXSample.h.<bpt id=\"p1\">**</bpt>ThrowIfFailed<ept id=\"p1\">**</ept> throws an exception if the provided <bpt id=\"p2\">**</bpt>HRESULT<ept id=\"p2\">**</ept> is an error code.","pos":[9779,9906],"source":" This function is defined in DirectXSample.h.**ThrowIfFailed** throws an exception if the provided **HRESULT** is an error code."},{"content":"For example, <bpt id=\"p1\">**</bpt>E\\_POINTER<ept id=\"p1\">**</ept> causes <bpt id=\"p2\">**</bpt>ThrowIfFailed<ept id=\"p2\">**</ept> to throw <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Platform::NullReferenceException<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh755823.aspx)</ept>.","pos":[9907,10071],"source":" For example, **E\\_POINTER** causes **ThrowIfFailed** to throw [**Platform::NullReferenceException**](https://msdn.microsoft.com/library/windows/apps/hh755823.aspx)."},{"pos":[10077,10217],"content":"When you use <bpt id=\"p1\">**</bpt>ThrowIfFailed<ept id=\"p1\">**</ept>, put the DirectX call on a separate line to help improve code readability, as shown in the following example.","source":"When you use **ThrowIfFailed**, put the DirectX call on a separate line to help improve code readability, as shown in the following example."},{"content":"Although we recommend that you avoid the use of <bpt id=\"p1\">**</bpt>HRESULT<ept id=\"p1\">**</ept> for unexpected errors , it is more important to avoid the use of exception handling to control the flow of code.","pos":[10438,10610],"source":"Although we recommend that you avoid the use of **HRESULT** for unexpected errors , it is more important to avoid the use of exception handling to control the flow of code."},{"content":"Therefore, it is preferred to use an <bpt id=\"p1\">**</bpt>HRESULT<ept id=\"p1\">**</ept> return value when necessary to control the flow of code.","pos":[10611,10716],"source":" Therefore, it is preferred to use an **HRESULT** return value when necessary to control the flow of code."},{"content":"SAL annotations","pos":[10723,10738]},{"content":"Use SAL annotations together with code analysis tools to help discover errors in your app.","pos":[10740,10830]},{"content":"By using Microsoft source-code annotation language (SAL), you can annotate, or describe, how a function uses its parameters.","pos":[10832,10956]},{"content":"SAL annotations also describe return values.","pos":[10957,11001]},{"content":"SAL annotations work with the C/C++ Code Analysis tool to discover possible defects in C and C++ source code.","pos":[11002,11111]},{"content":"Common coding errors reported by the tool include buffer overruns, uninitialized memory, null pointer dereferences, and memory and resource leaks.","pos":[11112,11258]},{"content":"Consider the <bpt id=\"p1\">**</bpt>BasicLoader::LoadMesh<ept id=\"p1\">**</ept> method, which is declared in BasicLoader.h.","pos":[11260,11342],"source":"Consider the **BasicLoader::LoadMesh** method, which is declared in BasicLoader.h."},{"content":"This method uses \\_In\\_ to specify that <bpt id=\"p1\">*</bpt>filename<ept id=\"p1\">*</ept> is an input parameter (and therefore will only be read from), \\_Out\\_ to specify that <bpt id=\"p2\">*</bpt>vertexBuffer<ept id=\"p2\">*</ept> and <bpt id=\"p3\">*</bpt>indexBuffer<ept id=\"p3\">*</ept> are output parameters (and therefore will only be written to), and \\_Out\\_opt\\_ to specify that <bpt id=\"p4\">*</bpt>vertexCount<ept id=\"p4\">*</ept> and <bpt id=\"p5\">*</bpt>indexCount<ept id=\"p5\">*</ept> are optional output parameters (and might be written to).","pos":[11343,11697],"source":" This method uses \\_In\\_ to specify that *filename* is an input parameter (and therefore will only be read from), \\_Out\\_ to specify that *vertexBuffer* and *indexBuffer* are output parameters (and therefore will only be written to), and \\_Out\\_opt\\_ to specify that *vertexCount* and *indexCount* are optional output parameters (and might be written to)."},{"content":"Because <bpt id=\"p1\">*</bpt>vertexCount<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>indexCount<ept id=\"p2\">*</ept> are optional output parameters, they are allowed to be <bpt id=\"p3\">**</bpt>nullptr<ept id=\"p3\">**</ept>.","pos":[11698,11804],"source":" Because *vertexCount* and *indexCount* are optional output parameters, they are allowed to be **nullptr**."},{"content":"The C/C++ Code Analysis tool examines calls to this method to ensure that the parameters it passes meet these criteria.","pos":[11805,11924]},{"content":"To perform code analysis on your app, on the menu bar, choose <bpt id=\"p1\">**</bpt>Build, Run Code Analysis on Solution<ept id=\"p1\">**</ept>.","pos":[12142,12245],"source":"To perform code analysis on your app, on the menu bar, choose **Build, Run Code Analysis on Solution**."},{"content":"For more info about code analysis, see <bpt id=\"p1\">[</bpt>Analyzing C/C++ Code Quality by Using Code Analysis<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/ms182025.aspx)</ept>.","pos":[12246,12402],"source":" For more info about code analysis, see [Analyzing C/C++ Code Quality by Using Code Analysis](https://msdn.microsoft.com/library/windows/apps/ms182025.aspx)."},{"content":"The complete list of available annotations is defined in sal.h.","pos":[12404,12467]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>SAL Annotations<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/ms235402.aspx)</ept>.","pos":[12468,12568],"source":" For more info, see [SAL Annotations](https://msdn.microsoft.com/library/windows/apps/ms235402.aspx)."},{"content":"Next steps","pos":[12573,12583]},{"pos":[12586,12836],"content":"Read <bpt id=\"p1\">[</bpt>Marble Maze application structure<ept id=\"p1\">](marble-maze-application-structure.md)</ept> for information about how the Marble Maze application code is structured and how the structure of a DirectX UWP app differs from that of a traditional desktop application.","source":"Read [Marble Maze application structure](marble-maze-application-structure.md) for information about how the Marble Maze application code is structured and how the structure of a DirectX UWP app differs from that of a traditional desktop application."},{"content":"Related topics","pos":[12841,12855]},{"content":"Marble Maze application structure","pos":[12861,12894]},{"content":"Developing Marble Maze, a UWP game in C++ and DirectX","pos":[12937,12990]}],"content":"---\ntitle: Marble Maze sample fundamentals\ndescription: This document describes the fundamental characteristics of the Marble Maze project, for example, how it uses Visual C++ in the Windows Runtime environment, how it is created and structured, and how it is built.\nms.assetid: 73329b29-62e3-1b36-01db-b7744ee5b4c3\n---\n\n# Marble Maze sample fundamentals\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\nThis document describes the fundamental characteristics of the Marble Maze project, for example, how it uses Visual C++ in the Windows Runtime environment, how it is created and structured, and how it is built. The document also describes several of the conventions that are used in the code.\n\n> **Note**   The sample code that corresponds to this document is found in the [DirectX Marble Maze game sample](http://go.microsoft.com/fwlink/?LinkId=624011).\n\n \n## \nHere are some of the key points that this document discusses for when you plan and develop your Universal Windows Platform (UWP) game.\n\n-   Use the **DirectX 11 App (Universal Windows)** template in a C++ application to create your DirectX UWP game. Use Visual Studio to build a UWP app project as you would build a standard project.\n-   The Windows Runtime provides classes and interfaces so that you can develop UWP apps in a more modern, object-oriented manner.\n-   Use object references with the hat (^) symbol to manage the lifetime of Windows Runtime variables, [**Microsoft::WRL::ComPtr**](https://msdn.microsoft.com/library/windows/apps/br244983.aspx) to manage the lifetime of COM objects, and [**std::shared\\_ptr**](https://msdn.microsoft.com/library/windows/apps/bb982026.aspx) or [**std::unique\\_ptr**](https://msdn.microsoft.com/library/windows/apps/ee410601.aspx) to manage the lifetime of all other heap-allocated C++ objects.\n-   In most cases, use exception handling, instead of result codes, to deal with unexpected errors.\n-   Use SAL annotations together with code analysis tools to help discover errors in your app.\n\n## Creating the Visual Studio project\n\n\nIf you've downloaded and extracted the sample, you can open the MarbleMaze.sln solution file in Visual Studio, and you'll have the code in front of you. You can also view the source on the [DirectX Marble Maze game sample](http://go.microsoft.com/fwlink/?LinkId=624011) MSDN Samples Gallery page by selecting the **Browse Code** tab.\n\nWhen we created the Visual Studio project for Marble Maze, we started with an existing project. However, if you do not already have an existing project that provides the basic functionality that your DirectX UWP game requires, we recommend that you create a project based on the Visual Studio **DirectX 11 App (Universal Windows)** template because it provides a basic working 3-D application.\n\nOne important project setting in the **DirectX 11 App (Universal Windows)** template is the **/ZW** option, which enables the program to use the Windows Runtime language extensions. This option is enabled by default when you use the Visual Studio template.\n\n> **Caution**   The **/ZW** option is not compatible with options such as **/clr**.In the case of **/clr**, this means that you cannot target both the .NET Framework and the Windows Runtime from the same Visual C++ project.\n\n \n\nEvery UWP app that you acquire from the Windows Store comes in the form of an app package. An app package contains a package manifest, which contains information about your app. For example, you can specify the capabilities (that is, the required access to protected system resources or user data) of your app. If you determine that your app requires certain capabilities, use the package manifest to declare the required capabilities. The manifest also lets you specify project properties such as supported device rotations, tile images, and the splash screen. For more info about app packages, see [Packaging apps](https://msdn.microsoft.com/library/windows/apps/mt270969).\n\n##  Building, deploying, and running the game\n\n\nBuild a UWP app project as you would build a standard project. (On the menu bar, choose **Build, Build Solution**.) The build step compiles the code and also packages it for use as a UWP app.\n\nAfter you build the project, you must deploy it.(On the menu bar, choose **Build, Deploy Solution**.) Visual Studio also deploys the project when you run the game from the debugger.\n\nAfter you deploy the project, pick the Marble Maze tile to run the game. Alternatively, from Visual Studio, on the menu bar, choose **Debug, Start Debugging**.\n\n###  Controlling the game\n\nYou can use touch, the accelerometer, the Xbox 360 controller, or the mouse to control Marble Maze.\n\n-   Use the directional pad on the controller to change the active menu item.\n-   Use touch, the A button, the Start button, or the mouse to pick a menu item.\n-   Use touch, the accelerometer, the left thumbstick, or the mouse to tilt the maze.\n-   Use touch, the A button, the Start button, or the mouse to close menus such as the high score table.\n-   Use the Start button or the P key to pause or resume the game.\n-   Use the Back button on the controller or the Home key on the keyboard to restart the game.\n-   When the high-score table is visible, use the Back button or Home key to clear all scores.\n\n##  Code conventions\n\n\nThe Windows Runtime is a programming interface that you can use to create UWP apps that run only in a special application environment. Such apps use authorized functions, data types, and devices, and are distributed from the Windows Store. At the lowest level, the Windows Runtime consists of an Application Binary Interface (ABI). The ABI is a low-level binary contract that makes Windows Runtime APIs accessible to multiple programming languages such as JavaScript, the .NET languages, and Visual C++.\n\nIn order to call Windows Runtime APIs from JavaScript and .NET, those languages require projections that are specific to each language environment. When you call a Windows Runtime API from JavaScript or .NET, you are invoking the projection, which in turn calls the underlying ABI function. Although you can call the ABI functions directly in C++, Microsoft provides projections for C++ as well, because they make it much simpler to consume the Windows Runtime APIs, while still maintaining high performance. Microsoft also provides language extensions to Visual C++ that specifically support the Windows Runtime projections. Many of these language extensions resemble the syntax for the C++/CLI language. However, instead of targeting the common language runtime (CLR), native apps use this syntax to target the Windows Runtime. The object reference, or hat (^), modifier is an important part of this new syntax because it enables the automatic deletion of runtime objects by means of reference counting. Instead of calling methods such as **AddRef** and **Release** to manage the lifetime of a Windows Runtime object, the runtime deletes the object when no other component references it, for example, when it leaves scope or you set all references to **nullptr**. Another important part of using Visual C++ to create UWP apps is the **ref new** keyword. Use **ref new** instead of **new** to create reference-counted Windows Runtime objects. For more info, see [Type System (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh755822).\n\n> **Important**  \nYou only have to use **^** and **ref new** when you create Windows Runtime objects or create Windows Runtime components. You can use the standard C++ syntax when you write core application code that does not use the Windows Runtime.\n\nMarble Maze uses **^** together with [**Microsoft::WRL::ComPtr**](https://msdn.microsoft.com/library/windows/apps/br244983.aspx) to manage heap-allocated objects and minimize memory leaks. We recommend that you use ^ to manage the lifetime of Windows Runtime variables, **ComPtr** to manage the lifetime of COM variables (such as when you use DirectX), and std::[**std::shared\\_ptr**](https://msdn.microsoft.com/library/windows/apps/bb982026) or [**std::unique\\_ptr**](https://msdn.microsoft.com/library/windows/apps/ee410601) to manage the lifetime of all other heap-allocated C++ objects.\n\n \n\nFor more info about the language extensions that are available to a C++ UWP app, see [Visual C++ Language Reference (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh699871).\n\n###  Error handling\n\nMarble Maze uses exception handling as the primary way to deal with unexpected errors. Although game code traditionally uses logging or error codes, such as **HRESULT** values, to indicate errors, exception handling has two main advantages. First, it can make the code easier to read and maintain. From a code perspective, exception handling is a more efficient way to propagate an error to a routine that can handle that error. The use of error codes typically requires each function to explicitly propagate errors. A second advantage is that you can configure the Visual Studio debugger to break when an exception occurs so that you can stop immediately at the location and context of the error. The Windows Runtime also uses exception handling extensively. Therefore, by using exception handling in your code, you can combine all error handling into one model.\n\nWe recommend that you use the following conventions in your error handling model:\n\n-   Use exceptions to communicate unexpected errors.\n-   Do not use exceptions to control the flow of code.\n-   Catch only the exceptions that you can safely handle and recover from. Otherwise, do not catch the exception and allow the app to terminate.\n-   When you call a DirectX routine that returns **HRESULT**, use the **DX::ThrowIfFailed** function. This function is defined in DirectXSample.h.**ThrowIfFailed** throws an exception if the provided **HRESULT** is an error code. For example, **E\\_POINTER** causes **ThrowIfFailed** to throw [**Platform::NullReferenceException**](https://msdn.microsoft.com/library/windows/apps/hh755823.aspx).\n\n    When you use **ThrowIfFailed**, put the DirectX call on a separate line to help improve code readability, as shown in the following example.\n\n    ```cpp\n    // Identify the physical adapter (GPU or card) this device is running on.\n    ComPtr<IDXGIAdapter> dxgiAdapter;\n    DX::ThrowIfFailed(\n        dxgiDevice->GetAdapter(&dxgiAdapter)\n        );\n    ```\n\n-   Although we recommend that you avoid the use of **HRESULT** for unexpected errors , it is more important to avoid the use of exception handling to control the flow of code. Therefore, it is preferred to use an **HRESULT** return value when necessary to control the flow of code.\n\n###  SAL annotations\n\nUse SAL annotations together with code analysis tools to help discover errors in your app.\n\nBy using Microsoft source-code annotation language (SAL), you can annotate, or describe, how a function uses its parameters. SAL annotations also describe return values. SAL annotations work with the C/C++ Code Analysis tool to discover possible defects in C and C++ source code. Common coding errors reported by the tool include buffer overruns, uninitialized memory, null pointer dereferences, and memory and resource leaks.\n\nConsider the **BasicLoader::LoadMesh** method, which is declared in BasicLoader.h. This method uses \\_In\\_ to specify that *filename* is an input parameter (and therefore will only be read from), \\_Out\\_ to specify that *vertexBuffer* and *indexBuffer* are output parameters (and therefore will only be written to), and \\_Out\\_opt\\_ to specify that *vertexCount* and *indexCount* are optional output parameters (and might be written to). Because *vertexCount* and *indexCount* are optional output parameters, they are allowed to be **nullptr**. The C/C++ Code Analysis tool examines calls to this method to ensure that the parameters it passes meet these criteria.\n\n```cpp\nvoid LoadMesh(\n    _In_ Platform::String^ filename,\n    _Out_ ID3D11Buffer** vertexBuffer,\n    _Out_ ID3D11Buffer** indexBuffer,\n    _Out_opt_ uint32* vertexCount,\n    _Out_opt_ uint32* indexCount\n    );\n```\n\nTo perform code analysis on your app, on the menu bar, choose **Build, Run Code Analysis on Solution**. For more info about code analysis, see [Analyzing C/C++ Code Quality by Using Code Analysis](https://msdn.microsoft.com/library/windows/apps/ms182025.aspx).\n\nThe complete list of available annotations is defined in sal.h. For more info, see [SAL Annotations](https://msdn.microsoft.com/library/windows/apps/ms235402.aspx).\n\n## Next steps\n\n\nRead [Marble Maze application structure](marble-maze-application-structure.md) for information about how the Marble Maze application code is structured and how the structure of a DirectX UWP app differs from that of a traditional desktop application.\n\n## Related topics\n\n\n* [Marble Maze application structure](marble-maze-application-structure.md)\n* [Developing Marble Maze, a UWP game in C++ and DirectX](developing-marble-maze-a-windows-store-game-in-cpp-and-directx.md)\n\n \n\n \n\n\n\n\n"}