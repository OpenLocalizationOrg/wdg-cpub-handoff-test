{"nodes":[{"content":"Apps use background tasks and two main mechanisms to maintain communications when they are not in the foreground: The socket broker, and control channel triggers.","pos":[18,180]},{"pos":[189,229],"content":"Network communications in the background","needQuote":true,"needEscape":true,"nodes":[{"content":"Network communications in the background","pos":[0,40]}]},{"content":"Network communications in the background","pos":[286,326]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[328,366]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[367,462],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"Important APIs","pos":[466,480]},{"content":"SocketActivityTrigger","pos":[491,512]},{"content":"ControlChannelTrigger","pos":[581,602]},{"content":"Apps use background tasks and two main mechanisms to maintain communications when they are not in the foreground: The socket broker, and control channel triggers.","pos":[665,827]},{"content":"Apps that use sockets can delegate ownership of a socket to a system socket broker when they leave the foreground.","pos":[828,942]},{"content":"The broker then activates the app when traffic arrives on the socket, transfers ownership back to the app, and the app processes the arriving traffic.","pos":[943,1093]},{"content":"Socket broker and the SocketActivityTrigger","pos":[1098,1141]},{"pos":[1143,1629],"content":"If your app uses <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DatagramSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br241319)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept>, or <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>StreamSocketListener<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br226906)</ept> connections, then you should use <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>SocketActivityTrigger<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/dn806009)</ept> and the socket broker to be notified when traffic arrives for your app while it's not in the foreground.","source":"If your app uses [**DatagramSocket**](https://msdn.microsoft.com/library/windows/apps/br241319), [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882), or [**StreamSocketListener**](https://msdn.microsoft.com/library/windows/apps/br226906) connections, then you should use [**SocketActivityTrigger**](https://msdn.microsoft.com/library/windows/apps/dn806009) and the socket broker to be notified when traffic arrives for your app while it's not in the foreground."},{"content":"In order for your app to receive and process data received on a socket when your app is not active, your app must perform some one-time setup at startup, and then transfer socket ownership to the socket broker when it is transitioning to a state where it is not active.","pos":[1631,1900]},{"content":"The one-time setup steps are:","pos":[1906,1935]},{"content":"Create a SocketActivityTrigger and register a background task for the trigger with the TaskEntryPoint parameter set to your code for processing a received packet.","pos":[1945,2107]},{"content":"Call EnableTransferOwnership on the socket, before you bind the socket.","pos":[2491,2562]},{"content":"The action to take at suspend is:","pos":[3201,3234]},{"content":"When your app is about to suspend, call <bpt id=\"p1\">**</bpt>TransferOwnership<ept id=\"p1\">**</ept> on the socket to transfer it to a socket broker.","pos":[3240,3350],"source":"When your app is about to suspend, call **TransferOwnership** on the socket to transfer it to a socket broker."},{"content":"The broker monitors the socket and activates your background task when data is received.","pos":[3351,3439]},{"content":"The following example includes a utility <bpt id=\"p1\">**</bpt>TransferOwnership<ept id=\"p1\">**</ept> function to perform the transfer for <bpt id=\"p2\">**</bpt>StreamSocketListener<ept id=\"p2\">**</ept> sockets.","pos":[3440,3573],"source":" The following example includes a utility **TransferOwnership** function to perform the transfer for **StreamSocketListener** sockets."},{"content":"(Note that the different types of sockets each have their own <bpt id=\"p1\">**</bpt>TransferOwnership<ept id=\"p1\">**</ept> method, so you must call the method appropriate for the socket whose ownership you are transferring.","pos":[3574,3758],"source":" (Note that the different types of sockets each have their own **TransferOwnership** method, so you must call the method appropriate for the socket whose ownership you are transferring."},{"content":"Your code would probably contain an overloaded <bpt id=\"p1\">**</bpt>TransferOwnership<ept id=\"p1\">**</ept> helper with one implementation for each socket type you use, so that the <bpt id=\"p2\">**</bpt>OnSuspending<ept id=\"p2\">**</ept> code remains easy to read.)","pos":[3759,3945],"source":" Your code would probably contain an overloaded **TransferOwnership** helper with one implementation for each socket type you use, so that the **OnSuspending** code remains easy to read.)"},{"content":"An app transfers ownership of a socket to a socket broker and passes the ID for the background task using the appropriate one of the following methods:","pos":[3951,4102]},{"pos":[4112,4297],"content":"One of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TransferOwnership<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn804256)</ept> methods on a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DatagramSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br241319)</ept>.","source":"One of the [**TransferOwnership**](https://msdn.microsoft.com/library/windows/apps/dn804256) methods on a [**DatagramSocket**](https://msdn.microsoft.com/library/windows/apps/br241319)."},{"pos":[4306,4489],"content":"One of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TransferOwnership<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn781433)</ept> methods on a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept>.","source":"One of the [**TransferOwnership**](https://msdn.microsoft.com/library/windows/apps/dn781433) methods on a [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882)."},{"pos":[4498,4689],"content":"One of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TransferOwnership<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn804407)</ept> methods on a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamSocketListener<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226906)</ept>.","source":"One of the [**TransferOwnership**](https://msdn.microsoft.com/library/windows/apps/dn804407) methods on a [**StreamSocketListener**](https://msdn.microsoft.com/library/windows/apps/br226906)."},{"content":"In your background task's event handler:","pos":[5329,5369]},{"content":"First, get a background task deferral so that you can handle the event using asynchronous methods.","pos":[5374,5472]},{"content":"Next, extract the SocketActivityTriggerDetails from the event arguments, and find the reason that the event was raised:","pos":[5553,5672]},{"content":"If the event was raised because of socket activity, create a DataReader on the socket, load the reader asynchronously, and then use the data according to your app's design.","pos":[5858,6030]},{"content":"Note that you must return ownership of the socket back to the socket broker, in order to be notified of further socket activity again.","pos":[6031,6165]},{"content":"In the following example, the text received on the socket is displayed in a toast.","pos":[6175,6257]},{"content":"If the event was raised because a keep alive timer expired, then your code should send some data over the socket in order to keep the socket alive and restart the keep alive timer.","pos":[6783,6963]},{"content":"Again, it is important to return ownership of the socket back to the socket broker in order to receive further event notifications:","pos":[6964,7095]},{"content":"If the event was raised because the socket was closed, re-establish the socket, making sure that after you create the new socket, you transfer ownership of it to the socket broker.","pos":[7575,7755]},{"content":"In this sample, the hostname and port are stored in local settings so that they can be used to establish a new socket connection:","pos":[7756,7885]},{"content":"Don't forget to Complete your deferral, once you have finished processing the event notification:","pos":[8566,8663]},{"content":"For a complete sample demonstrating the use of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SocketActivityTrigger<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn806009)</ept> and socket broker, see the <bpt id=\"p3\">[</bpt>SocketActivityStreamSocket sample<ept id=\"p3\">](http://go.microsoft.com/fwlink/p/?LinkId=620606)</ept>.","pos":[8703,8952],"source":"For a complete sample demonstrating the use of the [**SocketActivityTrigger**](https://msdn.microsoft.com/library/windows/apps/dn806009) and socket broker, see the [SocketActivityStreamSocket sample](http://go.microsoft.com/fwlink/p/?LinkId=620606)."},{"content":"The initialization of the socket is performed in Scenario1\\_Connect.xaml.cs, and the background task implementation is in SocketActivityTask.cs.","pos":[8953,9097]},{"content":"You will probably notice that the sample calls <bpt id=\"p1\">**</bpt>TransferOwnership<ept id=\"p1\">**</ept> as soon as it creates a new socket or acquires an existing socket, rather than using the <bpt id=\"p2\">**</bpt>OnSuspending<ept id=\"p2\">**</ept> even handler to do so as described in this topic.","pos":[9099,9323],"source":"You will probably notice that the sample calls **TransferOwnership** as soon as it creates a new socket or acquires an existing socket, rather than using the **OnSuspending** even handler to do so as described in this topic."},{"content":"This is because the sample focuses on demonstrating the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SocketActivityTrigger<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn806009)</ept>, and doesn't use the socket for any other activity while it is running.","pos":[9324,9537],"source":" This is because the sample focuses on demonstrating the [**SocketActivityTrigger**](https://msdn.microsoft.com/library/windows/apps/dn806009), and doesn't use the socket for any other activity while it is running."},{"content":"Your app will probably be more complex, and should use <bpt id=\"p1\">**</bpt>OnSuspending<ept id=\"p1\">**</ept> to determine when to call <bpt id=\"p2\">**</bpt>TransferOwnership<ept id=\"p2\">**</ept>.","pos":[9538,9658],"source":" Your app will probably be more complex, and should use **OnSuspending** to determine when to call **TransferOwnership**."},{"content":"Control channel triggers","pos":[9663,9687]},{"content":"First, ensure that you're using control channel triggers (CCTs) appropriately.","pos":[9689,9767]},{"content":"If you're using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DatagramSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br241319)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept>, or <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>StreamSocketListener<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br226906)</ept> connections, we recommend you use <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>SocketActivityTrigger<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/dn806009)</ept>.","pos":[9768,10150],"source":" If you're using [**DatagramSocket**](https://msdn.microsoft.com/library/windows/apps/br241319), [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882), or [**StreamSocketListener**](https://msdn.microsoft.com/library/windows/apps/br226906) connections, we recommend you use [**SocketActivityTrigger**](https://msdn.microsoft.com/library/windows/apps/dn806009)."},{"content":"You can use CCTs for <bpt id=\"p1\">**</bpt>StreamSocket<ept id=\"p1\">**</ept>, but they use more resources and might not work in Connected Standby mode.","pos":[10151,10263],"source":" You can use CCTs for **StreamSocket**, but they use more resources and might not work in Connected Standby mode."},{"pos":[10265,10605],"content":"If you are using WebSockets, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IXMLHTTPRequest2<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh831151)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>System.Net.Http.HttpClient<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/dn298639)</ept> or <bpt id=\"p5\">**</bpt>Windows.Web.Http.HttpClient<ept id=\"p5\">**</ept>, you must use <bpt id=\"p6\">[</bpt><bpt id=\"p7\">**</bpt>ControlChannelTrigger<ept id=\"p7\">**</ept><ept id=\"p6\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>.","source":"If you are using WebSockets, [**IXMLHTTPRequest2**](https://msdn.microsoft.com/library/windows/desktop/hh831151), [**System.Net.Http.HttpClient**](https://msdn.microsoft.com/library/windows/apps/dn298639) or **Windows.Web.Http.HttpClient**, you must use [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032)."},{"content":"ControlChannelTrigger with WebSockets","pos":[10610,10647]},{"content":"Some special considerations apply when using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MessageWebSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226842)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamWebSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226923)</ept> with <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ControlChannelTrigger<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>.","pos":[10649,10949],"source":"Some special considerations apply when using [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) or [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032)."},{"content":"There are some transport-specific usage patterns and best practices that should be followed when using a <bpt id=\"p1\">**</bpt>MessageWebSocket<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>StreamWebSocket<ept id=\"p2\">**</ept> with <bpt id=\"p3\">**</bpt>ControlChannelTrigger<ept id=\"p3\">**</ept>.","pos":[10950,11130],"source":" There are some transport-specific usage patterns and best practices that should be followed when using a **MessageWebSocket** or **StreamWebSocket** with **ControlChannelTrigger**."},{"content":"In addition, these considerations affect the way that requests to receive packets on the <bpt id=\"p1\">**</bpt>StreamWebSocket<ept id=\"p1\">**</ept> are handled.","pos":[11131,11252],"source":" In addition, these considerations affect the way that requests to receive packets on the **StreamWebSocket** are handled."},{"content":"Requests to receive packets on the <bpt id=\"p1\">**</bpt>MessageWebSocket<ept id=\"p1\">**</ept> are not affected.","pos":[11253,11326],"source":" Requests to receive packets on the **MessageWebSocket** are not affected."},{"pos":[11328,11661],"content":"The following usage patterns and best practices should be followed when using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MessageWebSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226842)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamWebSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226923)</ept> with <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ControlChannelTrigger<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>:","source":"The following usage patterns and best practices should be followed when using [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) or [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032):"},{"content":"An outstanding socket receive must be kept posted at all times.","pos":[11667,11730]},{"content":"This is required to allow the push notification tasks to occur.","pos":[11731,11794]},{"content":"The WebSocket protocol defines a standard model for keep-alive messages.","pos":[11799,11871]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>WebSocketKeepAlive<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701531)</ept> class can send client-initiated WebSocket protocol keep-alive messages to the server.","pos":[11872,12044],"source":" The [**WebSocketKeepAlive**](https://msdn.microsoft.com/library/windows/apps/hh701531) class can send client-initiated WebSocket protocol keep-alive messages to the server."},{"content":"The <bpt id=\"p1\">**</bpt>WebSocketKeepAlive<ept id=\"p1\">**</ept> class should be registered as the TaskEntryPoint for a KeepAliveTrigger by the app.","pos":[12045,12155],"source":" The **WebSocketKeepAlive** class should be registered as the TaskEntryPoint for a KeepAliveTrigger by the app."},{"content":"Some special considerations affect the way that requests to receive packets on the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamWebSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226923)</ept> are handled.","pos":[12157,12332],"source":"Some special considerations affect the way that requests to receive packets on the [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) are handled."},{"content":"In particular, when using a <bpt id=\"p1\">**</bpt>StreamWebSocket<ept id=\"p1\">**</ept> with the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ControlChannelTrigger<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>, your app must use a raw async pattern for handling reads instead of the <bpt id=\"p4\">**</bpt>await<ept id=\"p4\">**</ept> model in C# and VB.NET or Tasks in C++.","pos":[12333,12598],"source":" In particular, when using a **StreamWebSocket** with the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032), your app must use a raw async pattern for handling reads instead of the **await** model in C# and VB.NET or Tasks in C++."},{"content":"The raw async pattern is illustrated in a code sample later in this section.","pos":[12599,12675]},{"content":"Using the raw async pattern allows Windows to synchronize the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IBackgroundTask.Run<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br224811)</ept> method on the background task for the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ControlChannelTrigger<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept> with the return of the receive completion callback.","pos":[12677,12998],"source":"Using the raw async pattern allows Windows to synchronize the [**IBackgroundTask.Run**](https://msdn.microsoft.com/library/windows/apps/br224811) method on the background task for the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) with the return of the receive completion callback."},{"content":"The <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> method is invoked after the completion callback returns.","pos":[12999,13067],"source":" The **Run** method is invoked after the completion callback returns."},{"content":"This ensures that the app has received the data/errors before the <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> method is invoked.","pos":[13068,13160],"source":" This ensures that the app has received the data/errors before the **Run** method is invoked."},{"content":"It is important to note that the app has to post another read before it returns control from the completion callback.","pos":[13162,13279]},{"content":"It is also important to note that the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DataReader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208119)</ept> cannot be directly used with the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>MessageWebSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226842)</ept> or <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>StreamWebSocket<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br226923)</ept> transport since that breaks the synchronization described above.","pos":[13280,13654],"source":" It is also important to note that the [**DataReader**](https://msdn.microsoft.com/library/windows/apps/br208119) cannot be directly used with the [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) or [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) transport since that breaks the synchronization described above."},{"content":"It is not supported to use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DataReader.LoadAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208135)</ept> method directly on top of the transport.","pos":[13655,13811],"source":" It is not supported to use the [**DataReader.LoadAsync**](https://msdn.microsoft.com/library/windows/apps/br208135) method directly on top of the transport."},{"content":"Instead, the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IBuffer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br241656)</ept> returned by the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>IInputStream.ReadAsync<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br241719)</ept> method on the <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>StreamWebSocket.InputStream<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br226936)</ept> property can be later passed to <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>DataReader.FromBuffer<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/br208133)</ept> method for further processing.","pos":[13812,14254],"source":" Instead, the [**IBuffer**](https://msdn.microsoft.com/library/windows/apps/br241656) returned by the [**IInputStream.ReadAsync**](https://msdn.microsoft.com/library/windows/apps/br241719) method on the [**StreamWebSocket.InputStream**](https://msdn.microsoft.com/library/windows/apps/br226936) property can be later passed to [**DataReader.FromBuffer**](https://msdn.microsoft.com/library/windows/apps/br208133) method for further processing."},{"pos":[14256,14420],"content":"The following sample shows how to use a raw async pattern for handling reads on the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamWebSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226923)</ept>.","source":"The following sample shows how to use a raw async pattern for handling reads on the [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923)."},{"content":"The read completion handler is guaranteed to fire before the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IBackgroundTask.Run<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br224811)</ept> method on the background task for the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ControlChannelTrigger<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept> is invoked.","pos":[15850,16130],"source":"The read completion handler is guaranteed to fire before the [**IBackgroundTask.Run**](https://msdn.microsoft.com/library/windows/apps/br224811) method on the background task for the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) is invoked."},{"content":"Windows has internal synchronization to wait for an app to return from the read completion callback.","pos":[16131,16231]},{"content":"The app typically quickly processes the data or the error from the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MessageWebSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226842)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamWebSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226923)</ept> in the read completion callback.","pos":[16232,16495],"source":" The app typically quickly processes the data or the error from the [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) or [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) in the read completion callback."},{"content":"The message itself is processed within the context of the <bpt id=\"p1\">**</bpt>IBackgroundTask.Run<ept id=\"p1\">**</ept> method.","pos":[16496,16585],"source":" The message itself is processed within the context of the **IBackgroundTask.Run** method."},{"content":"In this sample below, this point is illustrated by using a message queue that the read completion handler inserts the message into and the background task later processes.","pos":[16586,16757]},{"pos":[16759,16952],"content":"The following sample shows the read completion handler to use with a raw async pattern for handling reads on the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamWebSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226923)</ept>.","source":"The following sample shows the read completion handler to use with a raw async pattern for handling reads on the [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923)."},{"content":"An additional detail for Websockets is the keep-alive handler.","pos":[18213,18275]},{"content":"The WebSocket protocol defines a standard model for keep-alive messages.","pos":[18276,18348]},{"content":"When using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MessageWebSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226842)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamWebSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226923)</ept>, register a<bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>WebSocketKeepAlive<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/hh701531)</ept> class instance as the <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>TaskEntryPoint<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/br224774)</ept> for a KeepAliveTrigger to allow the app to be unsuspended and send keep-alive messages to the server (remote endpoint) periodically.","pos":[18350,18852],"source":"When using [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) or [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923), register a[**WebSocketKeepAlive**](https://msdn.microsoft.com/library/windows/apps/hh701531) class instance as the [**TaskEntryPoint**](https://msdn.microsoft.com/library/windows/apps/br224774) for a KeepAliveTrigger to allow the app to be unsuspended and send keep-alive messages to the server (remote endpoint) periodically."},{"content":"This should be done as part of the background registration app code as well as in the package manifest.","pos":[18853,18956]},{"pos":[18958,19118],"content":"This task entry point of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.Sockets.WebSocketKeepAlive<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701531)</ept> needs to be specified in two places:","source":"This task entry point of [**Windows.Sockets.WebSocketKeepAlive**](https://msdn.microsoft.com/library/windows/apps/hh701531) needs to be specified in two places:"},{"content":"When creating KeepAliveTrigger trigger in the source code (see example below).","pos":[19124,19202]},{"content":"In the app package manifest for the keepalive background task declaration.","pos":[19207,19281]},{"content":"The following sample adds a network trigger notification and a keepalive trigger under the <ph id=\"ph1\">&amp;lt;</ph>Application<ph id=\"ph2\">&amp;gt;</ph> element in an app manifest.","pos":[19283,19421],"source":"The following sample adds a network trigger notification and a keepalive trigger under the &lt;Application&gt; element in an app manifest."},{"content":"An app must be extremely careful when using an <bpt id=\"p1\">**</bpt>await<ept id=\"p1\">**</ept> statement in the context of a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ControlChannelTrigger<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept> and an asynchronous operation on a <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>StreamWebSocket<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br226923)</ept>, <bpt id=\"p6\">[</bpt><bpt id=\"p7\">**</bpt>MessageWebSocket<ept id=\"p7\">**</ept><ept id=\"p6\">](https://msdn.microsoft.com/library/windows/apps/br226842)</ept>, or <bpt id=\"p8\">[</bpt><bpt id=\"p9\">**</bpt>StreamSocket<ept id=\"p9\">**</ept><ept id=\"p8\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept>.","pos":[19987,20438],"source":"An app must be extremely careful when using an **await** statement in the context of a [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) and an asynchronous operation on a [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923), [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842), or [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882)."},{"content":"A <bpt id=\"p1\">**</bpt>Task<ph id=\"ph1\">&amp;lt;</ph>bool<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p1\">**</ept> object can be used to register a <bpt id=\"p2\">**</bpt>ControlChannelTrigger<ept id=\"p2\">**</ept> for push notification and WebSocket keep-alives on the <bpt id=\"p3\">**</bpt>StreamWebSocket<ept id=\"p3\">**</ept> and connect the transport.","pos":[20439,20622],"source":" A **Task&lt;bool&gt;** object can be used to register a **ControlChannelTrigger** for push notification and WebSocket keep-alives on the **StreamWebSocket** and connect the transport."},{"content":"As part of the registration, the <bpt id=\"p1\">**</bpt>StreamWebSocket<ept id=\"p1\">**</ept> transport is set as the transport for the <bpt id=\"p2\">**</bpt>ControlChannelTrigger<ept id=\"p2\">**</ept> and a read is posted.","pos":[20623,20765],"source":" As part of the registration, the **StreamWebSocket** transport is set as the transport for the **ControlChannelTrigger** and a read is posted."},{"content":"The <bpt id=\"p1\">**</bpt>Task.Result<ept id=\"p1\">**</ept> will block the current thread until all steps in the task execute and return statements in message body.","pos":[20766,20890],"source":" The **Task.Result** will block the current thread until all steps in the task execute and return statements in message body."},{"content":"The task is not resolved until the method returns either true or false.","pos":[20891,20962]},{"content":"This guarantees that the whole method is executed.","pos":[20963,21013]},{"content":"The <bpt id=\"p1\">**</bpt>Task<ept id=\"p1\">**</ept> can contain multiple <bpt id=\"p2\">**</bpt>await<ept id=\"p2\">**</ept> statements that are protected by the <bpt id=\"p3\">**</bpt>Task<ept id=\"p3\">**</ept>.","pos":[21014,21104],"source":" The **Task** can contain multiple **await** statements that are protected by the **Task**."},{"content":"This pattern should be used with the <bpt id=\"p1\">**</bpt>ControlChannelTrigger<ept id=\"p1\">**</ept> object when a <bpt id=\"p2\">**</bpt>StreamWebSocket<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>MessageWebSocket<ept id=\"p3\">**</ept> is used as the transport.","pos":[21105,21251],"source":" This pattern should be used with the **ControlChannelTrigger** object when a **StreamWebSocket** or **MessageWebSocket** is used as the transport."},{"content":"For those operations that may take a long period of time to complete (a typical async read operation, for example), the app should use the raw async pattern discussed previously.","pos":[21252,21430]},{"pos":[21432,21684],"content":"The following sample registers <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ControlChannelTrigger<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept> for push notification and WebSocket keep-alives on the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamWebSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226923)</ept>.","source":"The following sample registers [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) for push notification and WebSocket keep-alives on the [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923)."},{"pos":[27394,27784],"content":"For more information on using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MessageWebSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226842)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamWebSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226923)</ept> with <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ControlChannelTrigger<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>, see the <bpt id=\"p7\">[</bpt>ControlChannelTrigger StreamWebSocket sample<ept id=\"p7\">](http://go.microsoft.com/fwlink/p/?linkid=251232)</ept>.","source":"For more information on using [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) or [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032), see the [ControlChannelTrigger StreamWebSocket sample](http://go.microsoft.com/fwlink/p/?linkid=251232)."},{"content":"ControlChannelTrigger with HttpClient","pos":[27789,27826]},{"content":"Some special considerations apply when using <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> with <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ControlChannelTrigger<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>.","pos":[27828,28026],"source":"Some special considerations apply when using [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032)."},{"content":"There are some transport-specific usage patterns and best practices that should be followed when using a <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> with <bpt id=\"p2\">**</bpt>ControlChannelTrigger<ept id=\"p2\">**</ept>.","pos":[28027,28225],"source":" There are some transport-specific usage patterns and best practices that should be followed when using a [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) with **ControlChannelTrigger**."},{"content":"In addition, these considerations affect the way that requests to receive packets on the <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> are handled.","pos":[28226,28389],"source":" In addition, these considerations affect the way that requests to receive packets on the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) are handled."},{"pos":[28391,28624],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  <bpt id=\"p2\">[</bpt>HttpClient<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> using SSL is not currently supported using the network trigger feature and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ControlChannelTrigger<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>.","source":"**Note**  [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) using SSL is not currently supported using the network trigger feature and [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032)."},{"pos":[28628,28859],"content":"The following usage patterns and best practices should be followed when using <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> with <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ControlChannelTrigger<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>:","source":"The following usage patterns and best practices should be followed when using [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032):"},{"pos":[28865,29199],"content":"The app may need to set various properties and headers on the <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> or <bpt id=\"p2\">[</bpt>HttpClientHandler<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?linkid=241638)</ept> object in the <bpt id=\"p3\">[</bpt>System.Net.Http<ept id=\"p3\">](http://go.microsoft.com/fwlink/p/?linkid=227894)</ept> namespace before sending the request to the specific URI.","source":"The app may need to set various properties and headers on the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) or [HttpClientHandler](http://go.microsoft.com/fwlink/p/?linkid=241638) object in the [System.Net.Http](http://go.microsoft.com/fwlink/p/?linkid=227894) namespace before sending the request to the specific URI."},{"content":"An app may need to make need to an initial request to test and setup the transport properly before creating the <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> transport to be used with <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ControlChannelTrigger<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>.","pos":[29204,29490],"source":"An app may need to make need to an initial request to test and setup the transport properly before creating the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) transport to be used with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032)."},{"content":"Once the app determines that the transport can be properly setup, an <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> object can be configured as the transport object used with the <bpt id=\"p2\">**</bpt>ControlChannelTrigger<ept id=\"p2\">**</ept> object.","pos":[29491,29718],"source":" Once the app determines that the transport can be properly setup, an [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) object can be configured as the transport object used with the **ControlChannelTrigger** object."},{"content":"This process is designed prevent some scenarios from breaking the connection established over the transport.","pos":[29719,29827]},{"content":"Using SSL with a certificate, an app may require a dialog to be displayed for PIN entry or if there are multiple certificates to choose from.","pos":[29828,29969]},{"content":"Proxy authentication and server authentication may be required.","pos":[29970,30033]},{"content":"If the proxy or server authentication expires, the connection may be closed.","pos":[30034,30110]},{"content":"One way an app can deal with these authentication expiration issues is to set a timer.","pos":[30111,30197]},{"content":"When an HTTP redirect is required, it is not guaranteed that the second connection can be established reliably.","pos":[30198,30309]},{"content":"An initial test request will ensure that the app can use the most up-to-date redirected URL before using the <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> object as the transport with the <bpt id=\"p2\">**</bpt>ControlChannelTrigger<ept id=\"p2\">**</ept> object.","pos":[30310,30547],"source":" An initial test request will ensure that the app can use the most up-to-date redirected URL before using the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) object as the transport with the **ControlChannelTrigger** object."},{"content":"Unlike other network transports, the <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> object cannot be directly passed into the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>UsingTransport<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh701175)</ept> method of the <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>ControlChannelTrigger<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept> object.","pos":[30549,30876],"source":"Unlike other network transports, the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) object cannot be directly passed into the [**UsingTransport**](https://msdn.microsoft.com/library/windows/apps/hh701175) method of the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) object."},{"content":"Instead, an <bpt id=\"p1\">[</bpt>HttpRequestMessage<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=259153)</ept> object must be specially constructed for use with the <bpt id=\"p2\">[</bpt>HttpClient<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> object and the <bpt id=\"p3\">**</bpt>ControlChannelTrigger<ept id=\"p3\">**</ept>.","pos":[30877,31116],"source":" Instead, an [HttpRequestMessage](http://go.microsoft.com/fwlink/p/?linkid=259153) object must be specially constructed for use with the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) object and the **ControlChannelTrigger**."},{"content":"The <bpt id=\"p1\">[</bpt>HttpRequestMessage<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=259153)</ept> object is created using the <bpt id=\"p2\">[</bpt>RtcRequestFactory.Create<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?linkid=259154)</ept> method.","pos":[31117,31302],"source":" The [HttpRequestMessage](http://go.microsoft.com/fwlink/p/?linkid=259153) object is created using the [RtcRequestFactory.Create](http://go.microsoft.com/fwlink/p/?linkid=259154) method."},{"content":"The <bpt id=\"p1\">[</bpt>HttpRequestMessage<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=259153)</ept> object that is created is then passed to <bpt id=\"p2\">**</bpt>UsingTransport<ept id=\"p2\">**</ept> method .","pos":[31303,31445],"source":" The [HttpRequestMessage](http://go.microsoft.com/fwlink/p/?linkid=259153) object that is created is then passed to **UsingTransport** method ."},{"pos":[31447,31751],"content":"The following sample shows how to construct an <bpt id=\"p1\">[</bpt>HttpRequestMessage<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=259153)</ept> object for use with the <bpt id=\"p2\">[</bpt>HttpClient<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> object and the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ControlChannelTrigger<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>.","source":"The following sample shows how to construct an [HttpRequestMessage](http://go.microsoft.com/fwlink/p/?linkid=259153) object for use with the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) object and the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032)."},{"content":"Some special considerations affect the way that requests to send HTTP requests on the <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> to initiate receiving a response are handled.","pos":[32933,33126],"source":"Some special considerations affect the way that requests to send HTTP requests on the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) to initiate receiving a response are handled."},{"content":"In particular, when using a <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> with the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ControlChannelTrigger<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>, your app must use a Task for handling sends instead of the <bpt id=\"p4\">**</bpt>await<ept id=\"p4\">**</ept> model.","pos":[33127,33388],"source":" In particular, when using a [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) with the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032), your app must use a Task for handling sends instead of the **await** model."},{"content":"Using <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept>, there is no synchronization with the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>IBackgroundTask.Run<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br224811)</ept> method on the background task for the <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>ControlChannelTrigger<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept> with the return of the receive completion callback.","pos":[33390,33755],"source":"Using [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637), there is no synchronization with the [**IBackgroundTask.Run**](https://msdn.microsoft.com/library/windows/apps/br224811) method on the background task for the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) with the return of the receive completion callback."},{"content":"For this reason, the app can only use the blocking HttpResponseMessage technique in the <bpt id=\"p1\">**</bpt>Run<ept id=\"p1\">**</ept> method and wait until the whole response is received.","pos":[33756,33905],"source":" For this reason, the app can only use the blocking HttpResponseMessage technique in the **Run** method and wait until the whole response is received."},{"content":"Using <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> with <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ControlChannelTrigger<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept> is noticeably different from the <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>StreamSocket<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept>, <bpt id=\"p6\">[</bpt><bpt id=\"p7\">**</bpt>MessageWebSocket<ept id=\"p7\">**</ept><ept id=\"p6\">](https://msdn.microsoft.com/library/windows/apps/br226842)</ept> or <bpt id=\"p8\">[</bpt><bpt id=\"p9\">**</bpt>StreamWebSocket<ept id=\"p9\">**</ept><ept id=\"p8\">](https://msdn.microsoft.com/library/windows/apps/br226923)</ept> transports .","pos":[33907,34353],"source":"Using [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) is noticeably different from the [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882), [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) or [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) transports ."},{"content":"The <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> receive callback is delivered via a Task to the app since the <bpt id=\"p2\">[</bpt>HttpClient<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> code.","pos":[34354,34549],"source":" The [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) receive callback is delivered via a Task to the app since the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) code."},{"content":"This means that the <bpt id=\"p1\">**</bpt>ControlChannelTrigger<ept id=\"p1\">**</ept> push notification task will fire as soon as the data or error is dispatched to the app.","pos":[34550,34683],"source":" This means that the **ControlChannelTrigger** push notification task will fire as soon as the data or error is dispatched to the app."},{"content":"In the sample below, the code stores the responseTask returned by <bpt id=\"p1\">[</bpt>HttpClient.SendAsync<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> method into global storage that the push notify task will pick up and process inline.","pos":[34684,34907],"source":" In the sample below, the code stores the responseTask returned by [HttpClient.SendAsync](http://go.microsoft.com/fwlink/p/?linkid=241637) method into global storage that the push notify task will pick up and process inline."},{"pos":[34909,35134],"content":"The following sample shows how to handle send requests on the <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> when used with <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ControlChannelTrigger<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>.","source":"The following sample shows how to handle send requests on the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) when used with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032)."},{"pos":[36902,37130],"content":"The following sample shows how to read responses received on the <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> when used with <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ControlChannelTrigger<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>.","source":"The following sample shows how to read responses received on the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) when used with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032)."},{"pos":[38468,38751],"content":"For more information on using <bpt id=\"p1\">[</bpt>HttpClient<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=241637)</ept> with <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ControlChannelTrigger<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>, see the <bpt id=\"p4\">[</bpt>ControlChannelTrigger HttpClient sample<ept id=\"p4\">](http://go.microsoft.com/fwlink/p/?linkid=258323)</ept>.","source":"For more information on using [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032), see the [ControlChannelTrigger HttpClient sample](http://go.microsoft.com/fwlink/p/?linkid=258323)."},{"content":"ControlChannelTrigger with IXMLHttpRequest2","pos":[38756,38799]},{"content":"Some special considerations apply when using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IXMLHTTPRequest2<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh831151)</ept> with <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ControlChannelTrigger<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>.","pos":[38801,39021],"source":"Some special considerations apply when using [**IXMLHTTPRequest2**](https://msdn.microsoft.com/library/windows/desktop/hh831151) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032)."},{"content":"There are some transport-specific usage patterns and best practices that should be followed when using a <bpt id=\"p1\">**</bpt>IXMLHTTPRequest2<ept id=\"p1\">**</ept> with <bpt id=\"p2\">**</bpt>ControlChannelTrigger<ept id=\"p2\">**</ept>.","pos":[39022,39179],"source":" There are some transport-specific usage patterns and best practices that should be followed when using a **IXMLHTTPRequest2** with **ControlChannelTrigger**."},{"content":"Using <bpt id=\"p1\">**</bpt>ControlChannelTrigger<ept id=\"p1\">**</ept> does not affect the way that requests to send or receive HTTP requests on the <bpt id=\"p2\">**</bpt>IXMLHTTPRequest2<ept id=\"p2\">**</ept> are handled.","pos":[39180,39323],"source":" Using **ControlChannelTrigger** does not affect the way that requests to send or receive HTTP requests on the **IXMLHTTPRequest2** are handled."},{"pos":[39325,39544],"content":"Usage patterns and best practices when using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IXMLHTTPRequest2<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh831151)</ept> with <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ControlChannelTrigger<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>","source":"Usage patterns and best practices when using [**IXMLHTTPRequest2**](https://msdn.microsoft.com/library/windows/desktop/hh831151) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032)"},{"content":"An <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IXMLHTTPRequest2<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh831151)</ept> object when used as the transport has a lifetime of only one request/response.","pos":[39550,39715],"source":"An [**IXMLHTTPRequest2**](https://msdn.microsoft.com/library/windows/desktop/hh831151) object when used as the transport has a lifetime of only one request/response."},{"content":"When used with the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ControlChannelTrigger<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept> object, it is convenient to create and set up the <bpt id=\"p3\">**</bpt>ControlChannelTrigger<ept id=\"p3\">**</ept> object once and then call the <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>UsingTransport<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/hh701175)</ept> method repeatedly, each time associating a new <bpt id=\"p6\">**</bpt>IXMLHTTPRequest2<ept id=\"p6\">**</ept> object.","pos":[39716,40081],"source":" When used with the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) object, it is convenient to create and set up the **ControlChannelTrigger** object once and then call the [**UsingTransport**](https://msdn.microsoft.com/library/windows/apps/hh701175) method repeatedly, each time associating a new **IXMLHTTPRequest2** object."},{"content":"An app should delete the previous <bpt id=\"p1\">**</bpt>IXMLHTTPRequest2<ept id=\"p1\">**</ept> object before supplying a new <bpt id=\"p2\">**</bpt>IXMLHTTPRequest2<ept id=\"p2\">**</ept> object to ensure that the app does not exceed the allocated resource limits.","pos":[40082,40264],"source":" An app should delete the previous **IXMLHTTPRequest2** object before supplying a new **IXMLHTTPRequest2** object to ensure that the app does not exceed the allocated resource limits."},{"pos":[40269,40596],"content":"The app may need to call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SetProperty<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh831167)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>SetRequestHeader<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh831168)</ept> methods to set up the HTTP transport before calling <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Send<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/hh831164)</ept> method.","source":"The app may need to call the [**SetProperty**](https://msdn.microsoft.com/library/windows/desktop/hh831167) and [**SetRequestHeader**](https://msdn.microsoft.com/library/windows/desktop/hh831168) methods to set up the HTTP transport before calling [**Send**](https://msdn.microsoft.com/library/windows/desktop/hh831164) method."},{"content":"An app may need to make need to an initial <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Send<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh831164)</ept> request to test and setup the transport properly before creating the transport to be used with <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ControlChannelTrigger<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>.","pos":[40601,40897],"source":"An app may need to make need to an initial [**Send**](https://msdn.microsoft.com/library/windows/desktop/hh831164) request to test and setup the transport properly before creating the transport to be used with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032)."},{"content":"Once the app determines that the transport is properly setup, the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IXMLHTTPRequest2<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh831151)</ept> object can be configured as the transport object used with the <bpt id=\"p3\">**</bpt>ControlChannelTrigger<ept id=\"p3\">**</ept>.","pos":[40898,41137],"source":" Once the app determines that the transport is properly setup, the [**IXMLHTTPRequest2**](https://msdn.microsoft.com/library/windows/desktop/hh831151) object can be configured as the transport object used with the **ControlChannelTrigger**."},{"content":"This process is designed prevent some scenarios from breaking the connection established over the transport.","pos":[41138,41246]},{"content":"Using SSL with a certificate, an app may require a dialog to be displayed for PIN entry or if there are multiple certificates to choose from.","pos":[41247,41388]},{"content":"Proxy authentication and server authentication may be required.","pos":[41389,41452]},{"content":"If the proxy or server authentication expires, the connection may be closed.","pos":[41453,41529]},{"content":"One way an app can deal with these authentication expiration issues is to set a timer.","pos":[41530,41616]},{"content":"When an HTTP redirect is required, it is not guaranteed that the second connection can be established reliably.","pos":[41617,41728]},{"content":"An initial test request will ensure that the app can use the most up-to-date redirected URL before using the <bpt id=\"p1\">**</bpt>IXMLHTTPRequest2<ept id=\"p1\">**</ept> object as the transport with the <bpt id=\"p2\">**</bpt>ControlChannelTrigger<ept id=\"p2\">**</ept> object.","pos":[41729,41925],"source":" An initial test request will ensure that the app can use the most up-to-date redirected URL before using the **IXMLHTTPRequest2** object as the transport with the **ControlChannelTrigger** object."},{"pos":[41927,42243],"content":"For more information on using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IXMLHTTPRequest2<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh831151)</ept> with <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ControlChannelTrigger<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>, see the <bpt id=\"p5\">[</bpt>ControlChannelTrigger with IXMLHTTPRequest2 sample<ept id=\"p5\">](http://go.microsoft.com/fwlink/p/?linkid=258538)</ept>.","source":"For more information on using [**IXMLHTTPRequest2**](https://msdn.microsoft.com/library/windows/desktop/hh831151) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032), see the [ControlChannelTrigger with IXMLHTTPRequest2 sample](http://go.microsoft.com/fwlink/p/?linkid=258538)."}],"content":"---\ndescription: 'Apps use background tasks and two main mechanisms to maintain communications when they are not in the foreground: The socket broker, and control channel triggers.'\ntitle: Network communications in the background\nms.assetid: 537F8E16-9972-435D-85A5-56D5764D3AC2\n---\n\n# Network communications in the background\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n**Important APIs**\n\n-   [**SocketActivityTrigger**](https://msdn.microsoft.com/library/windows/apps/dn806009)\n-   [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032)\n\nApps use background tasks and two main mechanisms to maintain communications when they are not in the foreground: The socket broker, and control channel triggers. Apps that use sockets can delegate ownership of a socket to a system socket broker when they leave the foreground. The broker then activates the app when traffic arrives on the socket, transfers ownership back to the app, and the app processes the arriving traffic.\n\n## Socket broker and the SocketActivityTrigger\n\nIf your app uses [**DatagramSocket**](https://msdn.microsoft.com/library/windows/apps/br241319), [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882), or [**StreamSocketListener**](https://msdn.microsoft.com/library/windows/apps/br226906) connections, then you should use [**SocketActivityTrigger**](https://msdn.microsoft.com/library/windows/apps/dn806009) and the socket broker to be notified when traffic arrives for your app while it's not in the foreground.\n\nIn order for your app to receive and process data received on a socket when your app is not active, your app must perform some one-time setup at startup, and then transfer socket ownership to the socket broker when it is transitioning to a state where it is not active.\n\n-   The one-time setup steps are:\n\n    -   Create a SocketActivityTrigger and register a background task for the trigger with the TaskEntryPoint parameter set to your code for processing a received packet.\n\n```csharp\n            var socketTaskBuilder = new BackgroundTaskBuilder(); \n            socketTaskBuilder.Name = _backgroundTaskName; \n            socketTaskBuilder.TaskEntryPoint = _backgroundTaskEntryPoint; \n            var trigger = new SocketActivityTrigger(); \n            socketTaskBuilder.SetTrigger(trigger); \n            _task = socketTaskBuilder.Register(); \n```\n\n    -   Call EnableTransferOwnership on the socket, before you bind the socket.\n\n```csharp\n   \n           _tcpListener = new StreamSocketListener(); \n          \n           // Note that EnableTransferOwnership() should be called before bind, \n           // so that tcpip keeps required state for the socket to enable connected \n           // standby action. Background task Id is taken as a parameter to tie wake pattern \n           // to a specific background task.  \n           _tcpListener. EnableTransferOwnership(_task,SocketActivityConnectedStandbyAction.Wake); \n           _tcpListener.ConnectionReceived += OnConnectionReceived; \n           await _tcpListener.BindServiceNameAsync(\"my-service-name\"); \n```\n\n-   The action to take at suspend is:\n\n    When your app is about to suspend, call **TransferOwnership** on the socket to transfer it to a socket broker. The broker monitors the socket and activates your background task when data is received. The following example includes a utility **TransferOwnership** function to perform the transfer for **StreamSocketListener** sockets. (Note that the different types of sockets each have their own **TransferOwnership** method, so you must call the method appropriate for the socket whose ownership you are transferring. Your code would probably contain an overloaded **TransferOwnership** helper with one implementation for each socket type you use, so that the **OnSuspending** code remains easy to read.)\n\n    An app transfers ownership of a socket to a socket broker and passes the ID for the background task using the appropriate one of the following methods:\n\n    -   One of the [**TransferOwnership**](https://msdn.microsoft.com/library/windows/apps/dn804256) methods on a [**DatagramSocket**](https://msdn.microsoft.com/library/windows/apps/br241319).\n    -   One of the [**TransferOwnership**](https://msdn.microsoft.com/library/windows/apps/dn781433) methods on a [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882).\n    -   One of the [**TransferOwnership**](https://msdn.microsoft.com/library/windows/apps/dn804407) methods on a [**StreamSocketListener**](https://msdn.microsoft.com/library/windows/apps/br226906).\n\n```csharp\n    private void TransferOwnership(StreamSocketListener tcpListener) \n    { \n        await tcpListener.CancelIOAsync(); \n\n        var dataWriter = new DataWriter(); \n        _transferOwnershipCount++; \n        dataWriter.WriteInt32(transferOwnershipCount); \n        var context = new SocketActivityContext(dataWriter.DetachBuffer()); \n        tcpListener.TransferOwnership(_socketId, context); \n    } \n\n    private void OnSuspending(object sender, SuspendingEventArgs e) \n    { \n        var deferral = e.SuspendingOperation.GetDeferral(); \n\n        TransferOwnership(_tcpListener); \n        deferral.Complete(); \n    } \n```\n\n-  In your background task's event handler:\n\n   First, get a background task deferral so that you can handle the event using asynchronous methods.\n\n```csharp\nvar deferral = taskInstance.GetDeferral();</code></pre></td>\n```\n\n   Next, extract the SocketActivityTriggerDetails from the event arguments, and find the reason that the event was raised:\n\n```csharp\nvar details = taskInstance.TriggerDetails as SocketActivityTriggerDetails; \n    var socketInformation = details.SocketInformation; \n    switch (details.Reason) \n```\n\n    -   If the event was raised because of socket activity, create a DataReader on the socket, load the reader asynchronously, and then use the data according to your app's design. Note that you must return ownership of the socket back to the socket broker, in order to be notified of further socket activity again.\n\n        In the following example, the text received on the socket is displayed in a toast.\n\n```csharp\ncase SocketActivityTriggerReason.SocketActivity: \n            var socket = socketInformation.StreamSocket; \n            DataReader reader = new DataReader(socket.InputStream); \n            reader.InputStreamOptions = InputStreamOptions.Partial; \n            await reader.LoadAsync(250); \n            var dataString = reader.ReadString(reader.UnconsumedBufferLength); \n            ShowToast(dataString); \n            socket.TransferOwnership(socketInformation.Id); /* Important! */\n            break; \n```\n\n    -   If the event was raised because a keep alive timer expired, then your code should send some data over the socket in order to keep the socket alive and restart the keep alive timer. Again, it is important to return ownership of the socket back to the socket broker in order to receive further event notifications:\n\n```csharp\ncase SocketActivityTriggerReason.KeepAliveTimerExpired: \n            socket = socketInformation.StreamSocket; \n            DataWriter writer = new DataWriter(socket.OutputStream); \n            writer.WriteBytes(Encoding.UTF8.GetBytes(\"Keep alive\")); \n            await writer.StoreAsync(); \n            writer.DetachStream(); \n            writer.Dispose(); \n            socket.TransferOwnership(socketInformation.Id); /* Important! */\n            break; \n```\n\n    -   If the event was raised because the socket was closed, re-establish the socket, making sure that after you create the new socket, you transfer ownership of it to the socket broker. In this sample, the hostname and port are stored in local settings so that they can be used to establish a new socket connection:\n\n```csharp\ncase SocketActivityTriggerReason.SocketClosed: \n            socket = new StreamSocket(); \n            socket.EnableTransferOwnership(taskInstance.Task.TaskId, SocketActivityConnectedStandbyAction.Wake); \n            if (ApplicationData.Current.LocalSettings.Values[\"hostname\"] == null) \n            { \n                break; \n            } \n            var hostname = (String)ApplicationData.Current.LocalSettings.Values[\"hostname\"]; \n            var port = (String)ApplicationData.Current.LocalSettings.Values[\"port\"]; \n            await socket.ConnectAsync(new HostName(hostname), port); \n            socket.TransferOwnership(socketId); \n            break; \n```\n\n-   Don't forget to Complete your deferral, once you have finished processing the event notification:\n\n```csharp\n  deferral.Complete();\n```\n\nFor a complete sample demonstrating the use of the [**SocketActivityTrigger**](https://msdn.microsoft.com/library/windows/apps/dn806009) and socket broker, see the [SocketActivityStreamSocket sample](http://go.microsoft.com/fwlink/p/?LinkId=620606). The initialization of the socket is performed in Scenario1\\_Connect.xaml.cs, and the background task implementation is in SocketActivityTask.cs.\n\nYou will probably notice that the sample calls **TransferOwnership** as soon as it creates a new socket or acquires an existing socket, rather than using the **OnSuspending** even handler to do so as described in this topic. This is because the sample focuses on demonstrating the [**SocketActivityTrigger**](https://msdn.microsoft.com/library/windows/apps/dn806009), and doesn't use the socket for any other activity while it is running. Your app will probably be more complex, and should use **OnSuspending** to determine when to call **TransferOwnership**.\n\n## Control channel triggers\n\nFirst, ensure that you're using control channel triggers (CCTs) appropriately. If you're using [**DatagramSocket**](https://msdn.microsoft.com/library/windows/apps/br241319), [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882), or [**StreamSocketListener**](https://msdn.microsoft.com/library/windows/apps/br226906) connections, we recommend you use [**SocketActivityTrigger**](https://msdn.microsoft.com/library/windows/apps/dn806009). You can use CCTs for **StreamSocket**, but they use more resources and might not work in Connected Standby mode.\n\nIf you are using WebSockets, [**IXMLHTTPRequest2**](https://msdn.microsoft.com/library/windows/desktop/hh831151), [**System.Net.Http.HttpClient**](https://msdn.microsoft.com/library/windows/apps/dn298639) or **Windows.Web.Http.HttpClient**, you must use [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032).\n\n## ControlChannelTrigger with WebSockets\n\nSome special considerations apply when using [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) or [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032). There are some transport-specific usage patterns and best practices that should be followed when using a **MessageWebSocket** or **StreamWebSocket** with **ControlChannelTrigger**. In addition, these considerations affect the way that requests to receive packets on the **StreamWebSocket** are handled. Requests to receive packets on the **MessageWebSocket** are not affected.\n\nThe following usage patterns and best practices should be followed when using [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) or [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032):\n\n-   An outstanding socket receive must be kept posted at all times. This is required to allow the push notification tasks to occur.\n-   The WebSocket protocol defines a standard model for keep-alive messages. The [**WebSocketKeepAlive**](https://msdn.microsoft.com/library/windows/apps/hh701531) class can send client-initiated WebSocket protocol keep-alive messages to the server. The **WebSocketKeepAlive** class should be registered as the TaskEntryPoint for a KeepAliveTrigger by the app.\n\nSome special considerations affect the way that requests to receive packets on the [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) are handled. In particular, when using a **StreamWebSocket** with the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032), your app must use a raw async pattern for handling reads instead of the **await** model in C# and VB.NET or Tasks in C++. The raw async pattern is illustrated in a code sample later in this section.\n\nUsing the raw async pattern allows Windows to synchronize the [**IBackgroundTask.Run**](https://msdn.microsoft.com/library/windows/apps/br224811) method on the background task for the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) with the return of the receive completion callback. The **Run** method is invoked after the completion callback returns. This ensures that the app has received the data/errors before the **Run** method is invoked.\n\nIt is important to note that the app has to post another read before it returns control from the completion callback. It is also important to note that the [**DataReader**](https://msdn.microsoft.com/library/windows/apps/br208119) cannot be directly used with the [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) or [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) transport since that breaks the synchronization described above. It is not supported to use the [**DataReader.LoadAsync**](https://msdn.microsoft.com/library/windows/apps/br208135) method directly on top of the transport. Instead, the [**IBuffer**](https://msdn.microsoft.com/library/windows/apps/br241656) returned by the [**IInputStream.ReadAsync**](https://msdn.microsoft.com/library/windows/apps/br241719) method on the [**StreamWebSocket.InputStream**](https://msdn.microsoft.com/library/windows/apps/br226936) property can be later passed to [**DataReader.FromBuffer**](https://msdn.microsoft.com/library/windows/apps/br208133) method for further processing.\n\nThe following sample shows how to use a raw async pattern for handling reads on the [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923).\n\n```csharp\nvoid PostSocketRead(int length) \n{\n    try\n    {\n        var readBuf = new Windows.Storage.Streams.Buffer((uint)length);\n        var readOp = socket.InputStream.ReadAsync(readBuf, (uint)length, InputStreamOptions.Partial);\n        readOp.Completed = (IAsyncOperationWithProgress<IBuffer, uint> \n            asyncAction, AsyncStatus asyncStatus) =>\n        {\n            switch (asyncStatus)\n            {\n                case AsyncStatus.Completed:\n                case AsyncStatus.Error:\n                    try\n                    {\n                        // GetResults in AsyncStatus::Error is called as it throws a user friendly error string.\n                        IBuffer localBuf = asyncAction.GetResults();\n                        uint bytesRead = localBuf.Length;\n                        readPacket = DataReader.FromBuffer(localBuf);\n                        OnDataReadCompletion(bytesRead, readPacket);\n                    }\n                    catch (Exception exp)\n                    {\n                        Diag.DebugPrint(\"Read operation failed:  \" + exp.Message);\n                    }\n                    break;\n                case AsyncStatus.Canceled:\n\n                    // Read is not cancelled in this sample.\n                    break;\n           }\n       };\n   }\n   catch (Exception exp)\n   {\n       Diag.DebugPrint(\"failed to post a read failed with error:  \" + exp.Message);\n   }\n}\n```\n\nThe read completion handler is guaranteed to fire before the [**IBackgroundTask.Run**](https://msdn.microsoft.com/library/windows/apps/br224811) method on the background task for the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) is invoked. Windows has internal synchronization to wait for an app to return from the read completion callback. The app typically quickly processes the data or the error from the [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) or [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) in the read completion callback. The message itself is processed within the context of the **IBackgroundTask.Run** method. In this sample below, this point is illustrated by using a message queue that the read completion handler inserts the message into and the background task later processes.\n\nThe following sample shows the read completion handler to use with a raw async pattern for handling reads on the [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923).\n\n```csharp\npublic void OnDataReadCompletion(uint bytesRead, DataReader readPacket)\n{\n    if (readPacket == null)\n    {\n        Diag.DebugPrint(\"DataReader is null\");\n\n        // Ideally when read completion returns error, \n        // apps should be resilient and try to \n        // recover if there is an error by posting another recv\n        // after creating a new transport, if required.\n        return;\n    }\n    uint buffLen = readPacket.UnconsumedBufferLength;\n    Diag.DebugPrint(\"bytesRead: \" + bytesRead + \", unconsumedbufflength: \" + buffLen);\n\n    // check if buffLen is 0 and treat that as fatal error.\n    if (buffLen == 0)\n    {\n        Diag.DebugPrint(\"Received zero bytes from the socket. Server must have closed the connection.\");\n        Diag.DebugPrint(\"Try disconnecting and reconnecting to the server\");\n        return;\n    }\n\n    // Perform minimal processing in the completion\n    string message = readPacket.ReadString(buffLen);\n    Diag.DebugPrint(\"Received Buffer : \" + message);\n\n    // Enqueue the message received to a queue that the push notify \n    // task will pick up.\n    AppContext.messageQueue.Enqueue(message);\n\n    // Post another receive to ensure future push notifications.\n    PostSocketRead(MAX_BUFFER_LENGTH);\n}\n```\n\nAn additional detail for Websockets is the keep-alive handler. The WebSocket protocol defines a standard model for keep-alive messages.\n\nWhen using [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) or [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923), register a[**WebSocketKeepAlive**](https://msdn.microsoft.com/library/windows/apps/hh701531) class instance as the [**TaskEntryPoint**](https://msdn.microsoft.com/library/windows/apps/br224774) for a KeepAliveTrigger to allow the app to be unsuspended and send keep-alive messages to the server (remote endpoint) periodically. This should be done as part of the background registration app code as well as in the package manifest.\n\nThis task entry point of [**Windows.Sockets.WebSocketKeepAlive**](https://msdn.microsoft.com/library/windows/apps/hh701531) needs to be specified in two places:\n\n-   When creating KeepAliveTrigger trigger in the source code (see example below).\n-   In the app package manifest for the keepalive background task declaration.\n\nThe following sample adds a network trigger notification and a keepalive trigger under the &lt;Application&gt; element in an app manifest.\n\n```xml\n  <Extensions>\n    <Extension Category=\"windows.backgroundTasks\" \n         Executable=\"$targetnametoken$.exe\" \n         EntryPoint=\"Background.PushNotifyTask\">\n      <BackgroundTasks>\n        <Task Type=\"controlChannel\" />\n      </BackgroundTasks>\n    </Extension>\n    <Extension Category=\"windows.backgroundTasks\" \n         Executable=\"$targetnametoken$.exe\" \n         EntryPoint=\"Windows.Networking.Sockets.WebSocketKeepAlive\">\n      <BackgroundTasks>\n        <Task Type=\"controlChannel\" />\n      </BackgroundTasks>\n    </Extension>\n  </Extensions> \n```\n\nAn app must be extremely careful when using an **await** statement in the context of a [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) and an asynchronous operation on a [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923), [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842), or [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882). A **Task&lt;bool&gt;** object can be used to register a **ControlChannelTrigger** for push notification and WebSocket keep-alives on the **StreamWebSocket** and connect the transport. As part of the registration, the **StreamWebSocket** transport is set as the transport for the **ControlChannelTrigger** and a read is posted. The **Task.Result** will block the current thread until all steps in the task execute and return statements in message body. The task is not resolved until the method returns either true or false. This guarantees that the whole method is executed. The **Task** can contain multiple **await** statements that are protected by the **Task**. This pattern should be used with the **ControlChannelTrigger** object when a **StreamWebSocket** or **MessageWebSocket** is used as the transport. For those operations that may take a long period of time to complete (a typical async read operation, for example), the app should use the raw async pattern discussed previously.\n\nThe following sample registers [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) for push notification and WebSocket keep-alives on the [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923).\n\n```csharp\nprivate bool RegisterWithControlChannelTrigger(string serverUri)\n{\n    // Make sure the objects are created in a system thread\n    // Demonstrate the core registration path \n    // Wait for the entire operation to complete before returning from this method.\n    // The transport setup routine can be triggered by user control, by network state change\n    // or by keepalive task\n    Task<bool> registerTask = RegisterWithCCTHelper(serverUri);\n    return registerTask.Result;\n}\n\nasync Task<bool> RegisterWithCCTHelper(string serverUri)\n{\n    bool result = false;\n    socket = new StreamWebSocket();\n\n    // Specify the keepalive interval expected by the server for this app\n    // in order of minutes.\n    const int serverKeepAliveInterval = 30;\n\n    // Specify the channelId string to differentiate this\n    // channel instance from any other channel instance.\n    // When background task fires, the channel object is provided\n    // as context and the channel id can be used to adapt the behavior\n    // of the app as required.\n    const string channelId = \"channelOne\";\n\n    // For websockets, the system does the keepalive on behalf of the app\n    // But the app still needs to specify this well known keepalive task.\n    // This should be done here in the background registration as well \n    // as in the package manifest.\n    const string WebSocketKeepAliveTask = \"Windows.Networking.Sockets.WebSocketKeepAlive\";\n\n    // Try creating the controlchanneltrigger if this has not been already \n    // created and stored in the property bag.\n    ControlChannelTriggerStatus status;\n    \n    // Create the ControlChannelTrigger object and request a hardware slot for this app.\n    // If the app is not on LockScreen, then the ControlChannelTrigger constructor will \n    // fail right away.\n    try\n    {\n        channel = new ControlChannelTrigger(channelId, serverKeepAliveInterval,\n                                   ControlChannelTriggerResourceType.RequestHardwareSlot);\n    }\n    catch (UnauthorizedAccessException exp)\n    {\n        Diag.DebugPrint(\"Is the app on lockscreen? \" + exp.Message);\n        return result;\n    }\n\n    Uri serverUriInstance;\n    try\n    {\n        serverUriInstance = new Uri(serverUri);\n    }\n    catch (Exception exp)\n    {\n        Diag.DebugPrint(\"Error creating URI: \" + exp.Message);\n        return result;\n    }\n\n    // Register the apps background task with the trigger for keepalive.\n    var keepAliveBuilder = new BackgroundTaskBuilder();\n    keepAliveBuilder.Name = \"KeepaliveTaskForChannelOne\";\n    keepAliveBuilder.TaskEntryPoint = WebSocketKeepAliveTask;\n    keepAliveBuilder.SetTrigger(channel.KeepAliveTrigger);\n    keepAliveBuilder.Register();\n\n    // Register the apps background task with the trigger for push notification task.\n    var pushNotifyBuilder = new BackgroundTaskBuilder();\n    pushNotifyBuilder.Name = \"PushNotificationTaskForChannelOne\";\n    pushNotifyBuilder.TaskEntryPoint = \"Background.PushNotifyTask\";\n    pushNotifyBuilder.SetTrigger(channel.PushNotificationTrigger);\n    pushNotifyBuilder.Register();\n\n    // Tie the transport method to the ControlChannelTrigger object to push enable it.\n    // Note that if the transport' s TCP connection is broken at a later point of time,\n    // the ControlChannelTrigger object can be reused to plug in a new transport by\n    // calling UsingTransport API again.\n    try\n    {\n        channel.UsingTransport(socket);\n\n        // Connect the socket\n        //\n        // If connect fails or times out it will throw exception.\n        // ConnectAsync can also fail if hardware slot was requested\n        // but none are available\n        await socket.ConnectAsync(serverUriInstance);\n\n        // Call WaitForPushEnabled API to make sure the TCP connection has \n        // been established, which will mean that the OS will have allocated \n        // any hardware slot for this TCP connection.\n        //\n        // In this sample, the ControlChannelTrigger object was created by \n        // explicitly requesting a hardware slot.\n        //\n        // On systems that without connected standby, if app requests hardware slot as above, \n        // the system will fallback to a software slot automatically.\n        //\n        // On systems that support connected standby,, if no hardware slot is available, then app \n        // can request a software slot by re-creating the ControlChannelTrigger object.\n        status = channel.WaitForPushEnabled();\n        if (status != ControlChannelTriggerStatus.HardwareSlotAllocated\n            &amp;&amp; status != ControlChannelTriggerStatus.SoftwareSlotAllocated)\n        {\n            throw new Exception(string.Format(\"Neither hardware nor software slot could be allocated. ChannelStatus is {0}\", status.ToString()));\n        }\n\n        // Store the objects created in the property bag for later use.\n        CoreApplication.Properties.Remove(channel.ControlChannelTriggerId);\n\n        var appContext = new AppContext(this, socket, channel, channel.ControlChannelTriggerId);\n        ((IDictionary<string, object>)CoreApplication.Properties).Add(channel.ControlChannelTriggerId, appContext);\n        result = true;\n\n        // Almost done. Post a read since we are using streamwebsocket\n        // to allow push notifications to be received.\n        PostSocketRead(MAX_BUFFER_LENGTH);\n    }\n    catch (Exception exp)\n    {\n         Diag.DebugPrint(\"RegisterWithCCTHelper Task failed with: \" + exp.Message);\n\n         // Exceptions may be thrown for example if the application has not \n         // registered the background task class id for using real time communications \n         // broker in the package manifest.\n    }\n    return result\n}\n```\n\nFor more information on using [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) or [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032), see the [ControlChannelTrigger StreamWebSocket sample](http://go.microsoft.com/fwlink/p/?linkid=251232).\n\n## ControlChannelTrigger with HttpClient\n\nSome special considerations apply when using [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032). There are some transport-specific usage patterns and best practices that should be followed when using a [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) with **ControlChannelTrigger**. In addition, these considerations affect the way that requests to receive packets on the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) are handled.\n\n**Note**  [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) using SSL is not currently supported using the network trigger feature and [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032).\n\n \nThe following usage patterns and best practices should be followed when using [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032):\n\n-   The app may need to set various properties and headers on the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) or [HttpClientHandler](http://go.microsoft.com/fwlink/p/?linkid=241638) object in the [System.Net.Http](http://go.microsoft.com/fwlink/p/?linkid=227894) namespace before sending the request to the specific URI.\n-   An app may need to make need to an initial request to test and setup the transport properly before creating the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) transport to be used with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032). Once the app determines that the transport can be properly setup, an [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) object can be configured as the transport object used with the **ControlChannelTrigger** object. This process is designed prevent some scenarios from breaking the connection established over the transport. Using SSL with a certificate, an app may require a dialog to be displayed for PIN entry or if there are multiple certificates to choose from. Proxy authentication and server authentication may be required. If the proxy or server authentication expires, the connection may be closed. One way an app can deal with these authentication expiration issues is to set a timer. When an HTTP redirect is required, it is not guaranteed that the second connection can be established reliably. An initial test request will ensure that the app can use the most up-to-date redirected URL before using the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) object as the transport with the **ControlChannelTrigger** object.\n\nUnlike other network transports, the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) object cannot be directly passed into the [**UsingTransport**](https://msdn.microsoft.com/library/windows/apps/hh701175) method of the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) object. Instead, an [HttpRequestMessage](http://go.microsoft.com/fwlink/p/?linkid=259153) object must be specially constructed for use with the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) object and the **ControlChannelTrigger**. The [HttpRequestMessage](http://go.microsoft.com/fwlink/p/?linkid=259153) object is created using the [RtcRequestFactory.Create](http://go.microsoft.com/fwlink/p/?linkid=259154) method. The [HttpRequestMessage](http://go.microsoft.com/fwlink/p/?linkid=259153) object that is created is then passed to **UsingTransport** method .\n\nThe following sample shows how to construct an [HttpRequestMessage](http://go.microsoft.com/fwlink/p/?linkid=259153) object for use with the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) object and the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032).\n\n```csharp\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Windows.Networking.Sockets;\n\npublic HttpRequestMessage httpRequest;\npublic HttpClient httpClient;\npublic HttpRequestMessage httpRequest;\npublic ControlChannelTrigger channel;\npublic Uri serverUri;\n\nprivate void SetupHttpRequestAndSendToHttpServer()\n{\n    try\n    {\n        // For HTTP based transports that use the RTC broker, whenever we send next request, we will abort the earlier \n        // outstanding http request and start new one.\n        // For example in case when http server is taking longer to reply, and keep alive trigger is fired in-between \n        // then keep alive task will abort outstanding http request and start a new request which should be finished \n        // before next keep alive task is triggered.\n        if (httpRequest != null)\n        {\n            httpRequest.Dispose();\n        }\n\n        httpRequest = RtcRequestFactory.Create(HttpMethod.Get, serverUri);\n\n        SendHttpRequest();\n    }\n        catch (Exception e)\n    {\n        Diag.DebugPrint(\"Connect failed with: \" + e.ToString());\n        throw;\n    }\n}\n```\n\nSome special considerations affect the way that requests to send HTTP requests on the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) to initiate receiving a response are handled. In particular, when using a [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) with the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032), your app must use a Task for handling sends instead of the **await** model.\n\nUsing [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637), there is no synchronization with the [**IBackgroundTask.Run**](https://msdn.microsoft.com/library/windows/apps/br224811) method on the background task for the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) with the return of the receive completion callback. For this reason, the app can only use the blocking HttpResponseMessage technique in the **Run** method and wait until the whole response is received.\n\nUsing [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) is noticeably different from the [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882), [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) or [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) transports . The [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) receive callback is delivered via a Task to the app since the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) code. This means that the **ControlChannelTrigger** push notification task will fire as soon as the data or error is dispatched to the app. In the sample below, the code stores the responseTask returned by [HttpClient.SendAsync](http://go.microsoft.com/fwlink/p/?linkid=241637) method into global storage that the push notify task will pick up and process inline.\n\nThe following sample shows how to handle send requests on the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) when used with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032).\n\n```csharp\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Windows.Networking.Sockets;\n\nprivate void SendHttpRequest()\n{\n    if (httpRequest == null)\n    {\n        throw new Exception(\"HttpRequest object is null\");\n    }\n\n    // Tie the transport method to the controlchanneltrigger object to push enable it.\n    // Note that if the transport' s TCP connection is broken at a later point of time,\n    // the controlchanneltrigger object can be reused to plugin a new transport by\n    // calling UsingTransport API again.\n    channel.UsingTransport(httpRequest);\n\n    // Call the SendAsync function to kick start the TCP connection establishment\n    // process for this http request.\n    Task<HttpResponseMessage> httpResponseTask = httpClient.SendAsync(httpRequest);\n\n    // Call WaitForPushEnabled API to make sure the TCP connection has been established, \n    // which will mean that the OS will have allocated any hardware slot for this TCP connection.\n    ControlChannelTriggerStatus status = channel.WaitForPushEnabled();\n    Diag.DebugPrint(\"WaitForPushEnabled() completed with status: \" + status);\n    if (status != ControlChannelTriggerStatus.HardwareSlotAllocated\n        &amp;&amp; status != ControlChannelTriggerStatus.SoftwareSlotAllocated)\n    {\n        throw new Exception(\"Hardware/Software slot not allocated\");\n    }\n\n    // The HttpClient receive callback is delivered via a Task to the app. \n    // The notification task will fire as soon as the data or error is dispatched\n    // Enqueue the responseTask returned by httpClient.sendAsync \n    // into a queue that the push notify task will pick up and process inline.\n    AppContext.messageQueue.Enqueue(httpResponseTask);\n}\n```\n\nThe following sample shows how to read responses received on the [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) when used with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032).\n\n```csharp\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic string ReadResponse(Task<HttpResponseMessage> httpResponseTask)\n{\n    string message = null;\n    try\n    {\n        if (httpResponseTask.IsCanceled || httpResponseTask.IsFaulted)\n        {\n            Diag.DebugPrint(\"Task is cancelled or has failed\");\n            return message;\n        }\n        // We' ll wait until we got the whole response. \n        // This is the only supported scenario for HttpClient for ControlChannelTrigger.\n        HttpResponseMessage httpResponse = httpResponseTask.Result;\n        if (httpResponse == null || httpResponse.Content == null)\n        {\n            Diag.DebugPrint(\"Cannot read from httpresponse, as either httpResponse or its content is null. try to reset connection.\");\n        }\n        else\n        {\n            // This is likely being processed in the context of a background task and so\n            // synchronously read the Content' s results inline so that the Toast can be shown.\n            // before we exit the Run method.\n            message = httpResponse.Content.ReadAsStringAsync().Result;\n        }\n    }\n    catch (Exception exp)\n    {\n        Diag.DebugPrint(\"Failed to read from httpresponse with error:  \" + exp.ToString());\n    }\n    return message;\n}\n```\n\nFor more information on using [HttpClient](http://go.microsoft.com/fwlink/p/?linkid=241637) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032), see the [ControlChannelTrigger HttpClient sample](http://go.microsoft.com/fwlink/p/?linkid=258323).\n\n## ControlChannelTrigger with IXMLHttpRequest2\n\nSome special considerations apply when using [**IXMLHTTPRequest2**](https://msdn.microsoft.com/library/windows/desktop/hh831151) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032). There are some transport-specific usage patterns and best practices that should be followed when using a **IXMLHTTPRequest2** with **ControlChannelTrigger**. Using **ControlChannelTrigger** does not affect the way that requests to send or receive HTTP requests on the **IXMLHTTPRequest2** are handled.\n\nUsage patterns and best practices when using [**IXMLHTTPRequest2**](https://msdn.microsoft.com/library/windows/desktop/hh831151) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032)\n\n-   An [**IXMLHTTPRequest2**](https://msdn.microsoft.com/library/windows/desktop/hh831151) object when used as the transport has a lifetime of only one request/response. When used with the [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032) object, it is convenient to create and set up the **ControlChannelTrigger** object once and then call the [**UsingTransport**](https://msdn.microsoft.com/library/windows/apps/hh701175) method repeatedly, each time associating a new **IXMLHTTPRequest2** object. An app should delete the previous **IXMLHTTPRequest2** object before supplying a new **IXMLHTTPRequest2** object to ensure that the app does not exceed the allocated resource limits.\n-   The app may need to call the [**SetProperty**](https://msdn.microsoft.com/library/windows/desktop/hh831167) and [**SetRequestHeader**](https://msdn.microsoft.com/library/windows/desktop/hh831168) methods to set up the HTTP transport before calling [**Send**](https://msdn.microsoft.com/library/windows/desktop/hh831164) method.\n-   An app may need to make need to an initial [**Send**](https://msdn.microsoft.com/library/windows/desktop/hh831164) request to test and setup the transport properly before creating the transport to be used with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032). Once the app determines that the transport is properly setup, the [**IXMLHTTPRequest2**](https://msdn.microsoft.com/library/windows/desktop/hh831151) object can be configured as the transport object used with the **ControlChannelTrigger**. This process is designed prevent some scenarios from breaking the connection established over the transport. Using SSL with a certificate, an app may require a dialog to be displayed for PIN entry or if there are multiple certificates to choose from. Proxy authentication and server authentication may be required. If the proxy or server authentication expires, the connection may be closed. One way an app can deal with these authentication expiration issues is to set a timer. When an HTTP redirect is required, it is not guaranteed that the second connection can be established reliably. An initial test request will ensure that the app can use the most up-to-date redirected URL before using the **IXMLHTTPRequest2** object as the transport with the **ControlChannelTrigger** object.\n\nFor more information on using [**IXMLHTTPRequest2**](https://msdn.microsoft.com/library/windows/desktop/hh831151) with [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032), see the [ControlChannelTrigger with IXMLHTTPRequest2 sample](http://go.microsoft.com/fwlink/p/?linkid=258538).\n\n"}