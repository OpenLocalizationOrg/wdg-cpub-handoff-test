{"nodes":[{"pos":[11,53],"content":"Creating Windows Runtime Components in C++","needQuote":true,"needEscape":true,"nodes":[{"content":"Creating Windows Runtime Components in C++","pos":[0,42]}]},{"pos":[67,261],"content":"This article shows how to use C++ to create a Windows Runtime component, which is a DLL that's callable from a Universal Windows app that's built by using JavaScript—or C#, Visual Basic, or C++.","needQuote":true,"needEscape":true,"nodes":[{"content":"This article shows how to use C++ to create a Windows Runtime component, which is a DLL that's callable from a Universal Windows app that's built by using JavaScript—or C#, Visual Basic, or C++.","pos":[0,194]}]},{"content":"Creating Windows Runtime Components in C++","pos":[319,361]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[364,402]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[403,498],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"\\[Some information relates to pre-released product which may be substantially modified before it's commercially released.","pos":[501,622]},{"content":"Microsoft makes no warranties, express or implied, with respect to the information provided here.\\]","pos":[623,722]},{"content":"This article shows how to use C++ to create a Windows Runtime component, which is a DLL that's callable from a Universal Windows app that's built by using JavaScript—or C#, Visual Basic, or C++.","pos":[724,918]},{"content":"Here are several reasons for building such a component:","pos":[920,975]},{"content":"To get the performance advantage of C++ in complex or computationally intensive operations.","pos":[981,1072]},{"content":"To reuse code that's already written and tested.","pos":[1078,1126]},{"content":"When you build a solution that contains a JavaScript or .NET project, and a Windows Runtime component project, the JavaScript project files and the compiled DLL are merged into one package, which you can debug locally in the simulator or remotely on a tethered device.","pos":[1128,1396]},{"content":"You can also distribute just the component project as an Extension SDK.","pos":[1397,1468]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Creating a Software Development Kit<ept id=\"p1\">](https://msdn.microsoft.com/library/hh768146.aspx)</ept>.","pos":[1469,1583],"source":" For more information, see [Creating a Software Development Kit](https://msdn.microsoft.com/library/hh768146.aspx)."},{"content":"In general, when you code your C++ component, use the regular C++ library and built-in types, except at the abstract binary interface (ABI) boundary where you are passing data to and from code in another .winmd package.","pos":[1585,1804]},{"content":"There, use Windows Runtime types and the special syntax that Visual C++ supports for creating and manipulating those types.","pos":[1805,1928]},{"content":"In addition, in your Visual C++ code, use types such as delegate and event to implement events that can be fired from your component and handled in JavaScript, Visual Basic, or C#.","pos":[1929,2109]},{"content":"For more information about the new Visual C++ syntax, see <bpt id=\"p1\">[</bpt>Visual C++ Language Reference (C++/CX)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh699871.aspx)</ept>.","pos":[2110,2277],"source":" For more information about the new Visual C++ syntax, see [Visual C++ Language Reference (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699871.aspx)."},{"content":"Casing and naming rules","pos":[2282,2305]},{"content":"JavaScript","pos":[2312,2322]},{"content":"JavaScript is case-sensitive.","pos":[2324,2353]},{"content":"Therefore, you must follow these casing conventions:","pos":[2354,2406]},{"content":"When you reference C++ namespaces and classes, use the same casing that's used on the C++ side.","pos":[2412,2507]},{"content":"When you call methods, use camel casing even if the method name is capitalized on the C++ side.","pos":[2512,2607]},{"content":"For example, a C++ method GetDate() must be called from JavaScript as getDate().","pos":[2608,2688]},{"content":"An activatable class name and namespace name can't contain UNICODE characters.","pos":[2693,2771]},{"content":".NET","pos":[2777,2781]},{"content":"The .NET languages follow their normal casing rules.","pos":[2783,2835]},{"content":"Instantiating the object","pos":[2840,2864]},{"content":"Only Windows Runtime types can be passed across the ABI boundary.","pos":[2867,2932]},{"content":"The compiler will raise an error if the component has a type like std::wstring as a return type or parameter in a public method.","pos":[2933,3061]},{"content":"The Visual C++ component extensions (C++/CX) built-in types include the usual scalars such as int and double, and also their typedef equivalents int32, float64, and so on.For more information, see <bpt id=\"p1\">[</bpt>Type System (C++/CX)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh755822.aspx)</ept>.","pos":[3062,3345],"source":" The Visual C++ component extensions (C++/CX) built-in types include the usual scalars such as int and double, and also their typedef equivalents int32, float64, and so on.For more information, see [Type System (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh755822.aspx)."},{"content":"C++ built-in types, library types, and Windows Runtime types","pos":[3914,3974]},{"content":"An activatable class (also known as a ref class) is one that can be instantiated from another language such as JavaScript, C# or Visual Basic.","pos":[3977,4119]},{"content":"To be consumable from another language, a component must contain at least one activatable class.","pos":[4120,4216]},{"content":"A Windows Runtime component can contain multiple public activatable classes as well as additional classes that are known only internally to the component.","pos":[4218,4372]},{"content":"Apply the <bpt id=\"p1\">[</bpt>WebHostHidden<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.webhosthiddenattribute.aspx)</ept> attribute to C++ types that are not intended to be visible to JavaScript.","pos":[4373,4577],"source":" Apply the [WebHostHidden](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.webhosthiddenattribute.aspx) attribute to C++ types that are not intended to be visible to JavaScript."},{"content":"All public classes must reside in the same root namespace which has the same name as the component metadata file.","pos":[4579,4692]},{"content":"For example, a class that's named A.B.C.MyClass can be instantiated only if it's defined in a metadata file that's named A.winmd or A.B.winmd or A.B.C.winmd.","pos":[4693,4850]},{"content":"The name of the DLL is not required to match the .winmd file name.","pos":[4851,4917]},{"pos":[4919,5045],"content":"Client code creates an instance of the component by using the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> (<bpt id=\"p2\">**</bpt>New<ept id=\"p2\">**</ept> in Visual Basic) keyword just as for any class.","source":"Client code creates an instance of the component by using the **new** (**New** in Visual Basic) keyword just as for any class."},{"content":"An activatable class must be declared as <bpt id=\"p1\">**</bpt>public ref class sealed<ept id=\"p1\">**</ept>.","pos":[5047,5116],"source":"An activatable class must be declared as **public ref class sealed**."},{"content":"The <bpt id=\"p1\">**</bpt>ref class<ept id=\"p1\">**</ept> keyword tells the compiler to create the class as a Windows Runtime compatible type, and the sealed keyword specifies that the class cannot be inherited.","pos":[5117,5288],"source":" The **ref class** keyword tells the compiler to create the class as a Windows Runtime compatible type, and the sealed keyword specifies that the class cannot be inherited."},{"content":"The Windows Runtime does not currently support a generalized inheritance model; a limited inheritance model supports creation of custom XAML controls.","pos":[5289,5439]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Ref classes and structs (C++/CX)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh699870.aspx)</ept>.","pos":[5440,5569],"source":" For more information, see [Ref classes and structs (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699870.aspx)."},{"content":"For C++, all the numeric primitives are defined in the default namespace.","pos":[5571,5644]},{"content":"The <bpt id=\"p1\">[</bpt>Platform<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh710417.aspx)</ept> namespace contains C++ classes that are specific to the Windows Runtime type system.","pos":[5645,5812],"source":" The [Platform](https://msdn.microsoft.com/library/windows/apps/xaml/hh710417.aspx) namespace contains C++ classes that are specific to the Windows Runtime type system."},{"content":"These include <bpt id=\"p1\">[</bpt>Platform::String<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh755812.aspx)</ept> class and <bpt id=\"p2\">[</bpt>Platform::Object<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh748265.aspx)</ept> class.","pos":[5813,6017],"source":" These include [Platform::String](https://msdn.microsoft.com/library/windows/apps/xaml/hh755812.aspx) class and [Platform::Object](https://msdn.microsoft.com/library/windows/apps/xaml/hh748265.aspx) class."},{"content":"The concrete collection types such as <bpt id=\"p1\">[</bpt>Platform::Collections::Map<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh441508.aspx)</ept> class and <bpt id=\"p2\">[</bpt>Platform::Collections::Vector<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh441570.aspx)</ept> class are defined in the <bpt id=\"p3\">[</bpt>Platform::Collections<ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh710418.aspx)</ept> namespace.","pos":[6018,6390],"source":" The concrete collection types such as [Platform::Collections::Map](https://msdn.microsoft.com/library/windows/apps/xaml/hh441508.aspx) class and [Platform::Collections::Vector](https://msdn.microsoft.com/library/windows/apps/xaml/hh441570.aspx) class are defined in the [Platform::Collections](https://msdn.microsoft.com/library/windows/apps/xaml/hh710418.aspx) namespace."},{"content":"The public interfaces that these types implement are defined in <bpt id=\"p1\">[</bpt>Windows::Foundation::Collections Namespace (C++/CX)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh441496.aspx)</ept>.","pos":[6391,6577],"source":" The public interfaces that these types implement are defined in [Windows::Foundation::Collections Namespace (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh441496.aspx)."},{"content":"It is these interface types that are consumed by JavaScript, C# and Visual Basic.","pos":[6578,6659]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Type System (C++/CX)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh755822.aspx)</ept>.","pos":[6660,6772],"source":" For more information, see [Type System (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh755822.aspx)."},{"content":"Method that returns a value of built-in type","pos":[6777,6821]},{"content":"Method that returns a custom value struct","pos":[7169,7210]},{"content":"To pass user-defined value structs across the ABI, define a JavaScript object that has the same members as the value struct that's defined in C++.","pos":[7673,7819]},{"content":"You can then pass that object as an argument to a C++ method so that the object is implicitly converted to the C++ type.","pos":[7820,7940]},{"content":"Another approach is to define a class that implements IPropertySet (not shown).","pos":[8473,8552]},{"content":"In the .NET languages, you just create a variable of the type that's defined in the C++ component.","pos":[8554,8652]},{"content":"Overloaded Methods","pos":[9297,9315]},{"content":"A C++ public ref class can contain overloaded methods, but JavaScript has limited ability to differentiate overloaded methods.","pos":[9318,9444]},{"content":"For example, it can tell the difference between these signatures:","pos":[9445,9510]},{"content":"But it can’t tell the difference between these:","pos":[9689,9736]},{"pos":[9800,10109],"content":"In ambiguous cases, you can ensure that JavaScript always calls a specific overload by applying the <bpt id=\"p1\">[</bpt>Windows::Foundation::Metadata::DefaultOverload<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.defaultoverloadattribute.aspx)</ept> attribute to the method signature in the header file.","source":"In ambiguous cases, you can ensure that JavaScript always calls a specific overload by applying the [Windows::Foundation::Metadata::DefaultOverload](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.defaultoverloadattribute.aspx) attribute to the method signature in the header file."},{"content":"This JavaScript always calls the attributed overload:","pos":[10111,10164]},{"content":".NET","pos":[10323,10327]},{"content":"The .NET languages recognize overloads in a C++ ref class just as in any .NET Framework class.","pos":[10330,10424]},{"content":"DateTime","pos":[10429,10437]},{"content":"In the Windows Runtime, a <bpt id=\"p1\">[</bpt>Windows::Foundation::DateTime<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.datetime.aspx)</ept> object is just a 64-bit signed integer that represents the number of 100-nanosecond intervals either before or after January 1, 1601.","pos":[10439,10712],"source":"In the Windows Runtime, a [Windows::Foundation::DateTime](https://msdn.microsoft.com/library/windows/apps/windows.foundation.datetime.aspx) object is just a 64-bit signed integer that represents the number of 100-nanosecond intervals either before or after January 1, 1601."},{"content":"There are no methods on a Windows:Foundation::DateTime object.","pos":[10713,10775]},{"content":"Instead, each language projects the DateTime in the way that is native to that language: the Date object in JavaScript and the System.DateTime and System.DateTimeOffset types in the .NET Framework.","pos":[10776,10973]},{"content":"When you pass a DateTime value from C++ to JavaScript, JavaScript accepts it as a Date object and displays it by default as a long-form date string.","pos":[11309,11457]},{"content":"When a .NET language passes a System.DateTime to a C++ component, the method accepts it as a Windows::Foundation::DateTime.","pos":[11772,11895]},{"content":"When the component passes a Windows::Foundation::DateTime to a .NET Framework method, the Framework method accepts it as a DateTimeOffset.","pos":[11896,12034]},{"content":"Collections and arrays","pos":[12519,12541]},{"content":"Collections are always passed across the ABI boundary as handles to Windows Runtime types such as Windows::Foundation::Collections::IVector^ and Windows::Foundation::Collections::IMap^.","pos":[12544,12729]},{"content":"For example, if you return a handle to a Platform::Collections::Map, it implicitly converts to a Windows::Foundation::Collections::IMap^.","pos":[12730,12867]},{"content":"The collection interfaces are defined in a namespace that's separate from the C++ classes that provide the concrete implementations.","pos":[12868,13000]},{"content":"JavaScript and .NET languages consume the interfaces.","pos":[13001,13054]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Collections (C++/CX)<ept id=\"p1\">](https://msdn.microsoft.com//library/windows/apps/hh700103.aspx)</ept> and <bpt id=\"p2\">[</bpt>Array and WriteOnlyArray (C++/CX)<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh700131.aspx)</ept>.","pos":[13055,13271],"source":" For more information, see [Collections (C++/CX)](https://msdn.microsoft.com//library/windows/apps/hh700103.aspx) and [Array and WriteOnlyArray (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh700131.aspx)."},{"content":"Passing IVector","pos":[13276,13291]},{"content":"The .NET languages see IVector<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph> as IList<ph id=\"ph3\">&amp;lt;</ph>T<ph id=\"ph4\">&amp;gt;</ph>.","pos":[13993,14051],"source":"The .NET languages see IVector&lt;T&gt; as IList&lt;T&gt;."},{"content":"Passing IMap","pos":[14449,14461]},{"content":"The .NET languages see IMap and IDictionary<ph id=\"ph1\">&amp;lt;</ph>K, V<ph id=\"ph2\">&amp;gt;</ph>.","pos":[15188,15244],"source":"The .NET languages see IMap and IDictionary&lt;K, V&gt;."},{"content":"Properties","pos":[15454,15464]},{"content":"A public ref class in Visual C++ component extensions exposes public data members as properties, by using the property keyword.","pos":[15467,15594]},{"content":"The concept is identical to .NET Framework properties.","pos":[15595,15649]},{"content":"A trivial property resembles a data member because its functionality is implicit.","pos":[15650,15731]},{"content":"A non-trivial property has explicit get and set accessors and a named private variable that's the \"backing store\" for the value.","pos":[15732,15860]},{"content":"In this example, the private member variable \\_propertyAValue is the backing store for PropertyA.","pos":[15861,15958]},{"content":"A property can fire an event when its value changes, and a client app can register to receive that event.","pos":[15959,16064]},{"content":"The .NET languages access properties on a native C++ object just as they would on a .NET Framework object.","pos":[17314,17420]},{"content":"Delegates and events","pos":[17843,17863]},{"content":"A delegate is a Windows Runtime type that represents a function object.","pos":[17866,17937]},{"content":"You can use delegates in connection with events, callbacks, and asynchronous method calls to specify an action to be performed later.","pos":[17938,18071]},{"content":"Like a function object, the delegate provides type-safety by enabling the compiler to verify the return type and parameter types of the function.","pos":[18072,18217]},{"content":"The declaration of a delegate resembles a function signature, the implementation resembles a class definition, and the invocation resembles a function invocation.","pos":[18218,18380]},{"content":"Adding an event listener","pos":[18385,18409]},{"content":"You can use the event keyword to declare a public member of a specified delegate type.","pos":[18412,18498]},{"content":"Client code subscribes to the event by using the standard mechanisms that are provided in the particular language.","pos":[18499,18613]},{"content":"This example uses the same C++ code as for the previous properties section.","pos":[18669,18744]},{"content":"In the .NET languages, subscribing to an event in a C++ component is the same as subscribing to an event in a .NET Framework class:","pos":[19250,19381]},{"content":"Adding multiple event listeners for one event","pos":[19866,19911]},{"content":"JavaScript has an addEventListener method that enables multiple handlers to subscribe to a single event.","pos":[19914,20018]},{"content":"In C#, any number of event handlers can subscribe to the event by using the += operator as shown in the previous example.","pos":[20955,21076]},{"content":"Enums","pos":[21081,21086]},{"content":"A Windows Runtime enum in C++ is declared by using public class enum; it resembles a scoped enum in standard C++.","pos":[21089,21202]},{"content":"Enum values are passed between C++ and JavaScript as integers.","pos":[21463,21525]},{"content":"You can optionally declare a JavaScript object that contains the same named values as the C++ enum and use it as follows.","pos":[21526,21647]},{"content":"Both C# and Visual Basic have language support for enums.","pos":[21917,21974]},{"content":"These languages see a C++ public enum class just as they would see a .NET Framework enum.","pos":[21975,22064]},{"content":"Asynchronous methods","pos":[22069,22089]},{"content":"To consume asynchronous methods that are exposed by other Windows Runtime objects, use the <bpt id=\"p1\">[</bpt>task Class (Concurrency Runtime)<ept id=\"p1\">](https://msdn.microsoft.com/library/hh750113.aspx)</ept>.","pos":[22092,22268],"source":"To consume asynchronous methods that are exposed by other Windows Runtime objects, use the [task Class (Concurrency Runtime)](https://msdn.microsoft.com/library/hh750113.aspx)."},{"content":"For more information, see and <bpt id=\"p1\">[</bpt>Task Parallelism (Concurrency Runtime)<ept id=\"p1\">](https://msdn.microsoft.com/library/dd492427.aspx)</ept>.","pos":[22269,22390],"source":" For more information, see and [Task Parallelism (Concurrency Runtime)](https://msdn.microsoft.com/library/dd492427.aspx)."},{"content":"To implement asynchronous methods in C++, use the <bpt id=\"p1\">[</bpt>create\\_async<ept id=\"p1\">](https://msdn.microsoft.com/library/hh750102.aspx)</ept> function that's defined in ppltasks.h.","pos":[22392,22546],"source":"To implement asynchronous methods in C++, use the [create\\_async](https://msdn.microsoft.com/library/hh750102.aspx) function that's defined in ppltasks.h."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Creating Asynchronous Operations in C++ for Windows Store Apps<ept id=\"p1\">](https://msdn.microsoft.com/library/vstudio/hh750082.aspx)</ept>.","pos":[22547,22696],"source":" For more information, see [Creating Asynchronous Operations in C++ for Windows Store Apps](https://msdn.microsoft.com/library/vstudio/hh750082.aspx)."},{"content":"For an example, see <bpt id=\"p1\">[</bpt>Walkthrough: Creating a basic Windows Runtime component in C++ and calling it from JavaScript or C#<ept id=\"p1\">](walkthrough-creating-a-basic-windows-runtime-component-in-cpp-and-calling-it-from-javascript-or-csharp.md)</ept>.","pos":[22697,22926],"source":" For an example, see [Walkthrough: Creating a basic Windows Runtime component in C++ and calling it from JavaScript or C#](walkthrough-creating-a-basic-windows-runtime-component-in-cpp-and-calling-it-from-javascript-or-csharp.md)."},{"content":"The .NET languages consume C++ asynchronous methods just as they would any asynchronous method that's defined in the .NET Framework.","pos":[22927,23059]},{"content":"Exceptions","pos":[23064,23074]},{"content":"You can throw any exception type that's defined by the Windows Runtime.","pos":[23077,23148]},{"content":"You cannot derive custom types from any Windows Runtime exception type.","pos":[23149,23220]},{"content":"However, you can throw COMException and provide a custom HRESULT that can be accessed by the code that catches the exception.","pos":[23221,23346]},{"content":"There's no way to specify a custom Message in a COMException.","pos":[23347,23408]},{"content":"Debugging tips","pos":[23413,23427]},{"content":"When you debug a JavaScript solution that has a component DLL, you can set the debugger to enable either stepping through script, or stepping through native code in the component, but not both at the same time.","pos":[23430,23640]},{"content":"To change the setting, select the JavaScript project node in Solution Explorer and then choose Properties, Debugging, Debugger Type.","pos":[23641,23773]},{"content":"Be sure to select appropriate capabilities in the package designer.","pos":[23775,23842]},{"content":"For example, if you are attempting to open an image file in the user's Pictures library by using the Windows Runtime APIs, be sure to select the Pictures Library check box in the Capabilities pane of the manifest designer.","pos":[23843,24065]},{"content":"If your JavaScript code doesn't seem to be recognizing the public properties or methods in the component, make sure that in JavaScript you are using camel casing.","pos":[24067,24229]},{"content":"For example, the LogCalc C++ method must be referenced as logCalc in JavaScript.","pos":[24230,24310]},{"content":"If you remove a C++ Windows Runtime component project from a solution, you must also manually remove the project reference from the JavaScript project.","pos":[24312,24463]},{"content":"Failure to do so prevents subsequent debug or build operations.","pos":[24464,24527]},{"content":"If necessary, you can then add an assembly reference to the DLL.","pos":[24528,24592]},{"content":"Related topics","pos":[24597,24611]},{"content":"Walkthrough: Creating a basic Windows Runtime component in C++ and calling it from JavaScript or C","pos":[24616,24714]}],"content":"---\ntitle: Creating Windows Runtime Components in C++\ndescription: This article shows how to use C++ to create a Windows Runtime component, which is a DLL that's callable from a Universal Windows app that's built by using JavaScript—or C#, Visual Basic, or C++.\nms.assetid: F7E06AA2-DCEC-427E-BD5D-9CA2A0ED2612\n---\n\n\n# Creating Windows Runtime Components in C++\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\n\\[Some information relates to pre-released product which may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\\]\n\nThis article shows how to use C++ to create a Windows Runtime component, which is a DLL that's callable from a Universal Windows app that's built by using JavaScript—or C#, Visual Basic, or C++.\n\nHere are several reasons for building such a component:\n\n-   To get the performance advantage of C++ in complex or computationally intensive operations.\n\n-   To reuse code that's already written and tested.\n\nWhen you build a solution that contains a JavaScript or .NET project, and a Windows Runtime component project, the JavaScript project files and the compiled DLL are merged into one package, which you can debug locally in the simulator or remotely on a tethered device. You can also distribute just the component project as an Extension SDK. For more information, see [Creating a Software Development Kit](https://msdn.microsoft.com/library/hh768146.aspx).\n\nIn general, when you code your C++ component, use the regular C++ library and built-in types, except at the abstract binary interface (ABI) boundary where you are passing data to and from code in another .winmd package. There, use Windows Runtime types and the special syntax that Visual C++ supports for creating and manipulating those types. In addition, in your Visual C++ code, use types such as delegate and event to implement events that can be fired from your component and handled in JavaScript, Visual Basic, or C#. For more information about the new Visual C++ syntax, see [Visual C++ Language Reference (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699871.aspx).\n\n## Casing and naming rules\n\n\n### JavaScript\n\nJavaScript is case-sensitive. Therefore, you must follow these casing conventions:\n\n-   When you reference C++ namespaces and classes, use the same casing that's used on the C++ side.\n-   When you call methods, use camel casing even if the method name is capitalized on the C++ side. For example, a C++ method GetDate() must be called from JavaScript as getDate().\n-   An activatable class name and namespace name can't contain UNICODE characters.\n\n### .NET\n\nThe .NET languages follow their normal casing rules.\n\n## Instantiating the object\n\n\nOnly Windows Runtime types can be passed across the ABI boundary. The compiler will raise an error if the component has a type like std::wstring as a return type or parameter in a public method. The Visual C++ component extensions (C++/CX) built-in types include the usual scalars such as int and double, and also their typedef equivalents int32, float64, and so on.For more information, see [Type System (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh755822.aspx).\n\n```cpp\n// ref class definition in C++\npublic ref class SampleRefClass sealed\n{\n    // Class members...\n\n    // #include <valarray>\npublic:\n    double LogCalc(double input)\n    {\n        // Use C++ standard library as usual.\n        return std::log(input); \n    }\n\n};\n```\n\n```javascript\n//Instantiation in JavaScript (requires \"Add reference > Project reference\")\nvar nativeObject = new CppComponent.SampleRefClass();\n```\n\n```csharp\n//Call a method and display result in a XAML TextBlock\nvar num = nativeObject.LogCalc(21.5);\nResultText.Text = num.ToString();\n```\n\n## C++ built-in types, library types, and Windows Runtime types\n\n\nAn activatable class (also known as a ref class) is one that can be instantiated from another language such as JavaScript, C# or Visual Basic. To be consumable from another language, a component must contain at least one activatable class.\n\nA Windows Runtime component can contain multiple public activatable classes as well as additional classes that are known only internally to the component. Apply the [WebHostHidden](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.webhosthiddenattribute.aspx) attribute to C++ types that are not intended to be visible to JavaScript.\n\nAll public classes must reside in the same root namespace which has the same name as the component metadata file. For example, a class that's named A.B.C.MyClass can be instantiated only if it's defined in a metadata file that's named A.winmd or A.B.winmd or A.B.C.winmd. The name of the DLL is not required to match the .winmd file name.\n\nClient code creates an instance of the component by using the **new** (**New** in Visual Basic) keyword just as for any class.\n\nAn activatable class must be declared as **public ref class sealed**. The **ref class** keyword tells the compiler to create the class as a Windows Runtime compatible type, and the sealed keyword specifies that the class cannot be inherited. The Windows Runtime does not currently support a generalized inheritance model; a limited inheritance model supports creation of custom XAML controls. For more information, see [Ref classes and structs (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699870.aspx).\n\nFor C++, all the numeric primitives are defined in the default namespace. The [Platform](https://msdn.microsoft.com/library/windows/apps/xaml/hh710417.aspx) namespace contains C++ classes that are specific to the Windows Runtime type system. These include [Platform::String](https://msdn.microsoft.com/library/windows/apps/xaml/hh755812.aspx) class and [Platform::Object](https://msdn.microsoft.com/library/windows/apps/xaml/hh748265.aspx) class. The concrete collection types such as [Platform::Collections::Map](https://msdn.microsoft.com/library/windows/apps/xaml/hh441508.aspx) class and [Platform::Collections::Vector](https://msdn.microsoft.com/library/windows/apps/xaml/hh441570.aspx) class are defined in the [Platform::Collections](https://msdn.microsoft.com/library/windows/apps/xaml/hh710418.aspx) namespace. The public interfaces that these types implement are defined in [Windows::Foundation::Collections Namespace (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh441496.aspx). It is these interface types that are consumed by JavaScript, C# and Visual Basic. For more information, see [Type System (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh755822.aspx).\n\n## Method that returns a value of built-in type\n\n```cpp\n    // #include <valarray>\npublic:\n    double LogCalc(double input)\n    {\n        // Use C++ standard library as usual.\n        return std::log(input); \n    }\n```\n\n```javascript\n//Call a method\nvar nativeObject = new CppComponent.SampleRefClass;\nvar num = nativeObject.logCalc(21.5);\ndocument.getElementById('P2').innerHTML = num;\n```\n\n## Method that returns a custom value struct\n\n```cpp\nnamespace CppComponent\n{\n    // Custom struct\n    public value struct PlayerData\n    {\n        Platform::String^ Name;\n        int Number;\n        double ScoringAverage;\n    };\n\n    public ref class Player sealed\n    {\n    private:\n        PlayerData m_player;\n    public:\n        property PlayerData PlayerStats \n        {\n            PlayerData get(){ return m_player; }\n            void set(PlayerData data) {m_player = data;}\n        }\n    };\n}\n```\n\nTo pass user-defined value structs across the ABI, define a JavaScript object that has the same members as the value struct that's defined in C++. You can then pass that object as an argument to a C++ method so that the object is implicitly converted to the C++ type.\n\n```javascript\n// Get and set the value struct\nfunction GetAndSetPlayerData() {\n    // Create an object to pass to C++\n    var myData =\n        { name: \"Bob Homer\", number: 12, scoringAverage: .357 };\n    var nativeObject = new CppComponent.Player();\n    nativeObject.playerStats = myData;\n\n    // Retrieve C++ value struct into new JavaScript object\n    var myData2 = nativeObject.playerStats;\n    document.getElementById('P3').innerHTML = myData.name + \" , \" + myData.number + \" , \" + myData.scoringAverage.toPrecision(3);\n}\n```\n\nAnother approach is to define a class that implements IPropertySet (not shown).\n\nIn the .NET languages, you just create a variable of the type that's defined in the C++ component.\n\n```csharp\nprivate void GetAndSetPlayerData()\n{\n    // Create a ref class\n    var player = new CppComponent.Player();\n\n    // Create a variable of a value struct\n    // type that is defined in C++\n    CppComponent.PlayerData myPlayer;\n    myPlayer.Name = \"Babe Ruth\";\n    myPlayer.Number = 12;\n    myPlayer.ScoringAverage = .398;\n\n    // Set the property\n    player.PlayerStats = myPlayer;\n\n    // Get the property and store it in a new variable\n    CppComponent.PlayerData myPlayer2 = player.PlayerStats;\n    ResultText.Text += myPlayer.Name + \" , \" + myPlayer.Number.ToString() +\n        \" , \" + myPlayer.ScoringAverage.ToString();\n}\n```\n\n## Overloaded Methods\n\n\nA C++ public ref class can contain overloaded methods, but JavaScript has limited ability to differentiate overloaded methods. For example, it can tell the difference between these signatures:\n\n```cpp\npublic ref class NumberClass sealed \n{\npublic:\n    int GetNumber(int i);\n    int GetNumber(int i, Platform::String^ str);\n    double GetNumber(int i, MyData^ d);\n};\n```\n\nBut it can’t tell the difference between these:\n\n```cpp\nint GetNumber(int i);\ndouble GetNumber(double d);\n```\n\nIn ambiguous cases, you can ensure that JavaScript always calls a specific overload by applying the [Windows::Foundation::Metadata::DefaultOverload](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.defaultoverloadattribute.aspx) attribute to the method signature in the header file.\n\nThis JavaScript always calls the attributed overload:\n\n```javascript\nvar nativeObject = new CppComponent.NumberClass();\nvar num = nativeObject.getNumber(9);\ndocument.getElementById('P4').innerHTML = num;\n```\n\n## .NET\n\n\nThe .NET languages recognize overloads in a C++ ref class just as in any .NET Framework class.\n\n## DateTime\n\nIn the Windows Runtime, a [Windows::Foundation::DateTime](https://msdn.microsoft.com/library/windows/apps/windows.foundation.datetime.aspx) object is just a 64-bit signed integer that represents the number of 100-nanosecond intervals either before or after January 1, 1601. There are no methods on a Windows:Foundation::DateTime object. Instead, each language projects the DateTime in the way that is native to that language: the Date object in JavaScript and the System.DateTime and System.DateTimeOffset types in the .NET Framework.\n\n```cpp\npublic  ref class MyDateClass sealed\n{\npublic:\n    property Windows::Foundation::DateTime TimeStamp;\n    void SetTime(Windows::Foundation::DateTime dt)\n    {\n        auto cal = ref new Windows::Globalization::Calendar();\n        cal->SetDateTime(dt);\n        TimeStamp = cal->GetDateTime(); // or TimeStamp = dt;\n    }\n};\n```\n\nWhen you pass a DateTime value from C++ to JavaScript, JavaScript accepts it as a Date object and displays it by default as a long-form date string.\n\n```javascript\nfunction SetAndGetDate() {\n    var nativeObject = new CppComponent.MyDateClass();\n\n    var myDate = new Date(1956, 4, 21);\n    nativeObject.setTime(myDate);\n\n    var myDate2 = nativeObject.timeStamp;\n\n    //prints long form date string\n    document.getElementById('P5').innerHTML = myDate2;\n\n}\n```\n\nWhen a .NET language passes a System.DateTime to a C++ component, the method accepts it as a Windows::Foundation::DateTime. When the component passes a Windows::Foundation::DateTime to a .NET Framework method, the Framework method accepts it as a DateTimeOffset.\n\n```csharp\nprivate void DateTimeExample()\n{\n    // Pass a System.DateTime to a C++ method\n    // that takes a Windows::Foundation::DateTime\n    DateTime dt = DateTime.Now;\n    var nativeObject = new CppComponent.MyDateClass();\n    nativeObject.SetTime(dt);\n\n    // Retrieve a Windows::Foundation::DateTime as a\n    // System.DateTimeOffset\n    DateTimeOffset myDate = nativeObject.TimeStamp;\n\n    // Print the long-form date string\n    ResultText.Text += myDate.ToString();\n}\n```\n\n## Collections and arrays\n\n\nCollections are always passed across the ABI boundary as handles to Windows Runtime types such as Windows::Foundation::Collections::IVector^ and Windows::Foundation::Collections::IMap^. For example, if you return a handle to a Platform::Collections::Map, it implicitly converts to a Windows::Foundation::Collections::IMap^. The collection interfaces are defined in a namespace that's separate from the C++ classes that provide the concrete implementations. JavaScript and .NET languages consume the interfaces. For more information, see [Collections (C++/CX)](https://msdn.microsoft.com//library/windows/apps/hh700103.aspx) and [Array and WriteOnlyArray (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh700131.aspx).\n\n## Passing IVector\n\n\n```cpp\n// Windows::Foundation::Collections::IVector across the ABI.\n//#include <algorithm>\n//#include <collection.h>\nWindows::Foundation::Collections::IVector<int>^ SortVector(Windows::Foundation::Collections::IVector<int>^ vec)\n{\n    std::sort(begin(vec), end(vec));\n    return vec;\n}\n```\n\n```javascript\nvar nativeObject = new CppComponent.CollectionExample();\n// Call the method to sort an integer array\nvar inVector = [14, 12, 45, 89, 23];\nvar outVector = nativeObject.sortVector(inVector);\nvar result = \"Sorted vector to array:\";\nfor (var i = 0; i < outVector.length; i++)\n{\n    outVector[i];\n    result += outVector[i].toString() + \",\";\n}\ndocument.getElementById('P6').innerHTML = result;\n```\n\nThe .NET languages see IVector&lt;T&gt; as IList&lt;T&gt;.\n\n```csharp\nprivate void SortListItems()\n{\n    IList<int> myList = new List<int>();\n    myList.Add(5);\n    myList.Add(9);\n    myList.Add(17);\n    myList.Add(2);\n\n    var nativeObject = new CppComponent.CollectionExample();\n    IList<int> mySortedList = nativeObject.SortVector(myList);\n\n    foreach (var item in mySortedList)\n    {\n        ResultText.Text += \" \" + item.ToString();\n    }\n}\n```\n\n## Passing IMap\n\n\n```cpp\n// #include <map>\n//#include <collection.h>\nWindows::Foundation::Collections::IMap<int, Platform::String^> ^GetMap(void)\n{    \n    Windows::Foundation::Collections::IMap<int, Platform::String^> ^ret = \n        ref new Platform::Collections::Map<int, Platform::String^>;\n    ret->Insert(1, \"One \");\n    ret->Insert(2, \"Two \");\n    ret->Insert(3, \"Three \");\n    ret->Insert(4, \"Four \");\n    ret->Insert(5, \"Five \");\n    return ret;\n}\n```\n\n```javascript\n// Call the method to get the map\nvar outputMap = nativeObject.getMap();\nvar mStr = \"Map result:\" + outputMap.lookup(1) + outputMap.lookup(2)\n    + outputMap.lookup(3) + outputMap.lookup(4) + outputMap.lookup(5);\ndocument.getElementById('P7').innerHTML = mStr;\n```\n\nThe .NET languages see IMap and IDictionary&lt;K, V&gt;.\n\n```csharp\nprivate void GetDictionary()\n{\n    var nativeObject = new CppComponent.CollectionExample();\n    IDictionary<int, string> d = nativeObject.GetMap();\n    ResultText.Text += d[2].ToString();\n}\n```\n\n## Properties\n\n\nA public ref class in Visual C++ component extensions exposes public data members as properties, by using the property keyword. The concept is identical to .NET Framework properties. A trivial property resembles a data member because its functionality is implicit. A non-trivial property has explicit get and set accessors and a named private variable that's the \"backing store\" for the value. In this example, the private member variable \\_propertyAValue is the backing store for PropertyA. A property can fire an event when its value changes, and a client app can register to receive that event.\n\n```cpp\n//Properties\npublic delegate void PropertyChangedHandler(Platform::Object^ sender, int arg);\npublic ref class PropertyExample  sealed\n{\npublic:\n    PropertyExample(){}\n\n    // Event that is fired when PropertyA changes\n    event PropertyChangedHandler^ PropertyChangedEvent;\n\n    // Property that has custom setter/getter\n    property int PropertyA\n    {\n        int get() { return m_propertyAValue; }\n        void set(int propertyAValue) \n        {\n            if (propertyAValue != m_propertyAValue)\n            {\n                m_propertyAValue = propertyAValue;\n                // Fire event. (See event example below.)\n                PropertyChangedEvent(this, propertyAValue);\n            }\n        }\n    }\n\n    // Trivial get/set property that has a compiler-generated backing store.\n    property Platform::String^ PropertyB;\n\nprivate:\n    // Backing store for propertyA.\n    int m_propertyAValue;\n};\n```\n\n```javascript\nvar nativeObject = new CppComponent.PropertyExample();\nvar propValue = nativeObject.propertyA;\ndocument.getElementById('P8').innerHTML = propValue;\n\n//Set the string property\nnativeObject.propertyB = \"What is the meaning of the universe?\";\ndocument.getElementById('P9').innerHTML += nativeObject.propertyB;\n```\n\nThe .NET languages access properties on a native C++ object just as they would on a .NET Framework object.\n\n```csharp\nprivate void GetAProperty()\n{\n    // Get the value of the integer property\n    // Instantiate the C++ object\n    var obj = new CppComponent.PropertyExample();\n\n    // Get an integer property\n    var propValue = obj.PropertyA;\n    ResultText.Text += propValue.ToString();\n\n    // Set a string property\n    obj.PropertyB = \" What is the meaning of the universe?\";\n    ResultText.Text += obj.PropertyB;\n\n}\n```\n\n## Delegates and events\n\n\nA delegate is a Windows Runtime type that represents a function object. You can use delegates in connection with events, callbacks, and asynchronous method calls to specify an action to be performed later. Like a function object, the delegate provides type-safety by enabling the compiler to verify the return type and parameter types of the function. The declaration of a delegate resembles a function signature, the implementation resembles a class definition, and the invocation resembles a function invocation.\n\n## Adding an event listener\n\n\nYou can use the event keyword to declare a public member of a specified delegate type. Client code subscribes to the event by using the standard mechanisms that are provided in the particular language.\n\n```cpp\npublic:\n    event SomeHandler^ someEvent;\n```\n\nThis example uses the same C++ code as for the previous properties section.\n\n```javascript\nfunction Button_Click() {\n    var nativeObj = new CppComponent.PropertyExample();\n    // Define an event handler method\n    var singlecasthandler = function (ev) {\n        document.getElementById('P10').innerHTML = \"The button was clicked and the value is \" + ev;\n    };\n\n    // Subscribe to the event\n    nativeObj.onpropertychangedevent = singlecasthandler;\n\n    // Set the value of the property and fire the event\n    var propValue = 21;\n    nativeObj.propertyA = 2 * propValue;\n\n}\n```\n\nIn the .NET languages, subscribing to an event in a C++ component is the same as subscribing to an event in a .NET Framework class:\n\n```csharp\n//Subscribe to event and call method that causes it to be fired.\nprivate void TestMethod()\n{\n    var objWithEvent = new CppComponent.PropertyExample();\n    objWithEvent.PropertyChangedEvent += objWithEvent_PropertyChangedEvent;\n\n    objWithEvent.PropertyA = 42;\n}\n\n//Event handler method\nprivate void objWithEvent_PropertyChangedEvent(object __param0, int __param1)\n{\n    ResultText.Text = \"the event was fired and the result is \" +\n         __param1.ToString();\n}\n```\n\n## Adding multiple event listeners for one event\n\n\nJavaScript has an addEventListener method that enables multiple handlers to subscribe to a single event.\n\n```cpp\npublic delegate void SomeHandler(Platform::String^ str);\n\npublic ref class LangSample sealed\n{\npublic:\n    event SomeHandler^ someEvent;\n    property Platform::String^ PropertyA;\n\n    // Method that fires an event\n    void FireEvent(Platform::String^ str)\n    {\n        someEvent(Platform::String::Concat(str, PropertyA->ToString()));\n    }\n    //...\n};\n```\n\n```javascript\n// Add two event handlers\nvar multicast1 = function (ev) {\n    document.getElementById('P11').innerHTML = \"Handler 1: \" + ev.target;\n};\nvar multicast2 = function (ev) {\n    document.getElementById('P12').innerHTML = \"Handler 2: \" + ev.target;\n};\n\nvar nativeObject = new CppComponent.LangSample();\n//Subscribe to the same event\nnativeObject.addEventListener(\"someevent\", multicast1);\nnativeObject.addEventListener(\"someevent\", multicast2);\n\nnativeObject.propertyA = \"42\";\n\n// This method should fire an event\nnativeObject.fireEvent(\"The answer is \");\n```\n\nIn C#, any number of event handlers can subscribe to the event by using the += operator as shown in the previous example.\n\n## Enums\n\n\nA Windows Runtime enum in C++ is declared by using public class enum; it resembles a scoped enum in standard C++.\n\n```cpp\npublic enum class Direction {North, South, East, West};\n\npublic ref class EnumExampleClass sealed\n{\npublic:\n    property Direction CurrentDirection\n    {\n        Direction  get(){return m_direction; }\n    }\n\nprivate:\n    Direction m_direction;\n};\n```\n\nEnum values are passed between C++ and JavaScript as integers. You can optionally declare a JavaScript object that contains the same named values as the C++ enum and use it as follows.\n\n```javascript\nvar Direction = { 0: \"North\", 1: \"South\", 2: \"East\", 3: \"West\" };\n//. . .\n\nvar nativeObject = new CppComponent.EnumExampleClass();\nvar curDirection = nativeObject.currentDirection;\ndocument.getElementById('P13').innerHTML =\nDirection[curDirection];\n```\n\nBoth C# and Visual Basic have language support for enums. These languages see a C++ public enum class just as they would see a .NET Framework enum.\n\n## Asynchronous methods\n\n\nTo consume asynchronous methods that are exposed by other Windows Runtime objects, use the [task Class (Concurrency Runtime)](https://msdn.microsoft.com/library/hh750113.aspx). For more information, see and [Task Parallelism (Concurrency Runtime)](https://msdn.microsoft.com/library/dd492427.aspx).\n\nTo implement asynchronous methods in C++, use the [create\\_async](https://msdn.microsoft.com/library/hh750102.aspx) function that's defined in ppltasks.h. For more information, see [Creating Asynchronous Operations in C++ for Windows Store Apps](https://msdn.microsoft.com/library/vstudio/hh750082.aspx). For an example, see [Walkthrough: Creating a basic Windows Runtime component in C++ and calling it from JavaScript or C#](walkthrough-creating-a-basic-windows-runtime-component-in-cpp-and-calling-it-from-javascript-or-csharp.md). The .NET languages consume C++ asynchronous methods just as they would any asynchronous method that's defined in the .NET Framework.\n\n## Exceptions\n\n\nYou can throw any exception type that's defined by the Windows Runtime. You cannot derive custom types from any Windows Runtime exception type. However, you can throw COMException and provide a custom HRESULT that can be accessed by the code that catches the exception. There's no way to specify a custom Message in a COMException.\n\n## Debugging tips\n\n\nWhen you debug a JavaScript solution that has a component DLL, you can set the debugger to enable either stepping through script, or stepping through native code in the component, but not both at the same time. To change the setting, select the JavaScript project node in Solution Explorer and then choose Properties, Debugging, Debugger Type.\n\nBe sure to select appropriate capabilities in the package designer. For example, if you are attempting to open an image file in the user's Pictures library by using the Windows Runtime APIs, be sure to select the Pictures Library check box in the Capabilities pane of the manifest designer.\n\nIf your JavaScript code doesn't seem to be recognizing the public properties or methods in the component, make sure that in JavaScript you are using camel casing. For example, the LogCalc C++ method must be referenced as logCalc in JavaScript.\n\nIf you remove a C++ Windows Runtime component project from a solution, you must also manually remove the project reference from the JavaScript project. Failure to do so prevents subsequent debug or build operations. If necessary, you can then add an assembly reference to the DLL.\n\n## Related topics\n\n* [Walkthrough: Creating a basic Windows Runtime component in C++ and calling it from JavaScript or C#](walkthrough-creating-a-basic-windows-runtime-component-in-cpp-and-calling-it-from-javascript-or-csharp.md)\n\n"}