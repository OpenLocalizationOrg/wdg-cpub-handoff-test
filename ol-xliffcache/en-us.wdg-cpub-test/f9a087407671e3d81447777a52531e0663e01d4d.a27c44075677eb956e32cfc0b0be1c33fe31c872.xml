{"nodes":[{"pos":[60,114],"content":"Sample data on the design surface, and for prototyping","needQuote":true,"needEscape":true,"nodes":[{"content":"Sample data on the design surface, and for prototyping","pos":[0,54]}]},{"pos":[128,322],"content":"It may be impossible or undesirable (perhaps for reasons of privacy or performance) for your app to display live data on the design surface in Microsoft Visual Studio or Blend for Visual Studio.","needQuote":true,"needEscape":true,"nodes":[{"content":"It may be impossible or undesirable (perhaps for reasons of privacy or performance) for your app to display live data on the design surface in Microsoft Visual Studio or Blend for Visual Studio.","pos":[0,194]}]},{"content":"Sample data on the design surface, and for prototyping","pos":[327,381]},{"content":"\\[ Updated for UWP apps on Windows 10.","pos":[477,515]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \\]","pos":[516,611],"source":" For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]"},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  The degree to which you need sample data—and how much it will help you—depends on whether your bindings use the <bpt id=\"p2\">[</bpt>{Binding} markup extension<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</ept> or the <bpt id=\"p3\">[</bpt>{x:Bind} markup extension<ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</ept>.","pos":[614,916],"source":"**Note**  The degree to which you need sample data—and how much it will help you—depends on whether your bindings use the [{Binding} markup extension](https://msdn.microsoft.com/library/windows/apps/Mt204782) or the [{x:Bind} markup extension](https://msdn.microsoft.com/library/windows/apps/Mt204783)."},{"content":"The techniques described in this topic are based on the use of a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DataContext<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208713)</ept>, so they're only appropriate for <bpt id=\"p3\">**</bpt>{Binding}<ept id=\"p3\">**</ept>.","pos":[917,1105],"source":" The techniques described in this topic are based on the use of a [**DataContext**](https://msdn.microsoft.com/library/windows/apps/BR208713), so they're only appropriate for **{Binding}**."},{"content":"But if you're using <bpt id=\"p1\">**</bpt>{x:Bind}<ept id=\"p1\">**</ept> then your bindings at least show placeholder values on the design surface (even for items controls), so you don't have quite the same need for sample data.","pos":[1106,1294],"source":" But if you're using **{x:Bind}** then your bindings at least show placeholder values on the design surface (even for items controls), so you don't have quite the same need for sample data."},{"content":"It may be impossible or undesirable (perhaps for reasons of privacy or performance) for your app to display live data on the design surface in Microsoft Visual Studio or Blend for Visual Studio.","pos":[1296,1490]},{"content":"In order to have your controls populated with data (so that you can work on your app's layout, templates, and other visual properties), there are various ways in which you can use design-time sample data.","pos":[1491,1695]},{"content":"Sample data can also be really useful and time-saving if you're building a sketch (or prototype) app.","pos":[1696,1797]},{"content":"You can use sample data in your sketch or prototype at run-time to illustrate your ideas without going as far as connecting to real, live data.","pos":[1798,1941]},{"content":"Setting DataContext in markup","pos":[1943,1972]},{"pos":[2004,2217],"content":"It's a fairly common developer practice to use imperative code (in code-behind) to set a page or user control's <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DataContext<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208713)</ept> to a view model instance.","source":"It's a fairly common developer practice to use imperative code (in code-behind) to set a page or user control's [**DataContext**](https://msdn.microsoft.com/library/windows/apps/BR208713) to a view model instance."},{"content":"But if you do that then your page isn't as \"designable\" as it could be.","pos":[2333,2404]},{"content":"The reason is that when your XAML page is opened in Visual Studio or Blend for Visual Studio, the imperative code that assigns the <bpt id=\"p1\">**</bpt>DataContext<ept id=\"p1\">**</ept> value is never run (in fact, none of your code-behind is executed).","pos":[2405,2619],"source":" The reason is that when your XAML page is opened in Visual Studio or Blend for Visual Studio, the imperative code that assigns the **DataContext** value is never run (in fact, none of your code-behind is executed)."},{"content":"The XAML tools do of course parse your markup and instantiate any objects declared in it, but they don't actually instantiate your page's type itself.","pos":[2620,2770]},{"content":"The result is that you won't see any data in your controls or in the <bpt id=\"p1\">**</bpt>Create Data Binding<ept id=\"p1\">**</ept> dialog, and your page will be more challenging to style and to lay out.","pos":[2771,2935],"source":" The result is that you won't see any data in your controls or in the **Create Data Binding** dialog, and your page will be more challenging to style and to lay out."},{"content":"Sparse design UI.","pos":[2939,2956]},{"content":"The first remedy to try is to comment out that <bpt id=\"p1\">**</bpt>DataContext<ept id=\"p1\">**</ept> assignment and set the <bpt id=\"p2\">**</bpt>DataContext<ept id=\"p2\">**</ept> in your page markup instead.","pos":[3006,3136],"source":"The first remedy to try is to comment out that **DataContext** assignment and set the **DataContext** in your page markup instead."},{"content":"That way, your live data shows up at design-time as well as at run-time.","pos":[3137,3209]},{"content":"To do this, first open your XAML page.","pos":[3210,3248]},{"content":"Then, in the <bpt id=\"p1\">**</bpt>Document Outline<ept id=\"p1\">**</ept> window, click the root designable element (usually with the label <bpt id=\"p2\">**</bpt>\\[Page\\]<ept id=\"p2\">**</ept>) to select it.","pos":[3249,3376],"source":" Then, in the **Document Outline** window, click the root designable element (usually with the label **\\[Page\\]**) to select it."},{"content":"In the <bpt id=\"p1\">**</bpt>Properties<ept id=\"p1\">**</ept> window, find the <bpt id=\"p2\">**</bpt>DataContext<ept id=\"p2\">**</ept> property (inside the Common category), and then click <bpt id=\"p3\">**</bpt>New<ept id=\"p3\">**</ept>.","pos":[3377,3494],"source":" In the **Properties** window, find the **DataContext** property (inside the Common category), and then click **New**."},{"content":"Click your view model type from the <bpt id=\"p1\">**</bpt>Select Object<ept id=\"p1\">**</ept> dialog box, and then click <bpt id=\"p2\">**</bpt>OK<ept id=\"p2\">**</ept>.","pos":[3495,3583],"source":" Click your view model type from the **Select Object** dialog box, and then click **OK**."},{"content":"UI for setting DataContext.","pos":[3587,3614]},{"content":"Here's what the resulting markup looks like.","pos":[3664,3708]},{"content":"And here’s what the design surface looks like now that your bindings can resolve.","pos":[3818,3899]},{"content":"Notice that the <bpt id=\"p1\">**</bpt>Path<ept id=\"p1\">**</ept> picker in the <bpt id=\"p2\">**</bpt>Create Data Binding<ept id=\"p2\">**</ept> dialog is now populated, based on the <bpt id=\"p3\">**</bpt>DataContext<ept id=\"p3\">**</ept> type and the properties that you can bind to.","pos":[3900,4062],"source":" Notice that the **Path** picker in the **Create Data Binding** dialog is now populated, based on the **DataContext** type and the properties that you can bind to."},{"content":"Designable UI.","pos":[4066,4080]},{"content":"The <bpt id=\"p1\">**</bpt>Create Data Binding<ept id=\"p1\">**</ept> dialog only needs a type to work from, but the bindings need the properties to be initialized with values.","pos":[4130,4264],"source":"The **Create Data Binding** dialog only needs a type to work from, but the bindings need the properties to be initialized with values."},{"content":"If you don't want to reach out to your cloud service at design-time (due to performance, paying for data transfer, privacy issues, that kind of thing) then your initialization code can check to see whether your app is running in a design tool (such as Visual Studio or Blend for Visual Studio) and in that case load sample data for use at design-time only.","pos":[4265,4621]},{"content":"You could use a view model locator if you need to pass parameters to your initialization code.","pos":[4782,4876]},{"content":"A view model locator is a class that you can put into app resources.","pos":[4877,4945]},{"content":"It has a property that exposes the view model, and your page's <bpt id=\"p1\">**</bpt>DataContext<ept id=\"p1\">**</ept> binds to that property.","pos":[4946,5048],"source":" It has a property that exposes the view model, and your page's **DataContext** binds to that property."},{"content":"Another pattern that the locator or the view model can use is dependency injection, which can construct a design-time or a run-time data provider (each of which implements a common interface), as applicable.","pos":[5049,5256]},{"content":"\"Sample data from class\", and design-time attributes","pos":[5258,5310]},{"content":"If for whatever reason none of the options in the previous section work for you then you still have plenty of design-time data options available via XAML tools features and design-time attributes.","pos":[5400,5596]},{"content":"One good option is the <bpt id=\"p1\">**</bpt>Create Sample Data from Class<ept id=\"p1\">**</ept> feature in Blend for Visual Studio.","pos":[5597,5689],"source":" One good option is the **Create Sample Data from Class** feature in Blend for Visual Studio."},{"content":"You can find that command on one of the buttons at the top of the <bpt id=\"p1\">**</bpt>Data<ept id=\"p1\">**</ept> panel.","pos":[5690,5771],"source":" You can find that command on one of the buttons at the top of the **Data** panel."},{"content":"All you need to do is to specify a class for the command to use.","pos":[5773,5837]},{"content":"The command then does two important things for you.","pos":[5838,5889]},{"content":"First, it generates a XAML file that contains sample data suitable for hydrating an instance of your chosen class and all of its members, recursively (in fact, the tooling works equally well with XAML or JSON files).","pos":[5890,6106]},{"content":"Second, it populates the <bpt id=\"p1\">**</bpt>Data<ept id=\"p1\">**</ept> panel with the schema of your chosen class.","pos":[6107,6184],"source":" Second, it populates the **Data** panel with the schema of your chosen class."},{"content":"You can then drag members from the <bpt id=\"p1\">**</bpt>Data<ept id=\"p1\">**</ept> panel onto the design surface to perform various tasks.","pos":[6185,6284],"source":" You can then drag members from the **Data** panel onto the design surface to perform various tasks."},{"content":"Depending on what you drag and where you drop it, you can add bindings to existing controls (using <bpt id=\"p1\">**</bpt>{Binding}<ept id=\"p1\">**</ept>), or create new controls and bind them at the same time.","pos":[6285,6454],"source":" Depending on what you drag and where you drop it, you can add bindings to existing controls (using **{Binding}**), or create new controls and bind them at the same time."},{"content":"In either case, the operation also sets a design-time data context (<bpt id=\"p1\">**</bpt>d:DataContext<ept id=\"p1\">**</ept>) for you (if one is not already set) on the layout root of your page.","pos":[6455,6610],"source":" In either case, the operation also sets a design-time data context (**d:DataContext**) for you (if one is not already set) on the layout root of your page."},{"content":"That design-time data context uses the <bpt id=\"p1\">**</bpt>d:DesignData<ept id=\"p1\">**</ept> attribute to get its sample data from the XAML file that was generated (which, by the way, you are free to find in your project and edit so that it contains the sample data you want).","pos":[6611,6850],"source":" That design-time data context uses the **d:DesignData** attribute to get its sample data from the XAML file that was generated (which, by the way, you are free to find in your project and edit so that it contains the sample data you want)."},{"content":"The various xmlns declarations mean that attributes with the <bpt id=\"p1\">**</bpt>d:<ept id=\"p1\">**</ept> prefix are interpreted only at design-time and are ignored at run-time.","pos":[7222,7361],"source":"The various xmlns declarations mean that attributes with the **d:** prefix are interpreted only at design-time and are ignored at run-time."},{"content":"So the <bpt id=\"p1\">**</bpt>d:DataContext<ept id=\"p1\">**</ept> attribute only affects the value of the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>DataContext<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/BR208713)</ept> property at design-time; it has no effect at run-time.","pos":[7362,7557],"source":" So the **d:DataContext** attribute only affects the value of the [**DataContext**](https://msdn.microsoft.com/library/windows/apps/BR208713) property at design-time; it has no effect at run-time."},{"content":"You can even set both <bpt id=\"p1\">**</bpt>d:DataContext<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>DataContext<ept id=\"p2\">**</ept> in markup if you like.","pos":[7558,7640],"source":" You can even set both **d:DataContext** and **DataContext** in markup if you like."},{"content":"<bpt id=\"p1\">**</bpt>d:DataContext<ept id=\"p1\">**</ept> will override at design-time, and <bpt id=\"p2\">**</bpt>DataContext<ept id=\"p2\">**</ept> will override at run-time.","pos":[7641,7735],"source":"**d:DataContext** will override at design-time, and **DataContext** will override at run-time."},{"content":"These same override rules apply to all design-time and run-time attributes.","pos":[7736,7811]},{"pos":[7813,8050],"content":"The <bpt id=\"p1\">**</bpt>d:DataContext<ept id=\"p1\">**</ept> attribute, and all other design-time attributes, are documented in the <bpt id=\"p2\">[</bpt>Design-Time Attributes<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?LinkId=272504)</ept> topic, which is still valid for Universal Windows Platform (UWP) apps.","source":"The **d:DataContext** attribute, and all other design-time attributes, are documented in the [Design-Time Attributes](http://go.microsoft.com/fwlink/p/?LinkId=272504) topic, which is still valid for Universal Windows Platform (UWP) apps."},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CollectionViewSource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209833)</ept> doesn't have a <bpt id=\"p3\">**</bpt>DataContext<ept id=\"p3\">**</ept> property, but it does have a <bpt id=\"p4\">**</bpt>Source<ept id=\"p4\">**</ept> property.","pos":[8052,8217],"source":"[**CollectionViewSource**](https://msdn.microsoft.com/library/windows/apps/BR209833) doesn't have a **DataContext** property, but it does have a **Source** property."},{"content":"Consequently, there's a <bpt id=\"p1\">**</bpt>d:Source<ept id=\"p1\">**</ept> property that you can use to set design-time-only sample data on a <bpt id=\"p2\">**</bpt>CollectionViewSource<ept id=\"p2\">**</ept>.","pos":[8218,8347],"source":" Consequently, there's a **d:Source** property that you can use to set design-time-only sample data on a **CollectionViewSource**."},{"pos":[8685,8930],"content":"For this to work, you would have a class named <ph id=\"ph1\">`Recordings : ObservableCollection&lt;Recording&gt;`</ph>, and you would edit the sample data XAML file so that it contains only a <bpt id=\"p1\">**</bpt>Recordings<ept id=\"p1\">**</ept> object (with <bpt id=\"p2\">**</bpt>Recording<ept id=\"p2\">**</ept> objects inside that), as shown here.","source":"For this to work, you would have a class named `Recordings : ObservableCollection<Recording>`, and you would edit the sample data XAML file so that it contains only a **Recordings** object (with **Recording** objects inside that), as shown here."},{"pos":[9587,9674],"content":"If you use a JSON sample data file instead of XAML, you must set the <bpt id=\"p1\">**</bpt>Type<ept id=\"p1\">**</ept> property.","source":"If you use a JSON sample data file instead of XAML, you must set the **Type** property."},{"content":"So far, we've been using <bpt id=\"p1\">**</bpt>d:DesignData<ept id=\"p1\">**</ept> to load design-time sample data from a XAML or JSON file.","pos":[9780,9879],"source":"So far, we've been using **d:DesignData** to load design-time sample data from a XAML or JSON file."},{"content":"An alternative to that is the <bpt id=\"p1\">**</bpt>d:DesignInstance<ept id=\"p1\">**</ept> markup extension, which indicates that the design-time source is based on the class specified by the <bpt id=\"p2\">**</bpt>Type<ept id=\"p2\">**</ept> property.","pos":[9880,10050],"source":" An alternative to that is the **d:DesignInstance** markup extension, which indicates that the design-time source is based on the class specified by the **Type** property."},{"content":"Here's an example.","pos":[10051,10069]}],"content":"---\nms.assetid: 089660A2-7CAE-4911-9994-F619C5D22287\ntitle: Sample data on the design surface, and for prototyping\ndescription: It may be impossible or undesirable (perhaps for reasons of privacy or performance) for your app to display live data on the design surface in Microsoft Visual Studio or Blend for Visual Studio.\n---\nSample data on the design surface, and for prototyping\n=============================================================================================\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\n**Note**  The degree to which you need sample data—and how much it will help you—depends on whether your bindings use the [{Binding} markup extension](https://msdn.microsoft.com/library/windows/apps/Mt204782) or the [{x:Bind} markup extension](https://msdn.microsoft.com/library/windows/apps/Mt204783). The techniques described in this topic are based on the use of a [**DataContext**](https://msdn.microsoft.com/library/windows/apps/BR208713), so they're only appropriate for **{Binding}**. But if you're using **{x:Bind}** then your bindings at least show placeholder values on the design surface (even for items controls), so you don't have quite the same need for sample data.\n\nIt may be impossible or undesirable (perhaps for reasons of privacy or performance) for your app to display live data on the design surface in Microsoft Visual Studio or Blend for Visual Studio. In order to have your controls populated with data (so that you can work on your app's layout, templates, and other visual properties), there are various ways in which you can use design-time sample data. Sample data can also be really useful and time-saving if you're building a sketch (or prototype) app. You can use sample data in your sketch or prototype at run-time to illustrate your ideas without going as far as connecting to real, live data.\n\nSetting DataContext in markup\n-----------------------------\n\nIt's a fairly common developer practice to use imperative code (in code-behind) to set a page or user control's [**DataContext**](https://msdn.microsoft.com/library/windows/apps/BR208713) to a view model instance.\n\n``` csharp\npublic MainPage()\n{\n    InitializeComponent();\n    this.DataContext = new BookstoreViewModel();\n}\n```\n\nBut if you do that then your page isn't as \"designable\" as it could be. The reason is that when your XAML page is opened in Visual Studio or Blend for Visual Studio, the imperative code that assigns the **DataContext** value is never run (in fact, none of your code-behind is executed). The XAML tools do of course parse your markup and instantiate any objects declared in it, but they don't actually instantiate your page's type itself. The result is that you won't see any data in your controls or in the **Create Data Binding** dialog, and your page will be more challenging to style and to lay out.\n\n![Sparse design UI.](images/displaying-data-in-the-designer-01.png)\n\nThe first remedy to try is to comment out that **DataContext** assignment and set the **DataContext** in your page markup instead. That way, your live data shows up at design-time as well as at run-time. To do this, first open your XAML page. Then, in the **Document Outline** window, click the root designable element (usually with the label **\\[Page\\]**) to select it. In the **Properties** window, find the **DataContext** property (inside the Common category), and then click **New**. Click your view model type from the **Select Object** dialog box, and then click **OK**.\n\n![UI for setting DataContext.](images/displaying-data-in-the-designer-02.png)\n\nHere's what the resulting markup looks like.\n\n``` xml\n<Page ... >\n    <Page.DataContext>\n        <local:BookstoreViewModel/>\n    </Page.DataContext>\n```\n\nAnd here’s what the design surface looks like now that your bindings can resolve. Notice that the **Path** picker in the **Create Data Binding** dialog is now populated, based on the **DataContext** type and the properties that you can bind to.\n\n![Designable UI.](images/displaying-data-in-the-designer-03.png)\n\nThe **Create Data Binding** dialog only needs a type to work from, but the bindings need the properties to be initialized with values. If you don't want to reach out to your cloud service at design-time (due to performance, paying for data transfer, privacy issues, that kind of thing) then your initialization code can check to see whether your app is running in a design tool (such as Visual Studio or Blend for Visual Studio) and in that case load sample data for use at design-time only.\n\n``` csharp\nif (Windows.ApplicationModel.DesignMode.DesignModeEnabled)\n{\n    // Load design-time books.\n}\nelse\n{\n    // Load books from a cloud service.\n}\n```\n\nYou could use a view model locator if you need to pass parameters to your initialization code. A view model locator is a class that you can put into app resources. It has a property that exposes the view model, and your page's **DataContext** binds to that property. Another pattern that the locator or the view model can use is dependency injection, which can construct a design-time or a run-time data provider (each of which implements a common interface), as applicable.\n\n\"Sample data from class\", and design-time attributes\n---------------------------------------------------------------------------------------\n\nIf for whatever reason none of the options in the previous section work for you then you still have plenty of design-time data options available via XAML tools features and design-time attributes. One good option is the **Create Sample Data from Class** feature in Blend for Visual Studio. You can find that command on one of the buttons at the top of the **Data** panel.\n\nAll you need to do is to specify a class for the command to use. The command then does two important things for you. First, it generates a XAML file that contains sample data suitable for hydrating an instance of your chosen class and all of its members, recursively (in fact, the tooling works equally well with XAML or JSON files). Second, it populates the **Data** panel with the schema of your chosen class. You can then drag members from the **Data** panel onto the design surface to perform various tasks. Depending on what you drag and where you drop it, you can add bindings to existing controls (using **{Binding}**), or create new controls and bind them at the same time. In either case, the operation also sets a design-time data context (**d:DataContext**) for you (if one is not already set) on the layout root of your page. That design-time data context uses the **d:DesignData** attribute to get its sample data from the XAML file that was generated (which, by the way, you are free to find in your project and edit so that it contains the sample data you want).\n\n``` xml\n<Page ...\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"d\">\n    <Grid ... d:DataContext=\"{d:DesignData /SampleData/RecordingViewModelSampleData.xaml}\"/>\n        <ListView ItemsSource=\"{Binding Recordings}\" ... />\n        ...\n    </Grid>\n</Page>\n```\n\nThe various xmlns declarations mean that attributes with the **d:** prefix are interpreted only at design-time and are ignored at run-time. So the **d:DataContext** attribute only affects the value of the [**DataContext**](https://msdn.microsoft.com/library/windows/apps/BR208713) property at design-time; it has no effect at run-time. You can even set both **d:DataContext** and **DataContext** in markup if you like. **d:DataContext** will override at design-time, and **DataContext** will override at run-time. These same override rules apply to all design-time and run-time attributes.\n\nThe **d:DataContext** attribute, and all other design-time attributes, are documented in the [Design-Time Attributes](http://go.microsoft.com/fwlink/p/?LinkId=272504) topic, which is still valid for Universal Windows Platform (UWP) apps.\n\n[**CollectionViewSource**](https://msdn.microsoft.com/library/windows/apps/BR209833) doesn't have a **DataContext** property, but it does have a **Source** property. Consequently, there's a **d:Source** property that you can use to set design-time-only sample data on a **CollectionViewSource**.\n\n``` xml\n    <Page.Resources>\n        <CollectionViewSource x:Name=\"RecordingsCollection\" Source=\"{Binding Recordings}\"\n            d:Source=\"{d:DesignData /SampleData/RecordingsSampleData.xaml}\"/>\n    </Page.Resources>\n\n    ...\n\n        <ListView ItemsSource=\"{Binding Source={StaticResource RecordingsCollection}}\" ... />\n    ...\n```\n\nFor this to work, you would have a class named `Recordings : ObservableCollection<Recording>`, and you would edit the sample data XAML file so that it contains only a **Recordings** object (with **Recording** objects inside that), as shown here.\n\n``` xml\n<Quickstart:Recordings xmlns:Quickstart=\"using:Quickstart\">\n    <Quickstart:Recording ArtistName=\"Mollis massa\" CompositionName=\"Cubilia metus\"\n        OneLineSummary=\"Morbi adipiscing sed\" ReleaseDateTime=\"01/01/1800 15:53:17\"/>\n    <Quickstart:Recording ArtistName=\"Vulputate nunc\" CompositionName=\"Parturient vestibulum\"\n        OneLineSummary=\"Dapibus praesent netus amet vestibulum\" ReleaseDateTime=\"01/01/1800 15:53:17\"/>\n    <Quickstart:Recording ArtistName=\"Phasellus accumsan\" CompositionName=\"Sit bibendum\"\n        OneLineSummary=\"Vestibulum egestas montes dictumst\" ReleaseDateTime=\"01/01/1800 15:53:17\"/>\n</Quickstart:Recordings>\n```\n\nIf you use a JSON sample data file instead of XAML, you must set the **Type** property.\n\n``` xml\n    d:Source=\"{d:DesignData /SampleData/RecordingsSampleData.json, Type=local:Recordings}\"\n```\n\nSo far, we've been using **d:DesignData** to load design-time sample data from a XAML or JSON file. An alternative to that is the **d:DesignInstance** markup extension, which indicates that the design-time source is based on the class specified by the **Type** property. Here's an example.\n\n``` xml\n    <CollectionViewSource x:Name=\"RecordingsCollection\" Source=\"{Binding Recordings}\"\n        d:Source=\"{d:DesignInstance Type=local:Recordings, IsDesignTimeCreatable=True}\"/>\n        ```\n\nThe **IsDesignTimeCreatable** property indicates that the design tool should actually create an instance of the class, which implies that the class has a public default constructor, and that it populates itself with data (either real or sample). If you don't set **IsDesignTimeCreatable** (or if you set it to **False**) then you won't get sample data displayed on the design surface. All the design tool does in that case is to parse the class for its bindable properties and display these in the the **Data** panel and in the **Create Data Binding** dialog.\n\nSample data for prototyping\n--------------------------------------------------------\n\nFor prototyping, you want sample data at both design-time and at run-time. For that use case, Blend for Visual Studio has the **New Sample Data** feature. You can find that command on one of the buttons at the top of the **Data** panel.\n\nInstead of specifying a class, you can actually design the schema of your sample data source right in the **Data** panel. You can also edit sample data values in the **Data** panel: there's no need to open and edit a file (although, you can still do that if you prefer).\n\nThe **New Sample Data** feature uses [**DataContext**](https://msdn.microsoft.com/library/windows/apps/BR208713), and not **d:DataContext**, so that the sample data is available when you run your sketch or prototype as well as while you're designing it. And the **Data** panel really speeds up your designing and binding tasks. For example, simply dragging a collection property from the **Data** panel onto the design surface generates a data-bound items control and the necessary templates, all ready to build and run.\n\n![Sample data for prototyping.](images/displaying-data-in-the-designer-04.png)\n\n \n\n \n\n\n\n\n"}