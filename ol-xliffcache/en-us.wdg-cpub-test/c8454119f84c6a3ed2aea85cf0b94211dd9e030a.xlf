<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="en-us" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-c5d768e</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">c8454119f84c6a3ed2aea85cf0b94211dd9e030a</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\optimize-performance-for-windows-store-direct3d-11-apps-with-coredispatcher.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">9fd799eaf5deb014b69dd7867d5ea7b75ba8c9cf</mda:meta><mda:meta type="olxliffhash">606eb2a716a5d31bf5e53c8d5ccdc22136e3cde7</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Optimize input latency for Universal Windows Platform (UWP) DirectX games</source>
					<target>Optimize input latency for Universal Windows Platform (UWP) DirectX games</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Input latency can significantly impact the experience of a game, and optimizing it can make a game feel more polished.</source>
					<target>Input latency can significantly impact the experience of a game, and optimizing it can make a game feel more polished.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Optimize input latency for Universal Windows Platform (UWP) DirectX games</source>
					<target>Optimize input latency for Universal Windows Platform (UWP) DirectX games</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Input latency can significantly impact the experience of a game, and optimizing it can make a game feel more polished.</source>
					<target>Input latency can significantly impact the experience of a game, and optimizing it can make a game feel more polished.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Additionally, proper input event optimization can improve battery life.</source>
					<target>Additionally, proper input event optimization can improve battery life.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>Learn how to choose the right CoreDispatcher input event processing options to make sure your game handles input as smoothly as possible.</source>
					<target>Learn how to choose the right CoreDispatcher input event processing options to make sure your game handles input as smoothly as possible.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Input latency</source>
					<target>Input latency</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>Input latency is the time it takes for the system to respond to user input.</source>
					<target>Input latency is the time it takes for the system to respond to user input.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>The response is often a change in what's displayed on the screen, or what's heard through audio feedback.</source>
					<target>The response is often a change in what's displayed on the screen, or what's heard through audio feedback.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>Every input event, whether it comes from a touch pointer, mouse pointer, or keyboard, generates a message to be processed by an event handler.</source>
					<target>Every input event, whether it comes from a touch pointer, mouse pointer, or keyboard, generates a message to be processed by an event handler.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Modern touch digitizers and gaming peripherals report input events at a minimum of 100 Hz per pointer, which means that apps can receive 100 events or more per second per pointer (or keystroke).</source>
					<target>Modern touch digitizers and gaming peripherals report input events at a minimum of 100 Hz per pointer, which means that apps can receive 100 events or more per second per pointer (or keystroke).</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>This rate of updates is amplified if multiple pointers are happening concurrently, or a higher precision input device is used (for example, a gaming mouse).</source>
					<target>This rate of updates is amplified if multiple pointers are happening concurrently, or a higher precision input device is used (for example, a gaming mouse).</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>The event message queue can fill up very quickly.</source>
					<target>The event message queue can fill up very quickly.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>It's important to understand the input latency demands of your game so that events are processed in a way that is best for the scenario.</source>
					<target>It's important to understand the input latency demands of your game so that events are processed in a way that is best for the scenario.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>There is no one solution for all games.</source>
					<target>There is no one solution for all games.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Power efficiency</source>
					<target>Power efficiency</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>In the context of input latency, "power efficiency" refers to how much a game uses the GPU.</source>
					<target>In the context of input latency, "power efficiency" refers to how much a game uses the GPU.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>A game that uses less GPU resources is more power efficient and allows for longer battery life.</source>
					<target>A game that uses less GPU resources is more power efficient and allows for longer battery life.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>This also holds true for the CPU.</source>
					<target>This also holds true for the CPU.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>If a game can draw the whole screen at less than 60 frames per second (currently, the maximum rendering speed on most displays) without degrading the user's experience, it will be more power efficient by drawing less often.</source>
					<target>If a game can draw the whole screen at less than 60 frames per second (currently, the maximum rendering speed on most displays) without degrading the user's experience, it will be more power efficient by drawing less often.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>Some games only update the screen in response to user input, so those games should not draw the same content repeatedly at 60 frames per second.</source>
					<target>Some games only update the screen in response to user input, so those games should not draw the same content repeatedly at 60 frames per second.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Choosing what to optimize for</source>
					<target>Choosing what to optimize for</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>When designing a DirectX app, you need to make some choices.</source>
					<target>When designing a DirectX app, you need to make some choices.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Does the app need to render 60 frames per second to present smooth animation, or does it only need to render in response to input?</source>
					<target>Does the app need to render 60 frames per second to present smooth animation, or does it only need to render in response to input?</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>Does it need to have the lowest possible input latency, or can it tolerate a little bit of delay?</source>
					<target>Does it need to have the lowest possible input latency, or can it tolerate a little bit of delay?</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>Will my users expect my app to be judicious about battery usage?</source>
					<target>Will my users expect my app to be judicious about battery usage?</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>The answers to these questions will likely align your app with one of the following scenarios:</source>
					<target>The answers to these questions will likely align your app with one of the following scenarios:</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>Render on demand.</source>
					<target>Render on demand.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Games in this category only need to update the screen in response to specific types of input.</source>
					<target>Games in this category only need to update the screen in response to specific types of input.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Power efficiency is excellent because the app doesn’t render identical frames repeatedly, and input latency is low because the app spends most of its time waiting for input.</source>
					<target>Power efficiency is excellent because the app doesn’t render identical frames repeatedly, and input latency is low because the app spends most of its time waiting for input.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Board games and news readers are examples of apps that might fall into this category.</source>
					<target>Board games and news readers are examples of apps that might fall into this category.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Render on demand with transient animations.</source>
					<target>Render on demand with transient animations.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>This scenario is similar to the first scenario except that certain types of input will start an animation that isn’t dependent on subsequent input from the user.</source>
					<target>This scenario is similar to the first scenario except that certain types of input will start an animation that isn’t dependent on subsequent input from the user.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>Power efficiency is good because the game doesn’t render identical frames repeatedly, and input latency is low while the game is not animating.</source>
					<target>Power efficiency is good because the game doesn’t render identical frames repeatedly, and input latency is low while the game is not animating.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Interactive children’s games and board games that animate each move are examples of apps that might fall into this category.</source>
					<target>Interactive children’s games and board games that animate each move are examples of apps that might fall into this category.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Render 60 frames per second.</source>
					<target>Render 60 frames per second.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>In this scenario, the game is constantly updating the screen.</source>
					<target>In this scenario, the game is constantly updating the screen.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Power efficiency is poor because it renders the maximum number of frames the display can present.</source>
					<target>Power efficiency is poor because it renders the maximum number of frames the display can present.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Input latency is high because DirectX blocks the thread while content is being presented.</source>
					<target>Input latency is high because DirectX blocks the thread while content is being presented.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>Doing so prevents the thread from sending more frames to the display than it can show to the user.</source>
					<target>Doing so prevents the thread from sending more frames to the display than it can show to the user.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>First person shooters, real-time strategy games, and physics-based games are examples of apps that might fall into this category.</source>
					<target>First person shooters, real-time strategy games, and physics-based games are examples of apps that might fall into this category.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>Render 60 frames per second and achieve the lowest possible input latency.</source>
					<target>Render 60 frames per second and achieve the lowest possible input latency.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>Similar to scenario 3, the app is constantly updating the screen, so power efficiency will be poor.</source>
					<target>Similar to scenario 3, the app is constantly updating the screen, so power efficiency will be poor.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>The difference is that the game responds to input on a separate thread, so that input processing isn’t blocked by presenting graphics to the display.</source>
					<target>The difference is that the game responds to input on a separate thread, so that input processing isn’t blocked by presenting graphics to the display.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Online multiplayer games, fighting games, or rhythm/timing games might fall into this category because they support move inputs within extremely tight event windows.</source>
					<target>Online multiplayer games, fighting games, or rhythm/timing games might fall into this category because they support move inputs within extremely tight event windows.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Implementation</source>
					<target>Implementation</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>Most DirectX games are driven by what is known as the game loop.</source>
					<target>Most DirectX games are driven by what is known as the game loop.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>The basic algorithm is to perform these steps until the user quits the game or app:</source>
					<target>The basic algorithm is to perform these steps until the user quits the game or app:</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Process input</source>
					<target>Process input</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>Update the game state</source>
					<target>Update the game state</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>Draw the game content</source>
					<target>Draw the game content</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>When the content of a DirectX game is rendered and ready to be presented to the screen, the game loop waits until the GPU is ready to receive a new frame before waking up to process input again.</source>
					<target>When the content of a DirectX game is rendered and ready to be presented to the screen, the game loop waits until the GPU is ready to receive a new frame before waking up to process input again.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>We’ll show the implementation of the game loop for each of the scenarios mentioned earlier by iterating on a simple jigsaw puzzle game.</source>
					<target>We’ll show the implementation of the game loop for each of the scenarios mentioned earlier by iterating on a simple jigsaw puzzle game.</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>The decision points, benefits, and tradeoffs discussed with each implementation can serve as a guide to help you optimize your apps for low latency input and power efficiency.</source>
					<target>The decision points, benefits, and tradeoffs discussed with each implementation can serve as a guide to help you optimize your apps for low latency input and power efficiency.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>Scenario 1: Render on demand</source>
					<target>Scenario 1: Render on demand</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>The first iteration of the jigsaw puzzle game only updates the screen when a user moves a puzzle piece.</source>
					<target>The first iteration of the jigsaw puzzle game only updates the screen when a user moves a puzzle piece.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>A user can either drag a puzzle piece into place or snap it into place by selecting it and then touching the correct destination.</source>
					<target>A user can either drag a puzzle piece into place or snap it into place by selecting it and then touching the correct destination.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>In the second case, the puzzle piece will jump to the destination with no animation or effects.</source>
					<target>In the second case, the puzzle piece will jump to the destination with no animation or effects.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh700505)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The code has a single-threaded game loop within the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IFrameworkView::Run</pc></pc> method that uses <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CoreProcessEventsOption::ProcessOneAndAllPending</pc>.</source>
					<target>The code has a single-threaded game loop within the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IFrameworkView::Run</pc></pc> method that uses <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CoreProcessEventsOption::ProcessOneAndAllPending</pc>.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>Using this option dispatches all currently available events in the queue.</source>
					<target>Using this option dispatches all currently available events in the queue.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>If no events are pending, the game loop waits until one appears.</source>
					<target>If no events are pending, the game loop waits until one appears.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>Scenario 2: Render on demand with transient animations</source>
					<target>Scenario 2: Render on demand with transient animations</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>In the second iteration, the game is modified so that when a user selects a puzzle piece and then touches the correct destination for that piece, it animates across the screen until it reaches its destination.</source>
					<target>In the second iteration, the game is modified so that when a user selects a puzzle piece and then touches the correct destination for that piece, it animates across the screen until it reaches its destination.</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>As before, the code has a single-threaded game loop that uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessOneAndAllPending</pc> to dispatch input events in the queue.</source>
					<target>As before, the code has a single-threaded game loop that uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessOneAndAllPending</pc> to dispatch input events in the queue.</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The difference now is that during an animation, the loop changes to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CoreProcessEventsOption::ProcessAllIfPresent</pc> so that it doesn’t wait for new input events.</source>
					<target>The difference now is that during an animation, the loop changes to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CoreProcessEventsOption::ProcessAllIfPresent</pc> so that it doesn’t wait for new input events.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208215)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If no events are pending, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ProcessEvents</pc></pc> returns immediately and allows the app to present the next frame in the animation.</source>
					<target>If no events are pending, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ProcessEvents</pc></pc> returns immediately and allows the app to present the next frame in the animation.</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When the animation is complete, the loop switches back to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessOneAndAllPending</pc> to limit screen updates.</source>
					<target>When the animation is complete, the loop switches back to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessOneAndAllPending</pc> to limit screen updates.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To support the transition between <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessOneAndAllPending</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ProcessAllIfPresent</pc>, the app must track state to know if it’s animating.</source>
					<target>To support the transition between <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessOneAndAllPending</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ProcessAllIfPresent</pc>, the app must track state to know if it’s animating.</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>In the jigsaw puzzle app, you do this by adding a new method that can be called during the game loop on the GameState class.</source>
					<target>In the jigsaw puzzle app, you do this by adding a new method that can be called during the game loop on the GameState class.</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>The animation branch of the game loop drives updates in the state of the animation by calling GameState’s new Update method.</source>
					<target>The animation branch of the game loop drives updates in the state of the animation by calling GameState’s new Update method.</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>Scenario 3: Render 60 frames per second</source>
					<target>Scenario 3: Render 60 frames per second</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>In the third iteration, the app displays a timer that shows the user how long they’ve been working on the puzzle.</source>
					<target>In the third iteration, the app displays a timer that shows the user how long they’ve been working on the puzzle.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>Because it displays the elapsed time up to the millisecond, it must render 60 frames per second to keep the display up to date.</source>
					<target>Because it displays the elapsed time up to the millisecond, it must render 60 frames per second to keep the display up to date.</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>As in scenarios 1 and 2, the app has a single-threaded game loop.</source>
					<target>As in scenarios 1 and 2, the app has a single-threaded game loop.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>The difference with this scenario is that because it’s always rendering, it no longer needs to track changes in the game state as was done in the first two scenarios.</source>
					<target>The difference with this scenario is that because it’s always rendering, it no longer needs to track changes in the game state as was done in the first two scenarios.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>As a result, it can default to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessAllIfPresent</pc> for processing events.</source>
					<target>As a result, it can default to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessAllIfPresent</pc> for processing events.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If no events are pending, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessEvents</pc> returns immediately and proceeds to render the next frame.</source>
					<target>If no events are pending, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessEvents</pc> returns immediately and proceeds to render the next frame.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>This approach is the easiest way to write a game because there’s no need to track additional state to determine when to render.</source>
					<target>This approach is the easiest way to write a game because there’s no need to track additional state to determine when to render.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>It achieves the fastest rendering possible along with reasonable input responsiveness on a timer interval.</source>
					<target>It achieves the fastest rendering possible along with reasonable input responsiveness on a timer interval.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>However, this ease of development comes with a price.</source>
					<target>However, this ease of development comes with a price.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>Rendering at 60 frames per second uses more power than rendering on demand.</source>
					<target>Rendering at 60 frames per second uses more power than rendering on demand.</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>It’s best to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessAllIfPresent</pc> when the game is changing what is displayed every frame.</source>
					<target>It’s best to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessAllIfPresent</pc> when the game is changing what is displayed every frame.</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>It also increases input latency by as much as 16.7 ms because the app is now blocking the game loop on the display’s sync interval instead of on <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessEvents</pc>.</source>
					<target>It also increases input latency by as much as 16.7 ms because the app is now blocking the game loop on the display’s sync interval instead of on <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessEvents</pc>.</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>Some input events might be dropped because the queue is only processed once per frame (60 Hz).</source>
					<target>Some input events might be dropped because the queue is only processed once per frame (60 Hz).</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Scenario 4: Render 60 frames per second and achieve the lowest possible input latency</source>
					<target>Scenario 4: Render 60 frames per second and achieve the lowest possible input latency</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Some games may be able to ignore or compensate for the increase in input latency seen in scenario 3.</source>
					<target>Some games may be able to ignore or compensate for the increase in input latency seen in scenario 3.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>However, if low input latency is critical to the game’s experience and sense of player feedback, games that render 60 frames per second need to process input on a separate thread.</source>
					<target>However, if low input latency is critical to the game’s experience and sense of player feedback, games that render 60 frames per second need to process input on a separate thread.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>The fourth iteration of the jigsaw puzzle game builds on scenario 3 by splitting the input processing and graphics rendering from the game loop into separate threads.</source>
					<target>The fourth iteration of the jigsaw puzzle game builds on scenario 3 by splitting the input processing and graphics rendering from the game loop into separate threads.</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>Having separate threads for each ensures that input is never delayed by graphics output; however, the code becomes more complex as a result.</source>
					<target>Having separate threads for each ensures that input is never delayed by graphics output; however, the code becomes more complex as a result.</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208215)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208217)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>In scenario 4, the input thread calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ProcessEvents</pc></pc> with <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CoreProcessEventsOption::ProcessUntilQuit</pc></pc>, which waits for new events and dispatches all available events.</source>
					<target>In scenario 4, the input thread calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ProcessEvents</pc></pc> with <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CoreProcessEventsOption::ProcessUntilQuit</pc></pc>, which waits for new events and dispatches all available events.</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208260)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>It continues this behavior until the window is closed or the game calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindow::Close</pc></pc>.</source>
					<target>It continues this behavior until the window is closed or the game calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindow::Close</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectX 11 and XAML App (Universal Windows)</pc> template in Microsoft Visual Studio 2015 splits the game loop into multiple threads in a similar fashion.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectX 11 and XAML App (Universal Windows)</pc> template in Microsoft Visual Studio 2015 splits the game loop into multiple threads in a similar fashion.</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn298460)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>It uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::UI::Core::CoreIndependentInputSource</pc></pc> object to start a thread dedicated to handling input and also creates a rendering thread independent of the XAML UI thread.</source>
					<target>It uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::UI::Core::CoreIndependentInputSource</pc></pc> object to start a thread dedicated to handling input and also creates a rendering thread independent of the XAML UI thread.</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](user-interface.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more details on these templates, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Create a Universal Windows Platform and DirectX game project from a template</pc>.</source>
					<target>For more details on these templates, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Create a Universal Windows Platform and DirectX game project from a template</pc>.</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>Additional ways to reduce input latency</source>
					<target>Additional ways to reduce input latency</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>Use waitable swap chains</source>
					<target>Use waitable swap chains</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>DirectX games respond to user input by updating what the user sees on-screen.</source>
					<target>DirectX games respond to user input by updating what the user sees on-screen.</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>On a 60 Hz display, the screen refreshes every 16.7 ms (1 second/60 frames).</source>
					<target>On a 60 Hz display, the screen refreshes every 16.7 ms (1 second/60 frames).</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>Figure 1 shows the approximate life cycle and response to an input event relative to the 16.7 ms refresh signal (VBlank) for an app that renders 60 frames per second:</source>
					<target>Figure 1 shows the approximate life cycle and response to an input event relative to the 16.7 ms refresh signal (VBlank) for an app that renders 60 frames per second:</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>Figure 1</source>
					<target>Figure 1</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>figure 1 input latency in directx</source>
					<target>figure 1 input latency in directx</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In Windows 8.1, DXGI introduced the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DXGI\_SWAP\_CHAIN\_FLAG\_FRAME\_LATENCY\_WAITABLE\_OBJECT</pc> flag for the swap chain, which allows apps to easily reduce this latency without requiring them to implement heuristics to keep the Present queue empty.</source>
					<target>In Windows 8.1, DXGI introduced the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DXGI\_SWAP\_CHAIN\_FLAG\_FRAME\_LATENCY\_WAITABLE\_OBJECT</pc> flag for the swap chain, which allows apps to easily reduce this latency without requiring them to implement heuristics to keep the Present queue empty.</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>Swap chains created with this flag are referred to as waitable swap chains.</source>
					<target>Swap chains created with this flag are referred to as waitable swap chains.</target>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>Figure 2 shows the approximate life cycle and response to an input event when using waitable swap chains:</source>
					<target>Figure 2 shows the approximate life cycle and response to an input event when using waitable swap chains:</target>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>Figure 2</source>
					<target>Figure 2</target>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>figure2 input latency in directx waitable</source>
					<target>figure2 input latency in directx waitable</target>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>What we see from these diagrams is that games can potentially reduce input latency by two full frames if they are capable of rendering and presenting each frame within the 16.7 ms budget defined by the display’s refresh rate.</source>
					<target>What we see from these diagrams is that games can potentially reduce input latency by two full frames if they are capable of rendering and presenting each frame within the 16.7 ms budget defined by the display’s refresh rate.</target>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>The jigsaw puzzle sample uses waitable swap chains and controls the Present queue limit by calling:</source>
					<target>The jigsaw puzzle sample uses waitable swap chains and controls the Present queue limit by calling:</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>