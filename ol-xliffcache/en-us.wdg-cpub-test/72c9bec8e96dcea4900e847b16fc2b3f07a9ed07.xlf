<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="en-us" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-c5d768e</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">72c9bec8e96dcea4900e847b16fc2b3f07a9ed07</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\layout\boxpanel-example-custom-panel.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">59cca17329b693da94b93671f6f2666dddeff240</mda:meta><mda:meta type="olxliffhash">686387ca912c65b70ac92a936034cde2d6573496</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Learn to write code for a custom Panel class, implementing ArrangeOverride and MeasureOverride methods, and using the Children property.</source>
					<target>Learn to write code for a custom Panel class, implementing ArrangeOverride and MeasureOverride methods, and using the Children property.</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>BoxPanel, an example custom panel</source>
					<target>BoxPanel, an example custom panel</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>BoxPanel, an example custom panel</source>
					<target>BoxPanel, an example custom panel</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Important APIs</source>
					<target>Important APIs</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Panel</source>
					<target>Panel</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>ArrangeOverride</source>
					<target>ArrangeOverride</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>MeasureOverride</source>
					<target>MeasureOverride</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227511)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208711)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br208730)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/br227514)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>Learn to write code for a custom <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Panel</pc></pc> class, implementing <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ArrangeOverride</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">MeasureOverride</pc></pc> methods, and using the <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Children</pc></pc> property.</source>
					<target>Learn to write code for a custom <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Panel</pc></pc> class, implementing <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ArrangeOverride</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">MeasureOverride</pc></pc> methods, and using the <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Children</pc></pc> property.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>The example code shows a custom panel implementation, but we don't devote a lot of time explaining the layout concepts that influence how you can customize a panel for different layout scenarios.</source>
					<target>The example code shows a custom panel implementation, but we don't devote a lot of time explaining the layout concepts that influence how you can customize a panel for different layout scenarios.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](custom-panels-overview.md)</data>
				</originalData>
				<segment state="initial">
					<source>If you want more info about these layout concepts and how they might apply to your particular layout scenario, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML custom panels overview</pc>.</source>
					<target>If you want more info about these layout concepts and how they might apply to your particular layout scenario, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML custom panels overview</pc>.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">panel</pc> is an object that provides a layout behavior for child elements it contains, when the XAML layout system runs and your app UI is rendered.</source>
					<target>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">panel</pc> is an object that provides a layout behavior for child elements it contains, when the XAML layout system runs and your app UI is rendered.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227511)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can define custom panels for XAML layout by deriving a custom class from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Panel</pc></pc> class.</source>
					<target>You can define custom panels for XAML layout by deriving a custom class from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Panel</pc></pc> class.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208711)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208730)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>You provide behavior for your panel by overriding the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ArrangeOverride</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MeasureOverride</pc></pc> methods, supplying logic that measures and arranges the child elements.</source>
					<target>You provide behavior for your panel by overriding the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ArrangeOverride</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MeasureOverride</pc></pc> methods, supplying logic that measures and arranges the child elements.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This example derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc>.</source>
					<target>This example derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc>.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>When you start from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ArrangeOverride</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">MeasureOverride</pc> methods don't have a starting behavior.</source>
					<target>When you start from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ArrangeOverride</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">MeasureOverride</pc> methods don't have a starting behavior.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Your code is providing the gateway by which child elements become known to the XAML layout system and get rendered in the UI.</source>
					<target>Your code is providing the gateway by which child elements become known to the XAML layout system and get rendered in the UI.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>So, it's really important that your code accounts for all child elements and follows the patterns the layout system expects.</source>
					<target>So, it's really important that your code accounts for all child elements and follows the patterns the layout system expects.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Your layout scenario</source>
					<target>Your layout scenario</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>When you define a custom panel, you're defining a layout scenario.</source>
					<target>When you define a custom panel, you're defining a layout scenario.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>A layout scenario is expressed through:</source>
					<target>A layout scenario is expressed through:</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>What the panel will do when it has child elements</source>
					<target>What the panel will do when it has child elements</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>When the panel has constraints on its own space</source>
					<target>When the panel has constraints on its own space</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>How the logic of the panel determines all the measurements, placement, positions, and sizings that eventually result in a rendered UI layout of children</source>
					<target>How the logic of the panel determines all the measurements, placement, positions, and sizings that eventually result in a rendered UI layout of children</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">`BoxPanel`</data>
				</originalData>
				<segment state="initial">
					<source>With that in mind, the <ph dataRef="id1" id="ph1" /> shown here is for a particular scenario.</source>
					<target>With that in mind, the <ph dataRef="id1" id="ph1" /> shown here is for a particular scenario.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>In the interest of keeping the code foremost in this example, we won't explain the scenario in detail yet, and instead concentrate on the steps needed and the coding patterns.</source>
					<target>In the interest of keeping the code foremost in this example, we won't explain the scenario in detail yet, and instead concentrate on the steps needed and the coding patterns.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#scenario)</data>
					<data id="id3">`BoxPanel`</data>
				</originalData>
				<segment state="initial">
					<source>If you want to know more about the scenario first, skip ahead to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">"The scenario for <ph dataRef="id3" id="ph1" />"</pc>, and then come back to the code.</source>
					<target>If you want to know more about the scenario first, skip ahead to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">"The scenario for <ph dataRef="id3" id="ph1" />"</pc>, and then come back to the code.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Start by deriving from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc></source>
					<target>Start by deriving from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc></target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227511)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Start by deriving a custom class from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Panel</pc></pc>.</source>
					<target>Start by deriving a custom class from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Panel</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3"> | </data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6"> | </data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>Probably the easiest way to do this is to define a separate code file for this class, using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Add</pc><ph dataRef="id3" id="ph1" /><pc dataRefEnd="id5" dataRefStart="id4" id="p2">New Item</pc><ph dataRef="id6" id="ph2" /><pc dataRefEnd="id8" dataRefStart="id7" id="p3">Class</pc> context menu options for a project from the <pc dataRefEnd="id10" dataRefStart="id9" id="p4">Solution Explorer</pc> in Microsoft Visual Studio.</source>
					<target>Probably the easiest way to do this is to define a separate code file for this class, using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Add</pc><ph dataRef="id3" id="ph1" /><pc dataRefEnd="id5" dataRefStart="id4" id="p2">New Item</pc><ph dataRef="id6" id="ph2" /><pc dataRefEnd="id8" dataRefStart="id7" id="p3">Class</pc> context menu options for a project from the <pc dataRefEnd="id10" dataRefStart="id9" id="p4">Solution Explorer</pc> in Microsoft Visual Studio.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">`BoxPanel`</data>
				</originalData>
				<segment state="initial">
					<source>Name the class (and file) <ph dataRef="id1" id="ph1" />.</source>
					<target>Name the class (and file) <ph dataRef="id1" id="ph1" />.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The template file for a class doesn't start with many <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using</pc> statements because it's not specifically for Universal Windows Platform (UWP) apps.</source>
					<target>The template file for a class doesn't start with many <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using</pc> statements because it's not specifically for Universal Windows Platform (UWP) apps.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>So first, add <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using</pc> statements.</source>
					<target>So first, add <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using</pc> statements.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The template file also starts with a few <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using</pc> statements that you probably don't need, and can be deleted.</source>
					<target>The template file also starts with a few <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using</pc> statements that you probably don't need, and can be deleted.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's a suggested list of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using</pc> statements that can resolve types you'll need for typical custom panel code:</source>
					<target>Here's a suggested list of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using</pc> statements that can resolve types you'll need for typical custom panel code:</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227511)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">`BoxPanel`</data>
				</originalData>
				<segment state="initial">
					<source>Now that you can resolve <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Panel</pc></pc>, make it the base class of <ph dataRef="id5" id="ph1" />.</source>
					<target>Now that you can resolve <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Panel</pc></pc>, make it the base class of <ph dataRef="id5" id="ph1" />.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">`BoxPanel`</data>
				</originalData>
				<segment state="initial">
					<source>Also, make <ph dataRef="id1" id="ph1" /> public:</source>
					<target>Also, make <ph dataRef="id1" id="ph1" /> public:</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>At the class level, define some <pc dataRefEnd="id2" dataRefStart="id1" id="p1">int</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">double</pc> values that will be shared by several of your logic functions, but which won't need to be exposed as public API.</source>
					<target>At the class level, define some <pc dataRefEnd="id2" dataRefStart="id1" id="p1">int</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">double</pc> values that will be shared by several of your logic functions, but which won't need to be exposed as public API.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">`maxrc`</data>
					<data id="id2">`rowcount`</data>
					<data id="id3">`colcount`</data>
					<data id="id4">`cellwidth`</data>
					<data id="id5">`cellheight`</data>
					<data id="id6">`maxcellheight`</data>
					<data id="id7">`aspectratio`</data>
				</originalData>
				<segment state="initial">
					<source>In the example, these are named: <ph dataRef="id1" id="ph1" />, <ph dataRef="id2" id="ph2" />, <ph dataRef="id3" id="ph3" />, <ph dataRef="id4" id="ph4" />, <ph dataRef="id5" id="ph5" />, <ph dataRef="id6" id="ph6" />, <ph dataRef="id7" id="ph7" />.</source>
					<target>In the example, these are named: <ph dataRef="id1" id="ph1" />, <ph dataRef="id2" id="ph2" />, <ph dataRef="id3" id="ph3" />, <ph dataRef="id4" id="ph4" />, <ph dataRef="id5" id="ph5" />, <ph dataRef="id6" id="ph6" />, <ph dataRef="id7" id="ph7" />.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>After you've done this, the complete code file looks like this (removing comments on <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using</pc>, now that you know why we have them):</source>
					<target>After you've done this, the complete code file looks like this (removing comments on <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using</pc>, now that you know why we have them):</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>From here on out, we'll be showing you one member definition at a time, be that a method override or something supporting such as a dependency property.</source>
					<target>From here on out, we'll be showing you one member definition at a time, be that a method override or something supporting such as a dependency property.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You can add these to the skeleton above in any order, and we won't be showing the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using</pc> statements or the definition of the class scope again in the snippets until we show the final code.</source>
					<target>You can add these to the skeleton above in any order, and we won't be showing the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using</pc> statements or the definition of the class scope again in the snippets until we show the final code.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>MeasureOverride</source>
					<target>MeasureOverride</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208730)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br227514)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The necessary pattern of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MeasureOverride</pc></pc> implementation is the loop through each element in <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Panel.Children</pc></pc>.</source>
					<target>The necessary pattern of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MeasureOverride</pc></pc> implementation is the loop through each element in <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Panel.Children</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208952)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Always call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Measure</pc></pc> method on each of these elements.</source>
					<target>Always call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Measure</pc></pc> method on each of these elements.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br225995)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Measure</pc> has a parameter of type <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Size</pc></pc>.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Measure</pc> has a parameter of type <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Size</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>What you're passing here is the size that your panel is committing to have available for that particular child element.</source>
					<target>What you're passing here is the size that your panel is committing to have available for that particular child element.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>So, before you can do the loop and start calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Measure</pc>, you need to know how much space each cell can devote.</source>
					<target>So, before you can do the loop and start calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Measure</pc>, you need to know how much space each cell can devote.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
				</originalData>
				<segment state="initial">
					<source>From the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MeasureOverride</pc> method itself, you have the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">availableSize</pc> value.</source>
					<target>From the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MeasureOverride</pc> method itself, you have the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">availableSize</pc> value.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>That is the size that the panel's parent used when it called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Measure</pc>, which was the trigger for this <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MeasureOverride</pc> being called in the first place.</source>
					<target>That is the size that the panel's parent used when it called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Measure</pc>, which was the trigger for this <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MeasureOverride</pc> being called in the first place.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>So a typical logic is to devise a scheme whereby each child element divides the space of the panel's overall <pc dataRefEnd="id2" dataRefStart="id1" id="p1">availableSize</pc>.</source>
					<target>So a typical logic is to devise a scheme whereby each child element divides the space of the panel's overall <pc dataRefEnd="id2" dataRefStart="id1" id="p1">availableSize</pc>.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You then pass each division of size to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Measure</pc> of each child element.</source>
					<target>You then pass each division of size to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Measure</pc> of each child element.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<originalData>
					<data id="id1">`BoxPanel`</data>
				</originalData>
				<segment state="initial">
					<source>How <ph dataRef="id1" id="ph1" /> divides size is fairly simple: it divides its space into a number of boxes that's largely controlled by the number of items.</source>
					<target>How <ph dataRef="id1" id="ph1" /> divides size is fairly simple: it divides its space into a number of boxes that's largely controlled by the number of items.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Boxes are sized based on row and column count and the available size.</source>
					<target>Boxes are sized based on row and column count and the available size.</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Sometimes one row or column from a square isn't needed, so it's dropped and the panel becomes a rectangle rather than square in terms of its row : column ratio.</source>
					<target>Sometimes one row or column from a square isn't needed, so it's dropped and the panel becomes a rectangle rather than square in terms of its row : column ratio.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#scenario)</data>
					<data id="id3">`BoxPanel`</data>
				</originalData>
				<segment state="initial">
					<source>For more info about how this logic was arrived at, skip ahead to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">"The scenario for <ph dataRef="id3" id="ph1" />"</pc>.</source>
					<target>For more info about how this logic was arrived at, skip ahead to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">"The scenario for <ph dataRef="id3" id="ph1" />"</pc>.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>So what does the measure pass do?</source>
					<target>So what does the measure pass do?</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208921)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208952)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>It sets a value for the read-only <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DesiredSize</pc></pc> property on each element where <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Measure</pc></pc> was called.</source>
					<target>It sets a value for the read-only <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DesiredSize</pc></pc> property on each element where <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Measure</pc></pc> was called.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Having a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DesiredSize</pc> value is possibly important once you get to the arrange pass, because the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DesiredSize</pc> communicates what the size can or should be when arranging and in the final rendering.</source>
					<target>Having a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DesiredSize</pc> value is possibly important once you get to the arrange pass, because the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DesiredSize</pc> communicates what the size can or should be when arranging and in the final rendering.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Even if you don't use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DesiredSize</pc> in your own logic, the system still needs it.</source>
					<target>Even if you don't use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DesiredSize</pc> in your own logic, the system still needs it.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>It's possible for this panel to be used when the height component of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">availableSize</pc> is unbounded.</source>
					<target>It's possible for this panel to be used when the height component of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">availableSize</pc> is unbounded.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>If that's true, the panel doesn't have a known height to divide.</source>
					<target>If that's true, the panel doesn't have a known height to divide.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>In this case, the logic for the measure pass informs each child that it doesn't have a bounded height, yet.</source>
					<target>In this case, the logic for the measure pass informs each child that it doesn't have a bounded height, yet.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br225995)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208952)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/hh763910)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>It does so by passing a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Size</pc></pc> to the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Measure</pc></pc> call for children where <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Size.Height</pc></pc> is infinite.</source>
					<target>It does so by passing a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Size</pc></pc> to the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Measure</pc></pc> call for children where <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Size.Height</pc></pc> is infinite.</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>That's legal.</source>
					<target>That's legal.</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208921)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br208718)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/br208751)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>When <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Measure</pc> is called, the logic is that the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DesiredSize</pc></pc> is set as the minimum of these: what was passed to <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Measure</pc>, or that element's natural size from factors such as explicitly-set <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Height</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Width</pc></pc>.</source>
					<target>When <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Measure</pc> is called, the logic is that the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DesiredSize</pc></pc> is set as the minimum of these: what was passed to <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Measure</pc>, or that element's natural size from factors such as explicitly-set <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Height</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Width</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br209635)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br208952)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>????The internal logic of <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">StackPanel</pc></pc> also has this behavior: <pc dataRefEnd="id8" dataRefStart="id7" id="p4">StackPanel</pc> passes an infinite dimension value to <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Measure</pc></pc> on children, indicating that there is no constraint on children in the orientation dimension.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>????The internal logic of <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">StackPanel</pc></pc> also has this behavior: <pc dataRefEnd="id8" dataRefStart="id7" id="p4">StackPanel</pc> passes an infinite dimension value to <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Measure</pc></pc> on children, indicating that there is no constraint on children in the orientation dimension.</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">StackPanel</pc> typically sizes itself dynamically, to accommodate all children in a stack that grows in that dimension.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">StackPanel</pc> typically sizes itself dynamically, to accommodate all children in a stack that grows in that dimension.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>??</source>
					<target>??</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br225995)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208730)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>However, the panel itself can't return a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Size</pc></pc> with an infinite value from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MeasureOverride</pc></pc>; that throws an exception during layout.</source>
					<target>However, the panel itself can't return a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Size</pc></pc> with an infinite value from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MeasureOverride</pc></pc>; that throws an exception during layout.</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>So, part of the logic is to find out the maximum height that any child requests, and use that height as the cell height in case that isn't coming from the panel's own size constraints already.</source>
					<target>So, part of the logic is to find out the maximum height that any child requests, and use that height as the cell height in case that isn't coming from the panel's own size constraints already.</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<originalData>
					<data id="id1">`LimitUnboundedSize`</data>
					<data id="id2">`cellheight`</data>
				</originalData>
				<segment state="initial">
					<source>Here's the helper function <ph dataRef="id1" id="ph1" /> that was referenced in previous code, which then takes that maximum cell height and uses it to give the panel a finite height to return, as well as assuring that <ph dataRef="id2" id="ph2" /> is a finite number before the arrange pass is initiated:</source>
					<target>Here's the helper function <ph dataRef="id1" id="ph1" /> that was referenced in previous code, which then takes that maximum cell height and uses it to give the panel a finite height to return, as well as assuring that <ph dataRef="id2" id="ph2" /> is a finite number before the arrange pass is initiated:</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>ArrangeOverride</source>
					<target>ArrangeOverride</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208711)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br227514)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The necessary pattern of an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ArrangeOverride</pc></pc> implementation is the loop through each element in <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Panel.Children</pc></pc>.</source>
					<target>The necessary pattern of an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ArrangeOverride</pc></pc> implementation is the loop through each element in <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Panel.Children</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208914)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Always call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Arrange</pc></pc> method on each of these elements.</source>
					<target>Always call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Arrange</pc></pc> method on each of these elements.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208730)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Note how there aren't as many calculations as in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MeasureOverride</pc></pc>; that's typical.</source>
					<target>Note how there aren't as many calculations as in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MeasureOverride</pc></pc>; that's typical.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208921)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The size of children is already known from the panel's own <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MeasureOverride</pc> logic, or from the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DesiredSize</pc></pc> value of each child set during the measure pass.</source>
					<target>The size of children is already known from the panel's own <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MeasureOverride</pc> logic, or from the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DesiredSize</pc></pc> value of each child set during the measure pass.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>However, we still need to decide the location within the panel where each child will appear.</source>
					<target>However, we still need to decide the location within the panel where each child will appear.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>In a typical panel, each child should render at a different position.</source>
					<target>In a typical panel, each child should render at a different position.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>A panel that creates overlapping elements isn't desirable for typical scenarios (although it's not out of the question to create panels that have purposeful overlaps, if that's really your intended scenario).</source>
					<target>A panel that creates overlapping elements isn't desirable for typical scenarios (although it's not out of the question to create panels that have purposeful overlaps, if that's really your intended scenario).</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>This panel arranges by the concept of rows and columns.</source>
					<target>This panel arranges by the concept of rows and columns.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>The number of rows and columns was already calculated (it was necessary for measurement).</source>
					<target>The number of rows and columns was already calculated (it was necessary for measurement).</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">`anchorPoint`</data>
				</originalData>
				<segment state="initial">
					<source>So now the shape of the rows and columns plus the known sizes of each cell contribute to the logic of defining a rendering position (the <ph dataRef="id1" id="ph1" />) for each element that this panel contains.</source>
					<target>So now the shape of the rows and columns plus the known sizes of each cell contribute to the logic of defining a rendering position (the <ph dataRef="id1" id="ph1" />) for each element that this panel contains.</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br225870)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br225995)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br225994)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>That <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Point</pc></pc>, along with the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Size</pc></pc> already known from measure, are used as the two components that construct a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Rect</pc></pc>.</source>
					<target>That <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Point</pc></pc>, along with the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Size</pc></pc> already known from measure, are used as the two components that construct a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Rect</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208914)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Rect</pc> is the input type for <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Arrange</pc></pc>.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Rect</pc> is the input type for <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Arrange</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Panels sometimes need to clip their content.</source>
					<target>Panels sometimes need to clip their content.</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208921)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208952)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>If they do, the clipped size is the size that's present in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DesiredSize</pc></pc>, because the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Measure</pc></pc> logic sets it as the minimum of what was passed to <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Measure</pc>, or other natural size factors.</source>
					<target>If they do, the clipped size is the size that's present in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DesiredSize</pc></pc>, because the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Measure</pc></pc> logic sets it as the minimum of what was passed to <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Measure</pc>, or other natural size factors.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208914)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>So you don't typically need to specifically check for clipping during <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Arrange</pc></pc>; the clipping just happens based on passing the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DesiredSize</pc> through to each <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Arrange</pc> call.</source>
					<target>So you don't typically need to specifically check for clipping during <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Arrange</pc></pc>; the clipping just happens based on passing the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DesiredSize</pc> through to each <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Arrange</pc> call.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>You don't always need a count while going through the loop if all the info you need for defining the rendering position is known by other means.</source>
					<target>You don't always need a count while going through the loop if all the info you need for defining the rendering position is known by other means.</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209267)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br227514)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Canvas</pc></pc> layout logic, the position in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Children</pc></pc> collection doesn't matter.</source>
					<target>For example, in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Canvas</pc></pc> layout logic, the position in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Children</pc></pc> collection doesn't matter.</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh759771)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/hh759772)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>All the info needed to position each element in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Canvas</pc> is known by reading <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Canvas.Left</pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Canvas.Top</pc></pc> values of children as part of the arrange logic.</source>
					<target>All the info needed to position each element in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Canvas</pc> is known by reading <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Canvas.Left</pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Canvas.Top</pc></pc> values of children as part of the arrange logic.</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">`BoxPanel`</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
					<data id="id5">*</data>
				</originalData>
				<segment state="initial">
					<source>The <ph dataRef="id1" id="ph1" /> logic happens to need a count to compare to the <pc dataRefEnd="id3" dataRefStart="id2" id="p1">colcount</pc> so it's known when to begin a new row and offset the <pc dataRefEnd="id5" dataRefStart="id4" id="p2">y</pc> value.</source>
					<target>The <ph dataRef="id1" id="ph1" /> logic happens to need a count to compare to the <pc dataRefEnd="id3" dataRefStart="id2" id="p1">colcount</pc> so it's known when to begin a new row and offset the <pc dataRefEnd="id5" dataRefStart="id4" id="p2">y</pc> value.</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br225995)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/br208711)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>It's typical that the input <pc dataRefEnd="id2" dataRefStart="id1" id="p1">finalSize</pc> and the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Size</pc></pc> you return from a <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ArrangeOverride</pc></pc> implementation are the same.</source>
					<target>It's typical that the input <pc dataRefEnd="id2" dataRefStart="id1" id="p1">finalSize</pc> and the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Size</pc></pc> you return from a <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ArrangeOverride</pc></pc> implementation are the same.</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](custom-panels-overview.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about why, see "<pc dataRefEnd="id2" dataRefStart="id1" id="p1">ArrangeOverride</pc>" section of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">XAML custom panels overview</pc>.</source>
					<target>For more info about why, see "<pc dataRefEnd="id2" dataRefStart="id1" id="p1">ArrangeOverride</pc>" section of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">XAML custom panels overview</pc>.</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>A refinement: controlling the row vs. column count</source>
					<target>A refinement: controlling the row vs. column count</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>You could compile and use this panel just as it is now.</source>
					<target>You could compile and use this panel just as it is now.</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>However, we'll add one more refinement.</source>
					<target>However, we'll add one more refinement.</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>In the code just shown, the logic puts the extra row or column on the side that's longest in aspect ratio.</source>
					<target>In the code just shown, the logic puts the extra row or column on the side that's longest in aspect ratio.</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>But for greater control over the shapes of cells, it might be desirable to choose a 4??3 set of cells instead of 3??4 even if the panel's own aspect ratio is "portrait."</source>
					<target>But for greater control over the shapes of cells, it might be desirable to choose a 4??3 set of cells instead of 3??4 even if the panel's own aspect ratio is "portrait."</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>So we'll add an optional dependency property that the panel consumer can set to control that behavior.</source>
					<target>So we'll add an optional dependency property that the panel consumer can set to control that behavior.</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>Here's the dependency property definition, which is very basic:</source>
					<target>Here's the dependency property definition, which is very basic:</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<originalData>
					<data id="id1">`UseOppositeRCRatio`</data>
				</originalData>
				<segment state="initial">
					<source>And here's how using <ph dataRef="id1" id="ph1" /> impacts the measure logic.</source>
					<target>And here's how using <ph dataRef="id1" id="ph1" /> impacts the measure logic.</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<originalData>
					<data id="id1">`rowcount`</data>
					<data id="id2">`colcount`</data>
					<data id="id3">`maxrc`</data>
				</originalData>
				<segment state="initial">
					<source>Really all it's doing is changing how <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> are derived from <ph dataRef="id3" id="ph3" /> and the true aspect ratio, and there are corresponding size differences for each cell because of that.</source>
					<target>Really all it's doing is changing how <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> are derived from <ph dataRef="id3" id="ph3" /> and the true aspect ratio, and there are corresponding size differences for each cell because of that.</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<originalData>
					<data id="id1">`UseOppositeRCRatio`</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
				</originalData>
				<segment state="initial">
					<source>When <ph dataRef="id1" id="ph1" /> is <pc dataRefEnd="id3" dataRefStart="id2" id="p1">true</pc>, it inverts the value of the true aspect ratio before using it for row and column counts.</source>
					<target>When <ph dataRef="id1" id="ph1" /> is <pc dataRefEnd="id3" dataRefStart="id2" id="p1">true</pc>, it inverts the value of the true aspect ratio before using it for row and column counts.</target>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>The scenario for</source>
					<target>The scenario for</target>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<originalData>
					<data id="id1">`BoxPanel`</data>
				</originalData>
				<segment state="initial">
					<source>The particular scenario for <ph dataRef="id1" id="ph1" /> is that it's a panel where one of the main determinants of how to divide space is by knowing the number of child items, and dividing the known available space for the panel.</source>
					<target>The particular scenario for <ph dataRef="id1" id="ph1" /> is that it's a panel where one of the main determinants of how to divide space is by knowing the number of child items, and dividing the known available space for the panel.</target>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>Panels are innately rectangle shapes.</source>
					<target>Panels are innately rectangle shapes.</target>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242704)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Many panels operate by dividing that rectangle space into further rectangles; that's what <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Grid</pc></pc> does for its cells.</source>
					<target>Many panels operate by dividing that rectangle space into further rectangles; that's what <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Grid</pc></pc> does for its cells.</target>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br209324)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/br227606)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/hh759795)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
					<data id="id15">[</data>
					<data id="id16">](https://msdn.microsoft.com/library/windows/apps/hh759774)</data>
					<data id="id17">**</data>
					<data id="id18">**</data>
				</originalData>
				<segment state="initial">
					<source>In <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Grid</pc>'s case, the size of the cells is set by <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ColumnDefinition</pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">RowDefinition</pc></pc> values, and elements declare the exact cell they go into with <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Grid.Row</pc></pc> and <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">Grid.Column</pc></pc> attached properties.</source>
					<target>In <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Grid</pc>'s case, the size of the cells is set by <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ColumnDefinition</pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">RowDefinition</pc></pc> values, and elements declare the exact cell they go into with <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Grid.Row</pc></pc> and <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">Grid.Column</pc></pc> attached properties.</target>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Getting good layout from a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Grid</pc> usually requires knowing the number of child elements beforehand, so that there are enough cells and each child element sets its attached properties to fit into its own cell.</source>
					<target>Getting good layout from a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Grid</pc> usually requires knowing the number of child elements beforehand, so that there are enough cells and each child element sets its attached properties to fit into its own cell.</target>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>But what if the number of children is dynamic?</source>
					<target>But what if the number of children is dynamic?</target>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>That's certainly possible; your app code can add items to collections, in response to any dynamic run-time condition you consider to be important enough to be worth updating your UI.</source>
					<target>That's certainly possible; your app code can add items to collections, in response to any dynamic run-time condition you consider to be important enough to be worth updating your UI.</target>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt210946)</data>
				</originalData>
				<segment state="initial">
					<source>If you're using data binding to backing collections/business objects, getting such updates and updating the UI is handled automatically, so that's often the preferred technique (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>).</source>
					<target>If you're using data binding to backing collections/business objects, getting such updates and updating the UI is handled automatically, so that's often the preferred technique (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>).</target>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>But not all app scenarios lend themselves to data binding.</source>
					<target>But not all app scenarios lend themselves to data binding.</target>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<segment state="initial">
					<source>Sometimes, you need to create new UI elements at runtime and make them visible.</source>
					<target>Sometimes, you need to create new UI elements at runtime and make them visible.</target>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>is for this scenario.</source>
					<target>is for this scenario.</target>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<originalData>
					<data id="id1">`BoxPanel`</data>
				</originalData>
				<segment state="initial">
					<source>A changing number of child items is no problem for <ph dataRef="id1" id="ph1" /> because it's using the child count in calculations, and adjusts both the existing and new child elements into a new layout so they all fit.</source>
					<target>A changing number of child items is no problem for <ph dataRef="id1" id="ph1" /> because it's using the child count in calculations, and adjusts both the existing and new child elements into a new layout so they all fit.</target>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<originalData>
					<data id="id1">`BoxPanel`</data>
					<data id="id2">[</data>
					<data id="id3">](https://msdn.microsoft.com/library/windows/apps/br208921)</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
				</originalData>
				<segment state="initial">
					<source>An advanced scenario for extending <ph dataRef="id1" id="ph1" /> further (not shown here) could both accommodate dynamic children and use a child's <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">DesiredSize</pc></pc> as a stronger factor for the sizing of individual cells.</source>
					<target>An advanced scenario for extending <ph dataRef="id1" id="ph1" /> further (not shown here) could both accommodate dynamic children and use a child's <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">DesiredSize</pc></pc> as a stronger factor for the sizing of individual cells.</target>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>This scenario might use varying row or column sizes or non-grid shapes so that there's less "wasted" space.</source>
					<target>This scenario might use varying row or column sizes or non-grid shapes so that there's less "wasted" space.</target>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<segment state="initial">
					<source>This requires a strategy for how multiple rectangles of various sizes and aspect ratios can all fit into a containing rectangle both for aesthetics and smallest size.</source>
					<target>This requires a strategy for how multiple rectangles of various sizes and aspect ratios can all fit into a containing rectangle both for aesthetics and smallest size.</target>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<segment state="initial">
					<source>doesn't do that; it's using a simpler technique for dividing space.</source>
					<target>doesn't do that; it's using a simpler technique for dividing space.</target>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>'s technique is to determine the least square number that's greater than the child count.</source>
					<target>'s technique is to determine the least square number that's greater than the child count.</target>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>For example, 9 items would fit in a 3??3 square.</source>
					<target>For example, 9 items would fit in a 3??3 square.</target>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>10 items require a 4??4 square.</source>
					<target>10 items require a 4??4 square.</target>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<segment state="initial">
					<source>However, you can often fit items while still removing one row or column of the starting square, to save space.</source>
					<target>However, you can often fit items while still removing one row or column of the starting square, to save space.</target>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>In the count=10 example, that fits in a 4??3 or 3??4 rectangle.</source>
					<target>In the count=10 example, that fits in a 4??3 or 3??4 rectangle.</target>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>You might wonder why the panel wouldn't instead choose 5??2 for 10 items, because that fits the item number neatly.</source>
					<target>You might wonder why the panel wouldn't instead choose 5??2 for 10 items, because that fits the item number neatly.</target>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<segment state="initial">
					<source>However, in practice, panels are sized as rectangles that seldom have a strongly oriented aspect ratio.</source>
					<target>However, in practice, panels are sized as rectangles that seldom have a strongly oriented aspect ratio.</target>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>The least-squares technique is a way to bias the sizing logic to work well with typical layout shapes and not encourage sizing where the cell shapes get odd aspect ratios.</source>
					<target>The least-squares technique is a way to bias the sizing logic to work well with typical layout shapes and not encourage sizing where the cell shapes get odd aspect ratios.</target>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>????</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>????</target>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</source>
					<target>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</target>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>If you???re developing for Windows 8.x or Windows Phone 8.x, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archived documentation</pc>.</source>
					<target>If you???re developing for Windows 8.x or Windows Phone 8.x, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archived documentation</pc>.</target>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>??</source>
					<target>??</target>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
					<target>Related topics</target>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">
*</data>
					<data id="id4">[</data>
					<data id="id5">](https://msdn.microsoft.com/library/windows/apps/br208711)</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Reference</pc><ph dataRef="id3" id="ph1" /><pc dataRefEnd="id5" dataRefStart="id4" id="p2"><pc dataRefEnd="id7" dataRefStart="id6" id="p3">FrameworkElement.ArrangeOverride</pc></pc></source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Reference</pc><ph dataRef="id3" id="ph1" /><pc dataRefEnd="id5" dataRefStart="id4" id="p2"><pc dataRefEnd="id7" dataRefStart="id6" id="p3">FrameworkElement.ArrangeOverride</pc></pc></target>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>FrameworkElement.MeasureOverride</source>
					<target>FrameworkElement.MeasureOverride</target>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>Panel</source>
					<target>Panel</target>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>Concepts</source>
					<target>Concepts</target>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<segment state="initial">
					<source>Alignment, margin, and padding</source>
					<target>Alignment, margin, and padding</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>