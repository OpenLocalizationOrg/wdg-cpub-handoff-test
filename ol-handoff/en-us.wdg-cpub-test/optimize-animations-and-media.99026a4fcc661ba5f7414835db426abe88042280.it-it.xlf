<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="it-it" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">d490d2a7fb51e7008748809bc4822871e4193cca</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci\debug-test-perf\optimize-animations-and-media.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">93191466b3ae1dee0fba8b463204fd007089794d</mda:meta><mda:meta type="olxliffhash">ebd53f8254490c0a31a07082ea41da26120f6260</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Optimize animations, media, and images</source>
					<target>Optimize animations, media, and images</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>Create Universal Windows Platform (UWP) apps with smooth animations, high frame rate, and high-performance media capture and playback.</source>
					<target>Create Universal Windows Platform (UWP) apps with smooth animations, high frame rate, and high-performance media capture and playback.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<segment state="initial">
					<source>Make animations smooth</source>
					<target>Make animations smooth</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>A key aspect of UWP apps is smooth interactions.</source>
					<target>A key aspect of UWP apps is smooth interactions.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>This includes touch manipulations that "stick to your finger," smooth transitions and animations, and small motions that provide input feedback.</source>
					<target>This includes touch manipulations that "stick to your finger," smooth transitions and animations, and small motions that provide input feedback.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>In the XAML framework there is a thread called the composition thread that is dedicated to the composition and animation of an app’s visual elements.</source>
					<target>In the XAML framework there is a thread called the composition thread that is dedicated to the composition and animation of an app’s visual elements.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Because the composition thread is separate from UI thread (the thread that runs framework and developer code), apps can achieve a consistent frame rate and smooth animations regardless of complicated layout passes or extended calculations.</source>
					<target>Because the composition thread is separate from UI thread (the thread that runs framework and developer code), apps can achieve a consistent frame rate and smooth animations regardless of complicated layout passes or extended calculations.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>This section shows how to use the composition thread to keep an app’s animations buttery smooth.</source>
					<target>This section shows how to use the composition thread to keep an app’s animations buttery smooth.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt187350)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about animations, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Animations overview</pc>.</source>
					<target>For more info about animations, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Animations overview</pc>.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](keep-the-ui-thread-responsive.md)</data>
				</originalData>
				<segment state="initial">
					<source>To learn about increasing an app’s responsiveness while performing intensive computations, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Keep the UI thread responsive</pc>.</source>
					<target>To learn about increasing an app’s responsiveness while performing intensive computations, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Keep the UI thread responsive</pc>.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Use independent instead of dependent animations</source>
					<target>Use independent instead of dependent animations</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Independent animations can be calculated from beginning to end at the time of creation because changes to the property being animated don't affect rest of the objects in a scene.</source>
					<target>Independent animations can be calculated from beginning to end at the time of creation because changes to the property being animated don't affect rest of the objects in a scene.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>Independent animations can therefore run on the composition thread instead of the UI thread.</source>
					<target>Independent animations can therefore run on the composition thread instead of the UI thread.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>This guarantees that they remain smooth because the composition thread is updated at a consistent cadence.</source>
					<target>This guarantees that they remain smooth because the composition thread is updated at a consistent cadence.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>All of these types of animations are guaranteed to be independent:</source>
					<target>All of these types of animations are guaranteed to be independent:</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Object animations using key frames</source>
					<target>Object animations using key frames</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>Zero-duration animations</source>
					<target>Zero-duration animations</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh759771)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/Hh759772)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Animations to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Canvas.Left</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Canvas.Top</pc></pc> properties</source>
					<target>Animations to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Canvas.Left</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Canvas.Top</pc></pc> properties</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208962)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Animations to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement.Opacity</pc></pc> property</source>
					<target>Animations to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement.Opacity</pc></pc> property</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR228076)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242963)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Animations to properties of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Brush</pc></pc> when targeting the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SolidColorBrush.Color</pc></pc> subproperty</source>
					<target>Animations to properties of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Brush</pc></pc> when targeting the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SolidColorBrush.Color</pc></pc> subproperty</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Animations to the following <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> properties when targeting subproperties of these return value types:</source>
					<target>Animations to the following <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> properties when targeting subproperties of these return value types:</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>RenderTransform</source>
					<target>RenderTransform</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Projection</source>
					<target>Projection</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Clip</source>
					<target>Clip</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>Dependent animations affect layout, which therefore cannot be calculated without extra input from the UI thread.</source>
					<target>Dependent animations affect layout, which therefore cannot be calculated without extra input from the UI thread.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208751)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208718)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Dependent animations include modifications to properties like <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Width</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Height</pc></pc>.</source>
					<target>Dependent animations include modifications to properties like <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Width</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Height</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>By default, dependent animations are not run and require an opt-in from the app developer.</source>
					<target>By default, dependent animations are not run and require an opt-in from the app developer.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>When enabled, they run smoothly if the UI thread remains unblocked, but they begin to stutter if the framework or app is doing a lot of other work on the UI thread.</source>
					<target>When enabled, they run smoothly if the UI thread remains unblocked, but they begin to stutter if the framework or app is doing a lot of other work on the UI thread.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Almost all animations in the XAML framework are independent by default, but there are some actions that you can take to disable this optimization.</source>
					<target>Almost all animations in the XAML framework are independent by default, but there are some actions that you can take to disable this optimization.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Beware of these scenarios particularly:</source>
					<target>Beware of these scenarios particularly:</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR210356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Setting the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">EnableDependentAnimation</pc></pc> property to allow a dependent animation to run on the UI thread.</source>
					<target>Setting the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">EnableDependentAnimation</pc></pc> property to allow a dependent animation to run on the UI thread.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Convert these animations into an independent version.</source>
					<target>Convert these animations into an independent version.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242946)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242948)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR208751)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR208718)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>For example animate <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScaleTransform.ScaleX</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ScaleTransform.ScaleY</pc></pc> instead of the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Width</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Height</pc></pc> of an object.</source>
					<target>For example animate <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScaleTransform.ScaleX</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ScaleTransform.ScaleY</pc></pc> instead of the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Width</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Height</pc></pc> of an object.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>Don’t be afraid to scale objects like images and text.</source>
					<target>Don’t be afraid to scale objects like images and text.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242940)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The framework applies bilinear scaling only while the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScaleTransform</pc></pc> is being animated.</source>
					<target>The framework applies bilinear scaling only while the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScaleTransform</pc></pc> is being animated.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>The image/text will be rerasterized at the final size to ensure it’s always clear.</source>
					<target>The image/text will be rerasterized at the final size to ensure it’s always clear.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>Making per frame updates, which are effectively dependent animations.</source>
					<target>Making per frame updates, which are effectively dependent animations.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR228127)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>An example of this is applying transformations in the handler of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositonTarget.Rendering</pc></pc> event.</source>
					<target>An example of this is applying transformations in the handler of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositonTarget.Rendering</pc></pc> event.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911-cachemode)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Running any animation considered independent in an element with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CacheMode</pc></pc> property set to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">BitmapCache</pc>.</source>
					<target>Running any animation considered independent in an element with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CacheMode</pc></pc> property set to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">BitmapCache</pc>.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>This is considered dependent because the cache must be re-rasterized for each frame.</source>
					<target>This is considered dependent because the cache must be re-rasterized for each frame.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>Don't animate a WebView or MediaElement</source>
					<target>Don't animate a WebView or MediaElement</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227702)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Web content within a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">WebView</pc></pc> control is not directly rendered by the XAML framework and it requires extra work to be composed with the rest of the scene.</source>
					<target>Web content within a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">WebView</pc></pc> control is not directly rendered by the XAML framework and it requires extra work to be composed with the rest of the scene.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>This extra work adds up when animating the control around the screen and can potentially introduce synchronization issues (for example, the HTML content might not move in sync with the rest of the XAML content on the page).</source>
					<target>This extra work adds up when animating the control around the screen and can potentially introduce synchronization issues (for example, the HTML content might not move in sync with the rest of the XAML content on the page).</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR227702brush)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>When you need to animate a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">WebView</pc> control, swap it with a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">WebViewBrush</pc></pc> for the duration of the animation.</source>
					<target>When you need to animate a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">WebView</pc> control, swap it with a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">WebViewBrush</pc></pc> for the duration of the animation.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Animating a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> is a similarly bad idea.</source>
					<target>Animating a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> is a similarly bad idea.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Beyond the performance detriment, it can cause tearing or other artifacts in the video content being played.</source>
					<target>Beyond the performance detriment, it can cause tearing or other artifacts in the video content being played.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>Use infinite animations sparingly</source>
					<target>Use infinite animations sparingly</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243207)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Most animations execute for a specified amount of time, but setting the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Timeline.Duration</pc></pc> property to Forever allows an animation to run indefinitely.</source>
					<target>Most animations execute for a specified amount of time, but setting the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Timeline.Duration</pc></pc> property to Forever allows an animation to run indefinitely.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>We recommend minimizing the use of infinite animations because they continually consume CPU resources and can prevent the CPU from going into a low power or idle state, causing it to run out of power more quickly.</source>
					<target>We recommend minimizing the use of infinite animations because they continually consume CPU resources and can prevent the CPU from going into a low power or idle state, causing it to run out of power more quickly.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR228127)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Adding a handler for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionTarget.Rendering</pc></pc> is similar to running an infinite animation.</source>
					<target>Adding a handler for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionTarget.Rendering</pc></pc> is similar to running an infinite animation.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>Normally the UI thread is active only when there is work to do, but adding handler for this event forces it to run every frame.</source>
					<target>Normally the UI thread is active only when there is work to do, but adding handler for this event forces it to run every frame.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Remove the handler when there is no work to be done and reregister it when it’s needed again.</source>
					<target>Remove the handler when there is no work to be done and reregister it when it’s needed again.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Use the animation library</source>
					<target>Use the animation library</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243232)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Media.Animation</pc></pc> namespace includes a library of high-performance, smooth animations that have a look and feel consistent with other Windows animations.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Media.Animation</pc></pc> namespace includes a library of high-performance, smooth animations that have a look and feel consistent with other Windows animations.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt187350)</data>
				</originalData>
				<segment state="initial">
					<source>The relevant classes have "Theme" in their name, and are described in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Animations overview</pc>.</source>
					<target>The relevant classes have "Theme" in their name, and are described in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Animations overview</pc>.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>This library supports many common animation scenarios, such as animating the first view of the app and creating state and content transitions.</source>
					<target>This library supports many common animation scenarios, such as animating the first view of the app and creating state and content transitions.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>We recommend using this animation library whenever possible to increase performance and consistency for UWP UI.</source>
					<target>We recommend using this animation library whenever possible to increase performance and consistency for UWP UI.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The animation library can't animate all possible properties.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The animation library can't animate all possible properties.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt187354)</data>
				</originalData>
				<segment state="initial">
					<source>For XAML scenarios where the animation library doesn't apply, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc>.</source>
					<target>For XAML scenarios where the animation library doesn't apply, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc>.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>Animate CompositeTransform3D properties independently</source>
					<target>Animate CompositeTransform3D properties independently</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn914714)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can animate each property of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositeTransform3D</pc></pc> independently, so apply only the animations you need.</source>
					<target>You can animate each property of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositeTransform3D</pc></pc> independently, so apply only the animations you need.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911-transform3d)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For examples and more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement.Transform3D</pc></pc>.</source>
					<target>For examples and more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement.Transform3D</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt187354)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt187352)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about animating transforms, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Key-frame and easing function animations</pc>.</source>
					<target>For more info about animating transforms, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Key-frame and easing function animations</pc>.</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>Optimize media resources</source>
					<target>Optimize media resources</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Audio, video, and images are compelling forms of content that the majority of apps use.</source>
					<target>Audio, video, and images are compelling forms of content that the majority of apps use.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>As media capture rates increase and content moves from standard definition to high definition the amount of resources need to store, decode, and play back this content increases.</source>
					<target>As media capture rates increase and content moves from standard definition to high definition the amount of resources need to store, decode, and play back this content increases.</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>The XAML framework builds on the latest features added to the UWP media engines so apps get these improvements for free.</source>
					<target>The XAML framework builds on the latest features added to the UWP media engines so apps get these improvements for free.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>Here we explain some additional tricks that allow you to get the most out media in your UWP app.</source>
					<target>Here we explain some additional tricks that allow you to get the most out media in your UWP app.</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>Release media streams</source>
					<target>Release media streams</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>Media files are some of the most common and expensive resources apps typically use.</source>
					<target>Media files are some of the most common and expensive resources apps typically use.</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>Because media file resources can greatly increase the size of your app's memory footprint, you must remember to release the handle to media as soon as the app is finished using it.</source>
					<target>Because media file resources can greatly increase the size of your app's memory footprint, you must remember to release the handle to media as soon as the app is finished using it.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR241747)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR241718)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, if your app working with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RandomAccessStream</pc></pc> or an <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IInputStream</pc></pc> object, be sure to call the close method on the object when your app has finished using it, to release the underlying object.</source>
					<target>For example, if your app working with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RandomAccessStream</pc></pc> or an <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IInputStream</pc></pc> object, be sure to call the close method on the object when your app has finished using it, to release the underlying object.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>Display full screen video playback when possible</source>
					<target>Display full screen video playback when possible</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926-isfullwindow)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242926)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>In UWP apps, always use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsFullWindow</pc></pc> property on the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MediaElement</pc></pc> to enable and disable full window rendering.</source>
					<target>In UWP apps, always use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsFullWindow</pc></pc> property on the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MediaElement</pc></pc> to enable and disable full window rendering.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>This insures system level optimizations are used during media playback.</source>
					<target>This insures system level optimizations are used during media playback.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>The XAML framework can optimize the display of video content when it is the only thing being rendered, resulting in an experience that uses less power and yields higher frame rates.</source>
					<target>The XAML framework can optimize the display of video content when it is the only thing being rendered, resulting in an experience that uses less power and yields higher frame rates.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For most efficient media playback set the size of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> to be the width and height of the screen and don’t display other XAML elements</source>
					<target>For most efficient media playback set the size of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> to be the width and height of the screen and don’t display other XAML elements</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>There are legitimate reasons to overlay XAML elements on a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> that takes up the full width and height of the screen, for example closed captions or momentary transport controls.</source>
					<target>There are legitimate reasons to overlay XAML elements on a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> that takes up the full width and height of the screen, for example closed captions or momentary transport controls.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Making sure to hide these elements (eg.</source>
					<target>Making sure to hide these elements (eg.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>setting Visibility=”Collapsed”) when they are not needed pops media playback back into its most efficient state.</source>
					<target>setting Visibility=”Collapsed”) when they are not needed pops media playback back into its most efficient state.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>Display deactivation and conserving power</source>
					<target>Display deactivation and conserving power</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR241818)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To prevent the display from be deactivating when user action is no longer detected, such as when an app is playing video, you can call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayRequest.RequestActive</pc></pc>.</source>
					<target>To prevent the display from be deactivating when user action is no longer detected, such as when an app is playing video, you can call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayRequest.RequestActive</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR241819)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To conserve power and battery life, you should call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayRequest.RequestRelease</pc></pc> to release the display request as soon as it is no longer required.</source>
					<target>To conserve power and battery life, you should call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayRequest.RequestRelease</pc></pc> to release the display request as soon as it is no longer required.</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>Here are some situations when you should release the display request:</source>
					<target>Here are some situations when you should release the display request:</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Video playback is paused, for example by user action, buffering, or adjustment due to limited bandwidth.</source>
					<target>Video playback is paused, for example by user action, buffering, or adjustment due to limited bandwidth.</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Playback stops.</source>
					<target>Playback stops.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>For example, the video is done playing or the presentation is over.</source>
					<target>For example, the video is done playing or the presentation is over.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>A playback error has occurred.</source>
					<target>A playback error has occurred.</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>For example, network connectivity issues or a corrupted file.</source>
					<target>For example, network connectivity issues or a corrupted file.</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>Put other elements to the side of embedded video</source>
					<target>Put other elements to the side of embedded video</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>Often apps offer an embedded view where video is played within a page.</source>
					<target>Often apps offer an embedded view where video is played within a page.</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Now you obviously lost the full screen optimization because the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> is not the size of the page and there are other XAML objects drawn.</source>
					<target>Now you obviously lost the full screen optimization because the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> is not the size of the page and there are other XAML objects drawn.</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Beware of unintentionally entering this mode by drawing a border around a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaElement</pc>.</source>
					<target>Beware of unintentionally entering this mode by drawing a border around a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaElement</pc>.</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>Don’t draw XAML elements on top of video when it’s in embedded mode.</source>
					<target>Don’t draw XAML elements on top of video when it’s in embedded mode.</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>If you do, the framework is forced to do a little extra work to compose the scene.</source>
					<target>If you do, the framework is forced to do a little extra work to compose the scene.</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>Placing transport controls below an embedded media element instead of on top of the video is a good example of optimizing for this situation.</source>
					<target>Placing transport controls below an embedded media element instead of on top of the video is a good example of optimizing for this situation.</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>In this image, the red bar indicates a set of transport controls (play, pause, stop, etc.).</source>
					<target>In this image, the red bar indicates a set of transport controls (play, pause, stop, etc.).</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">](images/videowithoverlay.png)</data>
				</originalData>
				<segment state="initial">
					<source>MediaElement with overlaying elements<ph dataRef="id1" id="ph1" /> Don’t place these controls on top of media that is not full screen.</source>
					<target>MediaElement with overlaying elements<ph dataRef="id1" id="ph1" /> Don’t place these controls on top of media that is not full screen.</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>Instead place the transport controls somewhere outside of the area where the media is being rendered.</source>
					<target>Instead place the transport controls somewhere outside of the area where the media is being rendered.</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>In the next image, the controls are placed below the media.</source>
					<target>In the next image, the controls are placed below the media.</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>MediaElement with neighboring elements</source>
					<target>MediaElement with neighboring elements</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>Delay setting the source for a MediaElement</source>
					<target>Delay setting the source for a MediaElement</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>Media engines are expensive objects and the XAML framework delays loading dlls and creating large objects as long as possible.</source>
					<target>Media engines are expensive objects and the XAML framework delays loading dlls and creating large objects as long as possible.</target>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242926-source)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242926-setsource)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> is forced to do this work after its source is set via the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Source</pc></pc> property or the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">SetSource</pc></pc> method.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> is forced to do this work after its source is set via the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Source</pc></pc> property or the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">SetSource</pc></pc> method.</target>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Setting these when the user is really ready to play media delays the majority of the cost associated with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaElement</pc> as long as possible.</source>
					<target>Setting these when the user is really ready to play media delays the majority of the cost associated with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaElement</pc> as long as possible.</target>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>Set MediaElement.PosterSource</source>
					<target>Set MediaElement.PosterSource</target>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926-postersource)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement.PosterSource</pc></pc> enables XAML to release some GPU resources that would have otherwise been used.</source>
					<target>Setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement.PosterSource</pc></pc> enables XAML to release some GPU resources that would have otherwise been used.</target>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>This API allows an app to use as little memory as possible.</source>
					<target>This API allows an app to use as little memory as possible.</target>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>Improve media scrubbing</source>
					<target>Improve media scrubbing</target>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>Scrubbing is always a tough task for media platforms to make really responsive.</source>
					<target>Scrubbing is always a tough task for media platforms to make really responsive.</target>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>Generally people accomplish this by changing the value of a Slider.</source>
					<target>Generally people accomplish this by changing the value of a Slider.</target>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>Here are a couple tips on how to make this as efficient as possible:</source>
					<target>Here are a couple tips on how to make this as efficient as possible:</target>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209614)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242926-position)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Either bind the value of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Slider</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MediaElement.Position</pc></pc> or update it based on a timer.</source>
					<target>Either bind the value of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Slider</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MediaElement.Position</pc></pc> or update it based on a timer.</target>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<segment state="initial">
					<source>Don't do both.</source>
					<target>Don't do both.</target>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>If you choose the latter, make sure to use a reasonable update frequency for your timer.</source>
					<target>If you choose the latter, make sure to use a reasonable update frequency for your timer.</target>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The XAML framework only updates <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaElement.Position</pc> only every 250 milliseconds during playback.</source>
					<target>The XAML framework only updates <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaElement.Position</pc> only every 250 milliseconds during playback.</target>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>The size of the step frequency on the Slider must scale with the length of the video.</source>
					<target>The size of the step frequency on the Slider must scale with the length of the video.</target>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerpressed)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208911-pointermoved)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerreleased)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR242926-playbackrate)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>Subscribe to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerPressed</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PointerMoved</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PointerReleased</pc></pc> events on the slider to set the <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">MediaElement.PlaybackRate</pc></pc> property to 0 when the user drags the thumb of the slider.</source>
					<target>Subscribe to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerPressed</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PointerMoved</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PointerReleased</pc></pc> events on the slider to set the <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">MediaElement.PlaybackRate</pc></pc> property to 0 when the user drags the thumb of the slider.</target>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerreleased)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerReleased</pc></pc> event handler, manually set the media position to the slider position value to achieve optimal thumb snapping while scrubbing.</source>
					<target>In the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerReleased</pc></pc> event handler, manually set the media position to the slider position value to achieve optimal thumb snapping while scrubbing.</target>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<segment state="initial">
					<source>Match video resolution to device resolution</source>
					<target>Match video resolution to device resolution</target>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>Decoding video takes a lot of memory and GPU cycles, so choose a video format close to the resolution it will be displayed at.</source>
					<target>Decoding video takes a lot of memory and GPU cycles, so choose a video format close to the resolution it will be displayed at.</target>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>There is no point in using the resources to decode 1080 video if it’s going to get scaled down to a much smaller size.</source>
					<target>There is no point in using the resources to decode 1080 video if it’s going to get scaled down to a much smaller size.</target>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>Many apps don’t have the same video encoded at different resolutions; but if it is available, use an encoding that is close to the resolution at which it will be displayed.</source>
					<target>Many apps don’t have the same video encoded at different resolutions; but if it is available, use an encoding that is close to the resolution at which it will be displayed.</target>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<segment state="initial">
					<source>Choose recommended formats</source>
					<target>Choose recommended formats</target>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>Media format selection can be a sensitive topic and is often driven by business decisions.</source>
					<target>Media format selection can be a sensitive topic and is often driven by business decisions.</target>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>From a UWP performance perspective, we recommend H.264 video as the primary video format and AAC and MP3 as the preferred audio formats.</source>
					<target>From a UWP performance perspective, we recommend H.264 video as the primary video format and AAC and MP3 as the preferred audio formats.</target>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<segment state="initial">
					<source>For local file playback, MP4 is the preferred file container for video content.</source>
					<target>For local file playback, MP4 is the preferred file container for video content.</target>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>H.264 decoding is accelerated through most recent graphics hardware.</source>
					<target>H.264 decoding is accelerated through most recent graphics hardware.</target>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>Also, although hardware acceleration for VC-1 decoding is broadly available, for a large set of graphics hardware on the market, the acceleration is limited in many cases to a partial acceleration level (or IDCT level), rather than a full-steam level hardware offload (i.e. VLD mode).</source>
					<target>Also, although hardware acceleration for VC-1 decoding is broadly available, for a large set of graphics hardware on the market, the acceleration is limited in many cases to a partial acceleration level (or IDCT level), rather than a full-steam level hardware offload (i.e. VLD mode).</target>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>If you have full control of the video content generation process, you must figure out how to keep a good balance between compression efficiency and GOP structure.</source>
					<target>If you have full control of the video content generation process, you must figure out how to keep a good balance between compression efficiency and GOP structure.</target>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>Relatively smaller GOP size with B pictures can increase the performance in seeking or trick modes.</source>
					<target>Relatively smaller GOP size with B pictures can increase the performance in seeking or trick modes.</target>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>When including short, low-latency audio effects, for example in games, use WAV files with uncompressed PCM data to reduce processing overhead that is typical for compressed audio formats.</source>
					<target>When including short, low-latency audio effects, for example in games, use WAV files with uncompressed PCM data to reduce processing overhead that is typical for compressed audio formats.</target>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>Hardware audio offloading</source>
					<target>Hardware audio offloading</target>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926-audiocategory)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For hardware audio offload to be automatically applied, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement.AudioCategory</pc></pc> must be set to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ForegroundOnlyMedia</pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">BackgroundCapableMedia</pc>.</source>
					<target>For hardware audio offload to be automatically applied, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement.AudioCategory</pc></pc> must be set to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ForegroundOnlyMedia</pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">BackgroundCapableMedia</pc>.</target>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>Hardware audio offload optimizes audio rendering which can improve functionality and battery life.</source>
					<target>Hardware audio offload optimizes audio rendering which can improve functionality and battery life.</target>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>Optimize image resources</source>
					<target>Optimize image resources</target>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>Scale images to the appropriate size</source>
					<target>Scale images to the appropriate size</target>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<segment state="initial">
					<source>Images are captured at very high resolutions, which can lead to apps using more CPU when decoding the image data and more memory after it’s loaded from disk.</source>
					<target>Images are captured at very high resolutions, which can lead to apps using more CPU when decoding the image data and more memory after it’s loaded from disk.</target>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<segment state="initial">
					<source>But there’s no sense decoding and saving a high-resolution image in memory only to display it smaller than its native size.</source>
					<target>But there’s no sense decoding and saving a high-resolution image in memory only to display it smaller than its native size.</target>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243243)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR243241)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Instead, create a version of the image at the exact size it will be drawn on-screen using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelWidth</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc></pc> properties.</source>
					<target>Instead, create a version of the image at the exact size it will be drawn on-screen using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelWidth</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc></pc> properties.</target>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>Don't do this:</source>
					<target>Don't do this:</target>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<segment state="initial">
					<source>Instead, do this:</source>
					<target>Instead, do this:</target>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243243)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR243241)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The units for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelWidth</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc></pc> are by default physical pixels.</source>
					<target>The units for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelWidth</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc></pc> are by default physical pixels.</target>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn298545)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelType</pc></pc> property can be used to change this behavior: setting <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DecodePixelType</pc> to <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Logical</pc> results in the decode size automatically accounting for the system’s current scale factor, similar to other XAML content.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelType</pc></pc> property can be used to change this behavior: setting <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DecodePixelType</pc> to <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Logical</pc> results in the decode size automatically accounting for the system’s current scale factor, similar to other XAML content.</target>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>It would therefore be generally appropriate to set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DecodePixelType</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Logical</pc> if, for instance, you want <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DecodePixelWidth</pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc> to match the Height and Width properties of the Image control the image will be displayed in.</source>
					<target>It would therefore be generally appropriate to set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DecodePixelType</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Logical</pc> if, for instance, you want <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DecodePixelWidth</pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc> to match the Height and Width properties of the Image control the image will be displayed in.</target>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>With the default behavior of using physical pixels, you must account for the system’s current scale factor yourself; and you should listen for scale change notifications in case the user changes their display preferences.</source>
					<target>With the default behavior of using physical pixels, you must account for the system’s current scale factor yourself; and you should listen for scale change notifications in case the user changes their display preferences.</target>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>If DecodePixelWidth/Height are explicitly set larger than the image will be displayed on-screen then the app will unnecessarily use extra memory—up to 4 bytes per pixel—which quickly becomes expensive for large images.</source>
					<target>If DecodePixelWidth/Height are explicitly set larger than the image will be displayed on-screen then the app will unnecessarily use extra memory—up to 4 bytes per pixel—which quickly becomes expensive for large images.</target>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>The image will also be scaled down using bilinear scaling which could cause it to appear blurry for large scale factors.</source>
					<target>The image will also be scaled down using bilinear scaling which could cause it to appear blurry for large scale factors.</target>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>If DecodePixelWidth/DecodePixelHeight are explicitly set smaller than the image will be displayed on screen then it will be scaled up and could appear pixelated.</source>
					<target>If DecodePixelWidth/DecodePixelHeight are explicitly set smaller than the image will be displayed on screen then it will be scaled up and could appear pixelated.</target>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<segment state="initial">
					<source>In some cases where an appropriate decode size cannot be determined ahead of time, you should defer to XAML’s automatic right-size-decoding which will make a best effort attempt to decode the image at the appropriate size if an explicit DecodePixelWidth/DecodePixelHeight is not specified.</source>
					<target>In some cases where an appropriate decode size cannot be determined ahead of time, you should defer to XAML’s automatic right-size-decoding which will make a best effort attempt to decode the image at the appropriate size if an explicit DecodePixelWidth/DecodePixelHeight is not specified.</target>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>You should set an explicit decode size if you know the size of the image content ahead of time.</source>
					<target>You should set an explicit decode size if you know the size of the image content ahead of time.</target>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn298545)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>You should also in conjunction set <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelType</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Logical</pc> if the supplied decode size is relative to other XAML element sizes.</source>
					<target>You should also in conjunction set <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelType</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Logical</pc> if the supplied decode size is relative to other XAML element sizes.</target>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<segment state="initial">
					<source>For example, if you explicitly set the content size with Image.Width and Image.Height, you could set DecodePixelType to DecodePixelType.Logical to use the same logical pixel dimensions as an Image control and then explicitly use BitmapImage.DecodePixelWidth and/or BitmapImage.DecodePixelHeight to control the size of the image to achieve potentially large memory savings.</source>
					<target>For example, if you explicitly set the content size with Image.Width and Image.Height, you could set DecodePixelType to DecodePixelType.Logical to use the same logical pixel dimensions as an Image control and then explicitly use BitmapImage.DecodePixelWidth and/or BitmapImage.DecodePixelHeight to control the size of the image to achieve potentially large memory savings.</target>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>Note that Image.Stretch should be considered when determining the size of the decoded content.</source>
					<target>Note that Image.Stretch should be considered when determining the size of the decoded content.</target>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>Right-sized decoding</source>
					<target>Right-sized decoding</target>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>In the event that you don't set an explicit decode size, XAML will make a best effort attempt to save memory by decoding an image to the exact size it will appear on-screen according to the containing page’s initial layout.</source>
					<target>In the event that you don't set an explicit decode size, XAML will make a best effort attempt to save memory by decoding an image to the exact size it will appear on-screen according to the containing page’s initial layout.</target>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<segment state="initial">
					<source>You're advised to write your application in such a way as to make use of this feature when possible.</source>
					<target>You're advised to write your application in such a way as to make use of this feature when possible.</target>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<segment state="initial">
					<source>This feature will be disabled if any of the following conditions are met.</source>
					<target>This feature will be disabled if any of the following conditions are met.</target>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243235)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/JJ191522)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BitmapImage</pc></pc> is connected to the live XAML tree after setting the content with <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSourceAsync</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">UriSource</pc></pc>.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BitmapImage</pc></pc> is connected to the live XAML tree after setting the content with <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSourceAsync</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">UriSource</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243255)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The image is decoded using synchronous decoding such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetSource</pc></pc>.</source>
					<target>The image is decoded using synchronous decoding such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetSource</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208962)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208911-visibility)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>The image is hidden via setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Opacity</pc></pc> to 0 or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Visibility</pc></pc> to <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Collapsed</pc> on the host image element or brush or any parent element.</source>
					<target>The image is hidden via setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Opacity</pc></pc> to 0 or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Visibility</pc></pc> to <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Collapsed</pc> on the host image element or brush or any parent element.</target>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242968)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The image control or brush uses a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Stretch</pc></pc> of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">None</pc>.</source>
					<target>The image control or brush uses a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Stretch</pc></pc> of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">None</pc>.</target>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242756)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The image is used as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NineGrid</pc></pc>.</source>
					<target>The image is used as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NineGrid</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>is set on the image element or on any parent element.</source>
					<target>is set on the image element or on any parent element.</target>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>The image brush is non-rectangular (such as when applied to a shape or to text).</source>
					<target>The image brush is non-rectangular (such as when applied to a shape or to text).</target>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>In the above scenarios, setting an explicit decode size is the only way to achieve memory savings.</source>
					<target>In the above scenarios, setting an explicit decode size is the only way to achieve memory savings.</target>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243235)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You should always attach a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BitmapImage</pc></pc> to the live tree before setting the source.</source>
					<target>You should always attach a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BitmapImage</pc></pc> to the live tree before setting the source.</target>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<segment state="initial">
					<source>Any time an image element or brush is specified in markup, this will automatically be the case.</source>
					<target>Any time an image element or brush is specified in markup, this will automatically be the case.</target>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<segment state="initial">
					<source>Examples are provided below under the heading "Live tree examples".</source>
					<target>Examples are provided below under the heading "Live tree examples".</target>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243255)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/JJ191522)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>You should always avoid using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetSource</pc></pc> and instead use <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSourceAsync</pc></pc> when setting a stream source.</source>
					<target>You should always avoid using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetSource</pc></pc> and instead use <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSourceAsync</pc></pc> when setting a stream source.</target>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243235-imageopened)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>And it's a good idea to avoid hiding image content (either with zero opacity or with collapsed visibility) while waiting for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ImageOpened</pc></pc> event to be raised.</source>
					<target>And it's a good idea to avoid hiding image content (either with zero opacity or with collapsed visibility) while waiting for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ImageOpened</pc></pc> event to be raised.</target>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<segment state="initial">
					<source>Doing this is a judgment call: you won't benefit from automatic right-sized decoding if it's done.</source>
					<target>Doing this is a judgment call: you won't benefit from automatic right-sized decoding if it's done.</target>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<segment state="initial">
					<source>If your app must hide image content initially then it should also set the decode size explicitly if possible.</source>
					<target>If your app must hide image content initially then it should also set the decode size explicitly if possible.</target>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<segment state="initial">
					<source>Live tree examples</source>
					<target>Live tree examples</target>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<segment state="initial">
					<source>Example 1 (good)—Uniform Resource Identifier (URI) specified in markup.</source>
					<target>Example 1 (good)—Uniform Resource Identifier (URI) specified in markup.</target>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<segment state="initial">
					<source>Example 2 markup—URI specified in code-behind.</source>
					<target>Example 2 markup—URI specified in code-behind.</target>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>Example 2 code-behind (good)—connecting the BitmapImage to the tree before setting its UriSource.</source>
					<target>Example 2 code-behind (good)—connecting the BitmapImage to the tree before setting its UriSource.</target>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<segment state="initial">
					<source>Example 2 code-behind (bad)—setting the the BitmapImage's UriSource before connecting it to the tree.</source>
					<target>Example 2 code-behind (bad)—setting the the BitmapImage's UriSource before connecting it to the tree.</target>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>Caching optimizations</source>
					<target>Caching optimizations</target>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Caching optimizations are in effect for images that use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UriSource</pc></pc> to load content from an app package or from the web.</source>
					<target>Caching optimizations are in effect for images that use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UriSource</pc></pc> to load content from an app package or from the web.</target>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<segment state="initial">
					<source>The URI is used to uniquely identify the underlying content, and internally the XAML framework will not download or decode the content multiple times.</source>
					<target>The URI is used to uniquely identify the underlying content, and internally the XAML framework will not download or decode the content multiple times.</target>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<segment state="initial">
					<source>Instead, it will use the cached software or hardware resources to display the content multiple times.</source>
					<target>Instead, it will use the cached software or hardware resources to display the content multiple times.</target>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<segment state="initial">
					<source>The exception to this optimization is if the image is displayed multiple times at different resolutions (which can be specified explicitly or through automatic right-sized decoding).</source>
					<target>The exception to this optimization is if the image is displayed multiple times at different resolutions (which can be specified explicitly or through automatic right-sized decoding).</target>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<segment state="initial">
					<source>Each cache entry also stores the resolution of the image, and if XAML cannot find an image with a source URI that matches the required resolution then it will decode a new version at that size.</source>
					<target>Each cache entry also stores the resolution of the image, and if XAML cannot find an image with a source URI that matches the required resolution then it will decode a new version at that size.</target>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<segment state="initial">
					<source>It will not, however, download the encoded image data again.</source>
					<target>It will not, however, download the encoded image data again.</target>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/JJ191522)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Consequently, you should embrace using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UriSource</pc></pc> when loading images from an app package, and avoid using a file stream and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSourceAsync</pc></pc> when it's not required.</source>
					<target>Consequently, you should embrace using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UriSource</pc></pc> when loading images from an app package, and avoid using a file stream and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSourceAsync</pc></pc> when it's not required.</target>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<segment state="initial">
					<source>Images in virtualized panels (ListView, for instance)</source>
					<target>Images in virtualized panels (ListView, for instance)</target>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<segment state="initial">
					<source>If an image is removed from the tree—because the app explicitly removed it, or because it’s in a modern virtualized panel and was implicitly removed when scrolled out of view—then XAML will optimize memory usage by releasing the hardware resources for the image since they are no longer required.</source>
					<target>If an image is removed from the tree—because the app explicitly removed it, or because it’s in a modern virtualized panel and was implicitly removed when scrolled out of view—then XAML will optimize memory usage by releasing the hardware resources for the image since they are no longer required.</target>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<segment state="initial">
					<source>The memory is not released immediately, but rather is released during the frame update that occurs after one second of the image element no longer being in the tree.</source>
					<target>The memory is not released immediately, but rather is released during the frame update that occurs after one second of the image element no longer being in the tree.</target>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<segment state="initial">
					<source>Consequently, you should strive to use modern virtualized panels to host lists of image content.</source>
					<target>Consequently, you should strive to use modern virtualized panels to host lists of image content.</target>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<segment state="initial">
					<source>Software-rasterized images</source>
					<target>Software-rasterized images</target>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242756)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When an image is used for a non-rectangular brush or for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NineGrid</pc></pc>, the image will use a software rasterization path, which will not scale images at all.</source>
					<target>When an image is used for a non-rectangular brush or for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NineGrid</pc></pc>, the image will use a software rasterization path, which will not scale images at all.</target>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<segment state="initial">
					<source>Additionally, it must store a copy of the image in both software and hardware memory.</source>
					<target>Additionally, it must store a copy of the image in both software and hardware memory.</target>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<segment state="initial">
					<source>For instance, if an image is used as a brush for an ellipse then the potentially large full image will be stored twice internally.</source>
					<target>For instance, if an image is used as a brush for an ellipse then the potentially large full image will be stored twice internally.</target>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NineGrid</pc> or a non-rectangular brush, then, your app should pre-scale its images to approximately the size they will be rendered at.</source>
					<target>When using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NineGrid</pc> or a non-rectangular brush, then, your app should pre-scale its images to approximately the size they will be rendered at.</target>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<segment state="initial">
					<source>Background thread image-loading</source>
					<target>Background thread image-loading</target>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<segment state="initial">
					<source>XAML has an internal optimization that allows it to decode the contents of an image asynchronously to a surface in hardware memory without requiring an intermediate surface in software memory.</source>
					<target>XAML has an internal optimization that allows it to decode the contents of an image asynchronously to a surface in hardware memory without requiring an intermediate surface in software memory.</target>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<segment state="initial">
					<source>This reduces peak memory usage and rendering latency.</source>
					<target>This reduces peak memory usage and rendering latency.</target>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>This feature will be disabled if any of the following conditions are met.</source>
					<target>This feature will be disabled if any of the following conditions are met.</target>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242756)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The image is used as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NineGrid</pc></pc>.</source>
					<target>The image is used as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NineGrid</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<segment state="initial">
					<source>is set on the image element or on any parent element.</source>
					<target>is set on the image element or on any parent element.</target>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<segment state="initial">
					<source>The image brush is non-rectangular (such as when applied to a shape or to text).</source>
					<target>The image brush is non-rectangular (such as when applied to a shape or to text).</target>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<segment state="initial">
					<source>SoftwareBitmapSource</source>
					<target>SoftwareBitmapSource</target>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn997854)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR226176)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SoftwareBitmapSource</pc></pc> class exchanges interoperable uncompressed images between different WinRT namespaces such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">BitmapDecoder</pc></pc>, camera APIs, and XAML.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SoftwareBitmapSource</pc></pc> class exchanges interoperable uncompressed images between different WinRT namespaces such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">BitmapDecoder</pc></pc>, camera APIs, and XAML.</target>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243259)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This class obviates an extra copy that would typically be necessary with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">WriteableBitmap</pc></pc>, and that helps reduce peak memory and source-to-screen latency.</source>
					<target>This class obviates an extra copy that would typically be necessary with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">WriteableBitmap</pc></pc>, and that helps reduce peak memory and source-to-screen latency.</target>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn887358)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/Ee719675)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SoftwareBitmap</pc></pc> that supplies source information can also be configured to use a custom <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IWICBitmap</pc></pc> to provide a reloadable backing store that allows the app to re-map memory as it sees fit.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SoftwareBitmap</pc></pc> that supplies source information can also be configured to use a custom <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IWICBitmap</pc></pc> to provide a reloadable backing store that allows the app to re-map memory as it sees fit.</target>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<segment state="initial">
					<source>This is an advanced C++ use case.</source>
					<target>This is an advanced C++ use case.</target>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn887358)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/Dn997854)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Your app should use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SoftwareBitmap</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SoftwareBitmapSource</pc></pc> to interoperate with other WinRT APIs that produce and consume images.</source>
					<target>Your app should use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SoftwareBitmap</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SoftwareBitmapSource</pc></pc> to interoperate with other WinRT APIs that produce and consume images.</target>
				</segment>
			</unit>
			<unit id="311" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR243259)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>And your app should use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SoftwareBitmapSource</pc> when loading uncompressed image data instead of using <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">WriteableBitmap</pc></pc>.</source>
					<target>And your app should use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SoftwareBitmapSource</pc> when loading uncompressed image data instead of using <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">WriteableBitmap</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="312" translate="yes">
				<segment state="initial">
					<source>Use GetThumbnailAsync for thumbnails</source>
					<target>Use GetThumbnailAsync for thumbnails</target>
				</segment>
			</unit>
			<unit id="313" translate="yes">
				<segment state="initial">
					<source>One use case for scaling images is creating thumbnails.</source>
					<target>One use case for scaling images is creating thumbnails.</target>
				</segment>
			</unit>
			<unit id="314" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243243)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR243241)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Although you could use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelWidth</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc></pc> to provide small versions of images, UWP provides even more efficient APIs for retrieving thumbnails.</source>
					<target>Although you could use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelWidth</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc></pc> to provide small versions of images, UWP provides even more efficient APIs for retrieving thumbnails.</target>
				</segment>
			</unit>
			<unit id="315" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227210)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetThumbnailAsync</pc></pc> provides the thumbnails for images that have the file system already cached.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetThumbnailAsync</pc></pc> provides the thumbnails for images that have the file system already cached.</target>
				</segment>
			</unit>
			<unit id="316" translate="yes">
				<segment state="initial">
					<source>This provides even better performance than the XAML APIs because the image doesn’t need to be opened or decoded.</source>
					<target>This provides even better performance than the XAML APIs because the image doesn’t need to be opened or decoded.</target>
				</segment>
			</unit>
			<unit id="317" translate="yes">
				<segment state="initial">
					<source>Decode images once</source>
					<target>Decode images once</target>
				</segment>
			</unit>
			<unit id="318" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242760)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To prevent images from being decoded more than once, assign the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Image.Source</pc></pc> property from an Uri rather than using memory streams.</source>
					<target>To prevent images from being decoded more than once, assign the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Image.Source</pc></pc> property from an Uri rather than using memory streams.</target>
				</segment>
			</unit>
			<unit id="319" translate="yes">
				<segment state="initial">
					<source>The XAML framework can associate the same Uri in multiple places with one decoded image, but it cannot do the same for multiple memory streams that contain the same data and creates a different decoded image for each memory stream.</source>
					<target>The XAML framework can associate the same Uri in multiple places with one decoded image, but it cannot do the same for multiple memory streams that contain the same data and creates a different decoded image for each memory stream.</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>