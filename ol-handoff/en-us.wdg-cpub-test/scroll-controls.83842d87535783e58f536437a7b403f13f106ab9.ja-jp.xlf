<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="ja-jp" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">ffff25c913c4dcdb12a23691b0814e3a165809d6</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\controls-and-patterns\scroll-controls.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">94e97daabb004a1c964be87c9de28fdab972974e</mda:meta><mda:meta type="olxliffhash">71c9dd96e12bff9b204e45601ffd387ea3c0e2b0</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Panning and scrolling allows users to reach content that extends beyond the bounds of the screen.</source>
					<target>Panning and scrolling allows users to reach content that extends beyond the bounds of the screen.</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Guidelines for scroll bars</source>
					<target>Guidelines for scroll bars</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Scroll bars</source>
					<target>Scroll bars</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>Important APIs</source>
					<target>Important APIs</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<segment state="initial">
					<source>ScrollViewer class</source>
					<target>ScrollViewer class</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>ZoomMode property</source>
					<target>ZoomMode property</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Panning and scrolling allows users to reach content that extends beyond the bounds of the screen.</source>
					<target>Panning and scrolling allows users to reach content that extends beyond the bounds of the screen.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>A scroll viewer control is composed of as much content as will fit in the viewport, and either one or two scroll bars.</source>
					<target>A scroll viewer control is composed of as much content as will fit in the viewport, and either one or two scroll bars.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Touch gestures can be used to pan and zoom (the scroll bars fade in only during manipulation), and the pointer can be used to scroll.</source>
					<target>Touch gestures can be used to pan and zoom (the scroll bars fade in only during manipulation), and the pointer can be used to scroll.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>The flick gesture pans with inertia.</source>
					<target>The flick gesture pans with inertia.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Windows: There are two panning display modes based on the input device detected: panning indicators for touch; and scroll bars for other input devices including mouse, touchpad, keyboard, and stylus.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Windows: There are two panning display modes based on the input device detected: panning indicators for touch; and scroll bars for other input devices including mouse, touchpad, keyboard, and stylus.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>A sample of what standard scroll bar and panning indicator controls look like</source>
					<target>A sample of what standard scroll bar and panning indicator controls look like</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Examples</source>
					<target>Examples</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.scrollviewer.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollViewer</pc></pc> enables content to be displayed in a smaller area than its actual size.</source>
					<target>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollViewer</pc></pc> enables content to be displayed in a smaller area than its actual size.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>When the content of the scroll viewer is not entirely visible, the scroll viewer displays scrollbars that the user can use to move the content area that is visible.</source>
					<target>When the content of the scroll viewer is not entirely visible, the scroll viewer displays scrollbars that the user can use to move the content area that is visible.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>The area that includes all of the content of the scroll viewer is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">extent</pc>.</source>
					<target>The area that includes all of the content of the scroll viewer is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">extent</pc>.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>The visible area of the content is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">viewport</pc>.</source>
					<target>The visible area of the content is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">viewport</pc>.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>A screenshot that illustrates the standard scrollbar control</source>
					<target>A screenshot that illustrates the standard scrollbar control</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>Create a scroll viewer</source>
					<target>Create a scroll viewer</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>This XAML shows how to place an image in a scroll viewer and enable zooming.</source>
					<target>This XAML shows how to place an image in a scroll viewer and enable zooming.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>ScrollViewer in a control template</source>
					<target>ScrollViewer in a control template</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>It's typical for a ScrollViewer control to exist as a composite part of other controls.</source>
					<target>It's typical for a ScrollViewer control to exist as a composite part of other controls.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.scrollcontentpresenter.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A ScrollViewer part, along with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollContentPresenter</pc></pc> class for support, will display a viewport along with scrollbars only when the host control's layout space is being constrained smaller than the expanded content size.</source>
					<target>A ScrollViewer part, along with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollContentPresenter</pc></pc> class for support, will display a viewport along with scrollbars only when the host control's layout space is being constrained smaller than the expanded content size.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.listview.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.gridview.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>This is often the case for lists, so <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> templates always include a ScrollViewer.</source>
					<target>This is often the case for lists, so <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> templates always include a ScrollViewer.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.textbox.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.richeditbox.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBox</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">RichEditBox</pc></pc> also include a ScrollViewer in their templates.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBox</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">RichEditBox</pc></pc> also include a ScrollViewer in their templates.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ScrollViewer</pc> part exists in a control, the host control often has built-in event handling for certain input events and manipulations that enable the content to scroll.</source>
					<target>When a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ScrollViewer</pc> part exists in a control, the host control often has built-in event handling for certain input events and manipulations that enable the content to scroll.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>For example, a GridView interprets a swipe gesture and this causes the content to scroll horizontally.</source>
					<target>For example, a GridView interprets a swipe gesture and this causes the content to scroll horizontally.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.pointerpressed.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The input events and raw manipulations that the host control receives are considered handled by the control, and lower-level events such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerPressed</pc></pc> won't be raised and won't bubble to any parent containers either.</source>
					<target>The input events and raw manipulations that the host control receives are considered handled by the control, and lower-level events such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerPressed</pc></pc> won't be raised and won't bubble to any parent containers either.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You can change some of the built-in control handling by overriding a control class and the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">On</pc>* virtual methods for events, or by retemplating the control.</source>
					<target>You can change some of the built-in control handling by overriding a control class and the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">On</pc>* virtual methods for events, or by retemplating the control.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>But in either case it's not trivial to reproduce the original default behavior, which is typically there so that the control reacts in expected ways to events and to a user's input actions and gestures.</source>
					<target>But in either case it's not trivial to reproduce the original default behavior, which is typically there so that the control reacts in expected ways to events and to a user's input actions and gestures.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>So you should consider whether you really need that input event to fire.</source>
					<target>So you should consider whether you really need that input event to fire.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>You might want to investigate whether there are other input events or gestures that are not being handled by the control, and use those in your app or control interaction design.</source>
					<target>You might want to investigate whether there are other input events or gestures that are not being handled by the control, and use those in your app or control interaction design.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>To make it possible for controls that include a ScrollViewer to influence some of the behavior and properties that are from within the ScrollViewer part, ScrollViewer defines a number of XAML attached properties that can be set in styles and used in template bindings.</source>
					<target>To make it possible for controls that include a ScrollViewer to influence some of the behavior and properties that are from within the ScrollViewer part, ScrollViewer defines a number of XAML attached properties that can be set in styles and used in template bindings.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](../xaml-platform/attached-properties-overview.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about attached properties, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Attached properties overview</pc>.</source>
					<target>For more info about attached properties, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Attached properties overview</pc>.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>ScrollViewer XAML attached properties</source>
					<target>ScrollViewer XAML attached properties</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>ScrollViewer defines the following XAML attached properties:</source>
					<target>ScrollViewer defines the following XAML attached properties:</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>ScrollViewer.BringIntoViewOnFocusChange</source>
					<target>ScrollViewer.BringIntoViewOnFocusChange</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>ScrollViewer.HorizontalScrollBarVisibility</source>
					<target>ScrollViewer.HorizontalScrollBarVisibility</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>ScrollViewer.HorizontalScrollMode</source>
					<target>ScrollViewer.HorizontalScrollMode</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>ScrollViewer.IsDeferredScrollingEnabled</source>
					<target>ScrollViewer.IsDeferredScrollingEnabled</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>ScrollViewer.IsHorizontalRailEnabled</source>
					<target>ScrollViewer.IsHorizontalRailEnabled</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>ScrollViewer.IsHorizontalScrollChainingEnabled</source>
					<target>ScrollViewer.IsHorizontalScrollChainingEnabled</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>ScrollViewer.IsScrollInertiaEnabled</source>
					<target>ScrollViewer.IsScrollInertiaEnabled</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>ScrollViewer.IsVerticalRailEnabled</source>
					<target>ScrollViewer.IsVerticalRailEnabled</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>ScrollViewer.IsVerticalScrollChainingEnabled</source>
					<target>ScrollViewer.IsVerticalScrollChainingEnabled</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>ScrollViewer.IsZoomChainingEnabled</source>
					<target>ScrollViewer.IsZoomChainingEnabled</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>ScrollViewer.IsZoomInertiaEnabled</source>
					<target>ScrollViewer.IsZoomInertiaEnabled</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>ScrollViewer.VerticalScrollBarVisibility</source>
					<target>ScrollViewer.VerticalScrollBarVisibility</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>ScrollViewer.VerticalScrollMode</source>
					<target>ScrollViewer.VerticalScrollMode</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>ScrollViewer.ZoomMode</source>
					<target>ScrollViewer.ZoomMode</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>These XAML attached properties are intended for cases where the ScrollViewer is implicit, such as when the ScrollViewer exists in the default template for a ListView or GridView, and you want to be able to influence the scrolling behavior of the control without accessing template parts.</source>
					<target>These XAML attached properties are intended for cases where the ScrollViewer is implicit, such as when the ScrollViewer exists in the default template for a ListView or GridView, and you want to be able to influence the scrolling behavior of the control without accessing template parts.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>For example, here's how to make the vertical scroll bars always visible for a ListView's built in scroll viewer.</source>
					<target>For example, here's how to make the vertical scroll bars always visible for a ListView's built in scroll viewer.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>For cases where a ScrollViewer is explicit in your XAML, as is shown in the example code, you don't need to use attached property syntax.</source>
					<target>For cases where a ScrollViewer is explicit in your XAML, as is shown in the example code, you don't need to use attached property syntax.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<originalData>
					<data id="id1">`&lt;ScrollViewer VerticalScrollBarVisibility="Visible"/&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>Just use attribute syntax, for example <ph dataRef="id1" id="ph1" />.</source>
					<target>Just use attribute syntax, for example <ph dataRef="id1" id="ph1" />.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Recommendations</source>
					<target>Recommendations</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Use one-axis panning for content regions that extend beyond one viewport boundary (vertical or horizontal).</source>
					<target>Use one-axis panning for content regions that extend beyond one viewport boundary (vertical or horizontal).</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>Use two-axis panning for content regions that extend beyond both viewport boundaries (vertical and horizontal).</source>
					<target>Use two-axis panning for content regions that extend beyond both viewport boundaries (vertical and horizontal).</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>Use the built-in scroll functionality in the list box, drop-down list, text input box, grid view, list view, and hub controls.</source>
					<target>Use the built-in scroll functionality in the list box, drop-down list, text input box, grid view, list view, and hub controls.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>With those controls, if there are too many items to show all at once, the user is able to scroll either horizontally or vertically over the list of items.</source>
					<target>With those controls, if there are too many items to show all at once, the user is able to scroll either horizontally or vertically over the list of items.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>If you want the user to pan in both directions around a larger area, and possibly to zoom, too, for example, if you want to allow the user to pan and zoom over a full-sized image (rather than an image sized to fit the screen) then place the image inside a scroll viewer.</source>
					<target>If you want the user to pan in both directions around a larger area, and possibly to zoom, too, for example, if you want to allow the user to pan and zoom over a full-sized image (rather than an image sized to fit the screen) then place the image inside a scroll viewer.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>If the user will scroll through a long passage of text, configure the scroll viewer to scroll vertically only.</source>
					<target>If the user will scroll through a long passage of text, configure the scroll viewer to scroll vertically only.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>Use a scroll viewer to contain one object only.</source>
					<target>Use a scroll viewer to contain one object only.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>Note that the one object can be a layout panel, in turn containing any number of objects of its own.</source>
					<target>Note that the one object can be a layout panel, in turn containing any number of objects of its own.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
					<target>Related topics</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>For developers (XAML)</source>
					<target>For developers (XAML)</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>ScrollViewer class</source>
					<target>ScrollViewer class</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>