<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">2e38cd45843a15226b1456fecd150523c2add6bc</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci1\debug-test-perf\listview-and-gridview-data-optimization.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">febbc0548d6241d5c846a4f8ec0f82c01dc06b0c</mda:meta><mda:meta type="olxliffhash">8016eb5708537a2fdab627b2219d0afc25f2c1d5</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>ListView and GridView data virtualization</source>
					<target>ListView and GridView data virtualization</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Improve ListView and GridView performance and startup time through data virtualization.</source>
					<target>Improve ListView and GridView performance and startup time through data virtualization.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>ListView and GridView data virtualization</source>
					<target>ListView and GridView data virtualization</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://channel9.msdn.com/Events/Build/2013/3-158)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For more details, see the //build/ session <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Dramatically Increase Performance when Users Interact with Large Amounts of Data in GridView and ListView</pc>.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For more details, see the //build/ session <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Dramatically Increase Performance when Users Interact with Large Amounts of Data in GridView and ListView</pc>.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242705)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Improve <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> performance and startup time through data virtualization.</source>
					<target>Improve <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> performance and startup time through data virtualization.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](optimize-gridview-and-listview.md)</data>
				</originalData>
				<segment state="initial">
					<source>For UI virtualization, element reduction, and progressive updating of items, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView and GridView UI optimization</pc>.</source>
					<target>For UI virtualization, element reduction, and progressive updating of items, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView and GridView UI optimization</pc>.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>A method of data virtualization is needed for a data set that is so large that it cannot or should not all be stored in memory at one time.</source>
					<target>A method of data virtualization is needed for a data set that is so large that it cannot or should not all be stored in memory at one time.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>You load an initial portion into memory (from local disk, network, or cloud) and apply UI virtualization to this partial data set.</source>
					<target>You load an initial portion into memory (from local disk, network, or cloud) and apply UI virtualization to this partial data set.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>You can later load data incrementally, or from arbitrary points in the master data set (random access), on demand.</source>
					<target>You can later load data incrementally, or from arbitrary points in the master data set (random access), on demand.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>Whether data virtualization is appropriate for you depends on many factors.</source>
					<target>Whether data virtualization is appropriate for you depends on many factors.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>The size of your data set</source>
					<target>The size of your data set</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>The size of each item</source>
					<target>The size of each item</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>The source of the data set (local disk, network, or cloud)</source>
					<target>The source of the data set (local disk, network, or cloud)</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>The overall memory consumption of your app</source>
					<target>The overall memory consumption of your app</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Be aware that a feature is enabled by default for ListView and GridView that displays temporary placeholder visuals while the user is panning/scrolling quickly.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Be aware that a feature is enabled by default for ListView and GridView that displays temporary placeholder visuals while the user is panning/scrolling quickly.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>As data is loaded, these placeholder visuals are replaced with your item template.</source>
					<target>As data is loaded, these placeholder visuals are replaced with your item template.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-showsscrollingplaceholders)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can turn the feature off by setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListViewBase.ShowsScrollingPlaceholders</pc></pc> to false, but if you do so then we recommend that you use the x:Phase attribute to progressively render the elements in your item template.</source>
					<target>You can turn the feature off by setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListViewBase.ShowsScrollingPlaceholders</pc></pc> to false, but if you do so then we recommend that you use the x:Phase attribute to progressively render the elements in your item template.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](optimize-gridview-and-listview.md#update-items-incrementally)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Update ListView and GridView items progressively</pc>.</source>
					<target>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Update ListView and GridView items progressively</pc>.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>Here are more details about the incremental and random-access data virtualization techniques.</source>
					<target>Here are more details about the incremental and random-access data virtualization techniques.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>Incremental data virtualization</source>
					<target>Incremental data virtualization</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>Incremental data virtualization loads data sequentially.</source>
					<target>Incremental data virtualization loads data sequentially.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> that uses incremental data virtualization may be used to view a collection of a million items, but only 50 items are loaded initially.</source>
					<target>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> that uses incremental data virtualization may be used to view a collection of a million items, but only 50 items are loaded initially.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>As the user pans/scrolls, the next 50 are loaded.</source>
					<target>As the user pans/scrolls, the next 50 are loaded.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>As items are loaded, the scroll bar's thumb decreases in size.</source>
					<target>As items are loaded, the scroll bar's thumb decreases in size.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>For this type of data virtualization you write a data source class that implements these interfaces.</source>
					<target>For this type of data virtualization you write a data source class that implements these interfaces.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>IList</source>
					<target>IList</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.Collections.Specialized.INotifyCollectionChanged)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR226052)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">&amp;lt;</data>
					<data id="id10">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc> (C#/VB) or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector<ph dataRef="id9" id="ph1" />T<ph dataRef="id10" id="ph2" /></pc></pc> (C++/CX)</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc> (C#/VB) or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector<ph dataRef="id9" id="ph1" />T<ph dataRef="id10" id="ph2" /></pc></pc> (C++/CX)</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>ISupportIncrementalLoading</source>
					<target>ISupportIncrementalLoading</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>A data source like this is an in-memory list that can be continually extended.</source>
					<target>A data source like this is an in-memory list that can be continually extended.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.Collections.IList)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The items control will ask for items using the standard <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IList</pc></pc> indexer and count properties.</source>
					<target>The items control will ask for items using the standard <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IList</pc></pc> indexer and count properties.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>The count should represent the number of items locally, not the true size of the dataset.</source>
					<target>The count should represent the number of items locally, not the true size of the dataset.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh701916-hasmoreitems)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When the items control gets close to the end of the existing data, it will call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISupportIncrementalLoading.HasMoreItems</pc></pc>.</source>
					<target>When the items control gets close to the end of the existing data, it will call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISupportIncrementalLoading.HasMoreItems</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/Hh701916-loadmoreitemsasync)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>If you return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc>, then it will call <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ISupportIncrementalLoading.LoadMoreItemsAsync</pc></pc> passing an advised number of items to load.</source>
					<target>If you return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc>, then it will call <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ISupportIncrementalLoading.LoadMoreItemsAsync</pc></pc> passing an advised number of items to load.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>Depending on where you're loading data from (local disk, network, or cloud), you may choose to load a different number of items than that advised.</source>
					<target>Depending on where you're loading data from (local disk, network, or cloud), you may choose to load a different number of items than that advised.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>For example, if your service supports batches of 50 items but the items control only asks for 10 then you can load 50.</source>
					<target>For example, if your service supports batches of 50 items but the items control only asks for 10 then you can load 50.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.Collections.Specialized.INotifyCollectionChanged)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR226052)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">&amp;lt;</data>
					<data id="id10">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>Load the data from your back end, add it to your list, and raise a change notification via <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector<ph dataRef="id9" id="ph1" />T<ph dataRef="id10" id="ph2" /></pc></pc> so that the items control knows about the new items.</source>
					<target>Load the data from your back end, add it to your list, and raise a change notification via <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector<ph dataRef="id9" id="ph1" />T<ph dataRef="id10" id="ph2" /></pc></pc> so that the items control knows about the new items.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>Also return a count of the items you actually loaded.</source>
					<target>Also return a count of the items you actually loaded.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>If you load fewer items than advised, or the items control has been panned/scrolled even further in the interim, then your data source will be called again for more items and the cycle will continue.</source>
					<target>If you load fewer items than advised, or the items control has been panned/scrolled even further in the interim, then your data source will be called again for more items and the cycle will continue.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://code.msdn.microsoft.com/windowsapps/Data-Binding-7b1d67b5)</data>
				</originalData>
				<segment state="initial">
					<source>You can learn more by downloading the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML data binding sample</pc> for Windows 8.1 and re-using its source code in your Windows 10 app.</source>
					<target>You can learn more by downloading the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML data binding sample</pc> for Windows 8.1 and re-using its source code in your Windows 10 app.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>Random access data virtualization</source>
					<target>Random access data virtualization</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>Random access data virtualization allows loading from an arbitrary point in the data set.</source>
					<target>Random access data virtualization allows loading from an arbitrary point in the data set.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> that uses random access data virtualization, used to view a collection of a million items, can load the items 100,000 – 100,050.</source>
					<target>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> that uses random access data virtualization, used to view a collection of a million items, can load the items 100,000 – 100,050.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>If the user then moves to the beginning of the list, the control loads items 1 – 50.</source>
					<target>If the user then moves to the beginning of the list, the control loads items 1 – 50.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>At all times, the scroll bar's thumb indicates that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView</pc> contains a million items.</source>
					<target>At all times, the scroll bar's thumb indicates that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView</pc> contains a million items.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>The position of the scroll bar's thumb is relative to where the visible items are located in the collection's entire data set.</source>
					<target>The position of the scroll bar's thumb is relative to where the visible items are located in the collection's entire data set.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>This type of data virtualization can significantly reduce the memory requirements and load times for the collection.</source>
					<target>This type of data virtualization can significantly reduce the memory requirements and load times for the collection.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>To enable it you need to write a data source class that fetches data on demand and manages a local cache and implements these interfaces.</source>
					<target>To enable it you need to write a data source class that fetches data on demand and manages a local cache and implements these interfaces.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>IList</source>
					<target>IList</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.Collections.Specialized.INotifyCollectionChanged)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR226052)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">&amp;lt;</data>
					<data id="id10">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc> (C#/VB) or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector<ph dataRef="id9" id="ph1" />T<ph dataRef="id10" id="ph2" /></pc></pc> (C++/CX)</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc> (C#/VB) or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector<ph dataRef="id9" id="ph1" />T<ph dataRef="id10" id="ph2" /></pc></pc> (C++/CX)</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn877070)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>(Optionally) <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc></source>
					<target>(Optionally) <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc></target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn877074)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>(Optionally) <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISelectionInfo</pc></pc></source>
					<target>(Optionally) <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISelectionInfo</pc></pc></target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn877070)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc> provides information on which items the control is actively using.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc> provides information on which items the control is actively using.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>The items control will call this method whenever its view is changing, and will include these two sets of ranges.</source>
					<target>The items control will call this method whenever its view is changing, and will include these two sets of ranges.</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>The set of items that are in the viewport.</source>
					<target>The set of items that are in the viewport.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>A set of non-virtualized items that the control is using that may not be in the viewport.</source>
					<target>A set of non-virtualized items that the control is using that may not be in the viewport.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>A buffer of items around the viewport that the items control keeps so that touch panning is smooth.</source>
					<target>A buffer of items around the viewport that the items control keeps so that touch panning is smooth.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>The focused item.</source>
					<target>The focused item.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>The first item.</source>
					<target>The first item.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn877070)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>By implementing <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc> your data source knows what items need to be fetched and cached, and when to prune from the cache data that is no longer needed.</source>
					<target>By implementing <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc> your data source knows what items need to be fetched and cached, and when to prune from the cache data that is no longer needed.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/Dn877081)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">IItemsRangeInfo</pc> uses <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ItemIndexRange</pc></pc> objects to describe a set of items based on their index in the collection.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">IItemsRangeInfo</pc> uses <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ItemIndexRange</pc></pc> objects to describe a set of items based on their index in the collection.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>This is so that it doesn't use item pointers, which may not be correct or stable.</source>
					<target>This is so that it doesn't use item pointers, which may not be correct or stable.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">IItemsRangeInfo</pc> is designed to be used by only a single instance of an items control because it relies on state information for that items control.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">IItemsRangeInfo</pc> is designed to be used by only a single instance of an items control because it relies on state information for that items control.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>If multiple items controls need access to the same data then you will need a separate instance of the data source for each.</source>
					<target>If multiple items controls need access to the same data then you will need a separate instance of the data source for each.</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>They can share a common cache, but the logic to purge from the cache will be more complicated.</source>
					<target>They can share a common cache, but the logic to purge from the cache will be more complicated.</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Here's the basic strategy for your random access data virtualization data source.</source>
					<target>Here's the basic strategy for your random access data virtualization data source.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>When asked for an item</source>
					<target>When asked for an item</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>If you have it available in memory, then return it.</source>
					<target>If you have it available in memory, then return it.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>If you don’t have it, then return either null or a placeholder item.</source>
					<target>If you don’t have it, then return either null or a placeholder item.</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn877070)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Use the request for an item (or the range information from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc>) to know which items are needed, and to fetch data for items from your back end asynchronously.</source>
					<target>Use the request for an item (or the range information from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc>) to know which items are needed, and to fetch data for items from your back end asynchronously.</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.Collections.Specialized.INotifyCollectionChanged)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR226052)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">&amp;lt;</data>
					<data id="id10">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>After retrieving the data, raise a change notification via <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector<ph dataRef="id9" id="ph1" />T<ph dataRef="id10" id="ph2" /></pc></pc> so that the items control knows about the new item.</source>
					<target>After retrieving the data, raise a change notification via <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector<ph dataRef="id9" id="ph1" />T<ph dataRef="id10" id="ph2" /></pc></pc> so that the items control knows about the new item.</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn877070)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>(Optionally) as the items control's viewport changes, identify what items are needed from your data source via your implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc>.</source>
					<target>(Optionally) as the items control's viewport changes, identify what items are needed from your data source via your implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>Beyond that, the strategy for when to load data items, how many to load, and which items to keep in memory is up to your application.</source>
					<target>Beyond that, the strategy for when to load data items, how many to load, and which items to keep in memory is up to your application.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>Some general considerations to keep in mind:</source>
					<target>Some general considerations to keep in mind:</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Make asynchronous requests for data; don't block the UI thread.</source>
					<target>Make asynchronous requests for data; don't block the UI thread.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>Find the sweet spot in the size of the batches you fetch items in.</source>
					<target>Find the sweet spot in the size of the batches you fetch items in.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>Prefer chunky to chatty.</source>
					<target>Prefer chunky to chatty.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>Not so small that you make too many small requests; not too large that they take too long to retrieve.</source>
					<target>Not so small that you make too many small requests; not too large that they take too long to retrieve.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>Consider how many requests you want to have pending at the same time.</source>
					<target>Consider how many requests you want to have pending at the same time.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Performing one at a time is easier, but it may be too slow if turnaround time is high.</source>
					<target>Performing one at a time is easier, but it may be too slow if turnaround time is high.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>Can you cancel requests for data?</source>
					<target>Can you cancel requests for data?</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>If using a hosted service, is there a cost per transaction?</source>
					<target>If using a hosted service, is there a cost per transaction?</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>What kind of notifications are provided by the service when the results of a query are changed?</source>
					<target>What kind of notifications are provided by the service when the results of a query are changed?</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>Will you know if an item is inserted at index 33?</source>
					<target>Will you know if an item is inserted at index 33?</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>If your service supports queries based on a key-plus-offset, that may be better than just using an index.</source>
					<target>If your service supports queries based on a key-plus-offset, that may be better than just using an index.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>How smart do you want to be in pre-fetching items?</source>
					<target>How smart do you want to be in pre-fetching items?</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Are you going to try and track the direction and velocity of scrolling to predict which items are needed?</source>
					<target>Are you going to try and track the direction and velocity of scrolling to predict which items are needed?</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>How aggressive do you want to be in purging the cache?</source>
					<target>How aggressive do you want to be in purging the cache?</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>This is a tradeoff of memory versus experience.</source>
					<target>This is a tradeoff of memory versus experience.</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>