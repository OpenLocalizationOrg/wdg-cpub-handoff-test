<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">f9be158bcfd777c2285ff8865063220fc13ae42c</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci1\xaml-platform\custom-dependency-properties.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">32f2a7b4245eae6695a422c7125875456be49bb5</mda:meta><mda:meta type="olxliffhash">88c4e004a1bafd4eb4c1e358aebf5b0cd26f29bf</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Explains how to define and implement custom dependency properties for a Windows Runtime app using C++, C#, or Visual Basic.</source>
					<target>Explains how to define and implement custom dependency properties for a Windows Runtime app using C++, C#, or Visual Basic.</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Custom dependency properties</source>
					<target>Custom dependency properties</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Custom dependency properties</source>
					<target>Custom dependency properties</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Here we explain how to define and implement your own dependency properties for a Windows Runtime app using C++, C#, or Visual Basic.</source>
					<target>Here we explain how to define and implement your own dependency properties for a Windows Runtime app using C++, C#, or Visual Basic.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>We list reasons why app developers and component authors might want to create custom dependency properties.</source>
					<target>We list reasons why app developers and component authors might want to create custom dependency properties.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>We describe the implementation steps for a custom dependency property, as well as some best practices that can improve performance, usability, or versatility of the dependency property.</source>
					<target>We describe the implementation steps for a custom dependency property, as well as some best practices that can improve performance, usability, or versatility of the dependency property.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Prerequisites</source>
					<target>Prerequisites</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](dependency-properties-overview.md)</data>
				</originalData>
				<segment state="initial">
					<source>We assume that you have read the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dependency properties overview</pc> and that you understand dependency properties from the perspective of a consumer of existing dependency properties.</source>
					<target>We assume that you have read the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dependency properties overview</pc> and that you understand dependency properties from the perspective of a consumer of existing dependency properties.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>To follow the examples in this topic, you should also understand XAML and know how to write a basic Windows Runtime app using C++, C#, or Visual Basic.</source>
					<target>To follow the examples in this topic, you should also understand XAML and know how to write a basic Windows Runtime app using C++, C#, or Visual Basic.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>What is a dependency property?</source>
					<target>What is a dependency property?</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Dependency properties are properties that are registered with the Windows Runtime property system by calling the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty.Register</pc></pc> method, and that are identified by a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyProperty</pc></pc> identifier member on the defining class.</source>
					<target>Dependency properties are properties that are registered with the Windows Runtime property system by calling the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty.Register</pc></pc> method, and that are identified by a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyProperty</pc></pc> identifier member on the defining class.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>You can enable what would otherwise be a common language runtime (CLR) or C++ property to support styling, data binding, animations, and default values by implementing it as a dependency property.</source>
					<target>You can enable what would otherwise be a common language runtime (CLR) or C++ property to support styling, data binding, animations, and default values by implementing it as a dependency property.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Dependency properties can be used only by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> types.</source>
					<target>Dependency properties can be used only by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> types.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>But <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> is quite high in the class hierarchy, so the majority of classes that are intended for UI and presentation support can support dependency properties.</source>
					<target>But <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> is quite high in the class hierarchy, so the majority of classes that are intended for UI and presentation support can support dependency properties.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](dependency-properties-overview.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about dependency properties and some of the terminology and conventions used for describing them in this documentation, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dependency properties overview</pc>.</source>
					<target>For more information about dependency properties and some of the terminology and conventions used for describing them in this documentation, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dependency properties overview</pc>.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209395)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208751)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br209702)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>Examples of dependency properties in the Windows Runtime are: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control.Background</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement.Width</pc></pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">TextBox.Text</pc></pc>, among many others.</source>
					<target>Examples of dependency properties in the Windows Runtime are: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control.Background</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement.Width</pc></pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">TextBox.Text</pc></pc>, among many others.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>Each dependency property exposed by a class has a corresponding <pc dataRefEnd="id2" dataRefStart="id1" id="p1">public</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="p2">static</pc> <pc dataRefEnd="id6" dataRefStart="id5" id="p3">readonly</pc> property of type <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">DependencyProperty</pc></pc> that is exposed on that same class and that is the identifier for the dependency property.</source>
					<target>Each dependency property exposed by a class has a corresponding <pc dataRefEnd="id2" dataRefStart="id1" id="p1">public</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="p2">static</pc> <pc dataRefEnd="id6" dataRefStart="id5" id="p3">readonly</pc> property of type <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">DependencyProperty</pc></pc> that is exposed on that same class and that is the identifier for the dependency property.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>The identifier's name follows this convention: the name of the dependency property, with the string "Property" added to the end of the name.</source>
					<target>The identifier's name follows this convention: the name of the dependency property, with the string "Property" added to the end of the name.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209396)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, the corresponding <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyProperty</pc> identifier for the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control.Background</pc> property is <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Control.BackgroundProperty</pc></pc>.</source>
					<target>For example, the corresponding <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyProperty</pc> identifier for the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control.Background</pc> property is <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Control.BackgroundProperty</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The identifier stores the information about the dependency property as it was registered, and the identifier can then be used later for other operations involving the dependency property, such as calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetValue</pc></pc>.</source>
					<target>The identifier stores the information about the dependency property as it was registered, and the identifier can then be used later for other operations involving the dependency property, such as calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetValue</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>Property wrappers</source>
					<target>Property wrappers</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Dependency properties typically have a wrapper implementation.</source>
					<target>Dependency properties typically have a wrapper implementation.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242359)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Without the wrapper, the only way to get or set the properties would be to use the dependency property utility methods <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetValue</pc></pc> and to pass the identifier to them as a parameter.</source>
					<target>Without the wrapper, the only way to get or set the properties would be to use the dependency property utility methods <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetValue</pc></pc> and to pass the identifier to them as a parameter.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>This is a rather unnatural usage for something that is ostensibly a property.</source>
					<target>This is a rather unnatural usage for something that is ostensibly a property.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>But with the wrapper, your code and any other code that references the dependency property can use a straightforward object-property syntax that is natural for the language you're using.</source>
					<target>But with the wrapper, your code and any other code that references the dependency property can use a straightforward object-property syntax that is natural for the language you're using.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>If you implement a custom dependency property yourself and want it to be public and easy to call, define the property wrappers too.</source>
					<target>If you implement a custom dependency property yourself and want it to be public and easy to call, define the property wrappers too.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>The property wrappers are also useful for reporting basic information about the dependency property to reflection or static analysis processes.</source>
					<target>The property wrappers are also useful for reporting basic information about the dependency property to reflection or static analysis processes.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228011)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Specifically, the wrapper is where you place attributes such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentPropertyAttribute</pc></pc>.</source>
					<target>Specifically, the wrapper is where you place attributes such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentPropertyAttribute</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>When to implement a property as a dependency property</source>
					<target>When to implement a property as a dependency property</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Whenever you implement a public read/write property on a class, as long as your class derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>, you have the option to make your property work as a dependency property.</source>
					<target>Whenever you implement a public read/write property on a class, as long as your class derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>, you have the option to make your property work as a dependency property.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Sometimes the typical technique of backing your property with a private field is adequate.</source>
					<target>Sometimes the typical technique of backing your property with a private field is adequate.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Defining your custom property as a dependency property is not always necessary or appropriate.</source>
					<target>Defining your custom property as a dependency property is not always necessary or appropriate.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>The choice will depend on the scenarios that you intend your property to support.</source>
					<target>The choice will depend on the scenarios that you intend your property to support.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>You might consider implementing your property as a dependency property when you want it to support one or more of these features of the Windows Runtime or of Windows Runtime apps:</source>
					<target>You might consider implementing your property as a dependency property when you want it to support one or more of these features of the Windows Runtime or of Windows Runtime apps:</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208849)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Setting the property through a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc></source>
					<target>Setting the property through a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc></target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Acting as valid target property for data binding</source>
					<target>Acting as valid target property for data binding</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br210490)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Supporting animated values through a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Storyboard</pc></pc></source>
					<target>Supporting animated values through a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Storyboard</pc></pc></target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Reporting when the previous value of the property has been changed by:</source>
					<target>Reporting when the previous value of the property has been changed by:</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Actions taken by the property system itself</source>
					<target>Actions taken by the property system itself</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>The environment</source>
					<target>The environment</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>User actions</source>
					<target>User actions</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>Reading and writing styles</source>
					<target>Reading and writing styles</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>Checklist for defining a dependency property</source>
					<target>Checklist for defining a dependency property</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>Defining a dependency property can be thought of as a set of concepts.</source>
					<target>Defining a dependency property can be thought of as a set of concepts.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>These concepts are not necessarily procedural steps, because several concepts can be addressed in a single line of code in the implementation.</source>
					<target>These concepts are not necessarily procedural steps, because several concepts can be addressed in a single line of code in the implementation.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>This list gives just a quick overview.</source>
					<target>This list gives just a quick overview.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>We'll explain each concept in more detail later in this topic, and we'll show you example code in several languages.</source>
					<target>We'll explain each concept in more detail later in this topic, and we'll show you example code in several languages.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>(Optional) Create property metadata for the dependency property.</source>
					<target>(Optional) Create property metadata for the dependency property.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242357)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You need property metadata only if you want property-changed behavior, or a metadata-based default value that can be restored by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClearValue</pc></pc>.</source>
					<target>You need property metadata only if you want property-changed behavior, or a metadata-based default value that can be restored by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClearValue</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Register the property name with the property system (call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc>), specifying an owner type and the type of the property value.</source>
					<target>Register the property name with the property system (call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc>), specifying an owner type and the type of the property value.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>There's a required parameter for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> that expects property metadata.</source>
					<target>There's a required parameter for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> that expects property metadata.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Specify <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> for this, or specify the actual property metadata if you have declared any.</source>
					<target>Specify <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> for this, or specify the actual property metadata if you have declared any.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>Define a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> identifier as a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">public</pc> <pc dataRefEnd="id8" dataRefStart="id7" id="p4">static</pc> <pc dataRefEnd="id10" dataRefStart="id9" id="p5">readonly</pc> property member on the owner type.</source>
					<target>Define a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> identifier as a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">public</pc> <pc dataRefEnd="id8" dataRefStart="id7" id="p4">static</pc> <pc dataRefEnd="id10" dataRefStart="id9" id="p5">readonly</pc> property member on the owner type.</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Define a wrapper property, following the property accessor model that's used in the language you are implementing.</source>
					<target>Define a wrapper property, following the property accessor model that's used in the language you are implementing.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The wrapper property name should match the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">name</pc> string that you used in <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Register</pc></pc>.</source>
					<target>The wrapper property name should match the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">name</pc> string that you used in <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Register</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242359)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>Implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">set</pc> accessors to connect the wrapper with the dependency property that it wraps, by calling <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetValue</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">SetValue</pc></pc> and passing your own property's identifier as a parameter.</source>
					<target>Implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">set</pc> accessors to connect the wrapper with the dependency property that it wraps, by calling <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetValue</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">SetValue</pc></pc> and passing your own property's identifier as a parameter.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228011)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>(Optional) Place attributes such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentPropertyAttribute</pc></pc> on the wrapper.</source>
					<target>(Optional) Place attributes such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentPropertyAttribute</pc></pc> on the wrapper.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you are defining a custom attached property, you generally omit the wrapper.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you are defining a custom attached property, you generally omit the wrapper.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>Instead, you write a different style of accessor that a XAML processor can use.</source>
					<target>Instead, you write a different style of accessor that a XAML processor can use.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](custom-attached-properties.md)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom attached properties</pc>.</source>
					<target>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom attached properties</pc>.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>Registering the property</source>
					<target>Registering the property</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>For your property to be a dependency property, you must register the property into a property store maintained by the Windows Runtime property system.</source>
					<target>For your property to be a dependency property, you must register the property into a property store maintained by the Windows Runtime property system.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>You must give the property a unique identifier to be used as the qualifier for later property-system operations.</source>
					<target>You must give the property a unique identifier to be used as the qualifier for later property-system operations.</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>These operations might be internal operations, or your own code calling property-system APIs.</source>
					<target>These operations might be internal operations, or your own code calling property-system APIs.</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To register the property, you call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> method.</source>
					<target>To register the property, you call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> method.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For Microsoft .NET languages (C# and Microsoft Visual Basic) you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> within the body of your class (inside the class, but outside any member definitions).</source>
					<target>For Microsoft .NET languages (C# and Microsoft Visual Basic) you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> within the body of your class (inside the class, but outside any member definitions).</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The identifier is also provided by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> method call, as the return value.</source>
					<target>The identifier is also provided by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> method call, as the return value.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> call is typically made outside of other member definitions because you use the return value to assign and create a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">public</pc> <pc dataRefEnd="id8" dataRefStart="id7" id="p4">static</pc> <pc dataRefEnd="id10" dataRefStart="id9" id="p5">readonly</pc> property of type <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">DependencyProperty</pc></pc> as part of your class.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> call is typically made outside of other member definitions because you use the return value to assign and create a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">public</pc> <pc dataRefEnd="id8" dataRefStart="id7" id="p4">static</pc> <pc dataRefEnd="id10" dataRefStart="id9" id="p5">readonly</pc> property of type <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">DependencyProperty</pc></pc> as part of your class.</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>This property becomes the identifier for your dependency property.</source>
					<target>This property becomes the identifier for your dependency property.</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Here are examples of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> call.</source>
					<target>Here are examples of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> call.</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Registering the dependency property in a class body is the typical implementation, but you can also register a dependency property in the class static constructor.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Registering the dependency property in a class body is the typical implementation, but you can also register a dependency property in the class static constructor.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>This approach may make sense if you need more than one line of code to initialize the dependency property.</source>
					<target>This approach may make sense if you need more than one line of code to initialize the dependency property.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>For C++, you have options for how you split the implementation between the header and the code file.</source>
					<target>For C++, you have options for how you split the implementation between the header and the code file.</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The typical split is to declare the identifier itself as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">public</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="p2">static</pc> property in the header, with a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">get</pc> implementation but no <pc dataRefEnd="id8" dataRefStart="id7" id="p4">set</pc>.</source>
					<target>The typical split is to declare the identifier itself as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">public</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="p2">static</pc> property in the header, with a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">get</pc> implementation but no <pc dataRefEnd="id8" dataRefStart="id7" id="p4">set</pc>.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> implementation refers to a private field, which is an uninitialized <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyProperty</pc></pc> instance.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> implementation refers to a private field, which is an uninitialized <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyProperty</pc></pc> instance.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can also declare the wrappers and the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">set</pc> implementations of the wrapper.</source>
					<target>You can also declare the wrappers and the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">set</pc> implementations of the wrapper.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>In this case the header includes some minimal implementation.</source>
					<target>In this case the header includes some minimal implementation.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>If the wrapper needs Windows Runtime attribution, attribute in the header too.</source>
					<target>If the wrapper needs Windows Runtime attribution, attribute in the header too.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Put the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> call in the code file, within a helper function that only gets run when the app initializes the first time.</source>
					<target>Put the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> call in the code file, within a helper function that only gets run when the app initializes the first time.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Use the return value of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Register</pc> to fill the static but uninitialized identifiers that you declared in the header, which you initially set to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">nullptr</pc> at the root scope of the implementation file.</source>
					<target>Use the return value of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Register</pc> to fill the static but uninitialized identifiers that you declared in the header, which you initially set to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">nullptr</pc> at the root scope of the implementation file.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For the C++ code, the reason why you have a private field and a public read-only property that surfaces the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyProperty</pc></pc> is so that other callers who use your dependency property can also use property-system utility APIs that require the identifier to be public.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For the C++ code, the reason why you have a private field and a public read-only property that surfaces the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyProperty</pc></pc> is so that other callers who use your dependency property can also use property-system utility APIs that require the identifier to be public.</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>If you keep the identifier private, people can't use these utility APIs.</source>
					<target>If you keep the identifier private, people can't use these utility APIs.</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242359)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br242357)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/br242358)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
					<data id="id17">[</data>
					<data id="id18">](https://msdn.microsoft.com/library/windows/apps/br244257)</data>
					<data id="id19">**</data>
					<data id="id20">**</data>
					<data id="id21">[</data>
					<data id="id22">](https://msdn.microsoft.com/library/windows/apps/br208836)</data>
					<data id="id23">**</data>
					<data id="id24">**</data>
				</originalData>
				<segment state="initial">
					<source>Examples of such API and scenarios include <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetValue</pc></pc> by choice, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ClearValue</pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">GetAnimationBaseValue</pc></pc>, <pc dataRefEnd="id18" dataRefStart="id17" id="p9"><pc dataRefEnd="id20" dataRefStart="id19" id="p10">SetBinding</pc></pc>, and <pc dataRefEnd="id22" dataRefStart="id21" id="p11"><pc dataRefEnd="id24" dataRefStart="id23" id="p12">Setter.Property</pc></pc>.</source>
					<target>Examples of such API and scenarios include <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetValue</pc></pc> by choice, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ClearValue</pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">GetAnimationBaseValue</pc></pc>, <pc dataRefEnd="id18" dataRefStart="id17" id="p9"><pc dataRefEnd="id20" dataRefStart="id19" id="p10">SetBinding</pc></pc>, and <pc dataRefEnd="id22" dataRefStart="id21" id="p11"><pc dataRefEnd="id24" dataRefStart="id23" id="p12">Setter.Property</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You can't use a public field for this, because Windows Runtime compile rules don't allow public data members that use reference types like <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyProperty</pc>.</source>
					<target>You can't use a public field for this, because Windows Runtime compile rules don't allow public data members that use reference types like <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyProperty</pc>.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Dependency property name conventions</source>
					<target>Dependency property name conventions</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>There are naming conventions for dependency properties; follow them in all but exceptional circumstances.</source>
					<target>There are naming conventions for dependency properties; follow them in all but exceptional circumstances.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The dependency property itself has a basic name ("Label" in the preceding example) that is given as the first parameter of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc>.</source>
					<target>The dependency property itself has a basic name ("Label" in the preceding example) that is given as the first parameter of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>The name must be unique within each registering type, and the uniqueness requirement also applies to any inherited members.</source>
					<target>The name must be unique within each registering type, and the uniqueness requirement also applies to any inherited members.</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>Dependency properties inherited through base types are considered to be part of the registering type already; names of inherited properties cannot be registered again.</source>
					<target>Dependency properties inherited through base types are considered to be part of the registering type already; names of inherited properties cannot be registered again.</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>  Although the name you provide here can be any string identifier that is valid in programming for your language of choice, you usually want to be able to set your dependency property in XAML too.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>  Although the name you provide here can be any string identifier that is valid in programming for your language of choice, you usually want to be able to set your dependency property in XAML too.</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>To be set in XAML, the property name you choose must be a valid XAML name.</source>
					<target>To be set in XAML, the property name you choose must be a valid XAML name.</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](xaml-overview.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML overview</pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML overview</pc>.</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>When you create the identifier property, combine the name of the property as you registered it with the suffix "Property" ("LabelProperty", for example).</source>
					<target>When you create the identifier property, combine the name of the property as you registered it with the suffix "Property" ("LabelProperty", for example).</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242359)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>This property is your identifier for the dependency property, and it is used as an input for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetValue</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetValue</pc></pc> calls you make in your own property wrappers.</source>
					<target>This property is your identifier for the dependency property, and it is used as an input for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetValue</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetValue</pc></pc> calls you make in your own property wrappers.</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>It is also used by the property system and potentially by XAML processors.</source>
					<target>It is also used by the property system and potentially by XAML processors.</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>Implementing the wrapper</source>
					<target>Implementing the wrapper</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242359)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>Your property wrapper should call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">get</pc> implementation, and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">SetValue</pc></pc> in the <pc dataRefEnd="id12" dataRefStart="id11" id="p6">set</pc> implementation.</source>
					<target>Your property wrapper should call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">get</pc> implementation, and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">SetValue</pc></pc> in the <pc dataRefEnd="id12" dataRefStart="id11" id="p6">set</pc> implementation.</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242359)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>  In all but exceptional circumstances, your wrapper implementations should perform only the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">GetValue</pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">SetValue</pc></pc> operations.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>  In all but exceptional circumstances, your wrapper implementations should perform only the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">GetValue</pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">SetValue</pc></pc> operations.</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>Otherwise, you'll get different behavior when your property is set via XAML versus when it is set via code.</source>
					<target>Otherwise, you'll get different behavior when your property is set via XAML versus when it is set via code.</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>For efficiency, the XAML parser bypasses wrappers when setting dependency properties; whenever possible, it uses the registry of dependency properties.</source>
					<target>For efficiency, the XAML parser bypasses wrappers when setting dependency properties; whenever possible, it uses the registry of dependency properties.</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>Property metadata for a custom dependency property</source>
					<target>Property metadata for a custom dependency property</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>When property metadata is assigned to a dependency property, the same metadata is applied to that property for any instance of the property-owner type or its subclasses.</source>
					<target>When property metadata is assigned to a dependency property, the same metadata is applied to that property for any instance of the property-owner type or its subclasses.</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>In property metadata, you can specify two behaviors:</source>
					<target>In property metadata, you can specify two behaviors:</target>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>A default value that the property system assigns to all cases of the property.</source>
					<target>A default value that the property system assigns to all cases of the property.</target>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>A static callback method that is automatically invoked within the property system whenever a property value is detected.</source>
					<target>A static callback method that is automatically invoked within the property system whenever a property value is detected.</target>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>Calling Register with property metadata</source>
					<target>Calling Register with property metadata</target>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
				</originalData>
				<segment state="initial">
					<source>In the previous examples of calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty.Register</pc></pc>, we passed a null value for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">propertyMetadata</pc> parameter.</source>
					<target>In the previous examples of calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty.Register</pc></pc>, we passed a null value for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">propertyMetadata</pc> parameter.</target>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To enable a dependency property to provide a default value or use a property-changed callback, you must define a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc> instance that provides one or both of these capabilities.</source>
					<target>To enable a dependency property to provide a default value or use a property-changed callback, you must define a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc> instance that provides one or both of these capabilities.</target>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Typically you provide a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc> as an inline-created instance, within the parameters for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyProperty.Register</pc></pc>.</source>
					<target>Typically you provide a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc> as an inline-created instance, within the parameters for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyProperty.Register</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh701812)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/hh702099)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you are defining a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">CreateDefaultValueCallback</pc></pc> implementation, you must use the utility method <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">PropertyMetadata.Create</pc></pc> rather than calling a <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">PropertyMetadata</pc></pc> constructor to define the <pc dataRefEnd="id16" dataRefStart="id15" id="p8">PropertyMetadata</pc> instance.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you are defining a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">CreateDefaultValueCallback</pc></pc> implementation, you must use the utility method <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">PropertyMetadata.Create</pc></pc> rather than calling a <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">PropertyMetadata</pc></pc> constructor to define the <pc dataRefEnd="id16" dataRefStart="id15" id="p8">PropertyMetadata</pc> instance.</target>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br208770)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>This next example modifies the previously shown <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty.Register</pc></pc> examples by referencing a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PropertyMetadata</pc></pc> instance with a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PropertyChangedCallback</pc></pc> value.</source>
					<target>This next example modifies the previously shown <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty.Register</pc></pc> examples by referencing a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PropertyMetadata</pc></pc> instance with a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PropertyChangedCallback</pc></pc> value.</target>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>The implementation of the "OnLabelChanged" callback will be shown later in this section.</source>
					<target>The implementation of the "OnLabelChanged" callback will be shown later in this section.</target>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>Default value</source>
					<target>Default value</target>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<segment state="initial">
					<source>You can specify a default value for a dependency property such that the property always returns a particular default value when it is unset.</source>
					<target>You can specify a default value for a dependency property such that the property always returns a particular default value when it is unset.</target>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>This value can be different than the inherent default value for the type of that property.</source>
					<target>This value can be different than the inherent default value for the type of that property.</target>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>If a default value is not specified, the default value for a dependency property is null for a reference type, or the default of the type for a value type or language primitive (for example, 0 for an integer or an empty string for a string).</source>
					<target>If a default value is not specified, the default value for a dependency property is null for a reference type, or the default of the type for a value type or language primitive (for example, 0 for an integer or an empty string for a string).</target>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242357)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The main reason for establishing a default value is that this value is restored when you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClearValue</pc></pc> on the property.</source>
					<target>The main reason for establishing a default value is that this value is restored when you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClearValue</pc></pc> on the property.</target>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>Establishing a default value on a per-property basis might be more convenient than establishing default values in constructors, particularly for value types.</source>
					<target>Establishing a default value on a per-property basis might be more convenient than establishing default values in constructors, particularly for value types.</target>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<segment state="initial">
					<source>However, for reference types, make sure that establishing a default value does not create an unintentional singleton pattern.</source>
					<target>However, for reference types, make sure that establishing a default value does not create an unintentional singleton pattern.</target>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#best-practices)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Best practices</pc> later in this topic</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Best practices</pc> later in this topic</target>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242371)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Do not register with a default value of <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">UnsetValue</pc></pc>.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Do not register with a default value of <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">UnsetValue</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>If you do, it will confuse property consumers and will have unintended consequences within the property system.</source>
					<target>If you do, it will confuse property consumers and will have unintended consequences within the property system.</target>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>CreateDefaultValueCallback</source>
					<target>CreateDefaultValueCallback</target>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<segment state="initial">
					<source>In some scenarios, you are defining dependency properties for objects that are used on more than one UI thread.</source>
					<target>In some scenarios, you are defining dependency properties for objects that are used on more than one UI thread.</target>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>This might be the case if you are defining a data object that is used by multiple apps, or a control that you use in more than one app.</source>
					<target>This might be the case if you are defining a data object that is used by multiple apps, or a control that you use in more than one app.</target>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701812)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can enable the exchange of the object between different UI threads by providing a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc> implementation rather than a default value instance, which is tied to the thread that registered the property.</source>
					<target>You can enable the exchange of the object between different UI threads by providing a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc> implementation rather than a default value instance, which is tied to the thread that registered the property.</target>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701812)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Basically a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc> defines a factory for default values.</source>
					<target>Basically a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc> defines a factory for default values.</target>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The value returned by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDefaultValueCallback</pc> is always associated with the current UI <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc> thread that is using the object.</source>
					<target>The value returned by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDefaultValueCallback</pc> is always associated with the current UI <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc> thread that is using the object.</target>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701812)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh702115)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source>To define metadata that specifies a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc>, you must call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PropertyMetadata.Create</pc></pc> to return a metadata instance; the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PropertyMetadata</pc></pc> constructors do not have a signature that includes a <pc dataRefEnd="id14" dataRefStart="id13" id="p7">CreateDefaultValueCallback</pc> parameter.</source>
					<target>To define metadata that specifies a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc>, you must call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PropertyMetadata.Create</pc></pc> to return a metadata instance; the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PropertyMetadata</pc></pc> constructors do not have a signature that includes a <pc dataRefEnd="id14" dataRefStart="id13" id="p7">CreateDefaultValueCallback</pc> parameter.</target>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701812)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source>The typical implementation pattern for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc> is to create a new <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyObject</pc></pc> class, set the specific property value of each property of the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">DependencyObject</pc> to the intended default, and then return the new class as an <pc dataRefEnd="id12" dataRefStart="id11" id="p6">Object</pc> reference via the return value of the <pc dataRefEnd="id14" dataRefStart="id13" id="p7">CreateDefaultValueCallback</pc> method.</source>
					<target>The typical implementation pattern for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc> is to create a new <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyObject</pc></pc> class, set the specific property value of each property of the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">DependencyObject</pc> to the intended default, and then return the new class as an <pc dataRefEnd="id12" dataRefStart="id11" id="p6">Object</pc> reference via the return value of the <pc dataRefEnd="id14" dataRefStart="id13" id="p7">CreateDefaultValueCallback</pc> method.</target>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>Property-changed callback method</source>
					<target>Property-changed callback method</target>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>You can define a property-changed callback method to define your property's interactions with other dependency properties, or to set an internal property or state of your object whenever the property changes.</source>
					<target>You can define a property-changed callback method to define your property's interactions with other dependency properties, or to set an internal property or state of your object whenever the property changes.</target>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>If your callback is invoked, the property system has determined that there is an effective property value change.</source>
					<target>If your callback is invoked, the property system has determined that there is an effective property value change.</target>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>Because the callback method is static, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d</pc> parameter of the callback is important because it tells you which instance of the class has reported a change.</source>
					<target>Because the callback method is static, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d</pc> parameter of the callback is important because it tells you which instance of the class has reported a change.</target>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242364)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
				</originalData>
				<segment state="initial">
					<source>A typical implementation uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NewValue</pc></pc> property of the event data and processes that value in some manner, usually by performing some other change on the object passed as <pc dataRefEnd="id6" dataRefStart="id5" id="p3">d</pc>.</source>
					<target>A typical implementation uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NewValue</pc></pc> property of the event data and processes that value in some manner, usually by performing some other change on the object passed as <pc dataRefEnd="id6" dataRefStart="id5" id="p3">d</pc>.</target>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242365)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Additional responses to a property change are to reject the value reported by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NewValue</pc>, to restore <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">OldValue</pc></pc>, or to set the value to a programmatic constraint applied to the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">NewValue</pc>.</source>
					<target>Additional responses to a property change are to reject the value reported by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NewValue</pc>, to restore <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">OldValue</pc></pc>, or to set the value to a programmatic constraint applied to the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">NewValue</pc>.</target>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208770)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This next example shows a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyChangedCallback</pc></pc> implementation.</source>
					<target>This next example shows a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyChangedCallback</pc></pc> implementation.</target>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>It implements the method you saw referenced in the previous <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> examples, as part of the construction arguments for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PropertyMetadata</pc></pc>.</source>
					<target>It implements the method you saw referenced in the previous <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> examples, as part of the construction arguments for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PropertyMetadata</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<segment state="initial">
					<source>The scenario addressed by this callback is that the class also has a calculated read-only property named "HasLabelValue" (implementation not shown).</source>
					<target>The scenario addressed by this callback is that the class also has a calculated read-only property named "HasLabelValue" (implementation not shown).</target>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>Whenever the "Label" property gets reevaluated, this callback method is invoked, and the callback enables the dependent calculated value to remain in synchronization with changes to the dependency property.</source>
					<target>Whenever the "Label" property gets reevaluated, this callback method is invoked, and the callback enables the dependent calculated value to remain in synchronization with changes to the dependency property.</target>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>Property changed behavior for structures and enumerations</source>
					<target>Property changed behavior for structures and enumerations</target>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If the type of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> is an enumeration or a structure, the callback may be invoked even if the internal values of the structure or the enumeration value did not change.</source>
					<target>If the type of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> is an enumeration or a structure, the callback may be invoked even if the internal values of the structure or the enumeration value did not change.</target>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>This is different from a system primitive such as a string where it only is invoked if the value changed.</source>
					<target>This is different from a system primitive such as a string where it only is invoked if the value changed.</target>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>This is a side effect of box and unbox operations on these values that is done internally.</source>
					<target>This is a side effect of box and unbox operations on these values that is done internally.</target>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208770)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242365)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br242364)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>If you have a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyChangedCallback</pc></pc> method for a property where your value is an enumeration or structure, you need to compare the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OldValue</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">NewValue</pc></pc> by casting the values yourself and using the overloaded comparison operators that are available to the now-cast values.</source>
					<target>If you have a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyChangedCallback</pc></pc> method for a property where your value is an enumeration or structure, you need to compare the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OldValue</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">NewValue</pc></pc> by casting the values yourself and using the overloaded comparison operators that are available to the now-cast values.</target>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>Or, if no such operator is available (which might be the case for a custom structure), you may need to compare the individual values.</source>
					<target>Or, if no such operator is available (which might be the case for a custom structure), you may need to compare the individual values.</target>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>You would typically choose to do nothing if the result is that the values have not changed.</source>
					<target>You would typically choose to do nothing if the result is that the values have not changed.</target>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>Best practices</source>
					<target>Best practices</target>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>Keep the following considerations in mind as best practices when as you define your custom dependency property.</source>
					<target>Keep the following considerations in mind as best practices when as you define your custom dependency property.</target>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<segment state="initial">
					<source>DependencyObject and threading</source>
					<target>DependencyObject and threading</target>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209041)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>All <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> instances must be created on the UI thread which is associated with the current <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Window</pc></pc> that is shown by a Windows Runtime app.</source>
					<target>All <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> instances must be created on the UI thread which is associated with the current <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Window</pc></pc> that is shown by a Windows Runtime app.</target>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br230616)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Although each <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> must be created on the main UI thread, the objects can be accessed using a dispatcher reference from other threads, by calling <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Dispatcher</pc></pc>.</source>
					<target>Although each <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> must be created on the main UI thread, the objects can be accessed using a dispatcher reference from other threads, by calling <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Dispatcher</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The threading aspects of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> are relevant because it generally means that only code that runs on the UI thread can change or even read the value of a dependency property.</source>
					<target>The threading aspects of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> are relevant because it generally means that only code that runs on the UI thread can change or even read the value of a dependency property.</target>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Threading issues can usually be avoided in typical UI code that makes correct use of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> patterns and background worker threads.</source>
					<target>Threading issues can usually be avoided in typical UI code that makes correct use of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> patterns and background worker threads.</target>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>You typically only run into <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc>-related threading issues if you are defining your own <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc> types and you attempt to use them for data sources or other scenarios where a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyObject</pc> isn't necessarily appropriate.</source>
					<target>You typically only run into <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc>-related threading issues if you are defining your own <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc> types and you attempt to use them for data sources or other scenarios where a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyObject</pc> isn't necessarily appropriate.</target>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>Avoiding unintentional singletons</source>
					<target>Avoiding unintentional singletons</target>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>An unintentional singleton can happen if you are declaring a dependency property that takes a reference type, and you call a constructor for that reference type as part of the code that establishes your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc>.</source>
					<target>An unintentional singleton can happen if you are declaring a dependency property that takes a reference type, and you call a constructor for that reference type as part of the code that establishes your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>What happens is that all usages of the dependency property share just one instance of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PropertyMetadata</pc> and thus try to share the single reference type you constructed.</source>
					<target>What happens is that all usages of the dependency property share just one instance of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PropertyMetadata</pc> and thus try to share the single reference type you constructed.</target>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>Any subproperties of that value type that you set through your dependency property then propagate to other objects in ways you probably don't intend.</source>
					<target>Any subproperties of that value type that you set through your dependency property then propagate to other objects in ways you probably don't intend.</target>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](dependency-properties-overview.md)</data>
				</originalData>
				<segment state="initial">
					<source>You can use class constructors to set initial values for a reference-type dependency property if you want a non-null value, but be aware that this would be considered a local value for purposes of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dependency properties overview</pc>.</source>
					<target>You can use class constructors to set initial values for a reference-type dependency property if you want a non-null value, but be aware that this would be considered a local value for purposes of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dependency properties overview</pc>.</target>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>It might be more appropriate to use a template for this purpose, if your class supports templates.</source>
					<target>It might be more appropriate to use a template for this purpose, if your class supports templates.</target>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<segment state="initial">
					<source>Another way to avoid a singleton pattern, but still provide a useful default, is to expose a static property on the reference type that provides a suitable default for the values of that class.</source>
					<target>Another way to avoid a singleton pattern, but still provide a useful default, is to expose a static property on the reference type that provides a suitable default for the values of that class.</target>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<segment state="initial">
					<source>Collection-type dependency properties</source>
					<target>Collection-type dependency properties</target>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>Collection-type dependency properties have some additional implementation issues to consider.</source>
					<target>Collection-type dependency properties have some additional implementation issues to consider.</target>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>Collection-type dependency properties are relatively rare in the Windows Runtime API.</source>
					<target>Collection-type dependency properties are relatively rare in the Windows Runtime API.</target>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In most cases, you can use collections where the items are a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> subclass, but the collection property itself is implemented as a conventional CLR or C++ property.</source>
					<target>In most cases, you can use collections where the items are a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> subclass, but the collection property itself is implemented as a conventional CLR or C++ property.</target>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>This is because collections do not necessarily suit some typical scenarios where dependency properties are involved.</source>
					<target>This is because collections do not necessarily suit some typical scenarios where dependency properties are involved.</target>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<segment state="initial">
					<source>For example:</source>
					<target>For example:</target>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<segment state="initial">
					<source>You do not typically animate a collection.</source>
					<target>You do not typically animate a collection.</target>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<segment state="initial">
					<source>You do not typically prepopulate the items in a collection with styles or a template.</source>
					<target>You do not typically prepopulate the items in a collection with styles or a template.</target>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>Although binding to collections is a major scenario, a collection does not need to be a dependency property to be a binding source.</source>
					<target>Although binding to collections is a major scenario, a collection does not need to be a dependency property to be a binding source.</target>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242803)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242348)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For binding targets, it is more typical to use subclasses of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsControl</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DataTemplate</pc></pc> to support collection items, or to use view-model patterns.</source>
					<target>For binding targets, it is more typical to use subclasses of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsControl</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DataTemplate</pc></pc> to support collection items, or to use view-model patterns.</target>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt210946)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about binding to and from collections, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</source>
					<target>For more info about binding to and from collections, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</target>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](T:System.Collections.ObjectModel.ObservableCollection%601)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Notifications for collection changes are better addressed through interfaces such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">INotifyPropertyChanged</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc>, or by deriving the collection type from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ObservableCollection</pc></pc>.</source>
					<target>Notifications for collection changes are better addressed through interfaces such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">INotifyPropertyChanged</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc>, or by deriving the collection type from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ObservableCollection</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<segment state="initial">
					<source>Nevertheless, scenarios for collection-type dependency properties do exist.</source>
					<target>Nevertheless, scenarios for collection-type dependency properties do exist.</target>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<segment state="initial">
					<source>The next three sections provide some guidance on how to implement a collection-type dependency property.</source>
					<target>The next three sections provide some guidance on how to implement a collection-type dependency property.</target>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>Initializing the collection</source>
					<target>Initializing the collection</target>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<segment state="initial">
					<source>When you create a dependency property, you can establish a default value by means of dependency property metadata.</source>
					<target>When you create a dependency property, you can establish a default value by means of dependency property metadata.</target>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>But be careful to not use a singleton static collection as the default value.</source>
					<target>But be careful to not use a singleton static collection as the default value.</target>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<segment state="initial">
					<source>Instead, you must deliberately set the collection value to a unique (instance) collection as part of class-constructor logic for the owner class of the collection property.</source>
					<target>Instead, you must deliberately set the collection value to a unique (instance) collection as part of class-constructor logic for the owner class of the collection property.</target>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<segment state="initial">
					<source>Change notifications</source>
					<target>Change notifications</target>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<segment state="initial">
					<source>Defining the collection as a dependency property does not automatically provide change notification for the items in the collection by virtue of the property system invoking the "PropertyChanged" callback method.</source>
					<target>Defining the collection as a dependency property does not automatically provide change notification for the items in the collection by virtue of the property system invoking the "PropertyChanged" callback method.</target>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you want notifications for collections or collection items—for example, for a data-binding scenario— implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">INotifyPropertyChanged</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc> interface.</source>
					<target>If you want notifications for collections or collection items—for example, for a data-binding scenario— implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">INotifyPropertyChanged</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc> interface.</target>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt210946)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</target>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<segment state="initial">
					<source>Dependency property security considerations</source>
					<target>Dependency property security considerations</target>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<segment state="initial">
					<source>Declare dependency properties as public properties.</source>
					<target>Declare dependency properties as public properties.</target>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<segment state="initial">
					<source>Declare dependency property identifiers as public static read-only members.</source>
					<target>Declare dependency property identifiers as public static read-only members.</target>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Even if you attempt to declare other access levels permitted by a language (such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">protected</pc>), a dependency property can always be accessed through the identifier in combination with the property-system APIs.</source>
					<target>Even if you attempt to declare other access levels permitted by a language (such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">protected</pc>), a dependency property can always be accessed through the identifier in combination with the property-system APIs.</target>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<segment state="initial">
					<source>Declaring the dependency property identifier as internal or private will not work, because then the property system cannot operate properly.</source>
					<target>Declaring the dependency property identifier as internal or private will not work, because then the property system cannot operate properly.</target>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242359)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Wrapper properties are really just for convenience, Security mechanisms applied to the wrappers can be bypassed by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetValue</pc></pc> instead.</source>
					<target>Wrapper properties are really just for convenience, Security mechanisms applied to the wrappers can be bypassed by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetValue</pc></pc> instead.</target>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<segment state="initial">
					<source>So keep wrapper properties public; otherwise you just make your property harder for legitimate callers to use without providing any real security benefit.</source>
					<target>So keep wrapper properties public; otherwise you just make your property harder for legitimate callers to use without providing any real security benefit.</target>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<segment state="initial">
					<source>The Windows Runtime does not provide a way to register a custom dependency property as read-only.</source>
					<target>The Windows Runtime does not provide a way to register a custom dependency property as read-only.</target>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<segment state="initial">
					<source>Dependency properties and class constructors</source>
					<target>Dependency properties and class constructors</target>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<segment state="initial">
					<source>There is a general principle that class constructors should not call virtual methods.</source>
					<target>There is a general principle that class constructors should not call virtual methods.</target>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<segment state="initial">
					<source>This is because constructors can be called to accomplish base initialization of a derived class constructor, and entering the virtual method through the constructor might occur when the object instance being constructed is not yet completely initialized.</source>
					<target>This is because constructors can be called to accomplish base initialization of a derived class constructor, and entering the virtual method through the constructor might occur when the object instance being constructed is not yet completely initialized.</target>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When you derive from any class that already derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>, remember that the property system itself calls and exposes virtual methods internally as part of its services.</source>
					<target>When you derive from any class that already derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>, remember that the property system itself calls and exposes virtual methods internally as part of its services.</target>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<segment state="initial">
					<source>To avoid potential problems with run-time initialization, don't set dependency property values within constructors of classes.</source>
					<target>To avoid potential problems with run-time initialization, don't set dependency property values within constructors of classes.</target>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<segment state="initial">
					<source>Registering the dependency properties for C++/CX apps</source>
					<target>Registering the dependency properties for C++/CX apps</target>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>The implementation for registering a property in C++/CX is trickier than C#C#, both because of the separation into header and implementation file and also because initialization at the root scope of the implementation file is a bad practice.</source>
					<target>The implementation for registering a property in C++/CX is trickier than C#C#, both because of the separation into header and implementation file and also because initialization at the root scope of the implementation file is a bad practice.</target>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>(Visual C++ component extensions (C++/CX) puts static initializer code from the root scope directly into <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DllMain</pc>, whereas C# compilers assign the static initializers to classes and thus avoid <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DllMain</pc> load lock issues.).</source>
					<target>(Visual C++ component extensions (C++/CX) puts static initializer code from the root scope directly into <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DllMain</pc>, whereas C# compilers assign the static initializers to classes and thus avoid <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DllMain</pc> load lock issues.).</target>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<segment state="initial">
					<source>The best practice here is to declare a helper function that does all your dependency property registration for a class, one function per class.</source>
					<target>The best practice here is to declare a helper function that does all your dependency property registration for a class, one function per class.</target>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<segment state="initial">
					<source>Then for each custom class your app consumes, you'll have to reference the helper registration function that's exposed by each custom class you want to use.</source>
					<target>Then for each custom class your app consumes, you'll have to reference the helper registration function that's exposed by each custom class you want to use.</target>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242325)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">`App::App()`</data>
					<data id="id6">`InitializeComponent`</data>
				</originalData>
				<segment state="initial">
					<source>Call each helper registration function once as part of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Application constructor</pc></pc> (<ph dataRef="id5" id="ph1" />), prior to <ph dataRef="id6" id="ph2" />.</source>
					<target>Call each helper registration function once as part of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Application constructor</pc></pc> (<ph dataRef="id5" id="ph1" />), prior to <ph dataRef="id6" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<segment state="initial">
					<source>That constructor only runs when the app is really referenced for the first time, it won't run again if a suspended app resumes, for example.</source>
					<target>That constructor only runs when the app is really referenced for the first time, it won't run again if a suspended app resumes, for example.</target>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Also, as seen in the previous C++ registration example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">nullptr</pc> check around each <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Register</pc></pc> call is important: it's insurance that no caller of the function can register the property twice.</source>
					<target>Also, as seen in the previous C++ registration example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">nullptr</pc> check around each <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Register</pc></pc> call is important: it's insurance that no caller of the function can register the property twice.</target>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<segment state="initial">
					<source>A second registration call would probably crash your app without such a check because the property name would be a duplicate.</source>
					<target>A second registration call would probably crash your app without such a check because the property name would be a duplicate.</target>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=238581)</data>
				</originalData>
				<segment state="initial">
					<source>You can see this implementation pattern in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML user and custom controls sample</pc> if you look at the code for the C++/CX version of the sample.</source>
					<target>You can see this implementation pattern in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML user and custom controls sample</pc> if you look at the code for the C++/CX version of the sample.</target>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
					<target>Related topics</target>
				</segment>
			</unit>
			<unit id="311" translate="yes">
				<segment state="initial">
					<source>DependencyObject</source>
					<target>DependencyObject</target>
				</segment>
			</unit>
			<unit id="312" translate="yes">
				<segment state="initial">
					<source>DependencyProperty.Register</source>
					<target>DependencyProperty.Register</target>
				</segment>
			</unit>
			<unit id="313" translate="yes">
				<segment state="initial">
					<source>Dependency properties overview</source>
					<target>Dependency properties overview</target>
				</segment>
			</unit>
			<unit id="314" translate="yes">
				<segment state="initial">
					<source>XAML user and custom controls sample</source>
					<target>XAML user and custom controls sample</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>