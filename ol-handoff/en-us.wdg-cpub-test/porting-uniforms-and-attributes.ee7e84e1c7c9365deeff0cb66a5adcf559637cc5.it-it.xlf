<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="it-it" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">42cc98cf95cee16f889c79b869f28effc66b69b1</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\porting-uniforms-and-attributes.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">7e40397ad98dba06522607687fa2bd0e0e911901</mda:meta><mda:meta type="olxliffhash">0df673668ad91e90bdf7a330d6fdb4c7b040e7fe</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Compare OpenGL ES 2.0 buffers, uniforms, and vertex attributes to Direct3D</source>
					<target>Compare OpenGL ES 2.0 buffers, uniforms, and vertex attributes to Direct3D</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>During the process of porting to Direct3D 11 from OpenGL ES 2.0, you must change the syntax and API behavior for passing data between the app and the shader programs.</source>
					<target>During the process of porting to Direct3D 11 from OpenGL ES 2.0, you must change the syntax and API behavior for passing data between the app and the shader programs.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Compare OpenGL ES 2.0 buffers, uniforms, and vertex attributes to Direct3D</source>
					<target>Compare OpenGL ES 2.0 buffers, uniforms, and vertex attributes to Direct3D</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Important APIs</source>
					<target>Important APIs</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>ID3D11Device1::CreateBuffer</source>
					<target>ID3D11Device1::CreateBuffer</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>ID3D11Device1::CreateInputLayout</source>
					<target>ID3D11Device1::CreateInputLayout</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>ID3D11DeviceContext1::IASetInputLayout</source>
					<target>ID3D11DeviceContext1::IASetInputLayout</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>During the process of porting to Direct3D 11 from OpenGL ES 2.0, you must change the syntax and API behavior for passing data between the app and the shader programs.</source>
					<target>During the process of porting to Direct3D 11 from OpenGL ES 2.0, you must change the syntax and API behavior for passing data between the app and the shader programs.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>In OpenGL ES 2.0, data is passed to and from shader programs in four ways: as uniforms for constant data, as attributes for vertex data, as buffer objects for other resource data (such as textures).</source>
					<target>In OpenGL ES 2.0, data is passed to and from shader programs in four ways: as uniforms for constant data, as attributes for vertex data, as buffer objects for other resource data (such as textures).</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>In Direct3D 11, these roughly map to constant buffers, vertex buffers, and subresources.</source>
					<target>In Direct3D 11, these roughly map to constant buffers, vertex buffers, and subresources.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Despite the superficial commonality, they are handled quite different in usage.</source>
					<target>Despite the superficial commonality, they are handled quite different in usage.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Here's the basic mapping.</source>
					<target>Here's the basic mapping.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>OpenGL ES 2.0</source>
					<target>OpenGL ES 2.0</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Direct3D 11</source>
					<target>Direct3D 11</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>uniform</source>
					<target>uniform</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>constant buffer (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">cbuffer</pc>) field.</source>
					<target>constant buffer (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">cbuffer</pc>) field.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>attribute</source>
					<target>attribute</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>vertex buffer element field, designated by an input layout and marked with a specific HLSL semantic.</source>
					<target>vertex buffer element field, designated by an input layout and marked with a specific HLSL semantic.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>buffer object</source>
					<target>buffer object</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>buffer; See <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11\_SUBRESOURCE\_DATA</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">D3D11\_BUFFER\_DESC</pc></pc> and for a general-use buffer definitions.</source>
					<target>buffer; See <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11\_SUBRESOURCE\_DATA</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">D3D11\_BUFFER\_DESC</pc></pc> and for a general-use buffer definitions.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>frame buffer object (FBO)</source>
					<target>frame buffer object (FBO)</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>render target(s); See <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11RenderTargetView</pc></pc> with <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11Texture2D</pc></pc>.</source>
					<target>render target(s); See <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11RenderTargetView</pc></pc> with <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11Texture2D</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>back buffer</source>
					<target>back buffer</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404631)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff471343)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>swap chain with "back buffer" surface; See <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1</pc></pc> with attached <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IDXGISurface1</pc></pc>.</source>
					<target>swap chain with "back buffer" surface; See <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1</pc></pc> with attached <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IDXGISurface1</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>Port buffers</source>
					<target>Port buffers</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>In OpenGL ES 2.0, the process for creating and binding any kind of buffer generally follows this pattern</source>
					<target>In OpenGL ES 2.0, the process for creating and binding any kind of buffer generally follows this pattern</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>Call glGenBuffers to generate one or more buffers and return the handles to them.</source>
					<target>Call glGenBuffers to generate one or more buffers and return the handles to them.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>Call glBindBuffer to define the layout of a buffer, such as GL\_ELEMENT\_ARRAY\_BUFFER.</source>
					<target>Call glBindBuffer to define the layout of a buffer, such as GL\_ELEMENT\_ARRAY\_BUFFER.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Call glBufferData to populate the buffer with specific data (such as vertex structures, index data, or color data) in a specific layout.</source>
					<target>Call glBufferData to populate the buffer with specific data (such as vertex structures, index data, or color data) in a specific layout.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>The most common kind of buffer is the vertex buffer, which minimally contains the positions of the vertices in some coordinate system.</source>
					<target>The most common kind of buffer is the vertex buffer, which minimally contains the positions of the vertices in some coordinate system.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>In typical use, a vertex is represented by a structure that contains the position coordinates, a normal vector to the vertex position, a tangent vector to the vertex position, and texture lookup (uv) coordinates.</source>
					<target>In typical use, a vertex is represented by a structure that contains the position coordinates, a normal vector to the vertex position, a tangent vector to the vertex position, and texture lookup (uv) coordinates.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>The buffer contains a contiguous list of these vertices, in some order (like a triangle list, or strip, or fan), and which collectively represent the visible polygons in your scene.</source>
					<target>The buffer contains a contiguous list of these vertices, in some order (like a triangle list, or strip, or fan), and which collectively represent the visible polygons in your scene.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>(In Direct3D 11 as well as OpenGL ES 2.0 it is inefficient to have multiple vertex buffers per draw call.)</source>
					<target>(In Direct3D 11 as well as OpenGL ES 2.0 it is inefficient to have multiple vertex buffers per draw call.)</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>Here's an example a vertex buffer and an index buffer created with OpenGL ES 2.0:</source>
					<target>Here's an example a vertex buffer and an index buffer created with OpenGL ES 2.0:</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>OpenGL ES 2.0: Creating and populating a vertex buffer and an index buffer.</source>
					<target>OpenGL ES 2.0: Creating and populating a vertex buffer and an index buffer.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Other buffers include pixel buffers and maps, like textures.</source>
					<target>Other buffers include pixel buffers and maps, like textures.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>The shader pipeline can render into texture buffers (pixmaps) or render buffer objects and use those buffers in future shader passes.</source>
					<target>The shader pipeline can render into texture buffers (pixmaps) or render buffer objects and use those buffers in future shader passes.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>In the simplest case, the call flow is:</source>
					<target>In the simplest case, the call flow is:</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Call glGenFramebuffers to generate a frame buffer object.</source>
					<target>Call glGenFramebuffers to generate a frame buffer object.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>Call glBindFramebuffer to bind the frame buffer object for writing.</source>
					<target>Call glBindFramebuffer to bind the frame buffer object for writing.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>Call glFramebufferTexture2D to draw into a specified texture map.</source>
					<target>Call glFramebufferTexture2D to draw into a specified texture map.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>In Direct3D 11, buffer data elements are considered "subresources," and can range from individual vertex data elements to MIP-map textures.</source>
					<target>In Direct3D 11, buffer data elements are considered "subresources," and can range from individual vertex data elements to MIP-map textures.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Populate a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11\_SUBRESOURCE\_DATA</pc></pc> structure with the configuration for a buffer data element.</source>
					<target>Populate a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11\_SUBRESOURCE\_DATA</pc></pc> structure with the configuration for a buffer data element.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Populate a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11\_BUFFER\_DESC</pc></pc> structure with the size of the individual elements in the buffer as well as the buffer type.</source>
					<target>Populate a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11\_BUFFER\_DESC</pc></pc> structure with the size of the individual elements in the buffer as well as the buffer type.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device1::CreateBuffer</pc></pc> with these two structures.</source>
					<target>Call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device1::CreateBuffer</pc></pc> with these two structures.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Direct3D 11: Creating and populating a vertex buffer and an index buffer.</source>
					<target>Direct3D 11: Creating and populating a vertex buffer and an index buffer.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Writable pixel buffers or maps, such as a frame buffer, can be created as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Texture2D</pc></pc> objects.</source>
					<target>Writable pixel buffers or maps, such as a frame buffer, can be created as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Texture2D</pc></pc> objects.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476628)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>These can be bound as resources to an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11RenderTargetView</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11ShaderResourceView</pc></pc>, which, once drawn into, can be displayed with the associated swap chain or passed to a shader, respectively.</source>
					<target>These can be bound as resources to an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11RenderTargetView</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11ShaderResourceView</pc></pc>, which, once drawn into, can be displayed with the associated swap chain or passed to a shader, respectively.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Direct3D 11: Creating a frame buffer object.</source>
					<target>Direct3D 11: Creating a frame buffer object.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>Change uniforms and uniform buffer objects to Direct3D constant buffers</source>
					<target>Change uniforms and uniform buffer objects to Direct3D constant buffers</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>In Open GL ES 2.0, uniforms are the mechanism to supply constant data to individual shader programs.</source>
					<target>In Open GL ES 2.0, uniforms are the mechanism to supply constant data to individual shader programs.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>This data cannot be altered by the shaders.</source>
					<target>This data cannot be altered by the shaders.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Setting a uniform typically involves providing one of the glUniform\* methods with the upload location in the GPU along with a pointer to the data in app memory.</source>
					<target>Setting a uniform typically involves providing one of the glUniform\* methods with the upload location in the GPU along with a pointer to the data in app memory.</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>After ithe glUniform\* method executes, the uniform data is in the GPU memory and accessible by the shaders that have declared that uniform.</source>
					<target>After ithe glUniform\* method executes, the uniform data is in the GPU memory and accessible by the shaders that have declared that uniform.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>You are expected to ensure that the data is packed in such a way that the shader can interpret it based on the uniform declaration in the shader (by using compatible types).</source>
					<target>You are expected to ensure that the data is packed in such a way that the shader can interpret it based on the uniform declaration in the shader (by using compatible types).</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>OpenGL ES 2.0 Creating a uniform and uploading data to it</source>
					<target>OpenGL ES 2.0 Creating a uniform and uploading data to it</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>In a shader's GLSL, the corresponding uniform declaration looks like this:</source>
					<target>In a shader's GLSL, the corresponding uniform declaration looks like this:</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>Open GL ES 2.0: GLSL uniform declaration</source>
					<target>Open GL ES 2.0: GLSL uniform declaration</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>Direct3D designates uniform data as "constant buffers," which, like uniforms, contain constant data provided to individual shaders.</source>
					<target>Direct3D designates uniform data as "constant buffers," which, like uniforms, contain constant data provided to individual shaders.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>As with uniform buffers, it is important to pack the constant buffer data in memory identically to the way the shader expects to interpret it.</source>
					<target>As with uniform buffers, it is important to pack the constant buffer data in memory identically to the way the shader expects to interpret it.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ee419608)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Using DirectXMath types (such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XMFLOAT4</pc></pc>) instead of platform types (such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3">float\*</pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">float\[4\]</pc>) guarantees proper data element alignment.</source>
					<target>Using DirectXMath types (such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XMFLOAT4</pc></pc>) instead of platform types (such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3">float\*</pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">float\[4\]</pc>) guarantees proper data element alignment.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>Constant buffers must have an associated GPU register used to reference that data on the GPU.</source>
					<target>Constant buffers must have an associated GPU register used to reference that data on the GPU.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>The data is packed into the register location as indicated by the layout of the buffer.</source>
					<target>The data is packed into the register location as indicated by the layout of the buffer.</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>Direct3D 11: Creating a constant buffer and uploading data to it</source>
					<target>Direct3D 11: Creating a constant buffer and uploading data to it</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>In a shader's HLSL, the corresponding constant buffer declaration looks like this:</source>
					<target>In a shader's HLSL, the corresponding constant buffer declaration looks like this:</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>Direct3D 11: Constant buffer HLSL declaration</source>
					<target>Direct3D 11: Constant buffer HLSL declaration</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>Note that a register must be declared for each constant buffer.</source>
					<target>Note that a register must be declared for each constant buffer.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>Different Direct3D feature levels have different maximum available registers, so do not exceed the maximum number for the lowest feature level you are targeting.</source>
					<target>Different Direct3D feature levels have different maximum available registers, so do not exceed the maximum number for the lowest feature level you are targeting.</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>Port vertex attributes to a Direct3D input layouts and HLSL semantics</source>
					<target>Port vertex attributes to a Direct3D input layouts and HLSL semantics</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>Since vertex data can be modified by the shader pipeline, OpenGL ES 2.0 requires that you specify them as "attributes" instead of "uniforms".</source>
					<target>Since vertex data can be modified by the shader pipeline, OpenGL ES 2.0 requires that you specify them as "attributes" instead of "uniforms".</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>(This has changed in later versions of OpenGL and GLSL.) Vertex-specific data such the vertex position, normals, tangents, and color values are supplied to the shaders as attribute values.</source>
					<target>(This has changed in later versions of OpenGL and GLSL.) Vertex-specific data such the vertex position, normals, tangents, and color values are supplied to the shaders as attribute values.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>These attribute values correspond to specific offsets for each element in the vertex data; for example, the first attribute could point to the position component of an individual vertex, and the second to the normal, and so on.</source>
					<target>These attribute values correspond to specific offsets for each element in the vertex data; for example, the first attribute could point to the position component of an individual vertex, and the second to the normal, and so on.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>The basic process for moving the vertex buffer data from main memory to the GPU looks like this:</source>
					<target>The basic process for moving the vertex buffer data from main memory to the GPU looks like this:</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Upload the vertex data with glBindBuffer.</source>
					<target>Upload the vertex data with glBindBuffer.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>Get the location of the attributes on the GPU with glGetAttribLocation.</source>
					<target>Get the location of the attributes on the GPU with glGetAttribLocation.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>Call it for each attribute in the vertex data element.</source>
					<target>Call it for each attribute in the vertex data element.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>Call glVertexAttribPointer to provide set the correct attribute size and offset inside an individual vertex data element.</source>
					<target>Call glVertexAttribPointer to provide set the correct attribute size and offset inside an individual vertex data element.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>Do this for each attribute.</source>
					<target>Do this for each attribute.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Enable the vertex data layout information with glEnableVertexAttribArray.</source>
					<target>Enable the vertex data layout information with glEnableVertexAttribArray.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>OpenGL ES 2.0: Uploading vertex buffer data to the shader attribute</source>
					<target>OpenGL ES 2.0: Uploading vertex buffer data to the shader attribute</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>Now, in your vertex shader, you declare attributes with the same names you defined in your call to glGetAttribLocation.</source>
					<target>Now, in your vertex shader, you declare attributes with the same names you defined in your call to glGetAttribLocation.</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>OpenGL ES 2.0: Declaring an attribute in GLSL</source>
					<target>OpenGL ES 2.0: Declaring an attribute in GLSL</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>In some ways, the same process holds for Direct3D.</source>
					<target>In some ways, the same process holds for Direct3D.</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>Instead of a attributes, vertex data is provided in input buffers, which include vertex buffers and the corresponding index buffers.</source>
					<target>Instead of a attributes, vertex data is provided in input buffers, which include vertex buffers and the corresponding index buffers.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>However, since Direct3D does not have the "attribute" declaration, you must specify an input layout which declares the individual component of the data elements in the vertex buffer and the HLSL semantics that indicate where and how those components are to be interpreted by the vertex shader.</source>
					<target>However, since Direct3D does not have the "attribute" declaration, you must specify an input layout which declares the individual component of the data elements in the vertex buffer and the HLSL semantics that indicate where and how those components are to be interpreted by the vertex shader.</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>HLSL semantics require that you define the usage of each component with a specific string that informs the shader engine as to its purpose.</source>
					<target>HLSL semantics require that you define the usage of each component with a specific string that informs the shader engine as to its purpose.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>For example, vertex position data is marked as POSITION, normal data is marked as NORMAL, and vertex color data is marked as COLOR.</source>
					<target>For example, vertex position data is marked as POSITION, normal data is marked as NORMAL, and vertex color data is marked as COLOR.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](change-your-shader-loading-code.md)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/bb205574)</data>
				</originalData>
				<segment state="initial">
					<source>(Other shader stages also require specific semantics, and those semantics have different interpretations based on the shader stage.) For more info on HLSL semantics, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Port your shader pipeline</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HLSL Semantics</pc>.</source>
					<target>(Other shader stages also require specific semantics, and those semantics have different interpretations based on the shader stage.) For more info on HLSL semantics, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Port your shader pipeline</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HLSL Semantics</pc>.</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>Collectively, the process of setting the vertex and index buffers, and setting the input layout is called the "Input Assembly" (IA) stage of the Direct3D graphics pipeline.</source>
					<target>Collectively, the process of setting the vertex and index buffers, and setting the input layout is called the "Input Assembly" (IA) stage of the Direct3D graphics pipeline.</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>Direct3D 11: Configuring the input assembly stage</source>
					<target>Direct3D 11: Configuring the input assembly stage</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>An input layout is declared and associated with a vertex shader by declaring the format of the vertex data element and the semantic used for each component.</source>
					<target>An input layout is declared and associated with a vertex shader by declaring the format of the vertex data element and the semantic used for each component.</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>The vertex element data layout described in the D3D11\_INPUT\_ELEMENT\_DESC you create must correspond to the layout of the corresponding structure.</source>
					<target>The vertex element data layout described in the D3D11\_INPUT\_ELEMENT\_DESC you create must correspond to the layout of the corresponding structure.</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>Here, you create a layout for vertex data that has two components:</source>
					<target>Here, you create a layout for vertex data that has two components:</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>A vertex position coordinate, represented in main memory as an XMFLOAT3, which is an aligned array of 3 32-bit floating point values for the (x, y, z) coordinates.</source>
					<target>A vertex position coordinate, represented in main memory as an XMFLOAT3, which is an aligned array of 3 32-bit floating point values for the (x, y, z) coordinates.</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>A vertex color value, represented as an XMFLOAT4, which is an aligned array of 4 32-bit floating point values for the color (RGBA).</source>
					<target>A vertex color value, represented as an XMFLOAT4, which is an aligned array of 4 32-bit floating point values for the color (RGBA).</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>You assign a semantic for each one, as well as a format type.</source>
					<target>You assign a semantic for each one, as well as a format type.</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476512)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You then pass the description to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device1::CreateInputLayout</pc></pc>.</source>
					<target>You then pass the description to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device1::CreateInputLayout</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476454)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The input layout is used when we call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::IASetInputLayout</pc></pc> when you set up the input assembly during our render method.</source>
					<target>The input layout is used when we call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::IASetInputLayout</pc></pc> when you set up the input assembly during our render method.</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>Direct3D 11: Describing an input layout with specific semantics</source>
					<target>Direct3D 11: Describing an input layout with specific semantics</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>Finally, you make sure that the shader can understand the input data by declaring the input.</source>
					<target>Finally, you make sure that the shader can understand the input data by declaring the input.</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>The semantics you assigned in the layout are used to select the correct locations in GPU memory.</source>
					<target>The semantics you assigned in the layout are used to select the correct locations in GPU memory.</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>Direct3D 11: Declaring shader input data with HLSL semantics</source>
					<target>Direct3D 11: Declaring shader input data with HLSL semantics</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>