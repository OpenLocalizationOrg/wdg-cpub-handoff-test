<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="it-it" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">0650191324964593b8b3fc54b757648253b95caa</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci1\xaml-platform\xaml-overview.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">12b1b2a7f8b0d4486d61d295243a70731213e6d9</mda:meta><mda:meta type="olxliffhash">cde2236f3ceb4d99bf14dfdc53b8048c3169fd64</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>We introduce the XAML language and XAML concepts to the Windows Runtime app developer audience, and describe the different ways to declare objects and set attributes in XAML as it is used for creating a Windows Runtime app.</source>
					<target>We introduce the XAML language and XAML concepts to the Windows Runtime app developer audience, and describe the different ways to declare objects and set attributes in XAML as it is used for creating a Windows Runtime app.</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>XAML overview</source>
					<target>XAML overview</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>XAML overview</source>
					<target>XAML overview</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>We introduce the XAML language and XAML concepts to the Windows Runtime app developer audience, and describe the different ways to declare objects and set attributes in XAML as it is used for creating a Windows Runtime app.</source>
					<target>We introduce the XAML language and XAML concepts to the Windows Runtime app developer audience, and describe the different ways to declare objects and set attributes in XAML as it is used for creating a Windows Runtime app.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>What is XAML?</source>
					<target>What is XAML?</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>Extensible Application Markup Language (XAML) is a declarative language.</source>
					<target>Extensible Application Markup Language (XAML) is a declarative language.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Specifically, XAML can initialize objects and set properties of objects, using a language structure that shows hierarchical relationships between multiple objects, and using a backing type convention that supports extension of types.</source>
					<target>Specifically, XAML can initialize objects and set properties of objects, using a language structure that shows hierarchical relationships between multiple objects, and using a backing type convention that supports extension of types.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>You can create visible UI elements in the declarative XAML markup.</source>
					<target>You can create visible UI elements in the declarative XAML markup.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>You can then associate a separate code-behind file for each XAML file that can respond to events and manipulate the objects that you originally declare in XAML.</source>
					<target>You can then associate a separate code-behind file for each XAML file that can respond to events and manipulate the objects that you originally declare in XAML.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>The XAML language supports interchange of sources between different tools and roles in the development process, such as exchanging XAML sources between design tools and an IDE, or between primary developers and localization developers.</source>
					<target>The XAML language supports interchange of sources between different tools and roles in the development process, such as exchanging XAML sources between design tools and an IDE, or between primary developers and localization developers.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>By using XAML as the interchange format, designer roles and developer roles can be kept separate or brought together, and designers and developers can iterate during the production of an app.</source>
					<target>By using XAML as the interchange format, designer roles and developer roles can be kept separate or brought together, and designers and developers can iterate during the production of an app.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>When you see them as part of your Windows Runtime app projects, XAML files are XML files with the .xaml file name extension.</source>
					<target>When you see them as part of your Windows Runtime app projects, XAML files are XML files with the .xaml file name extension.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>Basic XAML syntax</source>
					<target>Basic XAML syntax</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>XAML has a basic syntax that builds on XML.</source>
					<target>XAML has a basic syntax that builds on XML.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>By definition, valid XAML must also be valid XML.</source>
					<target>By definition, valid XAML must also be valid XML.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>But XAML also has syntax concepts that are assigned a different and more complete meaning, while still being valid in XML per the XML 1.0 specification.</source>
					<target>But XAML also has syntax concepts that are assigned a different and more complete meaning, while still being valid in XML per the XML 1.0 specification.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>For example, XAML supports <pc dataRefEnd="id2" dataRefStart="id1" id="p1">property element syntax</pc>, where property values can be set within elements rather than as string values in attributes or as content.</source>
					<target>For example, XAML supports <pc dataRefEnd="id2" dataRefStart="id1" id="p1">property element syntax</pc>, where property values can be set within elements rather than as string values in attributes or as content.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>To regular XML, a XAML property element is an element with a dot in its name, so it's valid to plain XML but doesn't have the same meaning.</source>
					<target>To regular XML, a XAML property element is an element with a dot in its name, so it's valid to plain XML but doesn't have the same meaning.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>XAML and Microsoft Visual Studio</source>
					<target>XAML and Microsoft Visual Studio</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>Microsoft Visual Studio helps you to produce valid XAML syntax, both in the XAML text editor and in the more graphically oriented XAML design surface.</source>
					<target>Microsoft Visual Studio helps you to produce valid XAML syntax, both in the XAML text editor and in the more graphically oriented XAML design surface.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>So when you write XAML for your app using Visual Studio, don't worry too much about the syntax with each keystroke.</source>
					<target>So when you write XAML for your app using Visual Studio, don't worry too much about the syntax with each keystroke.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>The IDE encourages valid XAML syntax by providing autocompletion hints, showing suggestions in Microsoft IntelliSense lists and dropdowns, showing UI element libraries in the toolbox, or other techniques.</source>
					<target>The IDE encourages valid XAML syntax by providing autocompletion hints, showing suggestions in Microsoft IntelliSense lists and dropdowns, showing UI element libraries in the toolbox, or other techniques.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>If this is your first experience with XAML, it might still be useful to know the syntax rules and particularly the terminology that is sometimes used to describe the restrictions or choices when we describe XAML syntax in reference or other topics.</source>
					<target>If this is your first experience with XAML, it might still be useful to know the syntax rules and particularly the terminology that is sometimes used to describe the restrictions or choices when we describe XAML syntax in reference or other topics.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](xaml-syntax-guide.md)</data>
				</originalData>
				<segment state="initial">
					<source>We cover these fine points of XAML syntax in a separate topic, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML syntax guide</pc>.</source>
					<target>We cover these fine points of XAML syntax in a separate topic, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML syntax guide</pc>.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>XAML namespaces</source>
					<target>XAML namespaces</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>In general programming, a namespace is an organizing concept that determines how identifiers for programming entities are interpreted.</source>
					<target>In general programming, a namespace is an organizing concept that determines how identifiers for programming entities are interpreted.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>By using namespaces, a programming framework can separate user-declared identifiers from framework-declared identifiers, disambiguate identifiers through namespace qualifications, enforce rules for scoping names, and so on.</source>
					<target>By using namespaces, a programming framework can separate user-declared identifiers from framework-declared identifiers, disambiguate identifiers through namespace qualifications, enforce rules for scoping names, and so on.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>XAML has its own XAML namespace concept that serves this purpose for the XAML language.</source>
					<target>XAML has its own XAML namespace concept that serves this purpose for the XAML language.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Here's how XAML applies and extends the XML language namespace concepts:</source>
					<target>Here's how XAML applies and extends the XML language namespace concepts:</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>XAML uses the reserved XML attribute <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> for namespace declarations.</source>
					<target>XAML uses the reserved XML attribute <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> for namespace declarations.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>The value of the attribute is typically a Uniform Resource Identifier (URI), which is a convention inherited from XML.</source>
					<target>The value of the attribute is typically a Uniform Resource Identifier (URI), which is a convention inherited from XML.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>XAML uses prefixes in declarations to declare non-default namespaces, and prefix usages in elements and attributes reference that namespace.</source>
					<target>XAML uses prefixes in declarations to declare non-default namespaces, and prefix usages in elements and attributes reference that namespace.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>XAML has a concept of a default namespace, which is the namespace used when no prefix exists in a usage or declaration.</source>
					<target>XAML has a concept of a default namespace, which is the namespace used when no prefix exists in a usage or declaration.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>The default namespace can be defined differently for each XAML programming framework.</source>
					<target>The default namespace can be defined differently for each XAML programming framework.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Namespace definitions inherit in a XAML file or construct, from parent element to child element.</source>
					<target>Namespace definitions inherit in a XAML file or construct, from parent element to child element.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>For example if you define a namespace in the root element of a XAML file, all elements within that file inherit that namespace definition.</source>
					<target>For example if you define a namespace in the root element of a XAML file, all elements within that file inherit that namespace definition.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>If an element further into the page redefines the namespace, that element's descendants inherit the new definition.</source>
					<target>If an element further into the page redefines the namespace, that element's descendants inherit the new definition.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Attributes of an element inherit the element's namespaces.</source>
					<target>Attributes of an element inherit the element's namespaces.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>It's fairly uncommon to see prefixes on XAML attributes.</source>
					<target>It's fairly uncommon to see prefixes on XAML attributes.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>A XAML file almost always declares a default XAML namespace in its root element.</source>
					<target>A XAML file almost always declares a default XAML namespace in its root element.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>The default XAML namespace defines which elements you can declare without qualifying them by a prefix.</source>
					<target>The default XAML namespace defines which elements you can declare without qualifying them by a prefix.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>For typical Windows Runtime app projects, this default namespace contains all the built-in XAML vocabulary for the Windows Runtime that's used for UI definitions: the default controls, text elements, XAML graphics and animations, databinding and styling support types, and so on.</source>
					<target>For typical Windows Runtime app projects, this default namespace contains all the built-in XAML vocabulary for the Windows Runtime that's used for UI definitions: the default controls, text elements, XAML graphics and animations, databinding and styling support types, and so on.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>Most of the XAML you'll write for Windows Runtime apps will thus be able to avoid using XAML namespaces and prefixes when referring to common UI elements.</source>
					<target>Most of the XAML you'll write for Windows Runtime apps will thus be able to avoid using XAML namespaces and prefixes when referring to common UI elements.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227503)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's a snippet showing a template-created <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Page</pc></pc> root of the initial page for an app (showing the opening tag only, and simplified).</source>
					<target>Here's a snippet showing a template-created <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Page</pc></pc> root of the initial page for an app (showing the opening tag only, and simplified).</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>It declares the default namespace and also the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x</pc> namespace (which we'll explain next).</source>
					<target>It declares the default namespace and also the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x</pc> namespace (which we'll explain next).</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>The XAML-language XAML namespace</source>
					<target>The XAML-language XAML namespace</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>One particular XAML namespace that is declared in nearly every Windows Runtime XAML file is the XAML-language namespace.</source>
					<target>One particular XAML namespace that is declared in nearly every Windows Runtime XAML file is the XAML-language namespace.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>This namespace includes elements and concepts that are defined by the XAML language, by its language specification.</source>
					<target>This namespace includes elements and concepts that are defined by the XAML language, by its language specification.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>By convention, the XAML-language XAML namespace is mapped to the prefix "x".</source>
					<target>By convention, the XAML-language XAML namespace is mapped to the prefix "x".</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">`xmlns=`</data>
				</originalData>
				<segment state="initial">
					<source>The default project and file templates for Windows Runtime app projects always define both the default XAML namespace (no prefix, just <ph dataRef="id1" id="ph1" />) and the XAML-language XAML namespace (prefix "x") as part of the root element.</source>
					<target>The default project and file templates for Windows Runtime app projects always define both the default XAML namespace (no prefix, just <ph dataRef="id1" id="ph1" />) and the XAML-language XAML namespace (prefix "x") as part of the root element.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>The "x" prefix/XAML-language XAML namespace contains several programming constructs that you use often in your XAML.</source>
					<target>The "x" prefix/XAML-language XAML namespace contains several programming constructs that you use often in your XAML.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Here are the most common ones:</source>
					<target>Here are the most common ones:</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Term</source>
					<target>Term</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Description</source>
					<target>Description</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>x:Key</source>
					<target>x:Key</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Sets a unique user-defined key for each resource in a XAML <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>.</source>
					<target>Sets a unique user-defined key for each resource in a XAML <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The key's token string is the argument for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource</pc> markup extension, and you use this key later to retrieve the XAML resource from another XAML usage elsewhere in your app's XAML.</source>
					<target>The key's token string is the argument for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource</pc> markup extension, and you use this key later to retrieve the XAML resource from another XAML usage elsewhere in your app's XAML.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>x:Class</source>
					<target>x:Class</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>Specifies the code namespace and code class name for the class that provides code-behind for a XAML page.</source>
					<target>Specifies the code namespace and code class name for the class that provides code-behind for a XAML page.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>This names the class that is created or joined by the build actions when you build your app.</source>
					<target>This names the class that is created or joined by the build actions when you build your app.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>These build actions support the XAML markup compiler and combine your markup and code-behind when the app is compiled.</source>
					<target>These build actions support the XAML markup compiler and combine your markup and code-behind when the app is compiled.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>You must have such a class to support code-behind for a XAML page.</source>
					<target>You must have such a class to support code-behind for a XAML page.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209051)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Window.Content</pc></pc> in the default Windows Runtime activation model.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Window.Content</pc></pc> in the default Windows Runtime activation model.</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>x:Name</source>
					<target>x:Name</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Specifies a run-time object name for the instance that exists in run-time code after an object element defined in XAML is processed.</source>
					<target>Specifies a run-time object name for the instance that exists in run-time code after an object element defined in XAML is processed.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You can think of setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Name</pc> in XAML as being like declaring a named variable in code.</source>
					<target>You can think of setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Name</pc> in XAML as being like declaring a named variable in code.</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>As you'll learn later, that's exactly what happens when your XAML is loaded as a component of a Windows Runtime app.</source>
					<target>As you'll learn later, that's exactly what happens when your XAML is loaded as a component of a Windows Runtime app.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208735)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FrameworkElement.Name</pc></pc> is a similar property in the framework but not all elements support it.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FrameworkElement.Name</pc></pc> is a similar property in the framework but not all elements support it.</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>So you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Name</pc> for element identification, whenever <pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.Name</pc> is not supported on that element type.</source>
					<target>So you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Name</pc> for element identification, whenever <pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.Name</pc> is not supported on that element type.</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>x:Uid</source>
					<target>x:Uid</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>Identifies elements that should use localized resources for some of their property values.</source>
					<target>Identifies elements that should use localized resources for some of their property values.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/xaml/hh965329)</data>
				</originalData>
				<segment state="initial">
					<source>For more info on how to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Uid</pc>, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Quickstart: Translating UI resources</pc>.</source>
					<target>For more info on how to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Uid</pc>, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Quickstart: Translating UI resources</pc>.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>XAML intrinsic data types</source>
					<target>XAML intrinsic data types</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>These types can specify values for simple value-types when that's required for an attribute or resource.</source>
					<target>These types can specify values for simple value-types when that's required for an attribute or resource.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>These intrinsic types correspond to the simple value types that are typically defined as part of each programming language's intrinsic definitions.</source>
					<target>These intrinsic types correspond to the simple value types that are typically defined as part of each programming language's intrinsic definitions.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br210320)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, you might need an object representing a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc> Boolean value to use in an <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ObjectAnimationUsingKeyFrames</pc></pc> storyboarded visual state.</source>
					<target>For example, you might need an object representing a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc> Boolean value to use in an <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ObjectAnimationUsingKeyFrames</pc></pc> storyboarded visual state.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For that value in XAML, you'd use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Boolean</pc> intrinsic type as the object element, like this:</source>
					<target>For that value in XAML, you'd use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Boolean</pc> intrinsic type as the object element, like this:</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>Other programming constructs in the XAML-language XAML namespace exist but are not as common.</source>
					<target>Other programming constructs in the XAML-language XAML namespace exist but are not as common.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Mapping custom types to XAML namespaces</source>
					<target>Mapping custom types to XAML namespaces</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>One of the most powerful aspects of XAML as a language is that it's easy to extend the XAML vocabulary for your Windows Runtime apps.</source>
					<target>One of the most powerful aspects of XAML as a language is that it's easy to extend the XAML vocabulary for your Windows Runtime apps.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>You can define your own custom types in your app's programming language and then reference your custom types in XAML markup.</source>
					<target>You can define your own custom types in your app's programming language and then reference your custom types in XAML markup.</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>Support for extension through custom types is fundamentally built-in to how the XAML language works.</source>
					<target>Support for extension through custom types is fundamentally built-in to how the XAML language works.</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>Frameworks or app developers are responsible for creating the backing objects that XAML references.</source>
					<target>Frameworks or app developers are responsible for creating the backing objects that XAML references.</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>Neither frameworks nor the app developer are bound by specifications of what the objects in their vocabularies represent or do beyond the basic XAML syntax rules (there are some expectations of what the XAML-language XAML namespace types should do, but the Windows Runtime provides all the necessary support).</source>
					<target>Neither frameworks nor the app developer are bound by specifications of what the objects in their vocabularies represent or do beyond the basic XAML syntax rules (there are some expectations of what the XAML-language XAML namespace types should do, but the Windows Runtime provides all the necessary support).</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>If you use XAML for types that come from libraries other than the Windows Runtime core libraries and metadata, you must declare and map a XAML namespace with a prefix.</source>
					<target>If you use XAML for types that come from libraries other than the Windows Runtime core libraries and metadata, you must declare and map a XAML namespace with a prefix.</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Use that prefix in element usages to reference the types that were defined in your library.</source>
					<target>Use that prefix in element usages to reference the types that were defined in your library.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You declare prefix mappings as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> attributes, typically in a root element along with the other XAML namespace definitions.</source>
					<target>You declare prefix mappings as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> attributes, typically in a root element along with the other XAML namespace definitions.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>To make your own namespace definition that references custom types, you first specify the keyword <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns:</pc>, then the prefix you want.</source>
					<target>To make your own namespace definition that references custom types, you first specify the keyword <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns:</pc>, then the prefix you want.</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The value of that attribute must contain the keyword <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using:</pc> as the first part of the value.</source>
					<target>The value of that attribute must contain the keyword <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using:</pc> as the first part of the value.</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>The remainder of the value is a string token that references the specific code-backing namespace that contains your custom types, by name.</source>
					<target>The remainder of the value is a string token that references the specific code-backing namespace that contains your custom types, by name.</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>The prefix defines the markup token that is used to refer to that XAML namespace in the remainder of the markup in that XAML file.</source>
					<target>The prefix defines the markup token that is used to refer to that XAML namespace in the remainder of the markup in that XAML file.</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>A colon character (:) goes between the prefix and the entity to be referenced within the XAML namespace.</source>
					<target>A colon character (:) goes between the prefix and the entity to be referenced within the XAML namespace.</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<originalData>
					<data id="id1">`myTypes`</data>
					<data id="id2">`myCompany.myTypes`</data>
					<data id="id3">`    xmlns:myTypes="using:myCompany.myTypes"`</data>
				</originalData>
				<segment state="initial">
					<source>For example, the attribute syntax to map a prefix <ph dataRef="id1" id="ph1" /> to the namespace <ph dataRef="id2" id="ph2" /> is: <ph dataRef="id3" id="ph3" />, and a representative element usage is:</source>
					<target>For example, the attribute syntax to map a prefix <ph dataRef="id1" id="ph1" /> to the namespace <ph dataRef="id2" id="ph2" /> is: <ph dataRef="id3" id="ph3" />, and a representative element usage is:</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](xaml-namespaces-and-namespace-mapping.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info on mapping XAML namespaces for custom types, including special considerations for Visual C++ component extensions (C++/CX), see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML namespaces and namespace mapping</pc>.</source>
					<target>For more info on mapping XAML namespaces for custom types, including special considerations for Visual C++ component extensions (C++/CX), see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML namespaces and namespace mapping</pc>.</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>Other XAML namespaces</source>
					<target>Other XAML namespaces</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>You often see XAML files that define the prefixes "d" (for designer namespace) and "mc" (for markup compatibility).</source>
					<target>You often see XAML files that define the prefixes "d" (for designer namespace) and "mc" (for markup compatibility).</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>Generally these are for infrastructure support, or to enable scenarios in a design-time tool.</source>
					<target>Generally these are for infrastructure support, or to enable scenarios in a design-time tool.</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](xaml-namespaces-and-namespace-mapping.md#other-XAML-namespaces)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">"Other XAML namespaces" section of the XAML namespaces topic</pc>.</source>
					<target>For more info, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">"Other XAML namespaces" section of the XAML namespaces topic</pc>.</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>Markup extensions</source>
					<target>Markup extensions</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>Markup extensions are a XAML language concept that is often used in the Windows Runtime XAML implementation.</source>
					<target>Markup extensions are a XAML language concept that is often used in the Windows Runtime XAML implementation.</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>Markup extensions often represent some kind of "shortcut" that enables a XAML file to access a value or behavior that isn't simply declaring elements based on backing types.</source>
					<target>Markup extensions often represent some kind of "shortcut" that enables a XAML file to access a value or behavior that isn't simply declaring elements based on backing types.</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>Some markup extensions can set properties with plain strings or with additionally nested elements, with the goal of streamlining the syntax or the factoring between different XAML files.</source>
					<target>Some markup extensions can set properties with plain strings or with additionally nested elements, with the goal of streamlining the syntax or the factoring between different XAML files.</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>In XAML attribute syntax, curly braces "{" and "}" indicate a XAML markup extension usage.</source>
					<target>In XAML attribute syntax, curly braces "{" and "}" indicate a XAML markup extension usage.</target>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>This usage directs the XAML processing to escape from the general treatment of treating attribute values as either a literal string or a directly string-convertible value.</source>
					<target>This usage directs the XAML processing to escape from the general treatment of treating attribute values as either a literal string or a directly string-convertible value.</target>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>Instead, a XAML parser calls code that provides behavior for that particular markup extension, and that code provides an alternate object or behavior result that the XAML parser needs.</source>
					<target>Instead, a XAML parser calls code that provides behavior for that particular markup extension, and that code provides an alternate object or behavior result that the XAML parser needs.</target>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>Markup extensions can have arguments, which follow the markup extension name and are also contained within the curly braces.</source>
					<target>Markup extensions can have arguments, which follow the markup extension name and are also contained within the curly braces.</target>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>Typically, an evaluated markup extension provides an object return value.</source>
					<target>Typically, an evaluated markup extension provides an object return value.</target>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>During parsing, that return value is inserted into the position in the object tree where the markup extension usage was in the source XAML.</source>
					<target>During parsing, that return value is inserted into the position in the object tree where the markup extension usage was in the source XAML.</target>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>Windows Runtime XAML supports these markup extensions that are defined under the default XAML namespace and are understood by the Windows Runtime XAML parser:</source>
					<target>Windows Runtime XAML supports these markup extensions that are defined under the default XAML namespace and are understood by the Windows Runtime XAML parser:</target>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](x-bind-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{xBind}</pc>: supports data binding, which defers property evaluation until run-time by executing special-purpose code, which it generates at compile-time.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{xBind}</pc>: supports data binding, which defers property evaluation until run-time by executing special-purpose code, which it generates at compile-time.</target>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>This markup extension supports a wide range of arguments.</source>
					<target>This markup extension supports a wide range of arguments.</target>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](binding-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc>: supports data binding, which defers property evaluation until run-time by executing general-purpose runtime object inspection.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc>: supports data binding, which defers property evaluation until run-time by executing general-purpose runtime object inspection.</target>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>This markup extension supports a wide range of arguments.</source>
					<target>This markup extension supports a wide range of arguments.</target>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](staticresource-markup-extension.md)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{StaticResource}</pc>: supports referencing resource values that are defined in a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ResourceDictionary</pc></pc>.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{StaticResource}</pc>: supports referencing resource values that are defined in a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ResourceDictionary</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>These resources can be in a different XAML file but must ultimately be findable by the XAML parser at load time.</source>
					<target>These resources can be in a different XAML file but must ultimately be findable by the XAML parser at load time.</target>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<originalData>
					<data id="id1">`{StaticResource}`</data>
					<data id="id2">[</data>
					<data id="id3">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
				</originalData>
				<segment state="initial">
					<source>The argument of a <ph dataRef="id1" id="ph1" /> usage identifies the key (the name) for a keyed resource in a <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">ResourceDictionary</pc></pc>.</source>
					<target>The argument of a <ph dataRef="id1" id="ph1" /> usage identifies the key (the name) for a keyed resource in a <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">ResourceDictionary</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](themeresource-markup-extension.md)</data>
					<data id="id3">[</data>
					<data id="id4">](staticresource-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{ThemeResource}</pc>: similar to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{StaticResource}</pc> but can respond to run-time theme changes.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{ThemeResource}</pc>: similar to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{StaticResource}</pc> but can respond to run-time theme changes.</target>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>{ThemeResource} appears quite often in the Windows Runtime default XAML templates, because most of these templates are designed for compatibility with the user switching the theme while the app is running.</source>
					<target>{ThemeResource} appears quite often in the Windows Runtime default XAML templates, because most of these templates are designed for compatibility with the user switching the theme while the app is running.</target>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](templatebinding-markup-extension.md)</data>
					<data id="id3">[</data>
					<data id="id4">](binding-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{TemplateBinding}</pc>: a special case of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> that supports control templates in XAML and their eventual usage at run time.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{TemplateBinding}</pc>: a special case of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> that supports control templates in XAML and their eventual usage at run time.</target>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](relativesource-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{RelativeSource}</pc>: enables a particular form of template binding where values come from the templated parent.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{RelativeSource}</pc>: enables a particular form of template binding where values come from the templated parent.</target>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](customresource-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{CustomResource}</pc>: for advanced resource lookup scenarios.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{CustomResource}</pc>: for advanced resource lookup scenarios.</target>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](x-null-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source>Windows Runtime also supports the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Null} markup extension</pc>.</source>
					<target>Windows Runtime also supports the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Null} markup extension</pc>.</target>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.Nullable%601)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>You use this to set <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Nullable</pc></pc> values to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc> in XAML.</source>
					<target>You use this to set <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Nullable</pc></pc> values to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc> in XAML.</target>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209316)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>For example you might use this in a control template for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CheckBox</pc></pc>, which interprets <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc> as an indeterminate check state (triggering the "Indeterminate" visual state).</source>
					<target>For example you might use this in a control template for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CheckBox</pc></pc>, which interprets <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc> as an indeterminate check state (triggering the "Indeterminate" visual state).</target>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>A markup extension generally return an existing instance from some other part of the object graph for the app, or defers a value to run time.</source>
					<target>A markup extension generally return an existing instance from some other part of the object graph for the app, or defers a value to run time.</target>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>Because you can use a markup extension as an attribute value, and that's the typical usage, you often see markup extensions providing values for reference-type properties that might have otherwise required a property element syntax.</source>
					<target>Because you can use a markup extension as an attribute value, and that's the typical usage, you often see markup extensions providing values for reference-type properties that might have otherwise required a property element syntax.</target>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208849)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">`&lt;Button Style="{StaticResource SearchButtonStyle}"/&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>For example, here's the syntax for referencing a reusable <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> from a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ResourceDictionary</pc></pc>: <ph dataRef="id9" id="ph1" />.</source>
					<target>For example, here's the syntax for referencing a reusable <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> from a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ResourceDictionary</pc></pc>: <ph dataRef="id9" id="ph1" />.</target>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208849)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">`{StaticResource}`</data>
					<data id="id6">`&lt;Button.Style&gt;`</data>
					<data id="id7">`&lt;Style&gt;`</data>
					<data id="id8">[</data>
					<data id="id9">](https://msdn.microsoft.com/library/windows/apps/br208743)</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> is a reference type, not a simple value, so without the <ph dataRef="id5" id="ph1" /> usage, you would've needed a <ph dataRef="id6" id="ph2" /> property element and a <ph dataRef="id7" id="ph3" /> definition within it to set the <pc dataRefEnd="id9" dataRefStart="id8" id="p3"><pc dataRefEnd="id11" dataRefStart="id10" id="p4">FrameworkElement.Style</pc></pc> property.</source>
					<target>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> is a reference type, not a simple value, so without the <ph dataRef="id5" id="ph1" /> usage, you would've needed a <ph dataRef="id6" id="ph2" /> property element and a <ph dataRef="id7" id="ph3" /> definition within it to set the <pc dataRefEnd="id9" dataRefStart="id8" id="p3"><pc dataRefEnd="id11" dataRefStart="id10" id="p4">FrameworkElement.Style</pc></pc> property.</target>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>By using markup extensions, every property that is settable in XAML is potentially settable in attribute syntax.</source>
					<target>By using markup extensions, every property that is settable in XAML is potentially settable in attribute syntax.</target>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>You can use attribute syntax to provide reference values for a property even if it doesn't otherwise support an attribute syntax for direct object instantiation.</source>
					<target>You can use attribute syntax to provide reference values for a property even if it doesn't otherwise support an attribute syntax for direct object instantiation.</target>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>Or you can enable specific behavior that defers the general requirement that XAML properties be filled by value types or by newly created reference types.</source>
					<target>Or you can enable specific behavior that defers the general requirement that XAML properties be filled by value types or by newly created reference types.</target>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208743)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209250)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>To illustrate, the next XAML example sets the value of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> property of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Border</pc></pc> by using attribute syntax.</source>
					<target>To illustrate, the next XAML example sets the value of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> property of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Border</pc></pc> by using attribute syntax.</target>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208743)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208849)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> property takes an instance of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Style</pc></pc> class, a reference type that by default could not be created using an attribute syntax string.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> property takes an instance of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Style</pc></pc> class, a reference type that by default could not be created using an attribute syntax string.</target>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](staticresource-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source>But in this case, the attribute references a particular markup extension, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource</pc>.</source>
					<target>But in this case, the attribute references a particular markup extension, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource</pc>.</target>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When that markup extension is processed, it returns a reference to a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Style</pc> element that was defined earlier as a keyed resource in a resource dictionary.</source>
					<target>When that markup extension is processed, it returns a reference to a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Style</pc> element that was defined earlier as a keyed resource in a resource dictionary.</target>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>You can nest markup extensions.</source>
					<target>You can nest markup extensions.</target>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>The innermost markup extension is evaluated first.</source>
					<target>The innermost markup extension is evaluated first.</target>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<segment state="initial">
					<source>Because of markup extensions, you need special syntax for a literal "{" value in an attribute.</source>
					<target>Because of markup extensions, you need special syntax for a literal "{" value in an attribute.</target>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](xaml-syntax-guide.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML syntax guide</pc>.</source>
					<target>For more info see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML syntax guide</pc>.</target>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>Events</source>
					<target>Events</target>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>XAML is a declarative language for objects and their properties, but it also includes a syntax for attaching event handlers to objects in the markup.</source>
					<target>XAML is a declarative language for objects and their properties, but it also includes a syntax for attaching event handlers to objects in the markup.</target>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<segment state="initial">
					<source>The XAML event syntax can then integrate the XAML-declared events through the Windows Runtime programming model.</source>
					<target>The XAML event syntax can then integrate the XAML-declared events through the Windows Runtime programming model.</target>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>You specify the name of the event as an attribute name on the object where the event is handled.</source>
					<target>You specify the name of the event as an attribute name on the object where the event is handled.</target>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>For the attribute value, you specify the name of an event-handler function that you define in code.</source>
					<target>For the attribute value, you specify the name of an event-handler function that you define in code.</target>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>The XAML processor uses this name to create a delegate representation in the loaded object tree, and adds the specified handler to an internal handler list.</source>
					<target>The XAML processor uses this name to create a delegate representation in the loaded object tree, and adds the specified handler to an internal handler list.</target>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>Nearly all Windows Runtime apps are defined by both markup and code-behind sources.</source>
					<target>Nearly all Windows Runtime apps are defined by both markup and code-behind sources.</target>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>Here's a simple example.</source>
					<target>Here's a simple example.</target>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209265)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br227737)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> class supports an event named <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Click</pc></pc>.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> class supports an event named <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Click</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can write a handler for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Click</pc> that runs code that should be invoked after the user clicks the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc>.</source>
					<target>You can write a handler for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Click</pc> that runs code that should be invoked after the user clicks the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc>.</target>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In XAML, you specify <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Click</pc> as an attribute on the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc>.</source>
					<target>In XAML, you specify <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Click</pc> as an attribute on the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc>.</target>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>For the attribute value, provide a string that is the method name of your handler.</source>
					<target>For the attribute value, provide a string that is the method name of your handler.</target>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<originalData>
					<data id="id1">`showUpdatesButton-Click`</data>
					<data id="id2">[</data>
					<data id="id3">](x-class-attribute.md)</data>
				</originalData>
				<segment state="initial">
					<source>When you compile, the compiler now expects that there will be a method named <ph dataRef="id1" id="ph1" /> defined in the code-behind file, in the namespace declared in the XAML page's <pc dataRefEnd="id3" dataRefStart="id2" id="p1">x:Class</pc> value.</source>
					<target>When you compile, the compiler now expects that there will be a method named <ph dataRef="id1" id="ph1" /> defined in the code-behind file, in the namespace declared in the XAML page's <pc dataRefEnd="id3" dataRefStart="id2" id="p1">x:Class</pc> value.</target>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227737)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Also, that method must satisfy the delegate contract for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Click</pc></pc> event.</source>
					<target>Also, that method must satisfy the delegate contract for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Click</pc></pc> event.</target>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>For example:</source>
					<target>For example:</target>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>Within a project, the XAML is written as a .xaml file, and you use the language you prefer (C#, Visual Basic, C++/CX) to write a code-behind file.</source>
					<target>Within a project, the XAML is written as a .xaml file, and you use the language you prefer (C#, Visual Basic, C++/CX) to write a code-behind file.</target>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](x-class-attribute.md)</data>
				</originalData>
				<segment state="initial">
					<source>When a XAML file is markup-compiled as part of a build action for the project, the location of the XAML code-behind file for each XAML page is identified by specifying a namespace and class as the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Class</pc> attribute of the root element of the XAML page.</source>
					<target>When a XAML file is markup-compiled as part of a build action for the project, the location of the XAML code-behind file for each XAML page is identified by specifying a namespace and class as the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Class</pc> attribute of the root element of the XAML page.</target>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](events-and-routed-events-overview.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info on how these mechanisms work in XAML and how they relate to the programming and application models, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Events and routed events overview</pc>.</source>
					<target>For more info on how these mechanisms work in XAML and how they relate to the programming and application models, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Events and routed events overview</pc>.</target>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For C++/CX there are two code-behind files, one is a header (.xaml.h) and the other is implementation (.xaml.cpp).</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For C++/CX there are two code-behind files, one is a header (.xaml.h) and the other is implementation (.xaml.cpp).</target>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>The implementation references the header, and it's technically the header that represents the entry point for the code-behind connection.</source>
					<target>The implementation references the header, and it's technically the header that represents the entry point for the code-behind connection.</target>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<segment state="initial">
					<source>Resource dictionaries</source>
					<target>Resource dictionaries</target>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Creating a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> is a common task that is usually accomplished by authoring a resource dictionary as an area of a XAML page or a separate XAML file.</source>
					<target>Creating a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> is a common task that is usually accomplished by authoring a resource dictionary as an area of a XAML page or a separate XAML file.</target>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<segment state="initial">
					<source>Resource dictionaries and how to use them is a larger conceptual area that is outside the scope of this topic.</source>
					<target>Resource dictionaries and how to use them is a larger conceptual area that is outside the scope of this topic.</target>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt187273)</data>
				</originalData>
				<segment state="initial">
					<source>For more info see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary and XAML resource references</pc>.</source>
					<target>For more info see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary and XAML resource references</pc>.</target>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>XAML and XML</source>
					<target>XAML and XML</target>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>The XAML language is fundamentally based on the XML language.</source>
					<target>The XAML language is fundamentally based on the XML language.</target>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>But XAML extends XML significantly.</source>
					<target>But XAML extends XML significantly.</target>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>In particular it treats the concept of schema quite differently because of its relationship to the backing type concept, and adds language elements such as attached members and markup extensions.</source>
					<target>In particular it treats the concept of schema quite differently because of its relationship to the backing type concept, and adds language elements such as attached members and markup extensions.</target>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">xml:lang</pc> is valid in XAML, but influences runtime rather than parse behavior, and is typically aliased to a framework-level property.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">xml:lang</pc> is valid in XAML, but influences runtime rather than parse behavior, and is typically aliased to a framework-level property.</target>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702066)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.Language</pc></pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.Language</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">xml:base</pc> is valid in markup but parsers ignore it.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">xml:base</pc> is valid in markup but parsers ignore it.</target>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](xaml-and-whitespace.md)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">xml:space</pc> is valid, but is only relevant for scenarios described in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">XAML and whitespace</pc> topic.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">xml:space</pc> is valid, but is only relevant for scenarios described in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">XAML and whitespace</pc> topic.</target>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">encoding</pc> attribute is valid in XAML.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">encoding</pc> attribute is valid in XAML.</target>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<segment state="initial">
					<source>Only UTF-8 and UTF-16 encodings are supported.</source>
					<target>Only UTF-8 and UTF-16 encodings are supported.</target>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<segment state="initial">
					<source>UTF-32 encoding is not supported.</source>
					<target>UTF-32 encoding is not supported.</target>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<segment state="initial">
					<source>Case sensitivity in XAML</source>
					<target>Case sensitivity in XAML</target>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<segment state="initial">
					<source>XAML is case-sensitive.</source>
					<target>XAML is case-sensitive.</target>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>This is another consequence of XAML being based on XML, which is case-sensitive.</source>
					<target>This is another consequence of XAML being based on XML, which is case-sensitive.</target>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<segment state="initial">
					<source>The names of XAML elements and attributes are case-sensitive.</source>
					<target>The names of XAML elements and attributes are case-sensitive.</target>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>The value of an attribute is potentially case-sensitive; this depends on how the attribute value is handled for particular properties.</source>
					<target>The value of an attribute is potentially case-sensitive; this depends on how the attribute value is handled for particular properties.</target>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<segment state="initial">
					<source>For example, if the attribute value declares a member name of an enumeration, the built-in behavior that type-converts a member name string to return the enumeration member value is not case-sensitive.</source>
					<target>For example, if the attribute value declares a member name of an enumeration, the built-in behavior that type-converts a member name string to return the enumeration member value is not case-sensitive.</target>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In contrast, the value of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Name</pc> property, and utility methods for working with objects based on the name that the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Name</pc> property declares, treat the name string as case-sensitive.</source>
					<target>In contrast, the value of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Name</pc> property, and utility methods for working with objects based on the name that the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Name</pc> property declares, treat the name string as case-sensitive.</target>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<segment state="initial">
					<source>XAML namescopes</source>
					<target>XAML namescopes</target>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<segment state="initial">
					<source>The XAML language defines a concept of a XAML namescope.</source>
					<target>The XAML language defines a concept of a XAML namescope.</target>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The XAML namescope concept influences how XAML processors should treat the value of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Name</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Name</pc> applied to XAML elements, particularly the scopes in which names should be relied upon to be unique identifiers.</source>
					<target>The XAML namescope concept influences how XAML processors should treat the value of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Name</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Name</pc> applied to XAML elements, particularly the scopes in which names should be relied upon to be unique identifiers.</target>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](xaml-namescopes.md)</data>
				</originalData>
				<segment state="initial">
					<source>XAML namescopes are covered in more detail in a separate topic; see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML namescopes</pc>.</source>
					<target>XAML namescopes are covered in more detail in a separate topic; see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML namescopes</pc>.</target>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<segment state="initial">
					<source>The role of XAML in the development process</source>
					<target>The role of XAML in the development process</target>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<segment state="initial">
					<source>XAML plays several important roles in the app development process.</source>
					<target>XAML plays several important roles in the app development process.</target>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<segment state="initial">
					<source>XAML is the primary format for declaring an app's UI and elements in that UI, if you are programming using C#, Visual Basic or C++/CX.</source>
					<target>XAML is the primary format for declaring an app's UI and elements in that UI, if you are programming using C#, Visual Basic or C++/CX.</target>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<segment state="initial">
					<source>Typically at least one XAML file in your project represents a page metaphor in your app for the initially displayed UI.</source>
					<target>Typically at least one XAML file in your project represents a page metaphor in your app for the initially displayed UI.</target>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<segment state="initial">
					<source>Additional XAML files might declare additional pages for navigation UI.</source>
					<target>Additional XAML files might declare additional pages for navigation UI.</target>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<segment state="initial">
					<source>Other XAML files can declare resources, such as templates or styles.</source>
					<target>Other XAML files can declare resources, such as templates or styles.</target>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<segment state="initial">
					<source>You use the XAML format for declaring styles and templates applied to controls and UI for an app.</source>
					<target>You use the XAML format for declaring styles and templates applied to controls and UI for an app.</target>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<segment state="initial">
					<source>You might use styles and templates either for templating existing controls, or if you define a control that supplies a default template as part of a control package.</source>
					<target>You might use styles and templates either for templating existing controls, or if you define a control that supplies a default template as part of a control package.</target>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When you use it to define styles and templates, the relevant XAML is often declared as a discrete XAML file with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> root.</source>
					<target>When you use it to define styles and templates, the relevant XAML is often declared as a discrete XAML file with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> root.</target>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<segment state="initial">
					<source>XAML is the common format for designer support of creating app UI and exchanging the UI design between different designer apps.</source>
					<target>XAML is the common format for designer support of creating app UI and exchanging the UI design between different designer apps.</target>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<segment state="initial">
					<source>Most notably, XAML for the app can be interchanged between different XAML design tools (or design windows within tools).</source>
					<target>Most notably, XAML for the app can be interchanged between different XAML design tools (or design windows within tools).</target>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<segment state="initial">
					<source>Several other technologies also define the basic UI in XAML.</source>
					<target>Several other technologies also define the basic UI in XAML.</target>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<segment state="initial">
					<source>In relationship to Windows Presentation Foundation (WPF) XAML and Microsoft Silverlight XAML, the XAML for Windows Runtime uses the same URI for its shared default XAML namespace.</source>
					<target>In relationship to Windows Presentation Foundation (WPF) XAML and Microsoft Silverlight XAML, the XAML for Windows Runtime uses the same URI for its shared default XAML namespace.</target>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>The XAML vocabulary for Windows Runtime overlaps significantly with the XAML-for-UI vocabulary also used by Silverlight and to a slightly lesser extent by WPF.</source>
					<target>The XAML vocabulary for Windows Runtime overlaps significantly with the XAML-for-UI vocabulary also used by Silverlight and to a slightly lesser extent by WPF.</target>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<segment state="initial">
					<source>Thus, XAML promotes an efficient migration pathway for UI originally defined for precursor technologies that also used XAML.</source>
					<target>Thus, XAML promotes an efficient migration pathway for UI originally defined for precursor technologies that also used XAML.</target>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<segment state="initial">
					<source>XAML defines the visual appearance of a UI, and an associated code-behind file defines the logic.</source>
					<target>XAML defines the visual appearance of a UI, and an associated code-behind file defines the logic.</target>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<segment state="initial">
					<source>You can adjust the UI design without making changes to the logic in code-behind.</source>
					<target>You can adjust the UI design without making changes to the logic in code-behind.</target>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<segment state="initial">
					<source>XAML simplifies the workflow between designers and developers.</source>
					<target>XAML simplifies the workflow between designers and developers.</target>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<segment state="initial">
					<source>Because of the richness of the visual designer and design surface support for the XAML language, XAML supports rapid UI prototyping in the early development phases.</source>
					<target>Because of the richness of the visual designer and design surface support for the XAML language, XAML supports rapid UI prototyping in the early development phases.</target>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<segment state="initial">
					<source>Depending on your own role in the development process, you might not interact with XAML much.</source>
					<target>Depending on your own role in the development process, you might not interact with XAML much.</target>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<segment state="initial">
					<source>The degree to which you do interact with XAML files also depends on which development environment you are using, whether you use interactive design environment features such as toolboxes and property editors, and the scope and purpose of your Windows Runtime app.</source>
					<target>The degree to which you do interact with XAML files also depends on which development environment you are using, whether you use interactive design environment features such as toolboxes and property editors, and the scope and purpose of your Windows Runtime app.</target>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<segment state="initial">
					<source>Nevertheless, it is likely that during development of the app, you will be editing a XAML file at the element level using a text or XML editor.</source>
					<target>Nevertheless, it is likely that during development of the app, you will be editing a XAML file at the element level using a text or XML editor.</target>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<segment state="initial">
					<source>Using this info, you can confidently edit XAML in a text or XML representation and maintain the validity of that XAML file's declarations and purpose when it is consumed by tools, markup compile operations, or the run-time phase of your Windows Runtime app.</source>
					<target>Using this info, you can confidently edit XAML in a text or XML representation and maintain the validity of that XAML file's declarations and purpose when it is consumed by tools, markup compile operations, or the run-time phase of your Windows Runtime app.</target>
				</segment>
			</unit>
			<unit id="311" translate="yes">
				<segment state="initial">
					<source>Optimize your XAML for load performance</source>
					<target>Optimize your XAML for load performance</target>
				</segment>
			</unit>
			<unit id="312" translate="yes">
				<segment state="initial">
					<source>Here are some tips for defining UI elements in XAML using best practices for performance.</source>
					<target>Here are some tips for defining UI elements in XAML using best practices for performance.</target>
				</segment>
			</unit>
			<unit id="313" translate="yes">
				<segment state="initial">
					<source>Many of these tips relate to using XAML resources, but are listed here in the general XAML overview for convenience.</source>
					<target>Many of these tips relate to using XAML resources, but are listed here in the general XAML overview for convenience.</target>
				</segment>
			</unit>
			<unit id="314" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt187273)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about XAML resources see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary and XAML resource references</pc>.</source>
					<target>For more info about XAML resources see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary and XAML resource references</pc>.</target>
				</segment>
			</unit>
			<unit id="315" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt204779)</data>
				</originalData>
				<segment state="initial">
					<source>For some more tips on performance, including XAML that purposely demonstrates some of the poor performance practices that you should avoid in your XAML, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optimize your XAML markup</pc>.</source>
					<target>For some more tips on performance, including XAML that purposely demonstrates some of the poor performance practices that you should avoid in your XAML, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optimize your XAML markup</pc>.</target>
				</segment>
			</unit>
			<unit id="316" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242962)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you use the same color brush often in your XAML, define a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SolidColorBrush</pc></pc> as a resource rather than using a named color as an attribute value each time.</source>
					<target>If you use the same color brush often in your XAML, define a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SolidColorBrush</pc></pc> as a resource rather than using a named color as an attribute value each time.</target>
				</segment>
			</unit>
			<unit id="317" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242338)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you use the same resource on more than one UI page, consider defining it in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Application.Resources</pc></pc> rather than on each page.</source>
					<target>If you use the same resource on more than one UI page, consider defining it in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Application.Resources</pc></pc> rather than on each page.</target>
				</segment>
			</unit>
			<unit id="318" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Conversely, if only one page uses a resource, don't define it in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Application.Resources</pc> and instead define it only for the page that needs it.</source>
					<target>Conversely, if only one page uses a resource, don't define it in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Application.Resources</pc> and instead define it only for the page that needs it.</target>
				</segment>
			</unit>
			<unit id="319" translate="yes">
				<segment state="initial">
					<source>This is good both for XAML factoring while designing your app and for performance during XAML parsing.</source>
					<target>This is good both for XAML factoring while designing your app and for performance during XAML parsing.</target>
				</segment>
			</unit>
			<unit id="320" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](staticresource-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source>For resources that your app packages, check for unused resources (a resource that has a key, but there's no <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource</pc> reference in your app that uses it).</source>
					<target>For resources that your app packages, check for unused resources (a resource that has a key, but there's no <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource</pc> reference in your app that uses it).</target>
				</segment>
			</unit>
			<unit id="321" translate="yes">
				<segment state="initial">
					<source>Remove these from your XAML before you release your app.</source>
					<target>Remove these from your XAML before you release your app.</target>
				</segment>
			</unit>
			<unit id="322" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208801)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you're using separate XAML files that provides design resources (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc>), consider commenting or removing unused resources from these files.</source>
					<target>If you're using separate XAML files that provides design resources (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc>), consider commenting or removing unused resources from these files.</target>
				</segment>
			</unit>
			<unit id="323" translate="yes">
				<segment state="initial">
					<source>Even if you have a shared XAML starting point that you're using in more than one app or that provides common resources for all your app, it's still your app that packages the XAML resources each time, and potentially has to load them.</source>
					<target>Even if you have a shared XAML starting point that you're using in more than one app or that provides common resources for all your app, it's still your app that packages the XAML resources each time, and potentially has to load them.</target>
				</segment>
			</unit>
			<unit id="324" translate="yes">
				<segment state="initial">
					<source>Don't define UI elements you don't need for composition, and use the default control templates whenever possible (these templates have already been tested and verified for load performance).</source>
					<target>Don't define UI elements you don't need for composition, and use the default control templates whenever possible (these templates have already been tested and verified for load performance).</target>
				</segment>
			</unit>
			<unit id="325" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209250)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Use containers such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Border</pc></pc> rather than deliberate overdraws of UI elements.</source>
					<target>Use containers such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Border</pc></pc> rather than deliberate overdraws of UI elements.</target>
				</segment>
			</unit>
			<unit id="326" translate="yes">
				<segment state="initial">
					<source>Basically, don't draw the same pixel multiple times.</source>
					<target>Basically, don't draw the same pixel multiple times.</target>
				</segment>
			</unit>
			<unit id="327" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701823)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For more info on overdraw and how to test for it, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DebugSettings.IsOverdrawHeatMapEnabled</pc></pc>.</source>
					<target>For more info on overdraw and how to test for it, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DebugSettings.IsOverdrawHeatMapEnabled</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="328" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242878)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242705)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>Use the default items templates for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc>; these have special <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Presenter</pc> logic that solves performance issues when building the visual tree for large numbers of list items.</source>
					<target>Use the default items templates for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc>; these have special <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Presenter</pc> logic that solves performance issues when building the visual tree for large numbers of list items.</target>
				</segment>
			</unit>
			<unit id="329" translate="yes">
				<segment state="initial">
					<source>Debugging XAML</source>
					<target>Debugging XAML</target>
				</segment>
			</unit>
			<unit id="330" translate="yes">
				<segment state="initial">
					<source>Because XAML is a markup language, some of the typical strategies for debugging within Microsoft Visual Studio are not available.</source>
					<target>Because XAML is a markup language, some of the typical strategies for debugging within Microsoft Visual Studio are not available.</target>
				</segment>
			</unit>
			<unit id="331" translate="yes">
				<segment state="initial">
					<source>For example, there is no way to set a breakpoint within a XAML file.</source>
					<target>For example, there is no way to set a breakpoint within a XAML file.</target>
				</segment>
			</unit>
			<unit id="332" translate="yes">
				<segment state="initial">
					<source>However, there are other techniques that can help you debug issues with UI definitions or other XAML markup while you're still developing your app.</source>
					<target>However, there are other techniques that can help you debug issues with UI definitions or other XAML markup while you're still developing your app.</target>
				</segment>
			</unit>
			<unit id="333" translate="yes">
				<segment state="initial">
					<source>When there are problems with a XAML file, the most typical result is that some system or your app will throw a XAML parse exception.</source>
					<target>When there are problems with a XAML file, the most typical result is that some system or your app will throw a XAML parse exception.</target>
				</segment>
			</unit>
			<unit id="334" translate="yes">
				<segment state="initial">
					<source>Whenever there is a XAML parse exception, the XAML loaded by the XAML parser failed to create a valid object tree.</source>
					<target>Whenever there is a XAML parse exception, the XAML loaded by the XAML parser failed to create a valid object tree.</target>
				</segment>
			</unit>
			<unit id="335" translate="yes">
				<segment state="initial">
					<source>In some cases, such as when the XAML represents the first "page" of your application that is loaded as the root visual, the XAML parse exception is not recoverable.</source>
					<target>In some cases, such as when the XAML represents the first "page" of your application that is loaded as the root visual, the XAML parse exception is not recoverable.</target>
				</segment>
			</unit>
			<unit id="336" translate="yes">
				<segment state="initial">
					<source>XAML is often edited within an IDE such as Visual Studio and one of its XAML design surfaces.</source>
					<target>XAML is often edited within an IDE such as Visual Studio and one of its XAML design surfaces.</target>
				</segment>
			</unit>
			<unit id="337" translate="yes">
				<segment state="initial">
					<source>Visual Studio can often provide design-time validation and error checking of a XAML source as you edit it.</source>
					<target>Visual Studio can often provide design-time validation and error checking of a XAML source as you edit it.</target>
				</segment>
			</unit>
			<unit id="338" translate="yes">
				<segment state="initial">
					<source>For example it might display "squiggles" in the XAML text editor as soon as you type a bad attribute value, and you won't even have to wait for a XAML compile pass to see that something's wrong with your UI definition.</source>
					<target>For example it might display "squiggles" in the XAML text editor as soon as you type a bad attribute value, and you won't even have to wait for a XAML compile pass to see that something's wrong with your UI definition.</target>
				</segment>
			</unit>
			<unit id="339" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh673774)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Once the app actually runs, if any XAML parse errors have gone undetected at design time, these are reported by the common language runtime (CLR) as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XamlParseException</pc></pc>.</source>
					<target>Once the app actually runs, if any XAML parse errors have gone undetected at design time, these are reported by the common language runtime (CLR) as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XamlParseException</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="340" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/dn532194)</data>
				</originalData>
				<segment state="initial">
					<source>For more info on what you might be able to do for a run-time <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlParseException</pc>, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Exception handling for Windows Runtime apps in C# or Visual Basic</pc>.</source>
					<target>For more info on what you might be able to do for a run-time <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlParseException</pc>, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Exception handling for Windows Runtime apps in C# or Visual Basic</pc>.</target>
				</segment>
			</unit>
			<unit id="341" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh673774)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Apps that use C++/CX for code don't get the specific <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">XamlParseException</pc></pc>.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Apps that use C++/CX for code don't get the specific <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">XamlParseException</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="342" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>But the message in the exception clarifies that the source of the error is XAML-related, and includes context info such as line numbers in a XAML file, just like <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlParseException</pc> does.</source>
					<target>But the message in the exception clarifies that the source of the error is XAML-related, and includes context info such as line numbers in a XAML file, just like <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlParseException</pc> does.</target>
				</segment>
			</unit>
			<unit id="343" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh781607.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>Fore more info on debugging a Windows Runtime app, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Start a debug session</pc>.</source>
					<target>Fore more info on debugging a Windows Runtime app, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Start a debug session</pc>.</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>