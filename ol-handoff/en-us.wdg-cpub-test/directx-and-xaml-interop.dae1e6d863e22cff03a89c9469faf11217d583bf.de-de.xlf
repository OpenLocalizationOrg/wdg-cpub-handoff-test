<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">a3d0d7b37718ebb0060ee88a01de1b3847aa7237</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\directx-and-xaml-interop.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">8276f09b69df47ab3c129aadc122eaa05fc61ce1</mda:meta><mda:meta type="olxliffhash">053ba5762edd8bc77f67d2d182ecd07d4351bbe6</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>DirectX and XAML interop</source>
					<target>DirectX and XAML interop</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>You can use Extensible Application Markup Language (XAML) and Microsoft DirectX together in your Universal Windows Platform (UWP) game.</source>
					<target>You can use Extensible Application Markup Language (XAML) and Microsoft DirectX together in your Universal Windows Platform (UWP) game.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>DirectX and XAML interop</source>
					<target>DirectX and XAML interop</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>You can use Extensible Application Markup Language (XAML) and Microsoft DirectX together in your Universal Windows Platform (UWP) game.</source>
					<target>You can use Extensible Application Markup Language (XAML) and Microsoft DirectX together in your Universal Windows Platform (UWP) game.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>The combination of XAML and DirectX lets you build flexible user interface frameworks that interop with your DirectX-rendered content, and is particularly useful for graphics-intensive apps.</source>
					<target>The combination of XAML and DirectX lets you build flexible user interface frameworks that interop with your DirectX-rendered content, and is particularly useful for graphics-intensive apps.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>This topic explains the structure of a UWP app that uses DirectX and identifies the important types to use when building your UWP app to work with DirectX.</source>
					<target>This topic explains the structure of a UWP app that uses DirectX and identifies the important types to use when building your UWP app to work with DirectX.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  DirectX APIs are not defined as Windows Runtime types, so you typically use Visual C++ component extensions (C++/CX) to develop XAMLUWP components that interop with DirectX.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  DirectX APIs are not defined as Windows Runtime types, so you typically use Visual C++ component extensions (C++/CX) to develop XAMLUWP components that interop with DirectX.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>Also, you can create a UWP app with C# and XAML that uses DirectX, if you wrap the DirectX calls in a separate Windows Runtime metadata file.</source>
					<target>Also, you can create a UWP app with C# and XAML that uses DirectX, if you wrap the DirectX calls in a separate Windows Runtime metadata file.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>XAML and DirectX</source>
					<target>XAML and DirectX</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>DirectX provides two powerful libraries for 2D and 3D graphics: Direct2D and Microsoft Direct3D.</source>
					<target>DirectX provides two powerful libraries for 2D and 3D graphics: Direct2D and Microsoft Direct3D.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Although XAML provides support for basic 2D primitives and effects, many apps, such as modeling and gaming, need more complex graphics support.</source>
					<target>Although XAML provides support for basic 2D primitives and effects, many apps, such as modeling and gaming, need more complex graphics support.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>For these, you can use Direct2D and Direct3D to render part or all of the graphics and use XAML for everything else.</source>
					<target>For these, you can use Direct2D and Direct3D to render part or all of the graphics and use XAML for everything else.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>In the XAML and DirectX interop scenario, you need to know these two concepts:</source>
					<target>In the XAML and DirectX interop scenario, you need to know these two concepts:</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228076)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Shared surfaces are sized regions of the display, defined by XAML, that you can use DirectX to draw into indirectly, using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::UI::Xaml::Media::Brush</pc></pc> types.</source>
					<target>Shared surfaces are sized regions of the display, defined by XAML, that you can use DirectX to draw into indirectly, using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::UI::Xaml::Media::Brush</pc></pc> types.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>For shared surfaces, you don't control the calls to present the swap chain(s).</source>
					<target>For shared surfaces, you don't control the calls to present the swap chain(s).</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>The updates to the shared surface are synced to the XAML framework's updates.</source>
					<target>The updates to the shared surface are synced to the XAML framework's updates.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>The swap chain itself.</source>
					<target>The swap chain itself.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>This provides the back buffer of the DirectX rendering pipeline, the area of memory that is presented for display after the render target is complete.</source>
					<target>This provides the back buffer of the DirectX rendering pipeline, the area of memory that is presented for display after the render target is complete.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>Consider what you are using DirectX for.</source>
					<target>Consider what you are using DirectX for.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>Will it be used to composite or animate a single control that fits within the dimensions of the display window?</source>
					<target>Will it be used to composite or animate a single control that fits within the dimensions of the display window?</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>Can the composited surface be occluded by other surfaces, or the edges of the screen?</source>
					<target>Can the composited surface be occluded by other surfaces, or the edges of the screen?</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Will it contain output that needs to be rendered and controlled in real-time, as in a game?</source>
					<target>Will it contain output that needs to be rendered and controlled in real-time, as in a game?</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Once you've determined how you intend to use DirectX, you use one of these Windows Runtime types to incorporate DirectX rendering into your Windows Store app:</source>
					<target>Once you've determined how you intend to use DirectX, you use one of these Windows Runtime types to incorporate DirectX rendering into your Windows Store app:</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702041)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you want to compose a static image, or draw a complex image on event-driven intervals, draw to a shared surface with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::UI::Xaml::Media::Imaging::SurfaceImageSource</pc></pc>.</source>
					<target>If you want to compose a static image, or draw a complex image on event-driven intervals, draw to a shared surface with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::UI::Xaml::Media::Imaging::SurfaceImageSource</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>This type handles a sized DirectX drawing surface.</source>
					<target>This type handles a sized DirectX drawing surface.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>Typically, you use this type when composing an image or texture as a bitmap for display in a document or UI element.</source>
					<target>Typically, you use this type when composing an image or texture as a bitmap for display in a document or UI element.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>It doesn't work well for real-time interactivity, such as a high-performance game.</source>
					<target>It doesn't work well for real-time interactivity, such as a high-performance game.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>That's because updates to a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SurfaceImageSource</pc> object are synced to XAML user interface updates, and that can introduce latency into the visual feedback you provide to the user, like a fluctuating frame rate or a perceived poor response to real-time input.</source>
					<target>That's because updates to a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SurfaceImageSource</pc> object are synced to XAML user interface updates, and that can introduce latency into the visual feedback you provide to the user, like a fluctuating frame rate or a perceived poor response to real-time input.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Updates are still quick enough for dynamic controls or data simulations, though!</source>
					<target>Updates are still quick enough for dynamic controls or data simulations, though!</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702041)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SurfaceImageSource</pc></pc> graphics objects can be composited with other XAML UI elements.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SurfaceImageSource</pc></pc> graphics objects can be composited with other XAML UI elements.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>You can transform or project them , and the XAML framework respects any opacity or z-index values.</source>
					<target>You can transform or project them , and the XAML framework respects any opacity or z-index values.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702050)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If the image is larger than the provided screen real estate, and can be panned or zoomed by the user, use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource</pc></pc>.</source>
					<target>If the image is larger than the provided screen real estate, and can be panned or zoomed by the user, use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>This type handles a sized DirectX drawing surface that is larger than the screen.</source>
					<target>This type handles a sized DirectX drawing surface that is larger than the screen.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702041)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Like <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SurfaceImageSource</pc></pc>, you use this when composing a complex image or control dynamically.</source>
					<target>Like <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SurfaceImageSource</pc></pc>, you use this when composing a complex image or control dynamically.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>And, also like <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SurfaceImageSource</pc>, it doesn't work well for high-performance games.</source>
					<target>And, also like <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SurfaceImageSource</pc>, it doesn't work well for high-performance games.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Some examples of XAML elements that could use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">VirtualSurfaceImageSource</pc> are map controls, or a large, image-dense document viewer.</source>
					<target>Some examples of XAML elements that could use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">VirtualSurfaceImageSource</pc> are map controls, or a large, image-dense document viewer.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn252834)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you are using DirectX to present graphics updated in real-time, or in a situation where the updates must come on regular low-latency intervals, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> class, so you can refresh the graphics without syncing to the XAML framework refresh timer.</source>
					<target>If you are using DirectX to present graphics updated in real-time, or in a situation where the updates must come on regular low-latency intervals, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> class, so you can refresh the graphics without syncing to the XAML framework refresh timer.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404631)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This type enables you to access the graphics device's swap chain (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1</pc></pc>) directly and layer XAML atop the render target.</source>
					<target>This type enables you to access the graphics device's swap chain (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1</pc></pc>) directly and layer XAML atop the render target.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>This type works great for games and other full-screen DirectX apps that require a XAML-based user interface.</source>
					<target>This type works great for games and other full-screen DirectX apps that require a XAML-based user interface.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>You must know DirectX well to use this approach, including the Microsoft DirectX Graphics Infrastructure (DXGI), Direct2D, and Direct3D technologies.</source>
					<target>You must know DirectX well to use this approach, including the Microsoft DirectX Graphics Infrastructure (DXGI), Direct2D, and Direct3D technologies.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476345)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Programming Guide for Direct3D 11</pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Programming Guide for Direct3D 11</pc>.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>SurfaceImageSource</source>
					<target>SurfaceImageSource</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702041)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SurfaceImageSource</pc></pc> provides DirectX shared surfaces to draw into and then composes the bits into app content.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SurfaceImageSource</pc></pc> provides DirectX shared surfaces to draw into and then composes the bits into app content.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702041)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Here is the basic process for creating and updating a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SurfaceImageSource</pc></pc> object in the code behind:</source>
					<target>Here is the basic process for creating and updating a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SurfaceImageSource</pc></pc> object in the code behind:</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702041)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Define the size of the shared surface by passing the height and width to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SurfaceImageSource</pc></pc> constructor.</source>
					<target>Define the size of the shared surface by passing the height and width to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SurfaceImageSource</pc></pc> constructor.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>You can also indicate whether the surface needs alpha (opacity) support.</source>
					<target>You can also indicate whether the surface needs alpha (opacity) support.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>For example:</source>
					<target>For example:</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh848322)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Get a pointer to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISurfaceImageSourceNative</pc></pc>.</source>
					<target>Get a pointer to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISurfaceImageSourceNative</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702041)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/br205821)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source>Cast the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SurfaceImageSource</pc></pc> object as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IInspectable</pc></pc> (or <pc dataRefEnd="id10" dataRefStart="id9" id="p5">IUnknown</pc>), and call <pc dataRefEnd="id12" dataRefStart="id11" id="p6">QueryInterface</pc> on it to get the underlying <pc dataRefEnd="id14" dataRefStart="id13" id="p7">ISurfaceImageSourceNative</pc> implementation.</source>
					<target>Cast the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SurfaceImageSource</pc></pc> object as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IInspectable</pc></pc> (or <pc dataRefEnd="id10" dataRefStart="id9" id="p5">IUnknown</pc>), and call <pc dataRefEnd="id12" dataRefStart="id11" id="p6">QueryInterface</pc> on it to get the underlying <pc dataRefEnd="id14" dataRefStart="id13" id="p7">ISurfaceImageSourceNative</pc> implementation.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>You use the methods defined on this implementation to set the device and run the draw operations.</source>
					<target>You use the methods defined on this implementation to set the device and run the draw operations.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/hh848325)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Set the DXGI device by first calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11CreateDevice</pc></pc> and then passing the device and context to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ISurfaceImageSourceNative::SetDevice</pc></pc>.</source>
					<target>Set the DXGI device by first calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11CreateDevice</pc></pc> and then passing the device and context to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ISurfaceImageSourceNative::SetDevice</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>For example:</source>
					<target>For example:</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb174565)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/hh848323)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Provide a pointer to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISurface</pc></pc> object to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ISurfaceImageSourceNative::BeginDraw</pc></pc>, and draw into that surface using DirectX.</source>
					<target>Provide a pointer to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISurface</pc></pc> object to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ISurfaceImageSourceNative::BeginDraw</pc></pc>, and draw into that surface using DirectX.</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>Only the area specified for update in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">updateRect</pc> parameter is drawn.</source>
					<target>Only the area specified for update in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">updateRect</pc> parameter is drawn.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/hh848323)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/desktop/bb174527)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   You can only have one outstanding <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">BeginDraw</pc></pc> operation active at a time per <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">IDXGIDevice</pc></pc>.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   You can only have one outstanding <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">BeginDraw</pc></pc> operation active at a time per <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">IDXGIDevice</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>This method returns the point (x,y) offset of the updated target rectangle in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">offset</pc> parameter.</source>
					<target>This method returns the point (x,y) offset of the updated target rectangle in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">offset</pc> parameter.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb174565)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You use this offset to determine where to draw into inside the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISurface</pc></pc>.</source>
					<target>You use this offset to determine where to draw into inside the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISurface</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh848324)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISurfaceImageSourceNative::EndDraw</pc></pc> to complete the bitmap.</source>
					<target>Call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISurfaceImageSourceNative::EndDraw</pc></pc> to complete the bitmap.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br210101)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Pass this bitmap to an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ImageBrush</pc></pc>.</source>
					<target>Pass this bitmap to an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ImageBrush</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br210101)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ImageBrush</pc></pc> to draw the bitmap.</source>
					<target>Use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ImageBrush</pc></pc> to draw the bitmap.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br243255)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   Calling <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">SurfaceImageSource::SetSource</pc></pc> (inherited from <pc dataRefEnd="id8" dataRefStart="id7" id="p4">IBitmapSource::SetSource</pc>) currently throws an exception.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   Calling <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">SurfaceImageSource::SetSource</pc></pc> (inherited from <pc dataRefEnd="id8" dataRefStart="id7" id="p4">IBitmapSource::SetSource</pc>) currently throws an exception.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702041)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Do not call it from your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SurfaceImageSource</pc></pc> object.</source>
					<target>Do not call it from your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SurfaceImageSource</pc></pc> object.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>VirtualSurfaceImageSource</source>
					<target>VirtualSurfaceImageSource</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702050)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh702041)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VirtualSurfaceImageSource</pc></pc> extends <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SurfaceImageSource</pc></pc> when the content is potentially larger than what can fit on screen and so the content must be virtualized to render optimally.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VirtualSurfaceImageSource</pc></pc> extends <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SurfaceImageSource</pc></pc> when the content is potentially larger than what can fit on screen and so the content must be virtualized to render optimally.</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702050)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh702041)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/desktop/hh848337)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VirtualSurfaceImageSource</pc></pc> differs from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SurfaceImageSource</pc></pc> in that it uses a callback, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IVirtualSurfaceImageSourceCallbacksNative::UpdatesNeeded</pc></pc>, that you implement to update regions of the surface as they become visible on the screen.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VirtualSurfaceImageSource</pc></pc> differs from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SurfaceImageSource</pc></pc> in that it uses a callback, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IVirtualSurfaceImageSourceCallbacksNative::UpdatesNeeded</pc></pc>, that you implement to update regions of the surface as they become visible on the screen.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>You do not need to clear regions that are hidden, as the XAML framework takes care of that for you.</source>
					<target>You do not need to clear regions that are hidden, as the XAML framework takes care of that for you.</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702050)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Here is basic process for creating and updating a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VirtualSurfaceImageSource</pc></pc> object in the codebehind:</source>
					<target>Here is basic process for creating and updating a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VirtualSurfaceImageSource</pc></pc> object in the codebehind:</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702050)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Create an instance of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VirtualSurfaceImageSource</pc></pc> with the size you want.</source>
					<target>Create an instance of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VirtualSurfaceImageSource</pc></pc> with the size you want.</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>For example:</source>
					<target>For example:</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh848328)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Get a pointer to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVirtualSurfaceImageSourceNative</pc></pc>.</source>
					<target>Get a pointer to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVirtualSurfaceImageSourceNative</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702050)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/br205821)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/desktop/ms680509)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/desktop/ms682521)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
					<data id="id17">**</data>
					<data id="id18">**</data>
				</originalData>
				<segment state="initial">
					<source>Cast the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VirtualSurfaceImageSource</pc></pc> object as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IInspectable</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IUnknown</pc></pc>, and call <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">QueryInterface</pc></pc> on it to get the underlying <pc dataRefEnd="id18" dataRefStart="id17" id="p9">IVirtualSurfaceImageSourceNative</pc> implementation.</source>
					<target>Cast the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VirtualSurfaceImageSource</pc></pc> object as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IInspectable</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IUnknown</pc></pc>, and call <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">QueryInterface</pc></pc> on it to get the underlying <pc dataRefEnd="id18" dataRefStart="id17" id="p9">IVirtualSurfaceImageSourceNative</pc> implementation.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>You use the methods defined on this implementation to set the device and run the draw operations.</source>
					<target>You use the methods defined on this implementation to set the device and run the draw operations.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh848325)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Set the DXGI device by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVirtualSurfaceImageSourceNative::SetDevice</pc></pc>.</source>
					<target>Set the DXGI device by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVirtualSurfaceImageSourceNative::SetDevice</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>For example:</source>
					<target>For example:</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh848334)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/hh848336)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVirtualSurfaceImageSourceNative::RegisterForUpdatesNeeded</pc></pc>, passing in a reference to your implementation of <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IVirtualSurfaceUpdatesCallbackNative</pc></pc>.</source>
					<target>Call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVirtualSurfaceImageSourceNative::RegisterForUpdatesNeeded</pc></pc>, passing in a reference to your implementation of <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IVirtualSurfaceUpdatesCallbackNative</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh848334)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh702050)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The framework calls your implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVirtualSurfaceUpdatesCallbackNative::UpdatesNeeded</pc></pc> when a region of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">VirtualSurfaceImageSource</pc></pc> needs to be updated.</source>
					<target>The framework calls your implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVirtualSurfaceUpdatesCallbackNative::UpdatesNeeded</pc></pc> when a region of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">VirtualSurfaceImageSource</pc></pc> needs to be updated.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh848332)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This can happen either when the framework determines the region needs to be drawn (such as when the user pans or zooms the view of the surface), or after the app has called <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVirtualSurfaceImageSourceNative::Invalidate</pc></pc> on that region.</source>
					<target>This can happen either when the framework determines the region needs to be drawn (such as when the user pans or zooms the view of the surface), or after the app has called <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVirtualSurfaceImageSourceNative::Invalidate</pc></pc> on that region.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh848337)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/hh848329)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/desktop/hh848330)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>In <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVirtualSurfaceImageSourceNative::UpdatesNeeded</pc></pc>, use the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IVirtualSurfaceImageSourceNative::GetUpdateRectCount</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IVirtualSurfaceImageSourceNative::GetUpdateRects</pc></pc> methods to determine which region(s) of the surface must be drawn.</source>
					<target>In <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVirtualSurfaceImageSourceNative::UpdatesNeeded</pc></pc>, use the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IVirtualSurfaceImageSourceNative::GetUpdateRectCount</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IVirtualSurfaceImageSourceNative::GetUpdateRects</pc></pc> methods to determine which region(s) of the surface must be drawn.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Lastly, for each region that must be updated:</source>
					<target>Lastly, for each region that must be updated:</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb174565)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/hh848323)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Provide a pointer to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISurface</pc></pc> object to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IVirtualSurfaceImageSourceNative::BeginDraw</pc></pc>, and draw into that surface using DirectX.</source>
					<target>Provide a pointer to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISurface</pc></pc> object to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IVirtualSurfaceImageSourceNative::BeginDraw</pc></pc>, and draw into that surface using DirectX.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>Only the area specified for update in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">updateRect</pc> parameter will be drawn.</source>
					<target>Only the area specified for update in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">updateRect</pc> parameter will be drawn.</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh848323)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
				</originalData>
				<segment state="initial">
					<source>As with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IlSurfaceImageSourceNative::BeginDraw</pc></pc>, this method returns the point (x,y) offset of the updated target rectangle in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">offset</pc> parameter.</source>
					<target>As with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IlSurfaceImageSourceNative::BeginDraw</pc></pc>, this method returns the point (x,y) offset of the updated target rectangle in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">offset</pc> parameter.</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb174565)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You use this offset to determine where to draw into inside the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISurface</pc></pc>.</source>
					<target>You use this offset to determine where to draw into inside the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISurface</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/hh848323)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/desktop/bb174527)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   You can only have one outstanding <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">BeginDraw</pc></pc> operation active at a time per <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">IDXGIDevice</pc></pc>.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   You can only have one outstanding <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">BeginDraw</pc></pc> operation active at a time per <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">IDXGIDevice</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Draw the specific content to that region, but constrain your drawing to the bounded regions for better performance.</source>
					<target>Draw the specific content to that region, but constrain your drawing to the bounded regions for better performance.</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh848324)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVirtualSurfaceImageSourceNative::EndDraw</pc></pc>.</source>
					<target>Call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVirtualSurfaceImageSourceNative::EndDraw</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>The result is a bitmap.</source>
					<target>The result is a bitmap.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>SwapChainPanel and gaming</source>
					<target>SwapChainPanel and gaming</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn252834)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> is the Windows Runtime type designed to support high-performance graphics and gaming, where you manage the swap chain directly.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> is the Windows Runtime type designed to support high-performance graphics and gaming, where you manage the swap chain directly.</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>In this case, you create your own DirectX swap chain and manage the presentation of your rendered content.</source>
					<target>In this case, you create your own DirectX swap chain and manage the presentation of your rendered content.</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You can then add XAML elements to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SwapChainPanel</pc> object, such as menus, heads-up displays, and other UI overlays.</source>
					<target>You can then add XAML elements to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SwapChainPanel</pc> object, such as menus, heads-up displays, and other UI overlays.</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn252834)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To ensure good performance, there are certain limitations to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> type:</source>
					<target>To ensure good performance, there are certain limitations to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> type:</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn252834)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>There are no more than 4 <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> instances per app.</source>
					<target>There are no more than 4 <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> instances per app.</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/dn252834)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Opacity</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">RenderTransform</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Projection</pc>, and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Clip</pc> properties inherited by <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">SwapChainPanel</pc></pc> are not supported.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Opacity</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">RenderTransform</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Projection</pc>, and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Clip</pc> properties inherited by <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">SwapChainPanel</pc></pc> are not supported.</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404528)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You should set the DirectX swap chain's height and width (in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI\_SWAP\_CHAIN\_DESC1</pc></pc>) to the current dimensions of the app window.</source>
					<target>You should set the DirectX swap chain's height and width (in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI\_SWAP\_CHAIN\_DESC1</pc></pc>) to the current dimensions of the app window.</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If you don't, the display content will be scaled (using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DXGI\_SCALING\_STRETCH</pc>) to fit.</source>
					<target>If you don't, the display content will be scaled (using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DXGI\_SCALING\_STRETCH</pc>) to fit.</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404528)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>You must set the DirectX swap chain's scaling mode (in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI\_SWAP\_CHAIN\_DESC1</pc></pc>) to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DXGI\_SCALING\_STRETCH</pc>.</source>
					<target>You must set the DirectX swap chain's scaling mode (in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI\_SWAP\_CHAIN\_DESC1</pc></pc>) to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DXGI\_SCALING\_STRETCH</pc>.</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404528)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>You can't set the DirectX swap chain's alpha mode (in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI\_SWAP\_CHAIN\_DESC1</pc></pc>) to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DXGI\_ALPHA\_MODE\_PREMULTIPLIED</pc>.</source>
					<target>You can't set the DirectX swap chain's alpha mode (in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI\_SWAP\_CHAIN\_DESC1</pc></pc>) to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DXGI\_ALPHA\_MODE\_PREMULTIPLIED</pc>.</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404558)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You must create the DirectX swap chain by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGIFactory2::CreateSwapChainForComposition</pc></pc>.</source>
					<target>You must create the DirectX swap chain by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGIFactory2::CreateSwapChainForComposition</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn252834)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You update the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> based on the needs of your app, and not the updates of the XAML framework.</source>
					<target>You update the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> based on the needs of your app, and not the updates of the XAML framework.</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br228127)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>If you need to synchronize the updates of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SwapChainPanel</pc> to those of the XAML framework, register for the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Windows::UI::Xaml::Media::CompositionTarget::Rendering</pc></pc> event.</source>
					<target>If you need to synchronize the updates of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SwapChainPanel</pc> to those of the XAML framework, register for the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Windows::UI::Xaml::Media::CompositionTarget::Rendering</pc></pc> event.</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Otherwise, you must consider any cross-thread issues if you try to update the XAML elements from a different thread than the one updating the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SwapChainPanel</pc>.</source>
					<target>Otherwise, you must consider any cross-thread issues if you try to update the XAML elements from a different thread than the one updating the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SwapChainPanel</pc>.</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn252834)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>There are also a few general best practices to follow designing your app to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc>.</source>
					<target>There are also a few general best practices to follow designing your app to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn252834)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242704)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> inherits from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Windows::UI::Xaml::Controls::Grid</pc></pc>, and supports similar layout behavior.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> inherits from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Windows::UI::Xaml::Controls::Grid</pc></pc>, and supports similar layout behavior.</target>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Familiarize yourself with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Grid</pc> type and its properties.</source>
					<target>Familiarize yourself with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Grid</pc> type and its properties.</target>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn252834)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>After a DirectX swap chain has been set, all input events that are fired for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> work the same as they do for any other XAML element.</source>
					<target>After a DirectX swap chain has been set, all input events that are fired for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> work the same as they do for any other XAML element.</target>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208225)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>You don't set a background brush for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SwapChainPanel</pc>, and you don't need to handle input events from the app's <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">CoreWindow</pc></pc> object directly as you do in DirectX apps that don't use <pc dataRefEnd="id8" dataRefStart="id7" id="p4">SwapChainPanel</pc>.</source>
					<target>You don't set a background brush for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SwapChainPanel</pc>, and you don't need to handle input events from the app's <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">CoreWindow</pc></pc> object directly as you do in DirectX apps that don't use <pc dataRefEnd="id8" dataRefStart="id7" id="p4">SwapChainPanel</pc>.</target>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn252834)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>• All content of the visual XAML element tree under a direct child of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> is clipped to the layout size of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">SwapChainPanel</pc> object’s immediate child.</source>
					<target>• All content of the visual XAML element tree under a direct child of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> is clipped to the layout size of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">SwapChainPanel</pc> object’s immediate child.</target>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>Any content that is transformed outside these layout bounds won't be rendered.</source>
					<target>Any content that is transformed outside these layout bounds won't be rendered.</target>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br210490)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Therefore, place any XAML content that you animate with a XAML<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Storyboard</pc></pc> in the visual tree under an element whose layout bounds are large enough to contain the full range of the animation.</source>
					<target>Therefore, place any XAML content that you animate with a XAML<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Storyboard</pc></pc> in the visual tree under an element whose layout bounds are large enough to contain the full range of the animation.</target>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn252834)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Limit the number of immediate visual XAML elements under a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc>.</source>
					<target>Limit the number of immediate visual XAML elements under a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>If possible, group elements that are in close proximity under a common parent.</source>
					<target>If possible, group elements that are in close proximity under a common parent.</target>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>But there is a performance tradeoff between the number of immediate visual children and the size of the children: too many or unnecessarily large XAML elements can impact overall performance.</source>
					<target>But there is a performance tradeoff between the number of immediate visual children and the size of the children: too many or unnecessarily large XAML elements can impact overall performance.</target>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Likewise, don't create a single full-screen child XAML element for your app's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SwapChainPanel</pc> because this increases overdraw in the app and decreases performance.</source>
					<target>Likewise, don't create a single full-screen child XAML element for your app's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SwapChainPanel</pc> because this increases overdraw in the app and decreases performance.</target>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>As a rule, create no more than 8 immediate XAML visual children for your app's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SwapChainPanel</pc>, and each element must have a layout size only as large as necessary to contain the element's visual content.</source>
					<target>As a rule, create no more than 8 immediate XAML visual children for your app's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SwapChainPanel</pc>, and each element must have a layout size only as large as necessary to contain the element's visual content.</target>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>However, you can make the visual tree of elements under a child element of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SwapChainPanel</pc> sufficiently complex without decreasing performance too badly.</source>
					<target>However, you can make the visual tree of elements under a child element of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SwapChainPanel</pc> sufficiently complex without decreasing performance too badly.</target>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   In general, your DirectX apps should create swap chains in landscape orientation, and equal to the display window size (which is usually the native screen resolution in most Windows Store games).</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   In general, your DirectX apps should create swap chains in landscape orientation, and equal to the display window size (which is usually the native screen resolution in most Windows Store games).</target>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>This ensures that your app uses the optimal swap chain implementation when it doesn't have any visible XAML overlay.</source>
					<target>This ensures that your app uses the optimal swap chain implementation when it doesn't have any visible XAML overlay.</target>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/dn302144)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>If the app is rotated to portrait mode, your app should call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::SetRotation</pc></pc> on the existing swap chain, apply a transform to the content if needed, and then call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSwapChain</pc></pc> again on the same swap chain.</source>
					<target>If the app is rotated to portrait mode, your app should call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::SetRotation</pc></pc> on the existing swap chain, apply a transform to the content if needed, and then call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSwapChain</pc></pc> again on the same swap chain.</target>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/bb174577)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Similarly, your app should call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetSwapChain</pc> again on the same swap chain whenever the swap chain is resized by calling <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IDXGISwapChain::ResizeBuffers</pc></pc>.</source>
					<target>Similarly, your app should call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetSwapChain</pc> again on the same swap chain whenever the swap chain is resized by calling <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IDXGISwapChain::ResizeBuffers</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn252834)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Here is basic process for creating and updating a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> object in the code behind:</source>
					<target>Here is basic process for creating and updating a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> object in the code behind:</target>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>Get an instance of a swap chain panel for your app.</source>
					<target>Get an instance of a swap chain panel for your app.</target>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<originalData>
					<data id="id1">`&lt;SwapChainPanel&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>The instances are indicated in your XAML with the <ph dataRef="id1" id="ph1" /> tag.</source>
					<target>The instances are indicated in your XAML with the <ph dataRef="id1" id="ph1" /> tag.</target>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">`&lt;SwapChainPanel&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>Here is an example <ph dataRef="id1" id="ph1" /> tag.</source>
					<target>Here is an example <ph dataRef="id1" id="ph1" /> tag.</target>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/dn302143)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Get a pointer to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISwapChainPanelNative</pc></pc>.</source>
					<target>Get a pointer to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISwapChainPanelNative</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn252834)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/br205821)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source>Cast the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> object as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IInspectable</pc></pc> (or <pc dataRefEnd="id10" dataRefStart="id9" id="p5">IUnknown</pc>), and call <pc dataRefEnd="id12" dataRefStart="id11" id="p6">QueryInterface</pc> on it to get the underlying <pc dataRefEnd="id14" dataRefStart="id13" id="p7">ISwapChainPanelNative</pc> implementation.</source>
					<target>Cast the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapChainPanel</pc></pc> object as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IInspectable</pc></pc> (or <pc dataRefEnd="id10" dataRefStart="id9" id="p5">IUnknown</pc>), and call <pc dataRefEnd="id12" dataRefStart="id11" id="p6">QueryInterface</pc> on it to get the underlying <pc dataRefEnd="id14" dataRefStart="id13" id="p7">ISwapChainPanelNative</pc> implementation.</target>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/dn302143)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/dn302144)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Create the DXGI device and the swap chain, and set the swap chain to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISwapChainPanelNative</pc></pc> by passing it to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSwapChain</pc></pc>.</source>
					<target>Create the DXGI device and the swap chain, and set the swap chain to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISwapChainPanelNative</pc></pc> by passing it to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSwapChain</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>Draw to the DirectX swap chain, and present it to display the contents.</source>
					<target>Draw to the DirectX swap chain, and present it to display the contents.</target>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>The XAML elements are refreshed when the Windows Runtime layout/render logic signals an update.</source>
					<target>The XAML elements are refreshed when the Windows Runtime layout/render logic signals an update.</target>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
					<target>Related topics</target>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>SurfaceImageSource</source>
					<target>SurfaceImageSource</target>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>VirtualSurfaceImageSource</source>
					<target>VirtualSurfaceImageSource</target>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>SwapChainPanel</source>
					<target>SwapChainPanel</target>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>ISwapChainPanelNative</source>
					<target>ISwapChainPanelNative</target>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>Programming Guide for Direct3D 11</source>
					<target>Programming Guide for Direct3D 11</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>