<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="it-it" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">8e8f3476454b0c0d3173ca807bb21f20e5a429a5</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\create-a-basic-mesh.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">5e7e4362905233f7eb9a38fa3753982ae5948c34</mda:meta><mda:meta type="olxliffhash">5ef64479a583c63bc5026640359e3a492a3f00ee</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Create and display a basic mesh</source>
					<target>Create and display a basic mesh</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>3-D Universal Windows Platform (UWP) games typically use polygons to represent objects and surfaces in the game.</source>
					<target>3-D Universal Windows Platform (UWP) games typically use polygons to represent objects and surfaces in the game.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Create and display a basic mesh</source>
					<target>Create and display a basic mesh</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>3-D Universal Windows Platform (UWP) games typically use polygons to represent objects and surfaces in the game.</source>
					<target>3-D Universal Windows Platform (UWP) games typically use polygons to represent objects and surfaces in the game.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>The lists of vertices that comprise the structure of these polygonal objects and surfaces are called meshes.</source>
					<target>The lists of vertices that comprise the structure of these polygonal objects and surfaces are called meshes.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>Here, we create a basic mesh for a cube object and provide it to the shader pipeline for rendering and display.</source>
					<target>Here, we create a basic mesh for a cube object and provide it to the shader pipeline for rendering and display.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>   The example code included here uses types (such as DirectX::XMFLOAT3 and DirectX::XMFLOAT4X4) and inline methods declared in DirectXMath.h.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>   The example code included here uses types (such as DirectX::XMFLOAT3 and DirectX::XMFLOAT4X4) and inline methods declared in DirectXMath.h.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>If you're cutting and pasting this code, \#include <ph dataRef="id1" id="ph1" />DirectXMath.h<ph dataRef="id2" id="ph2" /> in your project.</source>
					<target>If you're cutting and pasting this code, \#include <ph dataRef="id1" id="ph1" />DirectXMath.h<ph dataRef="id2" id="ph2" /> in your project.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>What you need to know</source>
					<target>What you need to know</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>Technologies</source>
					<target>Technologies</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Direct3D</source>
					<target>Direct3D</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Prerequisites</source>
					<target>Prerequisites</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>Basic knowledge of linear algebra and 3-D coordinate systems</source>
					<target>Basic knowledge of linear algebra and 3-D coordinate systems</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>A Visual Studio 2015 Direct3D template</source>
					<target>A Visual Studio 2015 Direct3D template</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Instructions</source>
					<target>Instructions</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Step 1: Construct the mesh for the model</source>
					<target>Step 1: Construct the mesh for the model</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>In most games, the mesh for a game object is loaded from a file that contains the specific vertex data.</source>
					<target>In most games, the mesh for a game object is loaded from a file that contains the specific vertex data.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>The ordering of these vertices is app-dependent, but they are usually serialized as strips or fans.</source>
					<target>The ordering of these vertices is app-dependent, but they are usually serialized as strips or fans.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>Vertex data can come from any software source, or it can be created manually.</source>
					<target>Vertex data can come from any software source, or it can be created manually.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>It's up to your game to interpret the data in a way that the vertex shader can effectively process it.</source>
					<target>It's up to your game to interpret the data in a way that the vertex shader can effectively process it.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>In our example, we use a simple mesh for a cube.</source>
					<target>In our example, we use a simple mesh for a cube.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>The cube, like any object mesh at this stage in the pipeline, is represented using its own coordinate system.</source>
					<target>The cube, like any object mesh at this stage in the pipeline, is represented using its own coordinate system.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>The vertex shader takes its coordinates and, by applying the transformation matrices you provide, returns the final 2-D view projection in a homogeneous coordinate system.</source>
					<target>The vertex shader takes its coordinates and, by applying the transformation matrices you provide, returns the final 2-D view projection in a homogeneous coordinate system.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Define the mesh for a cube.</source>
					<target>Define the mesh for a cube.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>(Or load it from a file.</source>
					<target>(Or load it from a file.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>It's your call!)</source>
					<target>It's your call!)</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>The cube's coordinate system places the center of the cube at the origin, with the y-axis running top to bottom using a left-handed coordinate system.</source>
					<target>The cube's coordinate system places the center of the cube at the origin, with the y-axis running top to bottom using a left-handed coordinate system.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>Coordinate values are expressed as 32-bit floating values between -1 and 1.</source>
					<target>Coordinate values are expressed as 32-bit floating values between -1 and 1.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>In each bracketed pairing, the second DirectX::XMFLOAT3 value group specifies the color associated with the vertex as an RGB value.</source>
					<target>In each bracketed pairing, the second DirectX::XMFLOAT3 value group specifies the color associated with the vertex as an RGB value.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>For example, the first vertex at (-0.5, 0.5, -0.5) has a full green color (the G value is set to 1.0, and the "R" and "B" values are set to 0).</source>
					<target>For example, the first vertex at (-0.5, 0.5, -0.5) has a full green color (the G value is set to 1.0, and the "R" and "B" values are set to 0).</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Therefore, you have 8 vertices, each with a specific color.</source>
					<target>Therefore, you have 8 vertices, each with a specific color.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Each vertex/color pairing is the complete data for a vertex in our example.</source>
					<target>Each vertex/color pairing is the complete data for a vertex in our example.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>When you specify our vertex buffer, you must keep this specific layout in mind.</source>
					<target>When you specify our vertex buffer, you must keep this specific layout in mind.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>We provide this input layout to the vertex shader so it can understand your vertex data.</source>
					<target>We provide this input layout to the vertex shader so it can understand your vertex data.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Step 2: Set up the input layout</source>
					<target>Step 2: Set up the input layout</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Now, you have the vertices in memory.</source>
					<target>Now, you have the vertices in memory.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>But, your graphics device has its own memory, and you use Direct3D to access it.</source>
					<target>But, your graphics device has its own memory, and you use Direct3D to access it.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>To get your vertex data into the graphics device for processing, you need to clear the way, as it were: you must declare how the vertex data is laid out so that the graphics device can interpret it when it gets it from your game.</source>
					<target>To get your vertex data into the graphics device for processing, you need to clear the way, as it were: you must declare how the vertex data is laid out so that the graphics device can interpret it when it gets it from your game.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476575)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To do that, you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11InputLayout</pc></pc>.</source>
					<target>To do that, you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11InputLayout</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>Declare and set the input layout for the vertex buffer.</source>
					<target>Declare and set the input layout for the vertex buffer.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>In this code, you specify a layout for the vertices, specifically, what data each element in the vertex list contains.</source>
					<target>In this code, you specify a layout for the vertices, specifically, what data each element in the vertex list contains.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Here, in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">basicVertexLayoutDesc</pc>, you specify two data components:</source>
					<target>Here, in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">basicVertexLayoutDesc</pc>, you specify two data components:</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">POSITION</pc>: This is an HLSL semantic for position data provided to a shader.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">POSITION</pc>: This is an HLSL semantic for position data provided to a shader.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>In this code, it's a DirectX::XMFLOAT3, or more specifically, a structure with 3 32-bit floating point values that correspond to a 3D coordinate (x, y, z).</source>
					<target>In this code, it's a DirectX::XMFLOAT3, or more specifically, a structure with 3 32-bit floating point values that correspond to a 3D coordinate (x, y, z).</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>You could also use a float4 if you are supplying the homogeneous "w" coordinate, and in that case, you specify DXGI\_FORMAT\_R32G32B32A32\_FLOAT.</source>
					<target>You could also use a float4 if you are supplying the homogeneous "w" coordinate, and in that case, you specify DXGI\_FORMAT\_R32G32B32A32\_FLOAT.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Whether you use a DirectX::XMFLOAT3 or a float4 is up to the specific needs of your game.</source>
					<target>Whether you use a DirectX::XMFLOAT3 or a float4 is up to the specific needs of your game.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>Just make sure that the vertex data for your mesh corresponds correctly to the format you use!</source>
					<target>Just make sure that the vertex data for your mesh corresponds correctly to the format you use!</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>Each coordinate value is expressed as a floating point value between -1 and 1, in the object's coordinate space.</source>
					<target>Each coordinate value is expressed as a floating point value between -1 and 1, in the object's coordinate space.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>When the vertex shader completes, the transformed vertex is in the homogeneous (perspective corrected) view projection space.</source>
					<target>When the vertex shader completes, the transformed vertex is in the homogeneous (perspective corrected) view projection space.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>"But the enumeration value indicates RGB, not XYZ!"</source>
					<target>"But the enumeration value indicates RGB, not XYZ!"</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>you smartly note.</source>
					<target>you smartly note.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Good eye!</source>
					<target>Good eye!</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>In both the cases of color data and coordinate data, you typically use 3 or 4 component values, so why not use the same format for both?</source>
					<target>In both the cases of color data and coordinate data, you typically use 3 or 4 component values, so why not use the same format for both?</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>The HLSL semantic, not the format name, indicates how the shader treats the data.</source>
					<target>The HLSL semantic, not the format name, indicates how the shader treats the data.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">COLOR</pc>: This is an HLSL semantic for color data.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">COLOR</pc>: This is an HLSL semantic for color data.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Like <pc dataRefEnd="id2" dataRefStart="id1" id="p1">POSITION</pc>, it consists of 3 32-bit floating point values (DirectX::XMFLOAT3).</source>
					<target>Like <pc dataRefEnd="id2" dataRefStart="id1" id="p1">POSITION</pc>, it consists of 3 32-bit floating point values (DirectX::XMFLOAT3).</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>Each value contains a color component: red (r), blue (b), or green (g), expressed as a floating number between 0 and 1.</source>
					<target>Each value contains a color component: red (r), blue (b), or green (g), expressed as a floating number between 0 and 1.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">COLOR</pc> values are typically returned as a 4-component RGBA value at the end of the shader pipeline.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">COLOR</pc> values are typically returned as a 4-component RGBA value at the end of the shader pipeline.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>For this example, you will be setting the "A" alpha value to 1.0 (maximum opacity) in the shader pipeline for all pixels.</source>
					<target>For this example, you will be setting the "A" alpha value to 1.0 (maximum opacity) in the shader pipeline for all pixels.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb173059)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For a complete list of formats, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI\_FORMAT</pc></pc>.</source>
					<target>For a complete list of formats, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI\_FORMAT</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509647)</data>
				</originalData>
				<segment state="initial">
					<source>For a complete list of HLSL semantics, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Semantics</pc>.</source>
					<target>For a complete list of HLSL semantics, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Semantics</pc>.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476512)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device::CreateInputLayout</pc></pc> and create the input layout on the Direct3D device.</source>
					<target>Call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device::CreateInputLayout</pc></pc> and create the input layout on the Direct3D device.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>Now, you need to create a buffer that can actually hold the data!</source>
					<target>Now, you need to create a buffer that can actually hold the data!</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>Step 3: Populate the vertex buffers</source>
					<target>Step 3: Populate the vertex buffers</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Vertex buffers contain the list of vertices for each triangle in the mesh.</source>
					<target>Vertex buffers contain the list of vertices for each triangle in the mesh.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>Every vertex must be unique in this list.</source>
					<target>Every vertex must be unique in this list.</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>In our example, you have 8 vertices for the cube.</source>
					<target>In our example, you have 8 vertices for the cube.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>The vertex shader runs on the graphics device and reads from the vertex buffer, and it interprets the data based on the input layout you specified in the previous step.</source>
					<target>The vertex shader runs on the graphics device and reads from the vertex buffer, and it interprets the data based on the input layout you specified in the previous step.</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>In the next example, you provide a description and a subresource for the buffer, which tell Direct3D a number of things about the physical mapping of the vertex data and how to treat it in memory on the graphics device.</source>
					<target>In the next example, you provide a description and a subresource for the buffer, which tell Direct3D a number of things about the physical mapping of the vertex data and how to treat it in memory on the graphics device.</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476351)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This is necessary because you use a generic <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Buffer</pc></pc>, which could contain anything!</source>
					<target>This is necessary because you use a generic <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Buffer</pc></pc>, which could contain anything!</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11\_BUFFER\_DESC</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">D3D11\_SUBRESOURCE\_DATA</pc></pc> structures are supplied to ensure that Direct3D understands the physical memory layout of the buffer, including the size of each vertex element in the buffer as well as the maximum size of the vertex list.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11\_BUFFER\_DESC</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">D3D11\_SUBRESOURCE\_DATA</pc></pc> structures are supplied to ensure that Direct3D understands the physical memory layout of the buffer, including the size of each vertex element in the buffer as well as the maximum size of the vertex list.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>You can also control access to the buffer memory here and how it is traversed, but that's a bit beyond the scope of this tutorial.</source>
					<target>You can also control access to the buffer memory here and how it is traversed, but that's a bit beyond the scope of this tutorial.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>After you configure the buffer, you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device::CreateBuffer</pc></pc> to actually create it.</source>
					<target>After you configure the buffer, you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device::CreateBuffer</pc></pc> to actually create it.</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Obviously, if you have more than one object, create buffers for each unique model.</source>
					<target>Obviously, if you have more than one object, create buffers for each unique model.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>Declare and create the vertex buffer.</source>
					<target>Declare and create the vertex buffer.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>Vertices loaded.</source>
					<target>Vertices loaded.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>But what's the order of processing these vertices?</source>
					<target>But what's the order of processing these vertices?</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>That's handled when you provide a list of indices to the vertices—the ordering of these indices is the order in which the vertex shader processes them.</source>
					<target>That's handled when you provide a list of indices to the vertices—the ordering of these indices is the order in which the vertex shader processes them.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Step 4: Populate the index buffers</source>
					<target>Step 4: Populate the index buffers</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>Now, you provide a list of the indices for each of the vertices.</source>
					<target>Now, you provide a list of the indices for each of the vertices.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>These indices correspond to the position of the vertex in the vertex buffer, starting with 0.</source>
					<target>These indices correspond to the position of the vertex in the vertex buffer, starting with 0.</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>To help you visualize this, consider that each unique vertex in your mesh has a unique number assigned to it, like an ID.</source>
					<target>To help you visualize this, consider that each unique vertex in your mesh has a unique number assigned to it, like an ID.</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>This ID is the integer position of the vertex in the vertex buffer.</source>
					<target>This ID is the integer position of the vertex in the vertex buffer.</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>a cube with eight numbered vertices</source>
					<target>a cube with eight numbered vertices</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>In our example cube, you have 8 vertices, which create 6 quads for the sides.</source>
					<target>In our example cube, you have 8 vertices, which create 6 quads for the sides.</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>You split the quads into triangles, for a total of 12 triangles that use our 8 vertices.</source>
					<target>You split the quads into triangles, for a total of 12 triangles that use our 8 vertices.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>At 3 vertices per triangle, you have 36 entries in our index buffer.</source>
					<target>At 3 vertices per triangle, you have 36 entries in our index buffer.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In our example, this index pattern is known as a triangle list, and you indicate it to Direct3D as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST</pc> when you set the primitive topology.</source>
					<target>In our example, this index pattern is known as a triangle list, and you indicate it to Direct3D as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST</pc> when you set the primitive topology.</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>This is probably the most inefficient way to list indices, as there are many redundancies when triangles share points and sides.</source>
					<target>This is probably the most inefficient way to list indices, as there are many redundancies when triangles share points and sides.</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>For example, when a triangle shares a side in a rhombus shape, you list 6 indices for the four vertices, like this:</source>
					<target>For example, when a triangle shares a side in a rhombus shape, you list 6 indices for the four vertices, like this:</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>order of indices when constructing a rhombus</source>
					<target>order of indices when constructing a rhombus</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>Triangle 1: \[0, 1, 2\]</source>
					<target>Triangle 1: \[0, 1, 2\]</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>Triangle 2: \[0, 2, 3\]</source>
					<target>Triangle 2: \[0, 2, 3\]</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>In a strip or fan topology, you order the vertices in a way that eliminates many redundant sides during traversal (such as the side from index 0 to index 2 in the image.) For large meshes, this dramatically reduces the number of times the vertex shader is run, and improves performance significantly.</source>
					<target>In a strip or fan topology, you order the vertices in a way that eliminates many redundant sides during traversal (such as the side from index 0 to index 2 in the image.) For large meshes, this dramatically reduces the number of times the vertex shader is run, and improves performance significantly.</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>However, we'll keep it simple and stick with the triangle list.</source>
					<target>However, we'll keep it simple and stick with the triangle list.</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>Declare the indices for the vertex buffer as a simple triangle list topology.</source>
					<target>Declare the indices for the vertex buffer as a simple triangle list topology.</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>Thirty six index elements in the buffer is very redundant when you only have 8 vertices!</source>
					<target>Thirty six index elements in the buffer is very redundant when you only have 8 vertices!</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476189)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476455)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>If you choose to eliminate some of the redundancies and use a different vertex list type, such as a strip or a fan, you must specify that type when you provide a specific <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11\_PRIMITIVE\_TOPOLOGY</pc></pc> value to the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceContext::IASetPrimitiveTopology</pc></pc> method.</source>
					<target>If you choose to eliminate some of the redundancies and use a different vertex list type, such as a strip or a fan, you must specify that type when you provide a specific <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11\_PRIMITIVE\_TOPOLOGY</pc></pc> value to the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceContext::IASetPrimitiveTopology</pc></pc> method.</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb205124)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about different index list techniques, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Primitive Topologies</pc>.</source>
					<target>For more information about different index list techniques, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Primitive Topologies</pc>.</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>Step 5: Create a constant buffer for your transformation matrices</source>
					<target>Step 5: Create a constant buffer for your transformation matrices</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>Before you can start processing vertices, you need to provide the transformation matrices that will be applied (multiplied) to each vertex when it runs.</source>
					<target>Before you can start processing vertices, you need to provide the transformation matrices that will be applied (multiplied) to each vertex when it runs.</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>For most 3-D games, there are three of them:</source>
					<target>For most 3-D games, there are three of them:</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>The 4x4 matrix that transforms from the object (model) coordinate system to the overall world coordinate system.</source>
					<target>The 4x4 matrix that transforms from the object (model) coordinate system to the overall world coordinate system.</target>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>The 4x4 matrix that transforms from the world coordinate system to the camera (view) coordinate system.</source>
					<target>The 4x4 matrix that transforms from the world coordinate system to the camera (view) coordinate system.</target>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>The 4x4 matrix that transforms from the camera coordinate system to the 2-D view projection coordinate system.</source>
					<target>The 4x4 matrix that transforms from the camera coordinate system to the 2-D view projection coordinate system.</target>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>These matrices are passed to the shader in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">constant buffer</pc>.</source>
					<target>These matrices are passed to the shader in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">constant buffer</pc>.</target>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>A constant buffer is a region of memory that remains constant throughout the execution of the next pass of the shader pipeline, and which can be directly accessed by the shaders from your HLSL code.</source>
					<target>A constant buffer is a region of memory that remains constant throughout the execution of the next pass of the shader pipeline, and which can be directly accessed by the shaders from your HLSL code.</target>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>You define each constant buffer two times: first in your game's C++ code, and (at least) one time in the C-like HLSL syntax for your shader code.</source>
					<target>You define each constant buffer two times: first in your game's C++ code, and (at least) one time in the C-like HLSL syntax for your shader code.</target>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>The two declarations must directly correspond in terms of types and data alignment.</source>
					<target>The two declarations must directly correspond in terms of types and data alignment.</target>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>It's easy to introduce hard to find errors when the shader uses the HLSL declaration to interpret data declared in C++, and the types don't match or the alignment of data is off!</source>
					<target>It's easy to introduce hard to find errors when the shader uses the HLSL declaration to interpret data declared in C++, and the types don't match or the alignment of data is off!</target>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>Constant buffers don't get changed by the HLSL.</source>
					<target>Constant buffers don't get changed by the HLSL.</target>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>You can change them when your game updates specific data.</source>
					<target>You can change them when your game updates specific data.</target>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>Often, game devs create 4 classes of constant buffers: one type for updates per frame; one type for updates per model/object; one type for updates per game state refresh; and one type for data that never changes through the lifetime of the game.</source>
					<target>Often, game devs create 4 classes of constant buffers: one type for updates per frame; one type for updates per model/object; one type for updates per game state refresh; and one type for data that never changes through the lifetime of the game.</target>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<segment state="initial">
					<source>In this example, we just have one that never changes: the DirectX::XMFLOAT4X4 data for the three matrices.</source>
					<target>In this example, we just have one that never changes: the DirectX::XMFLOAT4X4 data for the three matrices.</target>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The example code presented here uses column-major matrices.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The example code presented here uses column-major matrices.</target>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use row-major matrices instead by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">row\_major</pc> keyword in HLSL, and ensuring your source matrix data is also row-major.</source>
					<target>You can use row-major matrices instead by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">row\_major</pc> keyword in HLSL, and ensuring your source matrix data is also row-major.</target>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>DirectXMath uses row-major matrices and can be used directly with HLSL matrices defined with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">row\_major</pc> keyword.</source>
					<target>DirectXMath uses row-major matrices and can be used directly with HLSL matrices defined with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">row\_major</pc> keyword.</target>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>Declare and create a constant buffer for the three matrices you use to transform each vertex.</source>
					<target>Declare and create a constant buffer for the three matrices you use to transform each vertex.</target>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  You usually declare the projection matrix when you set up device specific resources, because the results of multiplication with it must match the current 2-D viewport size parameters (which often correspond with the pixel height and width of the display).</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  You usually declare the projection matrix when you set up device specific resources, because the results of multiplication with it must match the current 2-D viewport size parameters (which often correspond with the pixel height and width of the display).</target>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<segment state="initial">
					<source>If those change, you must scale the x- and y-coordinate values accordingly.</source>
					<target>If those change, you must scale the x- and y-coordinate values accordingly.</target>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476149)</data>
				</originalData>
				<segment state="initial">
					<source>While you're here, set the vertex and index buffers on the<pc dataRefEnd="id2" dataRefStart="id1" id="p1">ID3D11DeviceContext</pc>, plus the topology you're using.</source>
					<target>While you're here, set the vertex and index buffers on the<pc dataRefEnd="id2" dataRefStart="id1" id="p1">ID3D11DeviceContext</pc>, plus the topology you're using.</target>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>All right!</source>
					<target>All right!</target>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>Input assembly complete.</source>
					<target>Input assembly complete.</target>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<segment state="initial">
					<source>Everything's in place for rendering.</source>
					<target>Everything's in place for rendering.</target>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>Let's get that vertex shader going.</source>
					<target>Let's get that vertex shader going.</target>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>Step 6: Process the mesh with the vertex shader</source>
					<target>Step 6: Process the mesh with the vertex shader</target>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<segment state="initial">
					<source>Now that you have a vertex buffer with the vertices that define your mesh, and the index buffer that defines the order in which the vertices are processed, you send them to the vertex shader.</source>
					<target>Now that you have a vertex buffer with the vertices that define your mesh, and the index buffer that defines the order in which the vertices are processed, you send them to the vertex shader.</target>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>The vertex shader code, expressed as compiled high-level shader language, runs one time for each vertex in the vertex buffer, allowing you to perform your per-vertex transforms.</source>
					<target>The vertex shader code, expressed as compiled high-level shader language, runs one time for each vertex in the vertex buffer, allowing you to perform your per-vertex transforms.</target>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>The final result is typically a 2-D projection.</source>
					<target>The final result is typically a 2-D projection.</target>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>(Did you load your vertex shader?</source>
					<target>(Did you load your vertex shader?</target>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](load-a-game-asset.md)</data>
				</originalData>
				<segment state="initial">
					<source>If not, review <pc dataRefEnd="id2" dataRefStart="id1" id="p1">How to load resources in your DirectX game</pc>.)</source>
					<target>If not, review <pc dataRefEnd="id2" dataRefStart="id1" id="p1">How to load resources in your DirectX game</pc>.)</target>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>Here, you create the vertex shader...</source>
					<target>Here, you create the vertex shader...</target>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>...and set the constant buffers.</source>
					<target>...and set the constant buffers.</target>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>Here's the vertex shader code that handles the transformation from object coordinates to world coordinates and then to the 2-D view projection coordinate system.</source>
					<target>Here's the vertex shader code that handles the transformation from object coordinates to world coordinates and then to the 2-D view projection coordinate system.</target>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>You also apply some simple per-vertex lighting to make things pretty.</source>
					<target>You also apply some simple per-vertex lighting to make things pretty.</target>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>This goes in your vertex shader's HLSL file (SimplerVertexShader.hlsl, in this example).</source>
					<target>This goes in your vertex shader's HLSL file (SimplerVertexShader.hlsl, in this example).</target>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>See that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">cbuffer</pc> at the top?</source>
					<target>See that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">cbuffer</pc> at the top?</target>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<segment state="initial">
					<source>That's the HLSL analogue to the same constant buffer we declared in our C++ code previously.</source>
					<target>That's the HLSL analogue to the same constant buffer we declared in our C++ code previously.</target>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>And the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">VertexShaderInputstruct</pc>?</source>
					<target>And the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">VertexShaderInputstruct</pc>?</target>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>Why, that looks just like your input layout and vertex data declaration!</source>
					<target>Why, that looks just like your input layout and vertex data declaration!</target>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>It's important that the constant buffer and vertex data declarations in your C++ code match the declarations in your HLSL code—and that includes signs, types, and data alignment.</source>
					<target>It's important that the constant buffer and vertex data declarations in your C++ code match the declarations in your HLSL code—and that includes signs, types, and data alignment.</target>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">PixelShaderInput</pc> specifies the layout of the data that is returned by the vertex shader's main function.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">PixelShaderInput</pc> specifies the layout of the data that is returned by the vertex shader's main function.</target>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>When you finish processing a vertex, you'll return a vertex position in the 2-D projection space and a color used for per-vertex lighting.</source>
					<target>When you finish processing a vertex, you'll return a vertex position in the 2-D projection space and a color used for per-vertex lighting.</target>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>The graphics card uses data output by the shader to calculate the "fragments" (possible pixels) that must be colored when the pixel shader is run in the next stage of the pipeline.</source>
					<target>The graphics card uses data output by the shader to calculate the "fragments" (possible pixels) that must be colored when the pixel shader is run in the next stage of the pipeline.</target>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>Step 7: Passing the mesh through the pixel shader</source>
					<target>Step 7: Passing the mesh through the pixel shader</target>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>Typically, at this stage in the graphics pipeline, you perform per-pixel operations on the visible projected surfaces of your objects.</source>
					<target>Typically, at this stage in the graphics pipeline, you perform per-pixel operations on the visible projected surfaces of your objects.</target>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>(People like textures.) For the purposes of sample, though, you simply pass it through this stage.</source>
					<target>(People like textures.) For the purposes of sample, though, you simply pass it through this stage.</target>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>First, let's create an instance of the pixel shader.</source>
					<target>First, let's create an instance of the pixel shader.</target>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>The pixel shader runs for every pixel in the 2-D projection of your scene, assigning a color to that pixel.</source>
					<target>The pixel shader runs for every pixel in the 2-D projection of your scene, assigning a color to that pixel.</target>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<segment state="initial">
					<source>In this case, we pass the color for the pixel returned by the vertex shader straight through.</source>
					<target>In this case, we pass the color for the pixel returned by the vertex shader straight through.</target>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>Set the pixel shader.</source>
					<target>Set the pixel shader.</target>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<segment state="initial">
					<source>Define a passthrough pixel shader in HLSL.</source>
					<target>Define a passthrough pixel shader in HLSL.</target>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<segment state="initial">
					<source>Put this code in an HLSL file separate from the vertex shader HLSL (such as SimplePixelShader.hlsl).</source>
					<target>Put this code in an HLSL file separate from the vertex shader HLSL (such as SimplePixelShader.hlsl).</target>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>This code is run one time for every visible pixel in your viewport (an in-memory representation of the portion of the screen you are drawing to), which, in this case, maps to the entire screen.</source>
					<target>This code is run one time for every visible pixel in your viewport (an in-memory representation of the portion of the screen you are drawing to), which, in this case, maps to the entire screen.</target>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>Now, your graphics pipeline is completely defined!</source>
					<target>Now, your graphics pipeline is completely defined!</target>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>Step 8: Rasterizing and displaying the mesh</source>
					<target>Step 8: Rasterizing and displaying the mesh</target>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<segment state="initial">
					<source>Let's run the pipeline.</source>
					<target>Let's run the pipeline.</target>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb173565)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This is easy: call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext::DrawIndexed</pc></pc>.</source>
					<target>This is easy: call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext::DrawIndexed</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>Draw that cube!</source>
					<target>Draw that cube!</target>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<segment state="initial">
					<source>Inside the graphics card, each vertex is processed in the order specified in your index buffer.</source>
					<target>Inside the graphics card, each vertex is processed in the order specified in your index buffer.</target>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>After your code has executed the vertex shader and the 2-D fragments are defined, the pixel shader is invoked and the triangles colored.</source>
					<target>After your code has executed the vertex shader and the 2-D fragments are defined, the pixel shader is invoked and the triangles colored.</target>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<segment state="initial">
					<source>Now, put the cube on the screen.</source>
					<target>Now, put the cube on the screen.</target>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<segment state="initial">
					<source>Present that frame buffer to the display.</source>
					<target>Present that frame buffer to the display.</target>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>And you're done!</source>
					<target>And you're done!</target>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>For a scene full of models, use multiple vertex and index buffers, and you might even have different shaders for different model types.</source>
					<target>For a scene full of models, use multiple vertex and index buffers, and you might even have different shaders for different model types.</target>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>Remember that each model has its own coordinate system, and you need to transform them to the shared world coordinate system using the matrices you defined in the constant buffer.</source>
					<target>Remember that each model has its own coordinate system, and you need to transform them to the shared world coordinate system using the matrices you defined in the constant buffer.</target>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>Remarks</source>
					<target>Remarks</target>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<segment state="initial">
					<source>This topic covers creating and displaying simple geometry that you create yourself.</source>
					<target>This topic covers creating and displaying simple geometry that you create yourself.</target>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](load-a-game-asset.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about loading more complex geometry from a file and converting it to the sample-specific vertex buffer object (.vbo) format, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">How to load resources in your DirectX game</pc>.</source>
					<target>For more info about loading more complex geometry from a file and converting it to the sample-specific vertex buffer object (.vbo) format, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">How to load resources in your DirectX game</pc>.</target>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<segment state="initial">
					<source>Note</source>
					<target>Note</target>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</source>
					<target>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</target>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>If you’re developing for Windows 8.x or Windows Phone 8.x, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archived documentation</pc>.</source>
					<target>If you’re developing for Windows 8.x or Windows Phone 8.x, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archived documentation</pc>.</target>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
					<target>Related topics</target>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<segment state="initial">
					<source>How to load resources in your DirectX game</source>
					<target>How to load resources in your DirectX game</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>