<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">31e3676ada281ba902c95965859638d5a23d7c5b</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\supporting-screen-rotation-directx-and-cpp.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">32cc4b6585346611ad4c213acd822dc062344b2b</mda:meta><mda:meta type="olxliffhash">c63e813c37bab8455210aea0a0fcc1d1ed5d3aba</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Supporting screen orientation (DirectX and C++)</source>
					<target>Supporting screen orientation (DirectX and C++)</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Here, we'll discuss best practices for handling screen rotation in your UWP DirectX app, so that the Windows 10 device's graphics hardware are used efficiently and effectively.</source>
					<target>Here, we'll discuss best practices for handling screen rotation in your UWP DirectX app, so that the Windows 10 device's graphics hardware are used efficiently and effectively.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Supporting screen orientation (DirectX and C++)</source>
					<target>Supporting screen orientation (DirectX and C++)</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn264268)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Your Universal Windows Platform (UWP) app can support multiple screen orientations when you handle the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation::OrientationChanged</pc></pc> event.</source>
					<target>Your Universal Windows Platform (UWP) app can support multiple screen orientations when you handle the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation::OrientationChanged</pc></pc> event.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Here, we'll discuss best practices for handling screen rotation in your UWP DirectX app, so that the Windows 10 device's graphics hardware are used efficiently and effectively.</source>
					<target>Here, we'll discuss best practices for handling screen rotation in your UWP DirectX app, so that the Windows 10 device's graphics hardware are used efficiently and effectively.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>Before you start, remember that graphics hardware always outputs pixel data in the same way, regardless of the orientation of the device.</source>
					<target>Before you start, remember that graphics hardware always outputs pixel data in the same way, regardless of the orientation of the device.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Windows 10 devices can determine their current display orientation (with some sort of sensor, or with a software toggle) and allow users to change the display settings.</source>
					<target>Windows 10 devices can determine their current display orientation (with some sort of sensor, or with a software toggle) and allow users to change the display settings.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>Because of this, Windows 10 itself handles the rotation of the images to ensure they are "upright" based on the orientation of the device.</source>
					<target>Because of this, Windows 10 itself handles the rotation of the images to ensure they are "upright" based on the orientation of the device.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>By default, your app receives the notification that something has changed in orientation, for example, a window size.</source>
					<target>By default, your app receives the notification that something has changed in orientation, for example, a window size.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>When this happens, Windows 10 immediately rotates the image for final display.</source>
					<target>When this happens, Windows 10 immediately rotates the image for final display.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>For three of the four specific screen orientations (discussed later), Windows 10 uses additional graphic resources and computation to display the final image.</source>
					<target>For three of the four specific screen orientations (discussed later), Windows 10 uses additional graphic resources and computation to display the final image.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn264258)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For UWP DirectX apps, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation</pc></pc> object provides basic display orientation data that your app can query.</source>
					<target>For UWP DirectX apps, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation</pc></pc> object provides basic display orientation data that your app can query.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
				</originalData>
				<segment state="initial">
					<source>The default orientation is <pc dataRefEnd="id2" dataRefStart="id1" id="p1">landscape</pc>, where the pixel width of the display is greater than the height; the alternative orientation is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">portrait</pc>, where the display is rotated 90 degrees in either direction and the width becomes less than the height.</source>
					<target>The default orientation is <pc dataRefEnd="id2" dataRefStart="id1" id="p1">landscape</pc>, where the pixel width of the display is greater than the height; the alternative orientation is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">portrait</pc>, where the display is rotated 90 degrees in either direction and the width becomes less than the height.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Windows 10 defines four specific display orientation modes:</source>
					<target>Windows 10 defines four specific display orientation modes:</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Landscape—the default display orientation for Windows 10, and is considered the base or identity angle for rotation (0 degrees).</source>
					<target>Landscape—the default display orientation for Windows 10, and is considered the base or identity angle for rotation (0 degrees).</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Portrait—the display has been rotated clockwise 90 degrees (or counter-clockwise 270 degrees).</source>
					<target>Portrait—the display has been rotated clockwise 90 degrees (or counter-clockwise 270 degrees).</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>Landscape, flipped—the display has been rotated 180 degrees (turned upside-down).</source>
					<target>Landscape, flipped—the display has been rotated 180 degrees (turned upside-down).</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Portrait, flipped—the display has been rotated clockwise 270 degrees (or counter-clockwise 90 degrees).</source>
					<target>Portrait, flipped—the display has been rotated clockwise 270 degrees (or counter-clockwise 90 degrees).</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>When the display rotates from one orientation to another, Windows 10 internally performs a rotation operation to align the drawn image with the new orientation, and the user sees an upright image on the screen.</source>
					<target>When the display rotates from one orientation to another, Windows 10 internally performs a rotation operation to align the drawn image with the new orientation, and the user sees an upright image on the screen.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>Also, Windows 10 displays automatic transition animations to create a smooth user experience when shifting from one orientation to another.</source>
					<target>Also, Windows 10 displays automatic transition animations to create a smooth user experience when shifting from one orientation to another.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>As the display orientation shifts, the user sees these shifts as a fixed zoom and rotation animation of the displayed screen image.</source>
					<target>As the display orientation shifts, the user sees these shifts as a fixed zoom and rotation animation of the displayed screen image.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Time is allocated by Windows 10 to the app for layout in the new orientation.</source>
					<target>Time is allocated by Windows 10 to the app for layout in the new orientation.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Overall, this is the general process for handling changes in screen orientation:</source>
					<target>Overall, this is the general process for handling changes in screen orientation:</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Use a combination of the window bounds values and the display orientation data to keep the swap chain aligned with the native display orientation of the device.</source>
					<target>Use a combination of the window bounds values and the display orientation data to keep the swap chain aligned with the native display orientation of the device.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Notify Windows 10 of the orientation of the swap chain using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::SetRotation</pc></pc>.</source>
					<target>Notify Windows 10 of the orientation of the swap chain using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::SetRotation</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>Change the rendering code to generate images aligned with the user orientation of the device.</source>
					<target>Change the rendering code to generate images aligned with the user orientation of the device.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>Resizing the swap chain and pre-rotating its contents</source>
					<target>Resizing the swap chain and pre-rotating its contents</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>To perform a basic display resize and pre-rotate its contents in your UWP DirectX app , implement these steps:</source>
					<target>To perform a basic display resize and pre-rotate its contents in your UWP DirectX app , implement these steps:</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn264268)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Handle the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation::OrientationChanged</pc></pc> event.</source>
					<target>Handle the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation::OrientationChanged</pc></pc> event.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Resize the swap chain to the new dimensions of the window.</source>
					<target>Resize the swap chain to the new dimensions of the window.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::SetRotation</pc></pc> to set the orientation of the swap chain.</source>
					<target>Call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::SetRotation</pc></pc> to set the orientation of the swap chain.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Recreate any window size dependent resources, such as your render targets and other pixel data buffers.</source>
					<target>Recreate any window size dependent resources, such as your render targets and other pixel data buffers.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>Now's let's look at those steps in a bit more detail.</source>
					<target>Now's let's look at those steps in a bit more detail.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn264268)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Your first step is to register a handler for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation::OrientationChanged</pc></pc> event.</source>
					<target>Your first step is to register a handler for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation::OrientationChanged</pc></pc> event.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>This event is raised in your app every time the screen orientation changes, such as when the display is rotated.</source>
					<target>This event is raised in your app every time the screen orientation changes, such as when the display is rotated.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn264268)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/hh700509)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/hh700478)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source>To handle the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation::OrientationChanged</pc></pc> event, you connect your handler for <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DisplayInformation::OrientationChanged</pc> in the required <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">SetWindow</pc></pc> method, which is one of the methods of the <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">IFrameworkView</pc></pc> interface that your view provider must implement.</source>
					<target>To handle the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation::OrientationChanged</pc></pc> event, you connect your handler for <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DisplayInformation::OrientationChanged</pc> in the required <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">SetWindow</pc></pc> method, which is one of the methods of the <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">IFrameworkView</pc></pc> interface that your view provider must implement.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn264268)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>In this code example, the event handler for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation::OrientationChanged</pc></pc> is a method called <pc dataRefEnd="id6" dataRefStart="id5" id="p3">OnOrientationChanged</pc>.</source>
					<target>In this code example, the event handler for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation::OrientationChanged</pc></pc> is a method called <pc dataRefEnd="id6" dataRefStart="id5" id="p3">OnOrientationChanged</pc>.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>When <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DisplayInformation::OrientationChanged</pc> is raised, it in turn calls a method called <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetCurrentOrientation</pc> which then calls <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CreateWindowSizeDependentResources</pc>.</source>
					<target>When <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DisplayInformation::OrientationChanged</pc> is raised, it in turn calls a method called <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetCurrentOrientation</pc> which then calls <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CreateWindowSizeDependentResources</pc>.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Next, you resize the swap chain for the new screen orientation and prepare it to rotate the contents of the graphic pipeline when the rendering is performed.</source>
					<target>Next, you resize the swap chain for the new screen orientation and prepare it to rotate the contents of the graphic pipeline when the rendering is performed.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In this example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXBase::CreateWindowSizeDependentResources</pc> is a method that handles calling IDXGISwapChain::ResizeBuffers, setting a 3D and a 2D rotation matrix, calling SetRotation, and recreating your resources.</source>
					<target>In this example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXBase::CreateWindowSizeDependentResources</pc> is a method that handles calling IDXGISwapChain::ResizeBuffers, setting a 3D and a 2D rotation matrix, calling SetRotation, and recreating your resources.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>After saving the current height and width values of the window for the next time this method is called, convert the device independent pixel (DIP) values for the display bounds to pixels.</source>
					<target>After saving the current height and width values of the window for the next time this method is called, convert the device independent pixel (DIP) values for the display bounds to pixels.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In the sample, you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConvertDipsToPixels</pc>, which is a simple function that runs this code:</source>
					<target>In the sample, you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConvertDipsToPixels</pc>, which is a simple function that runs this code:</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>You add the 0.5f to ensure rounding to the nearest integer value.</source>
					<target>You add the 0.5f to ensure rounding to the nearest integer value.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208225)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>As an aside, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindow</pc></pc> coordinates are always defined in DIPs.</source>
					<target>As an aside, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindow</pc></pc> coordinates are always defined in DIPs.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 10 and earlier versions of Windows, a DIP is defined as 1/96th of an inch, and aligned to the OS's definition of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">up</pc>.</source>
					<target>For Windows 10 and earlier versions of Windows, a DIP is defined as 1/96th of an inch, and aligned to the OS's definition of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">up</pc>.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When the display orientation rotates to portrait mode, the app flips the width and height of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CoreWindow</pc>, and the render target size (bounds) must change accordingly.</source>
					<target>When the display orientation rotates to portrait mode, the app flips the width and height of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CoreWindow</pc>, and the render target size (bounds) must change accordingly.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Because Direct3D’s coordinates are always in physical pixels, you must convert from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CoreWindow</pc>'s DIP values to integer pixel values before you pass these values to Direct3D to set up the swap chain.</source>
					<target>Because Direct3D’s coordinates are always in physical pixels, you must convert from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CoreWindow</pc>'s DIP values to integer pixel values before you pass these values to Direct3D to set up the swap chain.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>Process-wise, you're doing a bit more work than you would if you simply resized the swap chain: you're actually rotating the Direct2D and Direct3D components of your image before you composite them for presentation, and you're telling the swap chain that you've rendered the results in a new orientation.</source>
					<target>Process-wise, you're doing a bit more work than you would if you simply resized the swap chain: you're actually rotating the Direct2D and Direct3D components of your image before you composite them for presentation, and you're telling the swap chain that you've rendered the results in a new orientation.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's a little more detail on this process, as shown in the code example for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DX::DeviceResources::CreateWindowSizeDependentResources</pc>:</source>
					<target>Here's a little more detail on this process, as shown in the code example for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DX::DeviceResources::CreateWindowSizeDependentResources</pc>:</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>Determine the new orientation of the display.</source>
					<target>Determine the new orientation of the display.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>If the display has flipped from landscape to portrait, or vice versa, swap the height and width values—changed from DIP values to pixels, of course—for the display bounds.</source>
					<target>If the display has flipped from landscape to portrait, or vice versa, swap the height and width values—changed from DIP values to pixels, of course—for the display bounds.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Then, check to see if the swap chain has been created.</source>
					<target>Then, check to see if the swap chain has been created.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404559)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If it hasn't been created, create it by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGIFactory2::CreateSwapChainForCoreWindow</pc></pc>.</source>
					<target>If it hasn't been created, create it by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGIFactory2::CreateSwapChainForCoreWindow</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb174577)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Otherwise, resize the existing swap chain's buffers to the new display dimensions by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapchain:ResizeBuffers</pc></pc>.</source>
					<target>Otherwise, resize the existing swap chain's buffers to the new display dimensions by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapchain:ResizeBuffers</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>Although you don't need to resize the swap chain for the rotation event—you're outputting the content already rotated by your rendering pipeline, after all—there are other size change events, such as snap and fill events, that require resizing.</source>
					<target>Although you don't need to resize the swap chain for the rotation event—you're outputting the content already rotated by your rendering pipeline, after all—there are other size change events, such as snap and fill events, that require resizing.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>After that, set the appropriate 2-D or 3-D matrix transformation to apply to the pixels or the vertices (respectively) in the graphics pipeline when rendering them to the swap chain.</source>
					<target>After that, set the appropriate 2-D or 3-D matrix transformation to apply to the pixels or the vertices (respectively) in the graphics pipeline when rendering them to the swap chain.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>We have 4 possible rotation matrices:</source>
					<target>We have 4 possible rotation matrices:</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>landscape (DXGI\_MODE\_ROTATION\_IDENTITY)</source>
					<target>landscape (DXGI\_MODE\_ROTATION\_IDENTITY)</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>portrait (DXGI\_MODE\_ROTATION\_ROTATE270)</source>
					<target>portrait (DXGI\_MODE\_ROTATION\_ROTATE270)</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>landscape, flipped (DXGI\_MODE\_ROTATION\_ROTATE180)</source>
					<target>landscape, flipped (DXGI\_MODE\_ROTATION\_ROTATE180)</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>portrait, flipped (DXGI\_MODE\_ROTATION\_ROTATE90)</source>
					<target>portrait, flipped (DXGI\_MODE\_ROTATION\_ROTATE90)</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn264268)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The correct matrix is selected based on the data provided by Windows 10 (such as the results of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation::OrientationChanged</pc></pc>) for determining display orientation, and it will be multiplied by the coordinates of each pixel (Direct2D) or vertex (Direct3D) in the scene, effectively rotating them to align to the orientation of the screen.</source>
					<target>The correct matrix is selected based on the data provided by Windows 10 (such as the results of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation::OrientationChanged</pc></pc>) for determining display orientation, and it will be multiplied by the coordinates of each pixel (Direct2D) or vertex (Direct3D) in the scene, effectively rotating them to align to the orientation of the screen.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>(Note that in Direct2D, the screen origin is defined as the upper-left corner, while in Direct3D the origin is defined as the logical center of the window.)</source>
					<target>(Note that in Direct2D, the screen origin is defined as the upper-left corner, while in Direct3D the origin is defined as the logical center of the window.)</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](#defining_matrices_2d)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   For more info about the 2-D transformations used for rotation and how to define them, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Defining matrices for screen rotation (2-D)</pc>.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   For more info about the 2-D transformations used for rotation and how to define them, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Defining matrices for screen rotation (2-D)</pc>.</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#defining_matrices_3d)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about the 3-D transformations used for rotation, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Defining matrices for screen rotation (3-D)</pc>.</source>
					<target>For more info about the 3-D transformations used for rotation, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Defining matrices for screen rotation (3-D)</pc>.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Now, here's the important bit: call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::SetRotation</pc></pc> and provide it with your updated rotation matrix, like this:</source>
					<target>Now, here's the important bit: call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::SetRotation</pc></pc> and provide it with your updated rotation matrix, like this:</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>You also store the selected rotation matrix where your render method can get it when it computes the new projection.</source>
					<target>You also store the selected rotation matrix where your render method can get it when it computes the new projection.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>You'll use this matrix when you render your final 3-D projection or composite your final 2-D layout.</source>
					<target>You'll use this matrix when you render your final 3-D projection or composite your final 2-D layout.</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>(It doesn't automatically apply it for you.)</source>
					<target>(It doesn't automatically apply it for you.)</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>After that, create a new render target for the rotated 3-D view, as well as a new depth stencil buffer for the view.</source>
					<target>After that, create a new render target for the rotated 3-D view, as well as a new depth stencil buffer for the view.</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476480)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Set the 3-D rendering viewport for the rotated scene by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext:RSSetViewports</pc></pc>.</source>
					<target>Set the 3-D rendering viewport for the rotated scene by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext:RSSetViewports</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404482)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Lastly, if you have 2-D images to rotate or lay out, create a 2-D render target as a writable bitmap for the resized swap chain using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID2D1DeviceContext::CreateBitmapFromDxgiSurface</pc></pc> and composite your new layout for the updated orientation.</source>
					<target>Lastly, if you have 2-D images to rotate or lay out, create a 2-D render target as a writable bitmap for the resized swap chain using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID2D1DeviceContext::CreateBitmapFromDxgiSurface</pc></pc> and composite your new layout for the updated orientation.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>Set any properties you need to on the render target, such as the anti-aliasing mode (as seen in the code example).</source>
					<target>Set any properties you need to on the render target, such as the anti-aliasing mode (as seen in the code example).</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Now, present the swap chain.</source>
					<target>Now, present the swap chain.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>Reduce the rotation delay by using CoreWindowResizeManager</source>
					<target>Reduce the rotation delay by using CoreWindowResizeManager</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>By default, Windows 10 provides a short but noticeable window of time for any app, regardless of app model or language, to complete the rotation of the image.</source>
					<target>By default, Windows 10 provides a short but noticeable window of time for any app, regardless of app model or language, to complete the rotation of the image.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>However, chances are that when your app performs the rotation calculation using one of the techniques described here, it will be done well before this window of time has closed.</source>
					<target>However, chances are that when your app performs the rotation calculation using one of the techniques described here, it will be done well before this window of time has closed.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>You'd like to get that time back and complete the rotation animation, right?</source>
					<target>You'd like to get that time back and complete the rotation animation, right?</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/jj215603)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>That's where <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindowResizeManager</pc></pc> comes in.</source>
					<target>That's where <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindowResizeManager</pc></pc> comes in.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/jj215603)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/dn264268)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/hh404170)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
					<data id="id15">[</data>
					<data id="id16">](https://msdn.microsoft.com/library/windows/apps/jj215605)</data>
					<data id="id17">**</data>
					<data id="id18">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's how to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindowResizeManager</pc></pc>: when a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DisplayInformation::OrientationChanged</pc></pc> event is raised, call <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">CoreWindowResizeManager::GetForCurrentView</pc></pc> within the handler for the event to obtain an instance of <pc dataRefEnd="id14" dataRefStart="id13" id="p7">CoreWindowResizeManager</pc> and, when the layout for the new orientation is complete and presented, call the <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">NotifyLayoutCompleted</pc></pc> to let Windows know that it can complete the rotation animation and display the app screen.</source>
					<target>Here's how to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindowResizeManager</pc></pc>: when a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DisplayInformation::OrientationChanged</pc></pc> event is raised, call <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">CoreWindowResizeManager::GetForCurrentView</pc></pc> within the handler for the event to obtain an instance of <pc dataRefEnd="id14" dataRefStart="id13" id="p7">CoreWindowResizeManager</pc> and, when the layout for the new orientation is complete and presented, call the <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">NotifyLayoutCompleted</pc></pc> to let Windows know that it can complete the rotation animation and display the app screen.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn264268)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's what the code in your event handler for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation::OrientationChanged</pc></pc> might look like:</source>
					<target>Here's what the code in your event handler for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayInformation::OrientationChanged</pc></pc> might look like:</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>When a user rotates the orientation of the display, Windows 10 shows an animation independent of your app as feedback to the user.</source>
					<target>When a user rotates the orientation of the display, Windows 10 shows an animation independent of your app as feedback to the user.</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>There are three parts to that animation that happen in the following order:</source>
					<target>There are three parts to that animation that happen in the following order:</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>Windows 10 shrinks the original image.</source>
					<target>Windows 10 shrinks the original image.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Windows 10 holds the image for the time it takes to rebuild the new layout.</source>
					<target>Windows 10 holds the image for the time it takes to rebuild the new layout.</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>This is the window of time that you'd like to reduce, because your app probably doesn't need all of it.</source>
					<target>This is the window of time that you'd like to reduce, because your app probably doesn't need all of it.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>When the layout window expires, or when a notification of layout completion is received, Windows rotates the image and then cross-fade zooms to new orientation.</source>
					<target>When the layout window expires, or when a notification of layout completion is received, Windows rotates the image and then cross-fade zooms to new orientation.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/jj215605)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>As suggested in the third bullet, when an app calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NotifyLayoutCompleted</pc></pc>, Windows 10 stops the timeout window, completes the rotation animation and returns control to your app, which is now drawing in the new display orientation.</source>
					<target>As suggested in the third bullet, when an app calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NotifyLayoutCompleted</pc></pc>, Windows 10 stops the timeout window, completes the rotation animation and returns control to your app, which is now drawing in the new display orientation.</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>The overall effect is that your app now feels a little bit more fluid and responsive, and works a little more efficiently!</source>
					<target>The overall effect is that your app now feels a little bit more fluid and responsive, and works a little more efficiently!</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>Appendix A: Applying matrices for screen rotation (2-D)</source>
					<target>Appendix A: Applying matrices for screen rotation (2-D)</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#rotation)</data>
					<data id="id3">[</data>
					<data id="id4">](http://go.microsoft.com/fwlink/p/?linkid=257600)</data>
				</originalData>
				<segment state="initial">
					<source>In the sample in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optimizing the rotation process</pc> (and in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI swap chain rotation sample</pc>), you might have noticed that we had separate rotation matrices for Direct2D output and Direct3D output.</source>
					<target>In the sample in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optimizing the rotation process</pc> (and in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI swap chain rotation sample</pc>), you might have noticed that we had separate rotation matrices for Direct2D output and Direct3D output.</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>Let's look at the 2-D matrices, first.</source>
					<target>Let's look at the 2-D matrices, first.</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>There are two reasons that we can't apply the same rotation matrices to Direct2D and Direct3D content:</source>
					<target>There are two reasons that we can't apply the same rotation matrices to Direct2D and Direct3D content:</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>One, they use different Cartesian coordinate models.</source>
					<target>One, they use different Cartesian coordinate models.</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>Direct2D uses the right-handed rule, where the y-coordinate increases in positive value moving upward from the origin.</source>
					<target>Direct2D uses the right-handed rule, where the y-coordinate increases in positive value moving upward from the origin.</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>However, Direct3D uses the left-handed rule, where the y-coordinate increases in positive value rightward from the origin.</source>
					<target>However, Direct3D uses the left-handed rule, where the y-coordinate increases in positive value rightward from the origin.</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>The result is the origin for the screen coordinates is located in the upper-left for Direct2D, while the origin for the screen (the projection plane) is in the lower-left for Direct3D.</source>
					<target>The result is the origin for the screen coordinates is located in the upper-left for Direct2D, while the origin for the screen (the projection plane) is in the lower-left for Direct3D.</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/bb324490.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>(See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">3-D coordinate systems</pc> for more info.)</source>
					<target>(See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">3-D coordinate systems</pc> for more info.)</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>direct3d coordinate system.</source>
					<target>direct3d coordinate system.</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>direct2d coordinate system.</source>
					<target>direct2d coordinate system.</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>Two, the 3-D rotation matrices must be specified explicitly to avoid rounding errors.</source>
					<target>Two, the 3-D rotation matrices must be specified explicitly to avoid rounding errors.</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>The swap chain assumes that the origin is located in the lower-left, so you must perform a rotation to align the right-handed Direct2D coordinate system with the left-handed one used by the swap chain.</source>
					<target>The swap chain assumes that the origin is located in the lower-left, so you must perform a rotation to align the right-handed Direct2D coordinate system with the left-handed one used by the swap chain.</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208225)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Specifically, you reposition the image under the new left-handed orientation by multiplying the rotation matrix with a translation matrix for the rotated coordinate system origin, and transform the image from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindow</pc></pc>'s coordinate space to the swap chain's coordinate space.</source>
					<target>Specifically, you reposition the image under the new left-handed orientation by multiplying the rotation matrix with a translation matrix for the rotated coordinate system origin, and transform the image from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindow</pc></pc>'s coordinate space to the swap chain's coordinate space.</target>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>Your app also must consistently apply this transform when the Direct2D render target is connected with the swap chain.</source>
					<target>Your app also must consistently apply this transform when the Direct2D render target is connected with the swap chain.</target>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>However, if your app is drawing to intermediate surfaces that are not associated directly with the swap chain, don't apply this coordinate space transformation.</source>
					<target>However, if your app is drawing to intermediate surfaces that are not associated directly with the swap chain, don't apply this coordinate space transformation.</target>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>Your code to select the correct matrix from the four possible rotations might look like this (be aware of the translation to the new coordinate system origin):</source>
					<target>Your code to select the correct matrix from the four possible rotations might look like this (be aware of the translation to the new coordinate system origin):</target>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/dd742857)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/dd371768)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/desktop/dd371924)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>After you have the correct rotation matrix and origin for the 2-D image, set it with a call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID2D1DeviceContext::SetTransform</pc></pc> between your calls to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID2D1DeviceContext::BeginDraw</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ID2D1DeviceContext::EndDraw</pc></pc>.</source>
					<target>After you have the correct rotation matrix and origin for the 2-D image, set it with a call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID2D1DeviceContext::SetTransform</pc></pc> between your calls to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID2D1DeviceContext::BeginDraw</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ID2D1DeviceContext::EndDraw</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Warning</pc>   Direct2D doesn't have a transformation stack.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Warning</pc>   Direct2D doesn't have a transformation stack.</target>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/dd742857)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If your app is also using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID2D1DeviceContext::SetTransform</pc></pc> as a part of its drawing code, this matrix needs to be post-multiplied to any other transform you have applied.</source>
					<target>If your app is also using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID2D1DeviceContext::SetTransform</pc></pc> as a part of its drawing code, this matrix needs to be post-multiplied to any other transform you have applied.</target>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>The next time you present the swap chain, your 2-D image will be rotated to match the new display orientation.</source>
					<target>The next time you present the swap chain, your 2-D image will be rotated to match the new display orientation.</target>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>Appendix B: Applying matrices for screen rotation (3-D)</source>
					<target>Appendix B: Applying matrices for screen rotation (3-D)</target>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#rotation)</data>
					<data id="id3">[</data>
					<data id="id4">](http://go.microsoft.com/fwlink/p/?linkid=257600)</data>
				</originalData>
				<segment state="initial">
					<source>In the sample in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optimizing the rotation process</pc> (and in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI swap chain rotation sample</pc>), we defined a specific transformation matrix for each possible screen orientation.</source>
					<target>In the sample in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optimizing the rotation process</pc> (and in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI swap chain rotation sample</pc>), we defined a specific transformation matrix for each possible screen orientation.</target>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>Now, let's look at the matrixes for rotating 3-D scenes.</source>
					<target>Now, let's look at the matrixes for rotating 3-D scenes.</target>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<segment state="initial">
					<source>As before, you create a set of matrices for each of the 4 possible orientations.</source>
					<target>As before, you create a set of matrices for each of the 4 possible orientations.</target>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>To prevent rounding errors and thus minor visual artifacts, declare the matrices explicitly in your code.</source>
					<target>To prevent rounding errors and thus minor visual artifacts, declare the matrices explicitly in your code.</target>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>You set up these 3-D rotation matrices as follows.</source>
					<target>You set up these 3-D rotation matrices as follows.</target>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>The matrices shown in the following code example are standard rotation matrices for 0, 90, 180, and 270 degree rotations of the vertices that define points in the camera's 3-D scene space.</source>
					<target>The matrices shown in the following code example are standard rotation matrices for 0, 90, 180, and 270 degree rotations of the vertices that define points in the camera's 3-D scene space.</target>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>Each vertex's \[x, y, z\] coordinate value in the scene is multiplied by this rotation matrix when the 2-D projection of the scene is computed.</source>
					<target>Each vertex's \[x, y, z\] coordinate value in the scene is multiplied by this rotation matrix when the 2-D projection of the scene is computed.</target>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You set the rotation type on the swap chain with a call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::SetRotation</pc></pc>, like this:</source>
					<target>You set the rotation type on the swap chain with a call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::SetRotation</pc></pc>, like this:</target>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<segment state="initial">
					<source>Now, in your render method, implement some code similar to this:</source>
					<target>Now, in your render method, implement some code similar to this:</target>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Now, when you call your render method, it multiplies the current rotation matrix (as specified by the class variable <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_orientationTransform3D</pc>) with the current projection matrix, and assigns the results of that operation as the new projection matrix for your renderer.</source>
					<target>Now, when you call your render method, it multiplies the current rotation matrix (as specified by the class variable <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_orientationTransform3D</pc>) with the current projection matrix, and assigns the results of that operation as the new projection matrix for your renderer.</target>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>Present the swap chain to see the scene in the updated display orientation.</source>
					<target>Present the swap chain to see the scene in the updated display orientation.</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>