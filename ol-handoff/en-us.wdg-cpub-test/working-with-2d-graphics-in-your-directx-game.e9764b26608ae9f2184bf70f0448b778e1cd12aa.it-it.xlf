<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="it-it" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">b5952c04f4baba3167f6f48e951b44e9bacbf217</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\working-with-2d-graphics-in-your-directx-game.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">3d8f49827477f39c5af07ea3cfaa5c53b93d6ff0</mda:meta><mda:meta type="olxliffhash">d963448f9b23940b1b0555259cfa3b3ff31158c6</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>2D graphics for DirectX games</source>
					<target>2D graphics for DirectX games</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>We discuss the use of 2D bitmap graphics and effects, and how to use them in your game.</source>
					<target>We discuss the use of 2D bitmap graphics and effects, and how to use them in your game.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>2D graphics for DirectX games</source>
					<target>2D graphics for DirectX games</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>We discuss the use of 2D bitmap graphics and effects, and how to use them in your game.</source>
					<target>We discuss the use of 2D bitmap graphics and effects, and how to use them in your game.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>2D graphics are a subset of 3D graphics that deal with 2D primitives or bitmaps.</source>
					<target>2D graphics are a subset of 3D graphics that deal with 2D primitives or bitmaps.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>More generally, they don't use a z-coordinate in the way a 3D game might, since the game play is usually confined to the x-y plane.</source>
					<target>More generally, they don't use a z-coordinate in the way a 3D game might, since the game play is usually confined to the x-y plane.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>They sometimes use 3D graphics techniques to create their visual components, and they are generally simpler to develop.</source>
					<target>They sometimes use 3D graphics techniques to create their visual components, and they are generally simpler to develop.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>If you are new to gaming, a 2D game is a great place to start, and 2D graphics development can be a good place for you to get a handle on DirectX.</source>
					<target>If you are new to gaming, a 2D game is a great place to start, and 2D graphics development can be a good place for you to get a handle on DirectX.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>You can develop 2D gaming graphics in DirectX using either Direct2D or Direct3D, or some combination.</source>
					<target>You can develop 2D gaming graphics in DirectX using either Direct2D or Direct3D, or some combination.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb205601)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Many of the more useful classes for 2D game development are in Direct3D, such as the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Sprite</pc></pc> class.</source>
					<target>Many of the more useful classes for 2D game development are in Direct3D, such as the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Sprite</pc></pc> class.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Direct2D is a set of APIs that primarily target user interfaces and apps that require support for drawing primitives (such as circles, lines, and flat polygon shapes).</source>
					<target>Direct2D is a set of APIs that primarily target user interfaces and apps that require support for drawing primitives (such as circles, lines, and flat polygon shapes).</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>With that in mind, it still provides a powerful and performant set of classes and methods for creating game graphics as well, especially when creating game overlays, interfaces, and heads-up displays (HUDs) -- or for creating a variety of 2D games, from simple to reasonably detailed.</source>
					<target>With that in mind, it still provides a powerful and performant set of classes and methods for creating game graphics as well, especially when creating game overlays, interfaces, and heads-up displays (HUDs) -- or for creating a variety of 2D games, from simple to reasonably detailed.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>The most effective approach when creating 2D games, though, is to use elements from both libraries, and that's the way we will approach 2D graphics development in this topic.</source>
					<target>The most effective approach when creating 2D games, though, is to use elements from both libraries, and that's the way we will approach 2D graphics development in this topic.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Concepts at a glance</source>
					<target>Concepts at a glance</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Before the advent of modern 3D graphics and the hardware that supports it, games were primarily 2D, and many of their graphics techniques involved moving blocks of memory around -- usually arrays of color data that would be translated or transformed to pixels on the screen in a 1:1 fashion.</source>
					<target>Before the advent of modern 3D graphics and the hardware that supports it, games were primarily 2D, and many of their graphics techniques involved moving blocks of memory around -- usually arrays of color data that would be translated or transformed to pixels on the screen in a 1:1 fashion.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>In DirectX, 2D graphics are part of the 3D pipeline.</source>
					<target>In DirectX, 2D graphics are part of the 3D pipeline.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>There is a much greater variety of screen resolutions and graphics hardware available, and your 2D graphics engine must be able to support them without a significant change in fidelity.</source>
					<target>There is a much greater variety of screen resolutions and graphics hardware available, and your 2D graphics engine must be able to support them without a significant change in fidelity.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Here are a few of the basic concepts you should be familiar with when starting 2D graphics development.</source>
					<target>Here are a few of the basic concepts you should be familiar with when starting 2D graphics development.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>Pixels and raster coordinates.</source>
					<target>Pixels and raster coordinates.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>A pixel is a single point on a raster display, and has its own (x, y) coordinate pair indicating its location on the display.</source>
					<target>A pixel is a single point on a raster display, and has its own (x, y) coordinate pair indicating its location on the display.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>(The term "pixel" is often used interchangeably between the physical pixels that comprise the display and the addressable memory elements used to hold the color and alpha values of the pixels before they are sent to the display.) The raster is treated by APIs as a rectangular grid of pixel elements, which often has a 1:1 correspondence with the physical pixel grid of a display.</source>
					<target>(The term "pixel" is often used interchangeably between the physical pixels that comprise the display and the addressable memory elements used to hold the color and alpha values of the pixels before they are sent to the display.) The raster is treated by APIs as a rectangular grid of pixel elements, which often has a 1:1 correspondence with the physical pixel grid of a display.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Raster coordinate systems start from the upper left, with the pixel at (0, 0) in the upper leftmost corner of the grid.</source>
					<target>Raster coordinate systems start from the upper left, with the pixel at (0, 0) in the upper leftmost corner of the grid.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Bitmap graphics (sometimes called raster graphics) are graphic elements represented as a rectangular grid of pixel values.</source>
					<target>Bitmap graphics (sometimes called raster graphics) are graphic elements represented as a rectangular grid of pixel values.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Sprites -- computed pixel arrays managed independent of the raster -- are one type of bitmap graphic, commonly used for the active characters or background-independent animated objects in a game.</source>
					<target>Sprites -- computed pixel arrays managed independent of the raster -- are one type of bitmap graphic, commonly used for the active characters or background-independent animated objects in a game.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>The various frames of animation for a sprite are represented as collections of bitmaps called "sheets" or "batches."</source>
					<target>The various frames of animation for a sprite are represented as collections of bitmaps called "sheets" or "batches."</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>Backgrounds are larger bitmap objects that are the same resolution or greater than that of the screen raster, and often serve as the backdrop(s) for a game's playfield.</source>
					<target>Backgrounds are larger bitmap objects that are the same resolution or greater than that of the screen raster, and often serve as the backdrop(s) for a game's playfield.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>Vector graphics are graphics that use geometric primitives, such as points, lines, circles, and polygons to define 2D objects.</source>
					<target>Vector graphics are graphics that use geometric primitives, such as points, lines, circles, and polygons to define 2D objects.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>They are represented not as arrays of pixels, but as the mathematical equations that define them in a 2D space.</source>
					<target>They are represented not as arrays of pixels, but as the mathematical equations that define them in a 2D space.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>They do not necessarily have a 1:1 correspondence with the pixel grid of the display, and must be transformed from the coordinate system that you rendered them in into the raster coordinate system of the display.</source>
					<target>They do not necessarily have a 1:1 correspondence with the pixel grid of the display, and must be transformed from the coordinate system that you rendered them in into the raster coordinate system of the display.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Translation is when you take a point or vertex and calculate its new location in the same coordinate system.</source>
					<target>Translation is when you take a point or vertex and calculate its new location in the same coordinate system.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Scaling is when you enlarge or shrink an object by a specified scale factor.</source>
					<target>Scaling is when you enlarge or shrink an object by a specified scale factor.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>With a vector image, you shrink and enlarge its component vertices; with a bitmap, you enlarge the pixel elements or diminish them.</source>
					<target>With a vector image, you shrink and enlarge its component vertices; with a bitmap, you enlarge the pixel elements or diminish them.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>With bitmap images, you lose pixel data when the image shrinks, and you enlarge the individual pixels when the image is scaled closer.</source>
					<target>With bitmap images, you lose pixel data when the image shrinks, and you enlarge the individual pixels when the image is scaled closer.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>For the latter, you can use pixel color interpolation operations, like bilinear filtering, to smooth out the harsh color boundaries between the enlarged pixels.</source>
					<target>For the latter, you can use pixel color interpolation operations, like bilinear filtering, to smooth out the harsh color boundaries between the enlarged pixels.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Rotation is when you rotate an object about a specified axis or axes.</source>
					<target>Rotation is when you rotate an object about a specified axis or axes.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>With a vector image, the vertices of the geometry are multiplied against a rotation matrix to obtain the rotated vertex; with a bitmap image, different algorithms can be employed, each with a lesser or greater degree of fidelity in the results.</source>
					<target>With a vector image, the vertices of the geometry are multiplied against a rotation matrix to obtain the rotated vertex; with a bitmap image, different algorithms can be employed, each with a lesser or greater degree of fidelity in the results.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>As with scaling and translation, there are APIs specifically for rotation operations.</source>
					<target>As with scaling and translation, there are APIs specifically for rotation operations.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Transformation is when you take one point or vertex in one coordinate system and calculate its corresponding point or vertex in another coordinate system.</source>
					<target>Transformation is when you take one point or vertex in one coordinate system and calculate its corresponding point or vertex in another coordinate system.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>This includes translation, scaling, and rotation, as well as other coordinate calculation operations.</source>
					<target>This includes translation, scaling, and rotation, as well as other coordinate calculation operations.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>Clipping is when you remove portions of bitmaps or geometry that are not within the viewable area of the display, or are hidden by objects with higher view priority.</source>
					<target>Clipping is when you remove portions of bitmaps or geometry that are not within the viewable area of the display, or are hidden by objects with higher view priority.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>The frame buffer is an area in memory -- often in the memory of the graphics hardware itself -- that contains the final raster map that you will draw to the screen.</source>
					<target>The frame buffer is an area in memory -- often in the memory of the graphics hardware itself -- that contains the final raster map that you will draw to the screen.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>The swap chain is a collection of buffers, where you draw in a back buffer and, when the image is ready, you "swap" it to the front and display it.</source>
					<target>The swap chain is a collection of buffers, where you draw in a back buffer and, when the image is ready, you "swap" it to the front and display it.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>Design considerations</source>
					<target>Design considerations</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>2D graphics development is a great way to get accustomed to developing with Direct3D, and will allow you to spend more time on other critical aspects of game development: audio, controls, and the game mechanics.</source>
					<target>2D graphics development is a great way to get accustomed to developing with Direct3D, and will allow you to spend more time on other critical aspects of game development: audio, controls, and the game mechanics.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Always draw to a back buffer.</source>
					<target>Always draw to a back buffer.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Drawing directly to your frame buffer means that your image will be displayed when the signal for display is received (usually every 1/60th of second), even if your drawing operation hasn't completed!</source>
					<target>Drawing directly to your frame buffer means that your image will be displayed when the signal for display is received (usually every 1/60th of second), even if your drawing operation hasn't completed!</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>Design your graphics engine to support a good selection of resolutions, from 1024x600 to 1920x1080 (or higher).</source>
					<target>Design your graphics engine to support a good selection of resolutions, from 1024x600 to 1920x1080 (or higher).</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>Your audience will thank you if you support their LCD monitor's native resolution, especially with 2D graphics.</source>
					<target>Your audience will thank you if you support their LCD monitor's native resolution, especially with 2D graphics.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Great artwork will be your greatest asset, when it comes to visuals.</source>
					<target>Great artwork will be your greatest asset, when it comes to visuals.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>While your bitmap graphics may lack the punch of 3D photorealistic visuals using the latest shader model features, great high-resolution artwork can often convey as much or more style and personality -- and with far less of a performance penalty.</source>
					<target>While your bitmap graphics may lack the punch of 3D photorealistic visuals using the latest shader model features, great high-resolution artwork can often convey as much or more style and personality -- and with far less of a performance penalty.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>Reference</source>
					<target>Reference</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Direct2D overview</source>
					<target>Direct2D overview</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Direct2D quickstart</source>
					<target>Direct2D quickstart</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Direct2D and Direct3D interoperability overview</source>
					<target>Direct2D and Direct3D interoperability overview</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>Note</source>
					<target>Note</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</source>
					<target>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>If you’re developing for Windows 8.x or Windows Phone 8.x, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archived documentation</pc>.</source>
					<target>If you’re developing for Windows 8.x or Windows Phone 8.x, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archived documentation</pc>.</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>