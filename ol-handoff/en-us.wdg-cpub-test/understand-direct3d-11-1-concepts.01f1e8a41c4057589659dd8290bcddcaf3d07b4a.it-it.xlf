<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="it-it" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">a9d5c48ab71549b5e6ee20ac8787378fe978143a</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\understand-direct3d-11-1-concepts.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">82180ad8d359461b859301c10bb5c911067b5e12</mda:meta><mda:meta type="olxliffhash">09212f5c30045d35a5d806c1e4044277d6cf80b0</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Important changes from Direct3D 9 to Direct3D 11</source>
					<target>Important changes from Direct3D 9 to Direct3D 11</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>This topic explains the high-level differences between DirectX 9 and DirectX 11.</source>
					<target>This topic explains the high-level differences between DirectX 9 and DirectX 11.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Important changes from Direct3D 9 to Direct3D 11</source>
					<target>Important changes from Direct3D 9 to Direct3D 11</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Summary</source>
					<target>Summary</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Plan your DirectX port</source>
					<target>Plan your DirectX port</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>Important changes from Direct3D 9 to Direct3D 11</source>
					<target>Important changes from Direct3D 9 to Direct3D 11</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Feature mapping</source>
					<target>Feature mapping</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>This topic explains the high-level differences between DirectX 9 and DirectX 11.</source>
					<target>This topic explains the high-level differences between DirectX 9 and DirectX 11.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>Direct3D 11 is fundamentally the same type of API as Direct3D 9 - a low-level, virtualized interface into graphics hardware.</source>
					<target>Direct3D 11 is fundamentally the same type of API as Direct3D 9 - a low-level, virtualized interface into graphics hardware.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>It still allows you to perform graphics drawing operations on a variety of hardware implementations.</source>
					<target>It still allows you to perform graphics drawing operations on a variety of hardware implementations.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>The layout of the graphics API has changed since Direct3D 9; the concept of a device context has been expanded, and an API has been added specifically for graphics infrastructure.</source>
					<target>The layout of the graphics API has changed since Direct3D 9; the concept of a device context has been expanded, and an API has been added specifically for graphics infrastructure.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Resources stored on the Direct3D device have a novel mechanism for data polymorphism called a resource view.</source>
					<target>Resources stored on the Direct3D device have a novel mechanism for data polymorphism called a resource view.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>Core API functions</source>
					<target>Core API functions</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>In Direct3D 9 you had to create an interface to the Direct3D API before you could start using it.</source>
					<target>In Direct3D 9 you had to create an interface to the Direct3D API before you could start using it.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In your Direct3D 11 Universal Windows Platform (UWP) game, you call a static function called <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11CreateDevice</pc></pc> to create the device and the device context.</source>
					<target>In your Direct3D 11 Universal Windows Platform (UWP) game, you call a static function called <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11CreateDevice</pc></pc> to create the device and the device context.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Devices and device context</source>
					<target>Devices and device context</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>A Direct3D 11 device represents a virtualized graphics adapter.</source>
					<target>A Direct3D 11 device represents a virtualized graphics adapter.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>It's used to create resources in video memory, for example: uploading textures to the GPU, creating views on texture resources and swap chains, and creating texture samplers.</source>
					<target>It's used to create resources in video memory, for example: uploading textures to the GPU, creating views on texture resources and swap chains, and creating texture samplers.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For a complete list of what a Direct3D 11 device interface is used for see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11Device1</pc></pc>.</source>
					<target>For a complete list of what a Direct3D 11 device interface is used for see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11Device1</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>A Direct3D 11.</source>
					<target>A Direct3D 11.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>device context is used to set pipeline state and generate rendering commands.</source>
					<target>device context is used to set pipeline state and generate rendering commands.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>For example, a Direct3D 11 rendering chain uses a device context to set up the rendering chain and draw the scene (see below).</source>
					<target>For example, a Direct3D 11 rendering chain uses a device context to set up the rendering chain and draw the scene (see below).</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>The device context is used to access (map) video memory used by Direct3D device resources; it's also used to update subresource data, for example constant buffer data.</source>
					<target>The device context is used to access (map) video memory used by Direct3D device resources; it's also used to update subresource data, for example constant buffer data.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For a complete list of what a Direct3D 11 device context is used for see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceContext1</pc></pc>.</source>
					<target>For a complete list of what a Direct3D 11 device context is used for see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceContext1</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>Note that most of our samples use an immediate context to render directly to the device, but Direct3D 11 also supports deferred device contexts, which are primarily used for multithreading.</source>
					<target>Note that most of our samples use an immediate context to render directly to the device, but Direct3D 11 also supports deferred device contexts, which are primarily used for multithreading.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In Direct3D 11, the device handle and device context handle are both obtained by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11CreateDevice</pc></pc>.</source>
					<target>In Direct3D 11, the device handle and device context handle are both obtained by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11CreateDevice</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>This method is also where you request a specific set of hardware features and retrieve information on Direct3D feature levels supported by the graphics adapter.</source>
					<target>This method is also where you request a specific set of hardware features and retrieve information on Direct3D feature levels supported by the graphics adapter.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476880)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Introduction to a Device in Direct3D 11</pc> for more info on devices, device contexts, and threading considerations.</source>
					<target>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Introduction to a Device in Direct3D 11</pc> for more info on devices, device contexts, and threading considerations.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Device infrastructure, frame buffers, and render target views</source>
					<target>Device infrastructure, frame buffers, and render target views</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb174523)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/hh404543)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>In Direct3D 11, the device adapter and hardware configuration are set with the DirectX Graphics Infrastructure (DXGI) API using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGIAdapter</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IDXGIDevice1</pc></pc> COM interfaces.</source>
					<target>In Direct3D 11, the device adapter and hardware configuration are set with the DirectX Graphics Infrastructure (DXGI) API using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGIAdapter</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IDXGIDevice1</pc></pc> COM interfaces.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404556)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Buffers and other window resources (visible or offscreen) are created and configured by specific DXGI interfaces; the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGIFactory2</pc></pc> factory pattern implementation acquires DXGI resources such as the frame buffer.</source>
					<target>Buffers and other window resources (visible or offscreen) are created and configured by specific DXGI interfaces; the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGIFactory2</pc></pc> factory pattern implementation acquires DXGI resources such as the frame buffer.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404631)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Since DXGI owns the swap chain, a DXGI interface is used to present frames to the screen - see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1</pc></pc>.</source>
					<target>Since DXGI owns the swap chain, a DXGI interface is used to present frames to the screen - see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404556)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGIFactory2</pc></pc> to create a swap chain compatible with your game.</source>
					<target>Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGIFactory2</pc></pc> to create a swap chain compatible with your game.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>You need to create a swap chain for a core window, or for composition (XAML interop), instead of creating a swap chain for an HWND.</source>
					<target>You need to create a swap chain for a core window, or for composition (XAML interop), instead of creating a swap chain for an HWND.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Device resources and resource views</source>
					<target>Device resources and resource views</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Direct3D 11 supports an additional level of polymorphism on video memory resources known as views.</source>
					<target>Direct3D 11 supports an additional level of polymorphism on video memory resources known as views.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>Essentially, where you had a single Direct3D 9 object for a texture, you now have two objects: the texture resource, which holds the data, and the resource view, which indicates how the view is used for rendering.</source>
					<target>Essentially, where you had a single Direct3D 9 object for a texture, you now have two objects: the texture resource, which holds the data, and the resource view, which indicates how the view is used for rendering.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>A view based on a resource enables that resource to be used for a specific purpose.</source>
					<target>A view based on a resource enables that resource to be used for a specific purpose.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476628)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, a 2D texture resource is created as an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Texture2D</pc></pc>, then a shader resource view (<pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11ShaderResourceView</pc></pc>) is created on it so it can be used as a texture in a shader.</source>
					<target>For example, a 2D texture resource is created as an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Texture2D</pc></pc>, then a shader resource view (<pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11ShaderResourceView</pc></pc>) is created on it so it can be used as a texture in a shader.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A render target view (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11RenderTargetView</pc></pc>) can also be created on the same 2D texture resource so that it can be used as a drawing surface.</source>
					<target>A render target view (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11RenderTargetView</pc></pc>) can also be created on the same 2D texture resource so that it can be used as a drawing surface.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>In another example, the same pixel data is represented in 2 different pixel formats by using 2 separate views on a single texture resource.</source>
					<target>In another example, the same pixel data is represented in 2 different pixel formats by using 2 separate views on a single texture resource.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>The underlying resource must be created with properties that are compatible with the type of views that will be created from it.</source>
					<target>The underlying resource must be created with properties that are compatible with the type of views that will be created from it.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476085)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, if an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11RenderTargetView</pc></pc> is applied to a surface, that surface is created with the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">D3D11\_BIND\_RENDER\_TARGET</pc></pc> flag.</source>
					<target>For example, if an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11RenderTargetView</pc></pc> is applied to a surface, that surface is created with the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">D3D11\_BIND\_RENDER\_TARGET</pc></pc> flag.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb173059)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The surface also has to have a DXGI surface format compatible with rendering (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI\_FORMAT</pc></pc>).</source>
					<target>The surface also has to have a DXGI surface format compatible with rendering (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI\_FORMAT</pc></pc>).</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476584)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476380)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Most of the resources you use for rendering inherit from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Resource</pc></pc> interface, which inherits from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceChild</pc></pc>.</source>
					<target>Most of the resources you use for rendering inherit from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Resource</pc></pc> interface, which inherits from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceChild</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Vertex buffers, index buffers, constant buffers, and shaders are all Direct3D 11 resources.</source>
					<target>Vertex buffers, index buffers, constant buffers, and shaders are all Direct3D 11 resources.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476380)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Input layouts and sampler states inherit directly from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceChild</pc></pc>.</source>
					<target>Input layouts and sampler states inherit directly from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceChild</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>Resources views use a DXGI\_FORMAT enum value to indicate the pixel format.</source>
					<target>Resources views use a DXGI\_FORMAT enum value to indicate the pixel format.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Not every D3DFMT is supported as a DXGI\_FORMAT.</source>
					<target>Not every D3DFMT is supported as a DXGI\_FORMAT.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>For example, there is no 24bpp RGB format in DXGI that is equivalent to D3DFMT\_R8G8B8.</source>
					<target>For example, there is no 24bpp RGB format in DXGI that is equivalent to D3DFMT\_R8G8B8.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>There are also not BGR equivalents to every RGB format (DXGI\_FORMAT\_R10G10B10A2\_UNORM is equivalent to D3DFMT\_A2B10G10R10, but there’s no direct equivalent to D3DFMT\_A2R10G10B10).</source>
					<target>There are also not BGR equivalents to every RGB format (DXGI\_FORMAT\_R10G10B10A2\_UNORM is equivalent to D3DFMT\_A2B10G10R10, but there’s no direct equivalent to D3DFMT\_A2R10G10B10).</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>You should plan to convert any content in these legacy formats to supported formats at build-time.</source>
					<target>You should plan to convert any content in these legacy formats to supported formats at build-time.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb173059)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For a complete list of DXGI formats see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI\_FORMAT</pc></pc> enumeration.</source>
					<target>For a complete list of DXGI formats see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI\_FORMAT</pc></pc> enumeration.</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Direct3D device resources (and resource views) are created before the scene is rendered.</source>
					<target>Direct3D device resources (and resource views) are created before the scene is rendered.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>Device contexts are used to set up the rendering chain, as explained below.</source>
					<target>Device contexts are used to set up the rendering chain, as explained below.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>Device context and the rendering chain</source>
					<target>Device context and the rendering chain</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>In Direct3D 9 and Direct3D 10.x, there was a single Direct3D device object which managed resource creation, state, and drawing.</source>
					<target>In Direct3D 9 and Direct3D 10.x, there was a single Direct3D device object which managed resource creation, state, and drawing.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>In Direct3D 11, the Direct3D device interface still manages resource creation, but all state and drawing operations are handled by using a Direct3D device context.</source>
					<target>In Direct3D 11, the Direct3D device interface still manages resource creation, but all state and drawing operations are handled by using a Direct3D device context.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's an example of how the device context (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1</pc></pc> interface) is used to set up the rendering chain:</source>
					<target>Here's an example of how the device context (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1</pc></pc> interface) is used to set up the rendering chain:</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>Set and clear render target views (and depth stencil view)</source>
					<target>Set and clear render target views (and depth stencil view)</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>Set the vertex buffer, index buffer, and input layout for the input assembler stage (IA stage)</source>
					<target>Set the vertex buffer, index buffer, and input layout for the input assembler stage (IA stage)</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>Bind vertex and pixel shaders to the pipeline</source>
					<target>Bind vertex and pixel shaders to the pipeline</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>Bind constant buffers to shaders</source>
					<target>Bind constant buffers to shaders</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>Bind texture views and samplers to the pixel shader</source>
					<target>Bind texture views and samplers to the pixel shader</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Draw the scene</source>
					<target>Draw the scene</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476407)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When one of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext::Draw</pc></pc> methods is called, the scene is drawn on the render target view.</source>
					<target>When one of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext::Draw</pc></pc> methods is called, the scene is drawn on the render target view.</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When you're done will all your drawing the DXGI adapter is used to present the completed frame by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::Present1</pc></pc>.</source>
					<target>When you're done will all your drawing the DXGI adapter is used to present the completed frame by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::Present1</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>State management</source>
					<target>State management</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>Direct3D 9 managed state settings with a large set of individual toggles set with the SetRenderState, SetSamplerState, and SetTextureStageState methods.</source>
					<target>Direct3D 9 managed state settings with a large set of individual toggles set with the SetRenderState, SetSamplerState, and SetTextureStageState methods.</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>Since Direct3D 11 does not support the legacy fixed-function pipeline, the SetTextureStageState is replaced by writing pixel shaders (PS).</source>
					<target>Since Direct3D 11 does not support the legacy fixed-function pipeline, the SetTextureStageState is replaced by writing pixel shaders (PS).</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>There is no equivalent to a Direct3D 9 state block.</source>
					<target>There is no equivalent to a Direct3D 9 state block.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>Direct3D 11 instead manages state through the use of 4 kinds of state objects which provide a more streamlined way to group the rendering state.</source>
					<target>Direct3D 11 instead manages state through the use of 4 kinds of state objects which provide a more streamlined way to group the rendering state.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>For example, instead of using SetRenderState with D3DRS\_ZENABLE, you create a DepthStencilState object with this and other related state settings and use it to change state while rendering.</source>
					<target>For example, instead of using SetRenderState with D3DRS\_ZENABLE, you create a DepthStencilState object with this and other related state settings and use it to change state while rendering.</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>When porting Direct3D 9 applications to state objects, be aware that your various state combinations are represented as immutable state objects.</source>
					<target>When porting Direct3D 9 applications to state objects, be aware that your various state combinations are represented as immutable state objects.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>They should be created once and re-used as long as they are valid.</source>
					<target>They should be created once and re-used as long as they are valid.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>Direct3D feature levels</source>
					<target>Direct3D feature levels</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>Direct3D has a new mechanism for determining hardware support called feature levels.</source>
					<target>Direct3D has a new mechanism for determining hardware support called feature levels.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>Feature levels simplify the task of figuring out what the graphics adapter can do by allowing you to request a well-defined set of GPU functionality.</source>
					<target>Feature levels simplify the task of figuring out what the graphics adapter can do by allowing you to request a well-defined set of GPU functionality.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>For example, the 9\_1 feature level implements the functionality provided by Direct3D 9 graphics adapters, including shader model 2.x.</source>
					<target>For example, the 9\_1 feature level implements the functionality provided by Direct3D 9 graphics adapters, including shader model 2.x.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>Since 9\_1 is the lowest feature level, you can expect all devices to support a vertex shader and a pixel shader, which were the same stages supported by the Direct3D 9 programmable shader model.</source>
					<target>Since 9\_1 is the lowest feature level, you can expect all devices to support a vertex shader and a pixel shader, which were the same stages supported by the Direct3D 9 programmable shader model.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Your game will use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11CreateDevice</pc></pc> to create the Direct3D device and device context.</source>
					<target>Your game will use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11CreateDevice</pc></pc> to create the Direct3D device and device context.</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>When you call this function you provide a list of feature levels that your game can support.</source>
					<target>When you call this function you provide a list of feature levels that your game can support.</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>It will return the highest supported feature level from that list.</source>
					<target>It will return the highest supported feature level from that list.</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>For example if your game can use BC4/BC5 textures (a feature of DirectX 10 hardware), you would include at least 9\_1 and 10\_0 in the list of supported feature levels.</source>
					<target>For example if your game can use BC4/BC5 textures (a feature of DirectX 10 hardware), you would include at least 9\_1 and 10\_0 in the list of supported feature levels.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If the game is running on DirectX 9 hardware and BC4/BC5 textures can't be used, then <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11CreateDevice</pc></pc> will return 9\_1.</source>
					<target>If the game is running on DirectX 9 hardware and BC4/BC5 textures can't be used, then <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11CreateDevice</pc></pc> will return 9\_1.</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Then your game can fall back to a different texture format (and smaller textures).</source>
					<target>Then your game can fall back to a different texture format (and smaller textures).</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>If you decide to extend your Direct3D 9 game to support higher Direct3D feature levels then it's better to finish porting your existing Direct3D 9 graphics code first.</source>
					<target>If you decide to extend your Direct3D 9 game to support higher Direct3D feature levels then it's better to finish porting your existing Direct3D 9 graphics code first.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>After you have your game working in Direct3D 11, it's easier to add additional rendering paths with enhanced graphics.</source>
					<target>After you have your game working in Direct3D 11, it's easier to add additional rendering paths with enhanced graphics.</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476876)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Direct3D feature levels</pc> for a detailed explanation of feature level support.</source>
					<target>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Direct3D feature levels</pc> for a detailed explanation of feature level support.</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476342)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/hh404562)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Direct3D 11 Features</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Direct3D 11.1 Features</pc> for a full list of Direct3D 11 features.</source>
					<target>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Direct3D 11 Features</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Direct3D 11.1 Features</pc> for a full list of Direct3D 11 features.</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>Feature levels and the programmable pipeline</source>
					<target>Feature levels and the programmable pipeline</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>Hardware has continue to evolve since Direct3D 9, and several new optional stages have been added to the programmable graphics pipeline.</source>
					<target>Hardware has continue to evolve since Direct3D 9, and several new optional stages have been added to the programmable graphics pipeline.</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>The set of options you have for the graphics pipeline varies with the Direct3D feature level.</source>
					<target>The set of options you have for the graphics pipeline varies with the Direct3D feature level.</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>Feature level 10.0 includes the geometry shader stage with optional stream out for multipass rendering on the GPU.</source>
					<target>Feature level 10.0 includes the geometry shader stage with optional stream out for multipass rendering on the GPU.</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>Feature level 11\_0 include the hull shader and domain shader for use with hardware tessellation.</source>
					<target>Feature level 11\_0 include the hull shader and domain shader for use with hardware tessellation.</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>Feature level 11\_0 also includes full support for DirectCompute shaders, while feature levels 10.x only include support for a limited form of DirectCompute.</source>
					<target>Feature level 11\_0 also includes full support for DirectCompute shaders, while feature levels 10.x only include support for a limited form of DirectCompute.</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>All shaders are written in HLSL using a shader profile that corresponds to a Direct3D feature level.</source>
					<target>All shaders are written in HLSL using a shader profile that corresponds to a Direct3D feature level.</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>Shader profiles are upwards compatible, so an HLSL shader that compiles using vs\_4\_0\_level\_9\_1 or ps\_4\_0\_level\_9\_1 will work across all devices.</source>
					<target>Shader profiles are upwards compatible, so an HLSL shader that compiles using vs\_4\_0\_level\_9\_1 or ps\_4\_0\_level\_9\_1 will work across all devices.</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>Shader profiles are not downlevel compatible, so a shader compiled using vs\_4\_1 will only work on feature level 10\_1, 11\_0, or 11\_1 devices.</source>
					<target>Shader profiles are not downlevel compatible, so a shader compiled using vs\_4\_1 will only work on feature level 10\_1, 11\_0, or 11\_1 devices.</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>Direct3D 9 managed constants for shaders using a shared array with SetVertexShaderConstant and SetPixelShaderConstant.</source>
					<target>Direct3D 9 managed constants for shaders using a shared array with SetVertexShaderConstant and SetPixelShaderConstant.</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>Direct3D 11 uses constant buffers, which are resources like a vertex buffer or index buffer.</source>
					<target>Direct3D 11 uses constant buffers, which are resources like a vertex buffer or index buffer.</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>Constant buffers are designed to be updated efficiently.</source>
					<target>Constant buffers are designed to be updated efficiently.</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>Instead of having all the shader contants organized into a single global array you organize your constants into logical groupings and manage them through one or more constant buffers.</source>
					<target>Instead of having all the shader contants organized into a single global array you organize your constants into logical groupings and manage them through one or more constant buffers.</target>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>When you port your Direct3D 9 game to Direct3D 11, plan to organize your constant buffers so that you can update them appropriately.</source>
					<target>When you port your Direct3D 9 game to Direct3D 11, plan to organize your constant buffers so that you can update them appropriately.</target>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>For example, group shader constants that aren't updated every frame into a separate constant buffer, so that you don't have to constantly upload that data to the graphics adapter along with your more dynamic shader constants.</source>
					<target>For example, group shader constants that aren't updated every frame into a separate constant buffer, so that you don't have to constantly upload that data to the graphics adapter along with your more dynamic shader constants.</target>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   Most Direct3D 9 applications made extensive use of shaders, but occasionally mixed in use of the legacy fixed-function behavior.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   Most Direct3D 9 applications made extensive use of shaders, but occasionally mixed in use of the legacy fixed-function behavior.</target>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>Note that Direct3D 11 only uses a programmable shading model.</source>
					<target>Note that Direct3D 11 only uses a programmable shading model.</target>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>The legacy fixed-function features of Direct3D 9 are deprecated.</source>
					<target>The legacy fixed-function features of Direct3D 9 are deprecated.</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>