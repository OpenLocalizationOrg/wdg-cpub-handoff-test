<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">e0a63e9e79cf385ac1fedc3943db0d3791a360b5</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\winrt-components\custom-events-and-event-accessors-in-windows-runtime-components.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">5afabd76a12da3ea08ceafbc228baf3672467b1b</mda:meta><mda:meta type="olxliffhash">5cee183886c5c51a2b20ee0f7f5daeca0c756d2e</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Custom events and event accessors in Windows Runtime Components</source>
					<target>Custom events and event accessors in Windows Runtime Components</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>.NET Framework support for Windows Runtime Components makes it easy to declare events components by hiding the differences between the Universal Windows Platform (UWP) event pattern and the .NET Framework event pattern.</source>
					<target>.NET Framework support for Windows Runtime Components makes it easy to declare events components by hiding the differences between the Universal Windows Platform (UWP) event pattern and the .NET Framework event pattern.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Custom events and event accessors in Windows Runtime Components</source>
					<target>Custom events and event accessors in Windows Runtime Components</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>\[Some information relates to pre-released product which may be substantially modified before it's commercially released.</source>
					<target>\[Some information relates to pre-released product which may be substantially modified before it's commercially released.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Microsoft makes no warranties, express or implied, with respect to the information provided here.\]</source>
					<target>Microsoft makes no warranties, express or implied, with respect to the information provided here.\]</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>.NET Framework support for Windows Runtime Components makes it easy to declare events components by hiding the differences between the Universal Windows Platform (UWP) event pattern and the .NET Framework event pattern.</source>
					<target>.NET Framework support for Windows Runtime Components makes it easy to declare events components by hiding the differences between the Universal Windows Platform (UWP) event pattern and the .NET Framework event pattern.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>However, when you declare custom event accessors in a Windows Runtime Component, you must follow the pattern used in the UWP.</source>
					<target>However, when you declare custom event accessors in a Windows Runtime Component, you must follow the pattern used in the UWP.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>Registering events</source>
					<target>Registering events</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>When you register to handle an event in the UWP, the add accessor returns a token.</source>
					<target>When you register to handle an event in the UWP, the add accessor returns a token.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>To unregister, you pass this token to the remove accessor.</source>
					<target>To unregister, you pass this token to the remove accessor.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>This means that the add and remove accessors for UWP events have different signatures from the accessors you're used to.</source>
					<target>This means that the add and remove accessors for UWP events have different signatures from the accessors you're used to.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Fortunately, the Visual Basic and C# compilers simplify this process: When you declare an event with custom accessors in a Windows Runtime Component, the compilers automatically use the UWP pattern.</source>
					<target>Fortunately, the Visual Basic and C# compilers simplify this process: When you declare an event with custom accessors in a Windows Runtime Component, the compilers automatically use the UWP pattern.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>For example, you get a compiler error if your add accessor doesn't return a token.</source>
					<target>For example, you get a compiler error if your add accessor doesn't return a token.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>The .NET Framework provides two types to support the implementation:</source>
					<target>The .NET Framework provides two types to support the implementation:</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.eventregistrationtoken.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EventRegistrationToken</pc> structure represents the token.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EventRegistrationToken</pc> structure represents the token.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/hh138412.aspx)</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EventRegistrationTokenTable<ph dataRef="id3" id="ph1" />T<ph dataRef="id4" id="ph2" /></pc> class creates tokens and maintains a mapping between tokens and event handlers.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EventRegistrationTokenTable<ph dataRef="id3" id="ph1" />T<ph dataRef="id4" id="ph2" /></pc> class creates tokens and maintains a mapping between tokens and event handlers.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>The generic type argument is the event argument type.</source>
					<target>The generic type argument is the event argument type.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>You create an instance of this class for each event, the first time an event handler is registered for that event.</source>
					<target>You create an instance of this class for each event, the first time an event handler is registered for that event.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>The following code for the NumberChanged event shows the basic pattern for UWP events.</source>
					<target>The following code for the NumberChanged event shows the basic pattern for UWP events.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>In this example, the constructor for the event argument object, NumberChangedEventArgs, takes a single integer parameter that represents the changed numeric value.</source>
					<target>In this example, the constructor for the event argument object, NumberChangedEventArgs, takes a single integer parameter that represents the changed numeric value.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  This is the same pattern the compilers use for ordinary events that you declare in a Windows Runtime Component.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  This is the same pattern the compilers use for ordinary events that you declare in a Windows Runtime Component.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>The static (Shared in Visual Basic) GetOrCreateEventRegistrationTokenTable method creates the event’s instance of the EventRegistrationTokenTable<ph dataRef="id1" id="ph1" />T<ph dataRef="id2" id="ph2" /> object lazily.</source>
					<target>The static (Shared in Visual Basic) GetOrCreateEventRegistrationTokenTable method creates the event’s instance of the EventRegistrationTokenTable<ph dataRef="id1" id="ph1" />T<ph dataRef="id2" id="ph2" /> object lazily.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Pass the class-level field that will hold the token table instance to this method.</source>
					<target>Pass the class-level field that will hold the token table instance to this method.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>If the field is empty, the method creates the table, stores a reference to the table in the field, and returns a reference to the table.</source>
					<target>If the field is empty, the method creates the table, stores a reference to the table in the field, and returns a reference to the table.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>If the field already contains a token table reference, the method just returns that reference.</source>
					<target>If the field already contains a token table reference, the method just returns that reference.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>  To ensure thread safety, the field that holds the event’s instance of EventRegistrationTokenTable<ph dataRef="id3" id="ph1" />T<ph dataRef="id4" id="ph2" /> must be a class-level field.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>  To ensure thread safety, the field that holds the event’s instance of EventRegistrationTokenTable<ph dataRef="id3" id="ph1" />T<ph dataRef="id4" id="ph2" /> must be a class-level field.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>If it is a class-level field, the GetOrCreateEventRegistrationTokenTable method ensures that when multiple threads try to create the token table, all threads get the same instance of the table.</source>
					<target>If it is a class-level field, the GetOrCreateEventRegistrationTokenTable method ensures that when multiple threads try to create the token table, all threads get the same instance of the table.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>For a given event, all calls to the GetOrCreateEventRegistrationTokenTable method must use the same class-level field.</source>
					<target>For a given event, all calls to the GetOrCreateEventRegistrationTokenTable method must use the same class-level field.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/fwd3bwed.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>Calling the GetOrCreateEventRegistrationTokenTable method in the remove accessor and in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RaiseEvent</pc> method (the OnRaiseEvent method in C#) ensures that no exceptions occur if these methods are called before any event handler delegates have been added.</source>
					<target>Calling the GetOrCreateEventRegistrationTokenTable method in the remove accessor and in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RaiseEvent</pc> method (the OnRaiseEvent method in C#) ensures that no exceptions occur if these methods are called before any event handler delegates have been added.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>The other members of the EventRegistrationTokenTable<ph dataRef="id1" id="ph1" />T<ph dataRef="id2" id="ph2" /> class that are used in the UWP event pattern include the following:</source>
					<target>The other members of the EventRegistrationTokenTable<ph dataRef="id1" id="ph1" />T<ph dataRef="id2" id="ph2" /> class that are used in the UWP event pattern include the following:</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/hh138458.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AddEventHandler</pc> method generates a token for the event handler delegate, stores the delegate in the table, adds it to the invocation list, and returns the token.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AddEventHandler</pc> method generates a token for the event handler delegate, stores the delegate in the table, adds it to the invocation list, and returns the token.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/hh138425.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RemoveEventHandler(EventRegistrationToken)</pc> method overload removes the delegate from the table and from the invocation list.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RemoveEventHandler(EventRegistrationToken)</pc> method overload removes the delegate from the table and from the invocation list.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The AddEventHandler and RemoveEventHandler(EventRegistrationToken) methods lock the table to help ensure thread safety.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The AddEventHandler and RemoveEventHandler(EventRegistrationToken) methods lock the table to help ensure thread safety.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/hh138465.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InvocationList</pc> property returns a delegate that includes all the event handlers that are currently registered to handle the event.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InvocationList</pc> property returns a delegate that includes all the event handlers that are currently registered to handle the event.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Use this delegate to raise the event, or use the methods of the Delegate class to invoke the handlers individually.</source>
					<target>Use this delegate to raise the event, or use the methods of the Delegate class to invoke the handlers individually.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  We recommend that you follow the pattern shown in the example provided earlier in this article, and copy the delegate to a temporary variable before invoking it.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  We recommend that you follow the pattern shown in the example provided earlier in this article, and copy the delegate to a temporary variable before invoking it.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>This avoids a race condition in which one thread removes the last handler, reducing the delegate to null just before another thread tries to invoke the delegate.</source>
					<target>This avoids a race condition in which one thread removes the last handler, reducing the delegate to null just before another thread tries to invoke the delegate.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Delegates are immutable, so the copy is still valid.</source>
					<target>Delegates are immutable, so the copy is still valid.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Place your own code in the accessors as appropriate.</source>
					<target>Place your own code in the accessors as appropriate.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>If thread safety is an issue, you must provide your own locking for your code.</source>
					<target>If thread safety is an issue, you must provide your own locking for your code.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>C# users: When you write custom event accessors in the UWP event pattern, the compiler doesn't provide the usual syntactic shortcuts.</source>
					<target>C# users: When you write custom event accessors in the UWP event pattern, the compiler doesn't provide the usual syntactic shortcuts.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>It generates errors if you use the name of the event in your code.</source>
					<target>It generates errors if you use the name of the event in your code.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>Visual Basic users: In the .NET Framework, an event is just a multicast delegate that represents all the registered event handlers.</source>
					<target>Visual Basic users: In the .NET Framework, an event is just a multicast delegate that represents all the registered event handlers.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>Raising the event just means invoking the delegate.</source>
					<target>Raising the event just means invoking the delegate.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Visual Basic syntax generally hides the interactions with the delegate, and the compiler copies the delegate before invoking it, as described in the note about thread safety.</source>
					<target>Visual Basic syntax generally hides the interactions with the delegate, and the compiler copies the delegate before invoking it, as described in the note about thread safety.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>When you create a custom event in a Windows Runtime Component, you have to deal with the delegate directly.</source>
					<target>When you create a custom event in a Windows Runtime Component, you have to deal with the delegate directly.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/system.multicastdelegate.getinvocationlist.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>This also means that you can, for example, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MulticastDelegate.GetInvocationList</pc> method to get an array that contains a separate delegate for each event handler, if you want to invoke the handlers separately.</source>
					<target>This also means that you can, for example, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MulticastDelegate.GetInvocationList</pc> method to get an array that contains a separate delegate for each event handler, if you want to invoke the handlers separately.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
					<target>Related topics</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Events (Visual Basic)</source>
					<target>Events (Visual Basic)</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>Events (C# Programming Guide)</source>
					<target>Events (C# Programming Guide)</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>.NET for Windows Store Apps Overview</source>
					<target>.NET for Windows Store Apps Overview</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>.NET for UWP apps</source>
					<target>.NET for UWP apps</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Walkthrough: Creating a Simple Windows Runtime Component and calling it from JavaScript</source>
					<target>Walkthrough: Creating a Simple Windows Runtime Component and calling it from JavaScript</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>