<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="en-us" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-c5d768e</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">df5f99a7b444f3d9c2f83bc5a8910c74ba475a9c</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\package-your-windows-store-directx-game.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">7015669c1cd4fd770adc509adf10216afbdd6967</mda:meta><mda:meta type="olxliffhash">0c804a0f618ae331ec49c02dc50e304fa0529a03</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Package your Universal Windows Platform (UWP) DirectX game</source>
					<target>Package your Universal Windows Platform (UWP) DirectX game</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Larger Universal Windows Platform (UWP) games, especially those that support multiple languages with region-specific assets or feature optional high-definition assets, can easily balloon to large sizes.</source>
					<target>Larger Universal Windows Platform (UWP) games, especially those that support multiple languages with region-specific assets or feature optional high-definition assets, can easily balloon to large sizes.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Package your Universal Windows Platform (UWP) DirectX game</source>
					<target>Package your Universal Windows Platform (UWP) DirectX game</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Larger Universal Windows Platform (UWP) games, especially those that support multiple languages with region-specific assets or feature optional high-definition assets, can easily balloon to large sizes.</source>
					<target>Larger Universal Windows Platform (UWP) games, especially those that support multiple languages with region-specific assets or feature optional high-definition assets, can easily balloon to large sizes.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>In this topic, learn how to use app packages and app bundles to customize your app so that your customers only receive the resources they actually need.</source>
					<target>In this topic, learn how to use app packages and app bundles to customize your app so that your customers only receive the resources they actually need.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>In addition to the app package model, Windows 10 supports app bundles which group together two types of packs:</source>
					<target>In addition to the app package model, Windows 10 supports app bundles which group together two types of packs:</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>App packs contain platform-specific executables and libraries.</source>
					<target>App packs contain platform-specific executables and libraries.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>Typically, a UWP game can have up to three app packs: one each for the x86, x64, and ARM CPU architectures.</source>
					<target>Typically, a UWP game can have up to three app packs: one each for the x86, x64, and ARM CPU architectures.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>All code and data specific to that hardware platform must be included in its app pack.</source>
					<target>All code and data specific to that hardware platform must be included in its app pack.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>An app pack should also contain all the core assets for the game to run with a baseline level of fidelity and performance.</source>
					<target>An app pack should also contain all the core assets for the game to run with a baseline level of fidelity and performance.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Resource packs contain optional or expanded platform-agnostic data, such as game assets (textures, meshes, sound, text).</source>
					<target>Resource packs contain optional or expanded platform-agnostic data, such as game assets (textures, meshes, sound, text).</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>A UWP game can have one or more resource packs, including resource packs for high-definition assets or textures, DirectX feature level 11+ resources, or language-specific assets and resources.</source>
					<target>A UWP game can have one or more resource packs, including resource packs for high-definition assets or textures, DirectX feature level 11+ resources, or language-specific assets and resources.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh965321)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about app bundles and app packs, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Defining app resources</pc>.</source>
					<target>For more information about app bundles and app packs, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Defining app resources</pc>.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>While you can place all content in your app packs, this is inefficient and redundant.</source>
					<target>While you can place all content in your app packs, this is inefficient and redundant.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Why have the same large texture file replicated three times for each platform, especially for ARM platforms that may not use it?</source>
					<target>Why have the same large texture file replicated three times for each platform, especially for ARM platforms that may not use it?</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>A good goal is to try to minimize what your customer has to download, so they can start playing your game sooner, save space on their device, and avoid possible metered bandwidth costs.</source>
					<target>A good goal is to try to minimize what your customer has to download, so they can start playing your game sooner, save space on their device, and avoid possible metered bandwidth costs.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>To use this feature of the UWP app installer, it is important to consider the directory layout and file naming conventions for app and resource packaging early in game development, so your tools and source can output them correctly in a way that makes packaging simple.</source>
					<target>To use this feature of the UWP app installer, it is important to consider the directory layout and file naming conventions for app and resource packaging early in game development, so your tools and source can output them correctly in a way that makes packaging simple.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Follow the rules outlined in this doc when developing or configuring asset creation and managing tools and scripts, and when authoring code that loads or references resources.</source>
					<target>Follow the rules outlined in this doc when developing or configuring asset creation and managing tools and scripts, and when authoring code that loads or references resources.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>Why create resource packs?</source>
					<target>Why create resource packs?</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>When you create an app, particularly a game app that can be sold in many locales or a broad variety of UWP hardware platforms, you often need to include multiple versions of many files to support those locales or platforms.</source>
					<target>When you create an app, particularly a game app that can be sold in many locales or a broad variety of UWP hardware platforms, you often need to include multiple versions of many files to support those locales or platforms.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>For example, if you are releasing your game in both the United States and Japan, you might need one set of voice files in English for the en-us locales, and another in Japanese for the jp-jp locale.</source>
					<target>For example, if you are releasing your game in both the United States and Japan, you might need one set of voice files in English for the en-us locales, and another in Japanese for the jp-jp locale.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Or, if you want to use an image in your game for ARM devices as well as x86 and x64 platforms, you must upload the same image asset 3 times, once for each CPU architecture.</source>
					<target>Or, if you want to use an image in your game for ARM devices as well as x86 and x64 platforms, you must upload the same image asset 3 times, once for each CPU architecture.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Additionally, if your game has a lot of high definition resources that do not apply to platforms with lower DirectX feature levels, why include them in the baseline app pack and require your user to a download a large volume of components that the device can’t use?</source>
					<target>Additionally, if your game has a lot of high definition resources that do not apply to platforms with lower DirectX feature levels, why include them in the baseline app pack and require your user to a download a large volume of components that the device can’t use?</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Separating these high-def resources into an optional resource pack means that customers with devices that support those high-def resources can obtain them at the cost of (possibly metered) bandwidth, while those who do not have higher-end devices can get their game quicker and at a lower network usage cost.</source>
					<target>Separating these high-def resources into an optional resource pack means that customers with devices that support those high-def resources can obtain them at the cost of (possibly metered) bandwidth, while those who do not have higher-end devices can get their game quicker and at a lower network usage cost.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>Content candidates for game resource packs include:</source>
					<target>Content candidates for game resource packs include:</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>International locale specific assets (localized text, audio, or images)</source>
					<target>International locale specific assets (localized text, audio, or images)</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>High resolution assets for different device scaling factors (1.0x, 1.4x, and 1.8x)</source>
					<target>High resolution assets for different device scaling factors (1.0x, 1.4x, and 1.8x)</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>High definition assets for higher DirectX feature levels (9, 10, and 11)</source>
					<target>High definition assets for higher DirectX feature levels (9, 10, and 11)</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>All of this is defined in the package.appxmanifest that is part of your UWP project, and in your directory structure of your final package.</source>
					<target>All of this is defined in the package.appxmanifest that is part of your UWP project, and in your directory structure of your final package.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Because of the new Visual Studio UI, if you follow the process in this document, you should not need to edit it manually.</source>
					<target>Because of the new Visual Studio UI, if you follow the process in this document, you should not need to edit it manually.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>   The loading and management of these resources are handled through the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.ApplicationModel.Resources</pc>\* APIs.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>   The loading and management of these resources are handled through the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.ApplicationModel.Resources</pc>\* APIs.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>If you use these app model resource APIs to load the correct file for a locale, scaling factor, or DirectX feature level, you do not need to load your assets using explicit file paths; rather, you provide the resource APIs with just the generalized file name of the asset you want, and let the resource management system obtain the correct variant of the resource for the user’s current platform and locale configuration (which you can specify directly as well with these same APIs).</source>
					<target>If you use these app model resource APIs to load the correct file for a locale, scaling factor, or DirectX feature level, you do not need to load your assets using explicit file paths; rather, you provide the resource APIs with just the generalized file name of the asset you want, and let the resource management system obtain the correct variant of the resource for the user’s current platform and locale configuration (which you can specify directly as well with these same APIs).</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>Resources for resource packaging are specified in one of two basic ways:</source>
					<target>Resources for resource packaging are specified in one of two basic ways:</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>Asset files have the same filename, and the resource pack specific versions are placed in specific named directories.</source>
					<target>Asset files have the same filename, and the resource pack specific versions are placed in specific named directories.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>These directory names are reserved by the system.</source>
					<target>These directory names are reserved by the system.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>For example, \\en-us, \\scale-140, \\dxfl-dx11.</source>
					<target>For example, \\en-us, \\scale-140, \\dxfl-dx11.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>Asset files are stored in folders with arbitrary names, but the files are named with a common label that is appended with strings reserved by the system to denote language or other qualifiers.</source>
					<target>Asset files are stored in folders with arbitrary names, but the files are named with a common label that is appended with strings reserved by the system to denote language or other qualifiers.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Specifically, the qualifier strings are affixed to the generalized filename after an underscore (“\_”).</source>
					<target>Specifically, the qualifier strings are affixed to the generalized filename after an underscore (“\_”).</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>For example, \\assets\\menu\_option1\_lang-en-us.png, \\assets\\menu\_option1\_scale-140.png, \\assets\\coolsign\_dxfl-dx11.dds.</source>
					<target>For example, \\assets\\menu\_option1\_lang-en-us.png, \\assets\\menu\_option1\_scale-140.png, \\assets\\coolsign\_dxfl-dx11.dds.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>You may also combine these strings.</source>
					<target>You may also combine these strings.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>For example, \\assets\\menu\_option1\_scale-140\_lang-en-us.png.</source>
					<target>For example, \\assets\\menu\_option1\_scale-140\_lang-en-us.png.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">&lt;tag&gt;</data>
					<data id="id4">[</data>
					<data id="id5">](https://msdn.microsoft.com/library/windows/apps/xaml/hh965324)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   When used in a filename rather than alone in a directory name, a language qualifier must take the form "lang-<ph dataRef="id3" id="ph1" />", e.g."lang-en-us" as described in <pc dataRefEnd="id5" dataRefStart="id4" id="p2">How to name resources using qualifiers</pc>.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   When used in a filename rather than alone in a directory name, a language qualifier must take the form "lang-<ph dataRef="id3" id="ph1" />", e.g."lang-en-us" as described in <pc dataRefEnd="id5" dataRefStart="id4" id="p2">How to name resources using qualifiers</pc>.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>Directory names can be combined for additional specificity in resource packaging.</source>
					<target>Directory names can be combined for additional specificity in resource packaging.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>However, they cannot be redundant.</source>
					<target>However, they cannot be redundant.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>For example, \\en-us\\menu\_option1\_lang-en-us.png is redundant.</source>
					<target>For example, \\en-us\\menu\_option1\_lang-en-us.png is redundant.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>You may specify any non-reserved subdirectory names you need underneath a resource directory, as long as the directory structure is identical in each resource directory.</source>
					<target>You may specify any non-reserved subdirectory names you need underneath a resource directory, as long as the directory structure is identical in each resource directory.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>For example, \\dxfl-dx10\\assets\\textures\\coolsign.dds.</source>
					<target>For example, \\dxfl-dx10\\assets\\textures\\coolsign.dds.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>When you load or reference an asset, the pathname must be generalized, removing any qualifiers for language, scale, or DirectX feature level, whether they are in folder nodes or in the file names.</source>
					<target>When you load or reference an asset, the pathname must be generalized, removing any qualifiers for language, scale, or DirectX feature level, whether they are in folder nodes or in the file names.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>For example, to refer in code to an asset for which one of the variants is \\dxfl-dx10\\assets\\textures\\coolsign.dds, use \\assets\\textures\\coolsign.dds.</source>
					<target>For example, to refer in code to an asset for which one of the variants is \\dxfl-dx10\\assets\\textures\\coolsign.dds, use \\assets\\textures\\coolsign.dds.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>Likewise, to refer to an asset with a variant \\images\\background\_scale-140.png, use \\images\\background.png.</source>
					<target>Likewise, to refer to an asset with a variant \\images\\background\_scale-140.png, use \\images\\background.png.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>Here are the following reserved directory names and filename underscore prefixes:</source>
					<target>Here are the following reserved directory names and filename underscore prefixes:</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Asset type</source>
					<target>Asset type</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Resource pack directory name</source>
					<target>Resource pack directory name</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Resource pack filename suffix</source>
					<target>Resource pack filename suffix</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>Localized assets</source>
					<target>Localized assets</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>All possible languages, or language and locale combinations, for Windows 10.</source>
					<target>All possible languages, or language and locale combinations, for Windows 10.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>(The qualifier prefix "lang-" is not required in a folder name.)</source>
					<target>(The qualifier prefix "lang-" is not required in a folder name.)</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>An "\_" followed by the language, locale, or language-locale specifier.</source>
					<target>An "\_" followed by the language, locale, or language-locale specifier.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>For example, "\_en", "\_us", or "\_en-us", respectively.</source>
					<target>For example, "\_en", "\_us", or "\_en-us", respectively.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>Scaling factor assets</source>
					<target>Scaling factor assets</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>scale-100, scale-140, scale-180.</source>
					<target>scale-100, scale-140, scale-180.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>These are for the 1.0x, 1.4x, and 1.8x UI scaling factors, respectively.</source>
					<target>These are for the 1.0x, 1.4x, and 1.8x UI scaling factors, respectively.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>An "\_" followed by "scale-100", "scale-140", or "scale-180".</source>
					<target>An "\_" followed by "scale-100", "scale-140", or "scale-180".</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>DirectX feature level assets</source>
					<target>DirectX feature level assets</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>dxfl-dx9, dxfl-dx10, and dxfl-dx11.</source>
					<target>dxfl-dx9, dxfl-dx10, and dxfl-dx11.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>These are for the DirectX 9, 10, and 11 feature levels, respectively.</source>
					<target>These are for the DirectX 9, 10, and 11 feature levels, respectively.</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>An "\_" followed by "dxfl-dx9", "dxfl-dx10", or "dxfl-dx11".</source>
					<target>An "\_" followed by "dxfl-dx9", "dxfl-dx10", or "dxfl-dx11".</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>Defining localized language resource packs</source>
					<target>Defining localized language resource packs</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>Locale-specific files are placed in project directories named for the language (for example, "en").</source>
					<target>Locale-specific files are placed in project directories named for the language (for example, "en").</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>When configuring your app to support localized assets for multiple languages, you should:</source>
					<target>When configuring your app to support localized assets for multiple languages, you should:</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>Create an app subdirectory (or file version) for each language and locale you will support (for example, en-us, jp-jp, zh-cn, fr-fr, and so on).</source>
					<target>Create an app subdirectory (or file version) for each language and locale you will support (for example, en-us, jp-jp, zh-cn, fr-fr, and so on).</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>During development, place copies of ALL assets (such as localized audio files, textures, and menu graphics) in the corresponding language locale subdirectory, even if they are not different across languages or locales.</source>
					<target>During development, place copies of ALL assets (such as localized audio files, textures, and menu graphics) in the corresponding language locale subdirectory, even if they are not different across languages or locales.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>For the best user experience, ensure that the user is alerted if they have not obtained an available language resource pack for their locale if one is available (or if they have accidentally deleted it after download and installation).</source>
					<target>For the best user experience, ensure that the user is alerted if they have not obtained an available language resource pack for their locale if one is available (or if they have accidentally deleted it after download and installation).</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Make sure each asset or string resource file (.resw) has the same name in each directory.</source>
					<target>Make sure each asset or string resource file (.resw) has the same name in each directory.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>For example, menu\_option1.png should have the same name in both the \\en-us and \\jp-jp directories even if the content of the file is for a different language.</source>
					<target>For example, menu\_option1.png should have the same name in both the \\en-us and \\jp-jp directories even if the content of the file is for a different language.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>In this case, you'd see them as \\en-us\\menu\_option1.png and \\jp-jp\\menu\_option1.png.</source>
					<target>In this case, you'd see them as \\en-us\\menu\_option1.png and \\jp-jp\\menu\_option1.png.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   You can optionally append the locale to the file name and store them in the same directory; for example, \\assets\\menu\_option1\_lang-en-us.png, \\assets\\menu\_option1\_lang-jp-jp.png.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   You can optionally append the locale to the file name and store them in the same directory; for example, \\assets\\menu\_option1\_lang-en-us.png, \\assets\\menu\_option1\_lang-jp-jp.png.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br206022)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br225039)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Use the APIs in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.ApplicationModel.Resources</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Windows.ApplicationModel.Resources.Core</pc></pc> to specify and load the locale-specific resources for you app.</source>
					<target>Use the APIs in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.ApplicationModel.Resources</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Windows.ApplicationModel.Resources.Core</pc></pc> to specify and load the locale-specific resources for you app.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Also, use asset references that do no include the specific locale, since these APIs determine the correct locale based on the user's settings and then retrieve the correct resource for the user.</source>
					<target>Also, use asset references that do no include the specific locale, since these APIs determine the correct locale based on the user's settings and then retrieve the correct resource for the user.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In Microsoft Visual Studio 2015, select <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PROJECT-&gt;Store-&gt;Create App Package...</pc> and create the package.</source>
					<target>In Microsoft Visual Studio 2015, select <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PROJECT-&gt;Store-&gt;Create App Package...</pc> and create the package.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>Defining scaling factor resource packs</source>
					<target>Defining scaling factor resource packs</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>Windows 10 provides three user interface scaling factors: 1.0x, 1.4x, and 1.8x.</source>
					<target>Windows 10 provides three user interface scaling factors: 1.0x, 1.4x, and 1.8x.</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>Scaling values for each display are set during installation based on a number of combined factors: the size of the screen, the resolution of the screen, and the assumed average distance of the user from the screen.</source>
					<target>Scaling values for each display are set during installation based on a number of combined factors: the size of the screen, the resolution of the screen, and the assumed average distance of the user from the screen.</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>The user can also adjust scale factors to improve readability.</source>
					<target>The user can also adjust scale factors to improve readability.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Your game should be both DPI-aware and scaling factor-aware for the best possible experience.</source>
					<target>Your game should be both DPI-aware and scaling factor-aware for the best possible experience.</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Part of this awareness means creating versions of critical visual assets for each of the three scaling factors.</source>
					<target>Part of this awareness means creating versions of critical visual assets for each of the three scaling factors.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>This also includes pointer interaction and hit testing!</source>
					<target>This also includes pointer interaction and hit testing!</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>When configuring your app to support resource packs for different UWP app scaling factors, you should:</source>
					<target>When configuring your app to support resource packs for different UWP app scaling factors, you should:</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>Create an app subdirectory (or file version) for each scaling factor you will support (scale-100, scale-140, and scale-180).</source>
					<target>Create an app subdirectory (or file version) for each scaling factor you will support (scale-100, scale-140, and scale-180).</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>During development, place scale factor-appropriate copies of ALL assets in each scale factor resource directory, even if they are not different across scaling factors.</source>
					<target>During development, place scale factor-appropriate copies of ALL assets in each scale factor resource directory, even if they are not different across scaling factors.</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>Make sure each asset has the same name in each directory.</source>
					<target>Make sure each asset has the same name in each directory.</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>For example, menu\_option1.png should have the same name in both the \\scale-100 and \\scale-180 directories even if the content of the file is different.</source>
					<target>For example, menu\_option1.png should have the same name in both the \\scale-100 and \\scale-180 directories even if the content of the file is different.</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>In this case, you'd see them as \\scale-100\\menu\_option1.png and \\scale-140\\menu\_option1.png.</source>
					<target>In this case, you'd see them as \\scale-100\\menu\_option1.png and \\scale-140\\menu\_option1.png.</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   Again, you can optionally append the scaling factor suffix to the file name and store them in the same directory; for example, \\assets\\menu\_option1\_scale-100.png, \\assets\\menu\_option1\_scale-140.png.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   Again, you can optionally append the scaling factor suffix to the file name and store them in the same directory; for example, \\assets\\menu\_option1\_scale-100.png, \\assets\\menu\_option1\_scale-140.png.</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br225039)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Use the APIs in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.ApplicationModel.Resources.Core</pc></pc> to load the assets.</source>
					<target>Use the APIs in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.ApplicationModel.Resources.Core</pc></pc> to load the assets.</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>Asset references should be generalized (no suffix), leaving out the specific scale variation.</source>
					<target>Asset references should be generalized (no suffix), leaving out the specific scale variation.</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>The system will retrieve the appropriate scale asset for the display and the user's settings.</source>
					<target>The system will retrieve the appropriate scale asset for the display and the user's settings.</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In Visual Studio 2015, select <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PROJECT-&gt;Store-&gt;Create App Package...</pc> and create the package.</source>
					<target>In Visual Studio 2015, select <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PROJECT-&gt;Store-&gt;Create App Package...</pc> and create the package.</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>Defining DirectX feature level resource packs</source>
					<target>Defining DirectX feature level resource packs</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>DirectX feature levels correspond to GPU feature sets for prior and current versions of DirectX (specifically, Direct3D).</source>
					<target>DirectX feature levels correspond to GPU feature sets for prior and current versions of DirectX (specifically, Direct3D).</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>This includes shader model specifications and functionality, shader language support, texture compression support, and overall graphics pipeline features.</source>
					<target>This includes shader model specifications and functionality, shader language support, texture compression support, and overall graphics pipeline features.</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>Your baseline app pack should use the baseline texture compression formats: BC1, BC2, or BC3.</source>
					<target>Your baseline app pack should use the baseline texture compression formats: BC1, BC2, or BC3.</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>These formats can be consumed by any UWP device, from low-end ARM platforms up to dedicated multi-GPU workstations and media computers.</source>
					<target>These formats can be consumed by any UWP device, from low-end ARM platforms up to dedicated multi-GPU workstations and media computers.</target>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>Texture format support at DirectX feature level 10 or higher should be added in a resource pack to conserve local disk space and download bandwidth.</source>
					<target>Texture format support at DirectX feature level 10 or higher should be added in a resource pack to conserve local disk space and download bandwidth.</target>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>This enables using the more advanced compression schemes for 11, like BC6H and BC7.</source>
					<target>This enables using the more advanced compression schemes for 11, like BC6H and BC7.</target>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh308955)</data>
				</originalData>
				<segment state="initial">
					<source>(For more details, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Texture block compression in Direct3D 11</pc>.) These formats are more efficient for the high-resolution texture assets supported by modern GPUs, and using them improves the look, performance, and space requirements of your game on high-end platforms.</source>
					<target>(For more details, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Texture block compression in Direct3D 11</pc>.) These formats are more efficient for the high-resolution texture assets supported by modern GPUs, and using them improves the look, performance, and space requirements of your game on high-end platforms.</target>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>DirectX feature level</source>
					<target>DirectX feature level</target>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>Supported texture compression</source>
					<target>Supported texture compression</target>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>9</source>
					<target>9</target>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>BC1, BC2, BC3</source>
					<target>BC1, BC2, BC3</target>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>10</source>
					<target>10</target>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>BC4, BC5</source>
					<target>BC4, BC5</target>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>11</source>
					<target>11</target>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<segment state="initial">
					<source>BC6H, BC7</source>
					<target>BC6H, BC7</target>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>Also, each DirectX feature levels supports different shader model versions.</source>
					<target>Also, each DirectX feature levels supports different shader model versions.</target>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>Compiled shader resources can be created on a per-feature level basis, and can be included in DirectX feature level resource packs.</source>
					<target>Compiled shader resources can be created on a per-feature level basis, and can be included in DirectX feature level resource packs.</target>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>Additionally, some later version shader models can use assets, such as normal maps, that earlier shader model versions cannot.</source>
					<target>Additionally, some later version shader models can use assets, such as normal maps, that earlier shader model versions cannot.</target>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>These shader model specific assets should be included in a DirectX feature level resource pack as well.</source>
					<target>These shader model specific assets should be included in a DirectX feature level resource pack as well.</target>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<segment state="initial">
					<source>The resource mechanism is primarily focused on texture formats supported for assets, so it supports only the 3 overall feature levels.</source>
					<target>The resource mechanism is primarily focused on texture formats supported for assets, so it supports only the 3 overall feature levels.</target>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<segment state="initial">
					<source>If you need to have separate shaders for sub-levels (dot versions) like DX9\_1 vs DX9\_3, your asset management and rendering code must handle them explicitly.</source>
					<target>If you need to have separate shaders for sub-levels (dot versions) like DX9\_1 vs DX9\_3, your asset management and rendering code must handle them explicitly.</target>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>When configuring your app to support resource packs for different DirectX feature levels, you should:</source>
					<target>When configuring your app to support resource packs for different DirectX feature levels, you should:</target>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>Create an app subdirectory (or file version) for each DirectX feature level you will support (dxfl-dx9, dxfl-dx10, and dxfl-dx11).</source>
					<target>Create an app subdirectory (or file version) for each DirectX feature level you will support (dxfl-dx9, dxfl-dx10, and dxfl-dx11).</target>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>During development, place feature level specific assets in each feature level resource directory.</source>
					<target>During development, place feature level specific assets in each feature level resource directory.</target>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<segment state="initial">
					<source>Unlike locales and scaling factors, you may have different rendering code branches for each feature level in your game, and if you have textures, compiled shaders, or other assets that are only used in one or a subset of all supported feature levels, put the corresponding assets only in the directories for the feature levels that use them.</source>
					<target>Unlike locales and scaling factors, you may have different rendering code branches for each feature level in your game, and if you have textures, compiled shaders, or other assets that are only used in one or a subset of all supported feature levels, put the corresponding assets only in the directories for the feature levels that use them.</target>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>For assets that are loaded across all feature levels, make sure that each feature level resource directory has a version of it with the same name.</source>
					<target>For assets that are loaded across all feature levels, make sure that each feature level resource directory has a version of it with the same name.</target>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>For example, for a feature level independent texture named "coolsign.dds", place the BC3-compressed version in the \\dxfl-dx9 directory and the BC7-compressed version in the \\dxfl-dx11 directory.</source>
					<target>For example, for a feature level independent texture named "coolsign.dds", place the BC3-compressed version in the \\dxfl-dx9 directory and the BC7-compressed version in the \\dxfl-dx11 directory.</target>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<segment state="initial">
					<source>Make sure each asset (if it is available to multiple feature levels) has the same name in each directory.</source>
					<target>Make sure each asset (if it is available to multiple feature levels) has the same name in each directory.</target>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>For example, coolsign.dds should have the same name in both the \\dxfl-dx9 and \\dxfl-dx11 directories even if the content of the file is different.</source>
					<target>For example, coolsign.dds should have the same name in both the \\dxfl-dx9 and \\dxfl-dx11 directories even if the content of the file is different.</target>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>In this case, you'd see them as \\dxfl-dx9\\coolsign.dds and \\dxfl-dx11\\coolsign.dds.</source>
					<target>In this case, you'd see them as \\dxfl-dx9\\coolsign.dds and \\dxfl-dx11\\coolsign.dds.</target>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   Again, you can optionally append the feature level suffix to the file name and store them in the same directory; for example, \\textures\\coolsign\_dxfl-dx9.dds, \\textures\\coolsign\_dxfl-dx11.dds.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   Again, you can optionally append the feature level suffix to the file name and store them in the same directory; for example, \\textures\\coolsign\_dxfl-dx9.dds, \\textures\\coolsign\_dxfl-dx11.dds.</target>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>Declare the supported DirectX feature levels when configuring your graphics resources.</source>
					<target>Declare the supported DirectX feature levels when configuring your graphics resources.</target>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br225039)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Use the APIs in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.ApplicationModel.Resources.Core</pc></pc> to load the resources.</source>
					<target>Use the APIs in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.ApplicationModel.Resources.Core</pc></pc> to load the resources.</target>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>Asset references should be generalized (no suffix), leaving out the feature level.</source>
					<target>Asset references should be generalized (no suffix), leaving out the feature level.</target>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>However, unlike language and scale, the system does not automatically determine which feature level is optimal for a given display; that is left to you to determine based on code logic.</source>
					<target>However, unlike language and scale, the system does not automatically determine which feature level is optimal for a given display; that is left to you to determine based on code logic.</target>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>Once you make that determination, use the APIs to inform the OS of the preferred feature level.</source>
					<target>Once you make that determination, use the APIs to inform the OS of the preferred feature level.</target>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>The system will then be able to retrieve the correct asset based on that preference.</source>
					<target>The system will then be able to retrieve the correct asset based on that preference.</target>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>Here is a code sample that shows how to inform your app of the current DirectX feature level for the platform:</source>
					<target>Here is a code sample that shows how to inform your app of the current DirectX feature level for the platform:</target>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  In your code, load the texture directly by name (or path below the feature level directory).</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  In your code, load the texture directly by name (or path below the feature level directory).</target>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<segment state="initial">
					<source>Do not include either the feature level directory name or the suffix.</source>
					<target>Do not include either the feature level directory name or the suffix.</target>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>For example, load "textures\\coolsign.dds", not "dxfl-dx11\\textures\\coolsign.dds" or "textures\\coolsign\_dxfl-dx11.dds".</source>
					<target>For example, load "textures\\coolsign.dds", not "dxfl-dx11\\textures\\coolsign.dds" or "textures\\coolsign\_dxfl-dx11.dds".</target>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br206078)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Now, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceManager</pc></pc> to locate the file that matches current DirectX feature level.</source>
					<target>Now, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceManager</pc></pc> to locate the file that matches current DirectX feature level.</target>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br206089)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/br206098)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/jj655438)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
					<data id="id15">[</data>
					<data id="id16">](https://msdn.microsoft.com/library/windows/apps/br206064)</data>
					<data id="id17">**</data>
					<data id="id18">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceManager</pc> returns a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ResourceMap</pc></pc>, which you query with <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ResourceMap::GetValue</pc></pc> (or <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">ResourceMap::TryGetValue</pc></pc>) and a supplied <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">ResourceContext</pc></pc>.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceManager</pc> returns a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ResourceMap</pc></pc>, which you query with <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ResourceMap::GetValue</pc></pc> (or <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">ResourceMap::TryGetValue</pc></pc>) and a supplied <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">ResourceContext</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br206051)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/mt622101)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>This returns a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceCandidate</pc></pc> that most closely matches the DirectX feature level that was specified by calling <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetGlobalQualifierValue</pc></pc>.</source>
					<target>This returns a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceCandidate</pc></pc> that most closely matches the DirectX feature level that was specified by calling <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetGlobalQualifierValue</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In Visual Studio 2015, select <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PROJECT-&gt;Store-&gt;Create App Package...</pc> and create the package.</source>
					<target>In Visual Studio 2015, select <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PROJECT-&gt;Store-&gt;Create App Package...</pc> and create the package.</target>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>Make sure that you enable app bundles in the package.appxmanifest manifest settings.</source>
					<target>Make sure that you enable app bundles in the package.appxmanifest manifest settings.</target>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
					<target>Related topics</target>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>Defining app resources</source>
					<target>Defining app resources</target>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>Packaging apps</source>
					<target>Packaging apps</target>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>App packager (MakeAppx.exe)</source>
					<target>App packager (MakeAppx.exe)</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>