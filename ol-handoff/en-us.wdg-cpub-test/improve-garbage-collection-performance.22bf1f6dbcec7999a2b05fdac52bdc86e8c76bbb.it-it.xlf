<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="it-it" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">4d48e0a8011192d2d96a9fb9c1cea9801523a15d</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci1\debug-test-perf\improve-garbage-collection-performance.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">4843d63f872e9fa61820ccb72f20bea59282cc93</mda:meta><mda:meta type="olxliffhash">20533fbdf3d3a690b8afd9228b82fc2557ca56df</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Improve garbage collection performance</source>
					<target>Improve garbage collection performance</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Universal Windows Platform (UWP) apps written in C# and Visual Basic get automatic memory management from the .NET garbage collector.</source>
					<target>Universal Windows Platform (UWP) apps written in C# and Visual Basic get automatic memory management from the .NET garbage collector.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>This section summarizes the behavior and performance best practices for the .NET garbage collector in UWP apps.</source>
					<target>This section summarizes the behavior and performance best practices for the .NET garbage collector in UWP apps.</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>Improve garbage collection performance</source>
					<target>Improve garbage collection performance</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Universal Windows Platform (UWP) apps written in C# and Visual Basic get automatic memory management from the .NET garbage collector.</source>
					<target>Universal Windows Platform (UWP) apps written in C# and Visual Basic get automatic memory management from the .NET garbage collector.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>This section summarizes the behavior and performance best practices for the .NET garbage collector in UWP apps.</source>
					<target>This section summarizes the behavior and performance best practices for the .NET garbage collector in UWP apps.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/0xy59wtx.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>For more info on how the .NET garbage collector works and tools for debugging and analyzing garbage collector performance, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Garbage collection</pc>.</source>
					<target>For more info on how the .NET garbage collector works and tools for debugging and analyzing garbage collector performance, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Garbage collection</pc>.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Needing to intervene in the default behavior of the garbage collector is strongly indicative of general memory issues with your app.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Needing to intervene in the default behavior of the garbage collector is strongly indicative of general memory issues with your app.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://blogs.msdn.com/b/visualstudioalm/archive/2014/11/13/memory-usage-tool-while-debugging-in-visual-studio-2015.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Memory Usage Tool while debugging in Visual Studio 2015</pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Memory Usage Tool while debugging in Visual Studio 2015</pc>.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>This topic applies to C# and Visual Basic only.</source>
					<target>This topic applies to C# and Visual Basic only.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>The garbage collector determines when to run by balancing the memory consumption of the managed heap with the amount of work a garbage collection needs to do.</source>
					<target>The garbage collector determines when to run by balancing the memory consumption of the managed heap with the amount of work a garbage collection needs to do.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>One of the ways the garbage collector does this is by dividing the heap into generations and collecting only part of the heap most of the time.</source>
					<target>One of the ways the garbage collector does this is by dividing the heap into generations and collecting only part of the heap most of the time.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>There are three generations in the managed heap:</source>
					<target>There are three generations in the managed heap:</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Generation 0.</source>
					<target>Generation 0.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>This generation contains newly allocated objects unless they are 85KB or larger, in which case they are part of the large object heap.</source>
					<target>This generation contains newly allocated objects unless they are 85KB or larger, in which case they are part of the large object heap.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>The large object heap is collected with generation 2 collections.</source>
					<target>The large object heap is collected with generation 2 collections.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>Generation 0 collections are the most frequently occurring type of collection and clean up short-lived objects such as local variables.</source>
					<target>Generation 0 collections are the most frequently occurring type of collection and clean up short-lived objects such as local variables.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Generation 1.</source>
					<target>Generation 1.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>This generation contains objects that have survived generation 0 collections.</source>
					<target>This generation contains objects that have survived generation 0 collections.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>It serves as a buffer between generation 0 and generation 2.</source>
					<target>It serves as a buffer between generation 0 and generation 2.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>Generation 1 collections occur less frequently than generation 0 collections and clean up temporary objects that were active during previous generation 0 collections.</source>
					<target>Generation 1 collections occur less frequently than generation 0 collections and clean up temporary objects that were active during previous generation 0 collections.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>A generation 1 collection also collects generation 0.</source>
					<target>A generation 1 collection also collects generation 0.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Generation 2.</source>
					<target>Generation 2.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>This generation contains long-lived objects that have survived generation 0 and generation 1 collections.</source>
					<target>This generation contains long-lived objects that have survived generation 0 and generation 1 collections.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>Generation 2 collections are the least frequent and collect the entire managed heap, including the large object heap which contains objects that are 85KB or larger.</source>
					<target>Generation 2 collections are the least frequent and collect the entire managed heap, including the large object heap which contains objects that are 85KB or larger.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>You can measure the performance of the garbage collector in 2 aspects: the time it takes to do the garbage collection, and the memory consumption of the managed heap.</source>
					<target>You can measure the performance of the garbage collector in 2 aspects: the time it takes to do the garbage collection, and the memory consumption of the managed heap.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>If you have a small app with a heap size less than 100MB then focus on reducing memory consumption.</source>
					<target>If you have a small app with a heap size less than 100MB then focus on reducing memory consumption.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>If you have an app with a managed heap larger than 100MB then focus on reducing the garbage collection time only.</source>
					<target>If you have an app with a managed heap larger than 100MB then focus on reducing the garbage collection time only.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Here's how you can help the .NET garbage collector achieve better performance.</source>
					<target>Here's how you can help the .NET garbage collector achieve better performance.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Reduce memory consumption</source>
					<target>Reduce memory consumption</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Release references</source>
					<target>Release references</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>A reference to an object in your app prevents that object, and all of the objects it references, from being collected.</source>
					<target>A reference to an object in your app prevents that object, and all of the objects it references, from being collected.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>The .NET compiler does a good job of detecting when a variable is no longer in use so objects held onto by that variable will be eligible for collection.</source>
					<target>The .NET compiler does a good job of detecting when a variable is no longer in use so objects held onto by that variable will be eligible for collection.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>But in some cases it may not be obvious that some objects have a reference to other objects because part of the object graph might be owned by libraries your app uses.</source>
					<target>But in some cases it may not be obvious that some objects have a reference to other objects because part of the object graph might be owned by libraries your app uses.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/ee851764.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>To learn about the tools and techniques to find out which objects survive a garbage collection, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Garbage collection and performance</pc>.</source>
					<target>To learn about the tools and techniques to find out which objects survive a garbage collection, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Garbage collection and performance</pc>.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Induce a garbage collection if it’s useful</source>
					<target>Induce a garbage collection if it’s useful</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>Induce a garbage collection only after you have measured your app's performance and have determined that inducing a collection will improve its performance.</source>
					<target>Induce a garbage collection only after you have measured your app's performance and have determined that inducing a collection will improve its performance.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You can induce a garbage collection of a generation by calling [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">GC.Collect(n)</pc>]https://msdn.microsoft.com/en-us/library/windows/apps/xaml/y46kxc5e.aspx), where n is the generation you want to collect (0, 1, or 2).</source>
					<target>You can induce a garbage collection of a generation by calling [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">GC.Collect(n)</pc>]https://msdn.microsoft.com/en-us/library/windows/apps/xaml/y46kxc5e.aspx), where n is the generation you want to collect (0, 1, or 2).</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  We recommend that you don't force a garbage collection in your app because the garbage collector uses many heuristics to determine the best time to perform a collection, and forcing a collection is in many cases an unnecessary use of the CPU.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  We recommend that you don't force a garbage collection in your app because the garbage collector uses many heuristics to determine the best time to perform a collection, and forcing a collection is in many cases an unnecessary use of the CPU.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>But if you know that you have a large number of objects in your app that are no longer used and you want to return this memory to the system, then it may be appropriate to force a garbage collection.</source>
					<target>But if you know that you have a large number of objects in your app that are no longer used and you want to return this memory to the system, then it may be appropriate to force a garbage collection.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>For example, you can induce a collection at the end of a loading sequence in a game to free up memory before gameplay starts.</source>
					<target>For example, you can induce a collection at the end of a loading sequence in a game to free up memory before gameplay starts.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/bb495757.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>To avoid inadvertently inducing too many garbage collections, you can set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GCCollectionMode</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Optimized</pc>.</source>
					<target>To avoid inadvertently inducing too many garbage collections, you can set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GCCollectionMode</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Optimized</pc>.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>This instructs the garbage collector to start a collection only if it determines that the collection would be productive enough to be justified.</source>
					<target>This instructs the garbage collector to start a collection only if it determines that the collection would be productive enough to be justified.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>Reduce garbage collection time</source>
					<target>Reduce garbage collection time</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>This section applies if you've analyzed your app and observed large garbage collection times.</source>
					<target>This section applies if you've analyzed your app and observed large garbage collection times.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Garbage collection-related pause times include: the time it takes to run a single garbage collection pass; and the total time your app spends doing garbage collections.</source>
					<target>Garbage collection-related pause times include: the time it takes to run a single garbage collection pass; and the total time your app spends doing garbage collections.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>The amount of time it takes to do a collection depends on how much live data the collector has to analyze.</source>
					<target>The amount of time it takes to do a collection depends on how much live data the collector has to analyze.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>Generation 0 and generation 1 are bounded in size, but generation 2 continues to grow as more long-lived objects are active in your app.</source>
					<target>Generation 0 and generation 1 are bounded in size, but generation 2 continues to grow as more long-lived objects are active in your app.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>This means that the collection times for generation 0 and generation 1 are bounded, while generation 2 collections can take longer.</source>
					<target>This means that the collection times for generation 0 and generation 1 are bounded, while generation 2 collections can take longer.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>How often garbage collections run depends mostly on how much memory you allocate, because a garbage collection frees up memory to satisfy allocation requests.</source>
					<target>How often garbage collections run depends mostly on how much memory you allocate, because a garbage collection frees up memory to satisfy allocation requests.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>The garbage collector occasionally pauses your app to perform work, but doesn't necessarily pause your app the entire time it is doing a collection.</source>
					<target>The garbage collector occasionally pauses your app to perform work, but doesn't necessarily pause your app the entire time it is doing a collection.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Pause times are usually not user-perceivable in your app, especially for generation 0 and generation 1 collections.</source>
					<target>Pause times are usually not user-perceivable in your app, especially for generation 0 and generation 1 collections.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/ee787088.aspx#background-garbage-collection)</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Background garbage collection</pc> feature of the .NET garbage collector allows Generation 2 collections to be performed concurrently while your app is running and will only pause your app for short periods of time.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Background garbage collection</pc> feature of the .NET garbage collector allows Generation 2 collections to be performed concurrently while your app is running and will only pause your app for short periods of time.</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>But it is not always possible to do a Generation 2 collection as a background collection.</source>
					<target>But it is not always possible to do a Generation 2 collection as a background collection.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>In that case, the pause can be user-perceivable if you have a large enough heap (more than 100MB).</source>
					<target>In that case, the pause can be user-perceivable if you have a large enough heap (more than 100MB).</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>Frequent garbage collections can contribute to increased CPU (and therefore power) consumption, longer loading times, or decreased frame rates in your application.</source>
					<target>Frequent garbage collections can contribute to increased CPU (and therefore power) consumption, longer loading times, or decreased frame rates in your application.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>Below are some techniques you can use to reduce garbage collection time and collection-related pauses in your managed UWP app.</source>
					<target>Below are some techniques you can use to reduce garbage collection time and collection-related pauses in your managed UWP app.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>Reduce memory allocations</source>
					<target>Reduce memory allocations</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>If you don’t allocate any objects then the garbage collector doesn’t run unless there is a low memory condition in the system.</source>
					<target>If you don’t allocate any objects then the garbage collector doesn’t run unless there is a low memory condition in the system.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>Reducing the amount of memory you allocate directly translates to less frequent garbage collections.</source>
					<target>Reducing the amount of memory you allocate directly translates to less frequent garbage collections.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>If in some sections of your app pauses are completely undesirable, then you can pre-allocate the necessary objects beforehand during a less performance-critical time.</source>
					<target>If in some sections of your app pauses are completely undesirable, then you can pre-allocate the necessary objects beforehand during a less performance-critical time.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>For example, a game might allocate all of the objects needed for gameplay during the loading screen of a level and not make any allocations during gameplay.</source>
					<target>For example, a game might allocate all of the objects needed for gameplay during the loading screen of a level and not make any allocations during gameplay.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>This avoids pauses while the user is playing the game and can result in a higher and more consistent frame rate.</source>
					<target>This avoids pauses while the user is playing the game and can result in a higher and more consistent frame rate.</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>Reduce generation 2 collections by avoiding objects with a medium-length lifetime</source>
					<target>Reduce generation 2 collections by avoiding objects with a medium-length lifetime</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Generational garbage collections perform best when you have really short-lived and/or really long-lived objects in your app.</source>
					<target>Generational garbage collections perform best when you have really short-lived and/or really long-lived objects in your app.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>Short lived objects are collected in the cheaper generation 0 and generation 1 collections, and objects that are long-lived get promoted to generation 2, which is collected infrequently.</source>
					<target>Short lived objects are collected in the cheaper generation 0 and generation 1 collections, and objects that are long-lived get promoted to generation 2, which is collected infrequently.</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>Long-lived objects are those that are in use for the entire duration of your app, or during a significant period of your app, such as during a specific page or game level.</source>
					<target>Long-lived objects are those that are in use for the entire duration of your app, or during a significant period of your app, such as during a specific page or game level.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>If you frequently create objects that have a temporary lifetime but live long enough to be promoted to generation 2, then more of the expensive generation 2 collections happen.</source>
					<target>If you frequently create objects that have a temporary lifetime but live long enough to be promoted to generation 2, then more of the expensive generation 2 collections happen.</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>You may be able to reduce generation 2 collections by recycling existing objects or releasing objects more quickly.</source>
					<target>You may be able to reduce generation 2 collections by recycling existing objects or releasing objects more quickly.</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>A common example of objects with medium-term lifetime is objects that are used for displaying items in a list that a user scrolls through.</source>
					<target>A common example of objects with medium-term lifetime is objects that are used for displaying items in a list that a user scrolls through.</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>If objects are created when items in the list are scrolled into view, and are no longer referenced as items in the list are scrolled out of view, then your app typically has a large number of generation 2 collections.</source>
					<target>If objects are created when items in the list are scrolled into view, and are no longer referenced as items in the list are scrolled out of view, then your app typically has a large number of generation 2 collections.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>In situations like this you can pre-allocate and reuse a set of objects for the data that is actively shown to the user, and use short-lived objects to load info as items in the list come into view.</source>
					<target>In situations like this you can pre-allocate and reuse a set of objects for the data that is actively shown to the user, and use short-lived objects to load info as items in the list come into view.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>Reduce generation 2 collections by avoiding large-sized objects with short lifetimes</source>
					<target>Reduce generation 2 collections by avoiding large-sized objects with short lifetimes</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Any object that is 85KB or larger is allocated on the large object heap (LOH) and gets collected as part of generation 2.</source>
					<target>Any object that is 85KB or larger is allocated on the large object heap (LOH) and gets collected as part of generation 2.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>If you have temporary variables, such as buffers, that are greater than 85KB, then a generation 2 collection cleans them up.</source>
					<target>If you have temporary variables, such as buffers, that are greater than 85KB, then a generation 2 collection cleans them up.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>Limiting temporary variables to less than 85KB reduces the number of generation 2 collections in your app.</source>
					<target>Limiting temporary variables to less than 85KB reduces the number of generation 2 collections in your app.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>One common technique is to create a buffer pool and reuse objects from the pool to avoid large temporary allocations.</source>
					<target>One common technique is to create a buffer pool and reuse objects from the pool to avoid large temporary allocations.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>Avoid reference-rich objects</source>
					<target>Avoid reference-rich objects</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>The garbage collector determines which objects are live by following references between objects, starting from roots in your app.</source>
					<target>The garbage collector determines which objects are live by following references between objects, starting from roots in your app.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/ee787088.aspx#what-happens-during-a-garbage-collection)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">What happens during a garbage collection</pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">What happens during a garbage collection</pc>.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>If an object contains many references, then there is more work for the garbage collector to do.</source>
					<target>If an object contains many references, then there is more work for the garbage collector to do.</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>A common technique (especially with large objects) is to convert reference rich objects into objects with no references (e.g., instead of storing a reference, store an index).</source>
					<target>A common technique (especially with large objects) is to convert reference rich objects into objects with no references (e.g., instead of storing a reference, store an index).</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>Of course this technique works only when it is logically possible to do so.</source>
					<target>Of course this technique works only when it is logically possible to do so.</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>Replacing object references with indexes can be a disruptive and complicated change to your app and is most effective for large objects with a large number of references.</source>
					<target>Replacing object references with indexes can be a disruptive and complicated change to your app and is most effective for large objects with a large number of references.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Do this only if you are noticing large garbage collection times in your app related to reference-heavy objects.</source>
					<target>Do this only if you are noticing large garbage collection times in your app related to reference-heavy objects.</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>