<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="it-it" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">b47beb459110f8149db02176beb880e6535d7874</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\glsl-to-hlsl-reference.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">40a0f71fc299b1bafd584ced30d421afabe74938</mda:meta><mda:meta type="olxliffhash">f868fbb30300e68c4b87fe9b166e5e02517afebe</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>GLSL-to-HLSL reference</source>
					<target>GLSL-to-HLSL reference</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>You port your OpenGL Shader Language (GLSL) code to Microsoft High Level Shader Language (HLSL) code when you port your graphics architecture from OpenGL ES 2.0 to Direct3D 11 to create a game for Universal Windows Platform (UWP).</source>
					<target>You port your OpenGL Shader Language (GLSL) code to Microsoft High Level Shader Language (HLSL) code when you port your graphics architecture from OpenGL ES 2.0 to Direct3D 11 to create a game for Universal Windows Platform (UWP).</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>GLSL-to-HLSL reference</source>
					<target>GLSL-to-HLSL reference</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](port-from-opengl-es-2-0-to-directx-11-1.md)</data>
				</originalData>
				<segment state="initial">
					<source>You port your OpenGL Shader Language (GLSL) code to Microsoft High Level Shader Language (HLSL) code when you <pc dataRefEnd="id2" dataRefStart="id1" id="p1">port your graphics architecture from OpenGL ES 2.0 to Direct3D 11</pc> to create a game for Universal Windows Platform (UWP).</source>
					<target>You port your OpenGL Shader Language (GLSL) code to Microsoft High Level Shader Language (HLSL) code when you <pc dataRefEnd="id2" dataRefStart="id1" id="p1">port your graphics architecture from OpenGL ES 2.0 to Direct3D 11</pc> to create a game for Universal Windows Platform (UWP).</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>The GLSL that is referred to herein is compatible with OpenGL ES 2.0; the HLSL is compatible with Direct3D 11.</source>
					<target>The GLSL that is referred to herein is compatible with OpenGL ES 2.0; the HLSL is compatible with Direct3D 11.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](feature-mapping.md)</data>
				</originalData>
				<segment state="initial">
					<source>For info about the differences between Direct3D 11 and previous versions of Direct3D, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Feature mapping</pc>.</source>
					<target>For info about the differences between Direct3D 11 and previous versions of Direct3D, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Feature mapping</pc>.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Comparing OpenGL ES 2.0 with Direct3D 11</source>
					<target>Comparing OpenGL ES 2.0 with Direct3D 11</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>Porting GLSL variables to HLSL</source>
					<target>Porting GLSL variables to HLSL</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>Porting GLSL types to HLSL</source>
					<target>Porting GLSL types to HLSL</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>Porting GLSL pre-defined global variables to HLSL</source>
					<target>Porting GLSL pre-defined global variables to HLSL</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Examples of porting GLSL variables to HLSL</source>
					<target>Examples of porting GLSL variables to HLSL</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Uniform, attribute, and varying in GLSL</source>
					<target>Uniform, attribute, and varying in GLSL</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>Constant buffers and data transfers in HLSL</source>
					<target>Constant buffers and data transfers in HLSL</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Examples of porting OpenGL rendering code to Direct3D</source>
					<target>Examples of porting OpenGL rendering code to Direct3D</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
					<target>Related topics</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Comparing OpenGL ES 2.0 with Direct3D 11</source>
					<target>Comparing OpenGL ES 2.0 with Direct3D 11</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>OpenGL ES 2.0 and Direct3D 11 have many similarities.</source>
					<target>OpenGL ES 2.0 and Direct3D 11 have many similarities.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>They both have similar rendering pipelines and graphics features.</source>
					<target>They both have similar rendering pipelines and graphics features.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>But Direct3D 11 is a rendering implementation and API, not a specification; OpenGL ES 2.0 is a rendering specification and API, not an implementation.</source>
					<target>But Direct3D 11 is a rendering implementation and API, not a specification; OpenGL ES 2.0 is a rendering specification and API, not an implementation.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>Direct3D 11 and OpenGL ES 2.0 generally differ in these ways:</source>
					<target>Direct3D 11 and OpenGL ES 2.0 generally differ in these ways:</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>OpenGL ES 2.0</source>
					<target>OpenGL ES 2.0</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Direct3D 11</source>
					<target>Direct3D 11</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Hardware and operating system agnostic specification with vendor provided implementations</source>
					<target>Hardware and operating system agnostic specification with vendor provided implementations</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Microsoft implementation of hardware abstraction and certification on Windows platforms</source>
					<target>Microsoft implementation of hardware abstraction and certification on Windows platforms</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>Abstracted for hardware diversity, runtime manages most resources</source>
					<target>Abstracted for hardware diversity, runtime manages most resources</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>Direct access to hardware layout; app can manage resources and processing</source>
					<target>Direct access to hardware layout; app can manage resources and processing</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>Provides higher-level modules via third-party libraries (for example, Simple DirectMedia Layer (SDL))</source>
					<target>Provides higher-level modules via third-party libraries (for example, Simple DirectMedia Layer (SDL))</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>Higher-level modules, like Direct2D, are built upon lower modules to simplify development for Windows apps</source>
					<target>Higher-level modules, like Direct2D, are built upon lower modules to simplify development for Windows apps</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Hardware vendors differentiate via extensions</source>
					<target>Hardware vendors differentiate via extensions</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Microsoft adds optional features to the API in a generic way so they aren't specific to any particular hardware vendor</source>
					<target>Microsoft adds optional features to the API in a generic way so they aren't specific to any particular hardware vendor</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>GLSL and HLSL generally differ in these ways:</source>
					<target>GLSL and HLSL generally differ in these ways:</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>GLSL</source>
					<target>GLSL</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>HLSL</source>
					<target>HLSL</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>Procedural, step-centric (C like)</source>
					<target>Procedural, step-centric (C like)</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Object oriented, data-centric (C++ like)</source>
					<target>Object oriented, data-centric (C++ like)</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Shader compilation integrated into the graphics API</source>
					<target>Shader compilation integrated into the graphics API</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509633)</data>
				</originalData>
				<segment state="initial">
					<source>The HLSL compiler <pc dataRefEnd="id2" dataRefStart="id1" id="p1">compiles the shader</pc> to an intermediate binary representation before Direct3D passes it to the driver.</source>
					<target>The HLSL compiler <pc dataRefEnd="id2" dataRefStart="id1" id="p1">compiles the shader</pc> to an intermediate binary representation before Direct3D passes it to the driver.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>Note<ph dataRef="id1" id="ph1" />  This binary representation is hardware independent.</source>
					<target>Note<ph dataRef="id1" id="ph1" />  This binary representation is hardware independent.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>It's typically compiled at app build time, rather than at app run time.</source>
					<target>It's typically compiled at app build time, rather than at app run time.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#variables)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Variable</pc> storage modifiers</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Variable</pc> storage modifiers</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>Constant buffers and data transfers via input layout declarations</source>
					<target>Constant buffers and data transfers via input layout declarations</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>Types</source>
					<target>Types</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>Typical vector type: vec2/3/4</source>
					<target>Typical vector type: vec2/3/4</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>lowp, mediump, highp</source>
					<target>lowp, mediump, highp</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Typical vector type: float2/3/4</source>
					<target>Typical vector type: float2/3/4</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>min10float, min16float</source>
					<target>min10float, min16float</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>texture2D [Function]</source>
					<target>texture2D [Function]</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509695)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">texture.Sample</pc> [datatype.Function]</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">texture.Sample</pc> [datatype.Function]</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>sampler2D [datatype]</source>
					<target>sampler2D [datatype]</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff471525)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Texture2D</pc> [datatype]</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Texture2D</pc> [datatype]</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>Row-major matrices (default)</source>
					<target>Row-major matrices (default)</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Column-major matrices (default)</source>
					<target>Column-major matrices (default)</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">&lt;/strong&gt;</data>
					<data id="id2">&lt;strong&gt;</data>
					<data id="id3">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>Note<ph dataRef="id1" id="ph1" />   Use the <ph dataRef="id2" id="ph2" />row_major<ph dataRef="id3" id="ph3" /> type-modifier to change the layout for one variable.</source>
					<target>Note<ph dataRef="id1" id="ph1" />   Use the <ph dataRef="id2" id="ph2" />row_major<ph dataRef="id3" id="ph3" /> type-modifier to change the layout for one variable.</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509706)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Variable Syntax</pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Variable Syntax</pc>.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>You can also specify a compiler flag or a pragma to change the global default.</source>
					<target>You can also specify a compiler flag or a pragma to change the global default.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>Fragment shader</source>
					<target>Fragment shader</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>Pixel shader</source>
					<target>Pixel shader</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  HLSL has textures and samplers as two separate objects.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  HLSL has textures and samplers as two separate objects.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>In GLSL, like Direct3D 9, the texture binding is part of the sampler state.</source>
					<target>In GLSL, like Direct3D 9, the texture binding is part of the sampler state.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>In GLSL, you present much of the OpenGL state as pre-defined global variables.</source>
					<target>In GLSL, you present much of the OpenGL state as pre-defined global variables.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, with GLSL, you use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">gl\_Position</pc> variable to specify vertex position and the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">gl\_FragColor</pc> variable to specify fragment color.</source>
					<target>For example, with GLSL, you use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">gl\_Position</pc> variable to specify vertex position and the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">gl\_FragColor</pc> variable to specify fragment color.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>In HLSL, you pass Direct3D state explicitly from the app code to the shader.</source>
					<target>In HLSL, you pass Direct3D state explicitly from the app code to the shader.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509581)</data>
				</originalData>
				<segment state="initial">
					<source>For example, with Direct3D and HLSL, the input to the vertex shader must match the data format in the vertex buffer, and the structure of a constant buffer in the app code must match the structure of a constant buffer (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">cbuffer</pc>) in shader code.</source>
					<target>For example, with Direct3D and HLSL, the input to the vertex shader must match the data format in the vertex buffer, and the structure of a constant buffer in the app code must match the structure of a constant buffer (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">cbuffer</pc>) in shader code.</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>Porting GLSL variables to HLSL</source>
					<target>Porting GLSL variables to HLSL</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>In GLSL, you apply modifiers (qualifiers) to a global shader variable declaration to give that variable a specific behavior in your shaders.</source>
					<target>In GLSL, you apply modifiers (qualifiers) to a global shader variable declaration to give that variable a specific behavior in your shaders.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>In HLSL, you don’t need these modifiers because you define the flow of the shader with the arguments that you pass to your shader and that you return from your shader.</source>
					<target>In HLSL, you don’t need these modifiers because you define the flow of the shader with the arguments that you pass to your shader and that you return from your shader.</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>GLSL variable behavior</source>
					<target>GLSL variable behavior</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>HLSL equivalent</source>
					<target>HLSL equivalent</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>uniform</source>
					<target>uniform</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>You pass a uniform variable from the app code into either or both vertex and fragment shaders.</source>
					<target>You pass a uniform variable from the app code into either or both vertex and fragment shaders.</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>You must set the values of all uniforms before you draw any triangles with those shaders so their values stay the same throughout the drawing of a triangle mesh.</source>
					<target>You must set the values of all uniforms before you draw any triangles with those shaders so their values stay the same throughout the drawing of a triangle mesh.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>These values are uniform.</source>
					<target>These values are uniform.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>Some uniforms are set for the entire frame and others uniquely to one particular vertex-pixel shader pair.</source>
					<target>Some uniforms are set for the entire frame and others uniquely to one particular vertex-pixel shader pair.</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Uniform variables are per-polygon variables.</source>
					<target>Uniform variables are per-polygon variables.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>Use constant buffer.</source>
					<target>Use constant buffer.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476896)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/bb509581)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">How to: Create a Constant Buffer</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Shader Constants</pc>.</source>
					<target>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">How to: Create a Constant Buffer</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Shader Constants</pc>.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>varying</source>
					<target>varying</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>You initialize a varying variable inside the vertex shader and pass it through to an identically named varying variable in the fragment shader.</source>
					<target>You initialize a varying variable inside the vertex shader and pass it through to an identically named varying variable in the fragment shader.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Because the vertex shader only sets the value of the varying variables at each vertex, the rasterizer interpolates those values (in a perspective-correct manner) to generate per fragment values to pass into the fragment shader.</source>
					<target>Because the vertex shader only sets the value of the varying variables at each vertex, the rasterizer interpolates those values (in a perspective-correct manner) to generate per fragment values to pass into the fragment shader.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>These variables vary across each triangle.</source>
					<target>These variables vary across each triangle.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>Use the structure that you return from your vertex shader as the input to your pixel shader.</source>
					<target>Use the structure that you return from your vertex shader as the input to your pixel shader.</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>Make sure the semantic values match.</source>
					<target>Make sure the semantic values match.</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>attribute</source>
					<target>attribute</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>An attribute is a part of the description of a vertex that you pass from the app code to the vertex shader alone.</source>
					<target>An attribute is a part of the description of a vertex that you pass from the app code to the vertex shader alone.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Unlike a uniform, you set each attribute’s value for each vertex, which, in turn, allows each vertex to have a different value.</source>
					<target>Unlike a uniform, you set each attribute’s value for each vertex, which, in turn, allows each vertex to have a different value.</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Attribute variables are per-vertex variables.</source>
					<target>Attribute variables are per-vertex variables.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>Define a vertex buffer in your Direct3D app code and match it to the vertex input defined in the vertex shader.</source>
					<target>Define a vertex buffer in your Direct3D app code and match it to the vertex input defined in the vertex shader.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>Optionally, define an index buffer.</source>
					<target>Optionally, define an index buffer.</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476899)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff476897)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">How to: Create a Vertex Buffer</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">How to: Create an Index Buffer</pc>.</source>
					<target>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">How to: Create a Vertex Buffer</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">How to: Create an Index Buffer</pc>.</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>Create an input layout in your Direct3D app code and match semantic values with those in the vertex input.</source>
					<target>Create an input layout in your Direct3D app code and match semantic values with those in the vertex input.</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb205117#Create_the_Input_Layout)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Create the input layout</pc>.</source>
					<target>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Create the input layout</pc>.</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>const</source>
					<target>const</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>Constants that are compiled into the shader and never change.</source>
					<target>Constants that are compiled into the shader and never change.</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>Use a <ph dataRef="id1" id="ph1" />static const<ph dataRef="id2" id="ph2" />.</source>
					<target>Use a <ph dataRef="id1" id="ph1" />static const<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<originalData>
					<data id="id1">&lt;/strong&gt;</data>
					<data id="id2">&lt;strong&gt;</data>
					<data id="id3">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>static<ph dataRef="id1" id="ph1" /> means the value isn't exposed to constant buffers, <ph dataRef="id2" id="ph2" />const<ph dataRef="id3" id="ph3" /> means the shader can't change the value.</source>
					<target>static<ph dataRef="id1" id="ph1" /> means the value isn't exposed to constant buffers, <ph dataRef="id2" id="ph2" />const<ph dataRef="id3" id="ph3" /> means the shader can't change the value.</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>So, the value is known at compile time based on its initializer.</source>
					<target>So, the value is known at compile time based on its initializer.</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>In GLSL, variables without modifiers are just ordinary global variables that are private to each shader.</source>
					<target>In GLSL, variables without modifiers are just ordinary global variables that are private to each shader.</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff471525)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/bb509644)</data>
				</originalData>
				<segment state="initial">
					<source>When you pass data to textures (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Texture2D</pc> in HLSL) and their associated samplers (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">SamplerState</pc> in HLSL), you typically declare them as global variables in the pixel shader.</source>
					<target>When you pass data to textures (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Texture2D</pc> in HLSL) and their associated samplers (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">SamplerState</pc> in HLSL), you typically declare them as global variables in the pixel shader.</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>Porting GLSL types to HLSL</source>
					<target>Porting GLSL types to HLSL</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>Use this table to port your GLSL types to HLSL.</source>
					<target>Use this table to port your GLSL types to HLSL.</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>GLSL type</source>
					<target>GLSL type</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>HLSL type</source>
					<target>HLSL type</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>scalar types: float, int, bool</source>
					<target>scalar types: float, int, bool</target>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>scalar types: float, int, bool</source>
					<target>scalar types: float, int, bool</target>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>also, uint, double</source>
					<target>also, uint, double</target>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509646)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Scalar Types</pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Scalar Types</pc>.</target>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>vector type</source>
					<target>vector type</target>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>floating-point vector: vec2, vec3, vec4</source>
					<target>floating-point vector: vec2, vec3, vec4</target>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>Boolean vector: bvec2, bvec3, bvec4</source>
					<target>Boolean vector: bvec2, bvec3, bvec4</target>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>signed integer vector: ivec2, ivec3, ivec4</source>
					<target>signed integer vector: ivec2, ivec3, ivec4</target>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>vector type</source>
					<target>vector type</target>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>float2, float3, float4, and float1</source>
					<target>float2, float3, float4, and float1</target>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>bool2, bool3, bool4, and bool1</source>
					<target>bool2, bool3, bool4, and bool1</target>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<segment state="initial">
					<source>int2, int3, int4, and int1</source>
					<target>int2, int3, int4, and int1</target>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>These types also have vector expansions similar to float, bool, and int:</source>
					<target>These types also have vector expansions similar to float, bool, and int:</target>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>uint</source>
					<target>uint</target>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>min10float, min16float</source>
					<target>min10float, min16float</target>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>min12int, min16int</source>
					<target>min12int, min16int</target>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<segment state="initial">
					<source>min16uint</source>
					<target>min16uint</target>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509707)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/bb509568)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Vector Type</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Keywords</pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Vector Type</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Keywords</pc>.</target>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>vector is also type defined as float4 (typedef vector <ph dataRef="id1" id="ph1" />float, 4<ph dataRef="id2" id="ph2" /> vector;).</source>
					<target>vector is also type defined as float4 (typedef vector <ph dataRef="id1" id="ph1" />float, 4<ph dataRef="id2" id="ph2" /> vector;).</target>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509702)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">User-Defined Type</pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">User-Defined Type</pc>.</target>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>matrix type</source>
					<target>matrix type</target>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<segment state="initial">
					<source>mat2: 2x2 float matrix</source>
					<target>mat2: 2x2 float matrix</target>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>mat3: 3x3 float matrix</source>
					<target>mat3: 3x3 float matrix</target>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>mat4: 4x4 float matrix</source>
					<target>mat4: 4x4 float matrix</target>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<segment state="initial">
					<source>matrix type</source>
					<target>matrix type</target>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>float2x2</source>
					<target>float2x2</target>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>float3x3</source>
					<target>float3x3</target>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>float4x4</source>
					<target>float4x4</target>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>also, float1x1, float1x2, float1x3, float1x4, float2x1, float2x3, float2x4, float3x1, float3x2, float3x4, float4x1, float4x2, float4x3</source>
					<target>also, float1x1, float1x2, float1x3, float1x4, float2x1, float2x3, float2x4, float3x1, float3x2, float3x4, float4x1, float4x2, float4x3</target>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>These types also have matrix expansions similar to float:</source>
					<target>These types also have matrix expansions similar to float:</target>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>int, uint, bool</source>
					<target>int, uint, bool</target>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>min10float, min16float</source>
					<target>min10float, min16float</target>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>min12int, min16int</source>
					<target>min12int, min16int</target>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>min16uint</source>
					<target>min16uint</target>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509623)</data>
				</originalData>
				<segment state="initial">
					<source>You can also use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">matrix type</pc> to define a matrix.</source>
					<target>You can also use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">matrix type</pc> to define a matrix.</target>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>For example: matrix <ph dataRef="id1" id="ph1" />float, 2, 2<ph dataRef="id2" id="ph2" /> fMatrix = {0.0f, 0.1, 2.1f, 2.2f};</source>
					<target>For example: matrix <ph dataRef="id1" id="ph1" />float, 2, 2<ph dataRef="id2" id="ph2" /> fMatrix = {0.0f, 0.1, 2.1f, 2.2f};</target>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>matrix is also type defined as float4x4 (typedef matrix <ph dataRef="id1" id="ph1" />float, 4, 4<ph dataRef="id2" id="ph2" /> matrix;).</source>
					<target>matrix is also type defined as float4x4 (typedef matrix <ph dataRef="id1" id="ph1" />float, 4, 4<ph dataRef="id2" id="ph2" /> matrix;).</target>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509702)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">User-Defined Type</pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">User-Defined Type</pc>.</target>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>precision qualifiers for float, int, sampler</source>
					<target>precision qualifiers for float, int, sampler</target>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<segment state="initial">
					<source>highp</source>
					<target>highp</target>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>This qualifier provides minimum precision requirements that are greater than that provided by min16float and less than a full 32-bit float.</source>
					<target>This qualifier provides minimum precision requirements that are greater than that provided by min16float and less than a full 32-bit float.</target>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>Equivalent in HLSL is:</source>
					<target>Equivalent in HLSL is:</target>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<originalData>
					<data id="id1">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>highp float -<ph dataRef="id1" id="ph1" /> float</source>
					<target>highp float -<ph dataRef="id1" id="ph1" /> float</target>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<originalData>
					<data id="id1">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>highp int -<ph dataRef="id1" id="ph1" /> int</source>
					<target>highp int -<ph dataRef="id1" id="ph1" /> int</target>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>mediump</source>
					<target>mediump</target>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>This qualifier applied to float and int is equivalent to min16float and min12int in HLSL.</source>
					<target>This qualifier applied to float and int is equivalent to min16float and min12int in HLSL.</target>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>Minimum 10 bits of mantissa, not like min10float.</source>
					<target>Minimum 10 bits of mantissa, not like min10float.</target>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<segment state="initial">
					<source>lowp</source>
					<target>lowp</target>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>This qualifier applied to float provides a floating point range of -2 to 2.</source>
					<target>This qualifier applied to float provides a floating point range of -2 to 2.</target>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<segment state="initial">
					<source>Equivalent to min10float in HLSL.</source>
					<target>Equivalent to min10float in HLSL.</target>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<segment state="initial">
					<source>precision types</source>
					<target>precision types</target>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>min16float: minimum 16-bit floating point value</source>
					<target>min16float: minimum 16-bit floating point value</target>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>min10float</source>
					<target>min10float</target>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>Minimum fixed-point signed 2.8 bit value (2 bits of whole number and 8 bits fractional component).</source>
					<target>Minimum fixed-point signed 2.8 bit value (2 bits of whole number and 8 bits fractional component).</target>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<segment state="initial">
					<source>The 8-bit fractional component can be inclusive of 1 instead of exclusive to give it the full inclusive range of -2 to 2.</source>
					<target>The 8-bit fractional component can be inclusive of 1 instead of exclusive to give it the full inclusive range of -2 to 2.</target>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<segment state="initial">
					<source>min16int: minimum 16-bit signed integer</source>
					<target>min16int: minimum 16-bit signed integer</target>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>min12int: minimum 12-bit signed integer</source>
					<target>min12int: minimum 12-bit signed integer</target>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476876)</data>
				</originalData>
				<segment state="initial">
					<source>This type is for 10Level9 (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">9_x feature levels</pc>) in which integers are represented by floating point numbers.</source>
					<target>This type is for 10Level9 (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">9_x feature levels</pc>) in which integers are represented by floating point numbers.</target>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>This is the precision you can get when you emulate an integer with a 16-bit floating point number.</source>
					<target>This is the precision you can get when you emulate an integer with a 16-bit floating point number.</target>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<segment state="initial">
					<source>min16uint: minimum 16-bit unsigned integer</source>
					<target>min16uint: minimum 16-bit unsigned integer</target>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509646)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/hh968108)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Scalar Types</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Using HLSL minimum precision</pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Scalar Types</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Using HLSL minimum precision</pc>.</target>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>sampler2D</source>
					<target>sampler2D</target>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>Texture2D</source>
					<target>Texture2D</target>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>samplerCube</source>
					<target>samplerCube</target>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>TextureCube</source>
					<target>TextureCube</target>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<segment state="initial">
					<source>Porting GLSL pre-defined global variables to HLSL</source>
					<target>Porting GLSL pre-defined global variables to HLSL</target>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<segment state="initial">
					<source>Use this table to port GLSL pre-defined global variables to HLSL.</source>
					<target>Use this table to port GLSL pre-defined global variables to HLSL.</target>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<segment state="initial">
					<source>GLSL pre-defined global variable</source>
					<target>GLSL pre-defined global variable</target>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>HLSL semantics</source>
					<target>HLSL semantics</target>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<segment state="initial">
					<source>gl_Position</source>
					<target>gl_Position</target>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>This variable is type <ph dataRef="id1" id="ph1" />vec4<ph dataRef="id2" id="ph2" />.</source>
					<target>This variable is type <ph dataRef="id1" id="ph1" />vec4<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<segment state="initial">
					<source>Vertex position</source>
					<target>Vertex position</target>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<segment state="initial">
					<source>for example - gl_Position = position;</source>
					<target>for example - gl_Position = position;</target>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<segment state="initial">
					<source>SV_Position</source>
					<target>SV_Position</target>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>POSITION in Direct3D 9</source>
					<target>POSITION in Direct3D 9</target>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>This semantic is type <ph dataRef="id1" id="ph1" />float4<ph dataRef="id2" id="ph2" />.</source>
					<target>This semantic is type <ph dataRef="id1" id="ph1" />float4<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>Vertex shader output</source>
					<target>Vertex shader output</target>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<segment state="initial">
					<source>Vertex position</source>
					<target>Vertex position</target>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<segment state="initial">
					<source>for example - float4 vPosition : SV_Position;</source>
					<target>for example - float4 vPosition : SV_Position;</target>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<segment state="initial">
					<source>gl_PointSize</source>
					<target>gl_PointSize</target>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>This variable is type <ph dataRef="id1" id="ph1" />float<ph dataRef="id2" id="ph2" />.</source>
					<target>This variable is type <ph dataRef="id1" id="ph1" />float<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<segment state="initial">
					<source>Point size</source>
					<target>Point size</target>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<segment state="initial">
					<source>PSIZE</source>
					<target>PSIZE</target>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<segment state="initial">
					<source>No meaning unless you target Direct3D 9</source>
					<target>No meaning unless you target Direct3D 9</target>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>This semantic is type <ph dataRef="id1" id="ph1" />float<ph dataRef="id2" id="ph2" />.</source>
					<target>This semantic is type <ph dataRef="id1" id="ph1" />float<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<segment state="initial">
					<source>Vertex shader output</source>
					<target>Vertex shader output</target>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<segment state="initial">
					<source>Point size</source>
					<target>Point size</target>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<segment state="initial">
					<source>gl_FragColor</source>
					<target>gl_FragColor</target>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>This variable is type <ph dataRef="id1" id="ph1" />vec4<ph dataRef="id2" id="ph2" />.</source>
					<target>This variable is type <ph dataRef="id1" id="ph1" />vec4<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<segment state="initial">
					<source>Fragment color</source>
					<target>Fragment color</target>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<segment state="initial">
					<source>for example - gl_FragColor = vec4(colorVarying, 1.0);</source>
					<target>for example - gl_FragColor = vec4(colorVarying, 1.0);</target>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<segment state="initial">
					<source>SV_Target</source>
					<target>SV_Target</target>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<segment state="initial">
					<source>COLOR in Direct3D 9</source>
					<target>COLOR in Direct3D 9</target>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>This semantic is type <ph dataRef="id1" id="ph1" />float4<ph dataRef="id2" id="ph2" />.</source>
					<target>This semantic is type <ph dataRef="id1" id="ph1" />float4<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<segment state="initial">
					<source>Pixel shader output</source>
					<target>Pixel shader output</target>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<segment state="initial">
					<source>Pixel color</source>
					<target>Pixel color</target>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>for example - float4 Color[4] : SV_Target;</source>
					<target>for example - float4 Color[4] : SV_Target;</target>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<segment state="initial">
					<source>gl_FragData[n]</source>
					<target>gl_FragData[n]</target>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>This variable is type <ph dataRef="id1" id="ph1" />vec4<ph dataRef="id2" id="ph2" />.</source>
					<target>This variable is type <ph dataRef="id1" id="ph1" />vec4<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<segment state="initial">
					<source>Fragment color for color attachment n</source>
					<target>Fragment color for color attachment n</target>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<segment state="initial">
					<source>SV_Target[n]</source>
					<target>SV_Target[n]</target>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>This semantic is type <ph dataRef="id1" id="ph1" />float4<ph dataRef="id2" id="ph2" />.</source>
					<target>This semantic is type <ph dataRef="id1" id="ph1" />float4<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>Pixel shader output value that is stored in n render target, where 0 <ph dataRef="id1" id="ph1" />= n <ph dataRef="id2" id="ph2" />= 7.</source>
					<target>Pixel shader output value that is stored in n render target, where 0 <ph dataRef="id1" id="ph1" />= n <ph dataRef="id2" id="ph2" />= 7.</target>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<segment state="initial">
					<source>gl_FragCoord</source>
					<target>gl_FragCoord</target>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>This variable is type <ph dataRef="id1" id="ph1" />vec4<ph dataRef="id2" id="ph2" />.</source>
					<target>This variable is type <ph dataRef="id1" id="ph1" />vec4<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<segment state="initial">
					<source>Fragment position within frame buffer</source>
					<target>Fragment position within frame buffer</target>
				</segment>
			</unit>
			<unit id="311" translate="yes">
				<segment state="initial">
					<source>SV_Position</source>
					<target>SV_Position</target>
				</segment>
			</unit>
			<unit id="312" translate="yes">
				<segment state="initial">
					<source>Not available in Direct3D 9</source>
					<target>Not available in Direct3D 9</target>
				</segment>
			</unit>
			<unit id="313" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>This semantic is type <ph dataRef="id1" id="ph1" />float4<ph dataRef="id2" id="ph2" />.</source>
					<target>This semantic is type <ph dataRef="id1" id="ph1" />float4<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="314" translate="yes">
				<segment state="initial">
					<source>Pixel shader input</source>
					<target>Pixel shader input</target>
				</segment>
			</unit>
			<unit id="315" translate="yes">
				<segment state="initial">
					<source>Screen space coordinates</source>
					<target>Screen space coordinates</target>
				</segment>
			</unit>
			<unit id="316" translate="yes">
				<segment state="initial">
					<source>for example - float4 screenSpace : SV_Position</source>
					<target>for example - float4 screenSpace : SV_Position</target>
				</segment>
			</unit>
			<unit id="317" translate="yes">
				<segment state="initial">
					<source>gl_FrontFacing</source>
					<target>gl_FrontFacing</target>
				</segment>
			</unit>
			<unit id="318" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>This variable is type <ph dataRef="id1" id="ph1" />bool<ph dataRef="id2" id="ph2" />.</source>
					<target>This variable is type <ph dataRef="id1" id="ph1" />bool<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="319" translate="yes">
				<segment state="initial">
					<source>Determines whether fragment belongs to a front-facing primitive.</source>
					<target>Determines whether fragment belongs to a front-facing primitive.</target>
				</segment>
			</unit>
			<unit id="320" translate="yes">
				<segment state="initial">
					<source>SV_IsFrontFace</source>
					<target>SV_IsFrontFace</target>
				</segment>
			</unit>
			<unit id="321" translate="yes">
				<segment state="initial">
					<source>VFACE in Direct3D 9</source>
					<target>VFACE in Direct3D 9</target>
				</segment>
			</unit>
			<unit id="322" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>SV_IsFrontFace is type <ph dataRef="id1" id="ph1" />bool<ph dataRef="id2" id="ph2" />.</source>
					<target>SV_IsFrontFace is type <ph dataRef="id1" id="ph1" />bool<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="323" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>VFACE is type <ph dataRef="id1" id="ph1" />float<ph dataRef="id2" id="ph2" />.</source>
					<target>VFACE is type <ph dataRef="id1" id="ph1" />float<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="324" translate="yes">
				<segment state="initial">
					<source>Pixel shader input</source>
					<target>Pixel shader input</target>
				</segment>
			</unit>
			<unit id="325" translate="yes">
				<segment state="initial">
					<source>Primitive facing</source>
					<target>Primitive facing</target>
				</segment>
			</unit>
			<unit id="326" translate="yes">
				<segment state="initial">
					<source>gl_PointCoord</source>
					<target>gl_PointCoord</target>
				</segment>
			</unit>
			<unit id="327" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>This variable is type <ph dataRef="id1" id="ph1" />vec2<ph dataRef="id2" id="ph2" />.</source>
					<target>This variable is type <ph dataRef="id1" id="ph1" />vec2<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="328" translate="yes">
				<segment state="initial">
					<source>Fragment position within a point (point rasterization only)</source>
					<target>Fragment position within a point (point rasterization only)</target>
				</segment>
			</unit>
			<unit id="329" translate="yes">
				<segment state="initial">
					<source>SV_Position</source>
					<target>SV_Position</target>
				</segment>
			</unit>
			<unit id="330" translate="yes">
				<segment state="initial">
					<source>VPOS in Direct3D 9</source>
					<target>VPOS in Direct3D 9</target>
				</segment>
			</unit>
			<unit id="331" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>SV_Position is type <ph dataRef="id1" id="ph1" />float4<ph dataRef="id2" id="ph2" />.</source>
					<target>SV_Position is type <ph dataRef="id1" id="ph1" />float4<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="332" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>VPOS is type <ph dataRef="id1" id="ph1" />float2<ph dataRef="id2" id="ph2" />.</source>
					<target>VPOS is type <ph dataRef="id1" id="ph1" />float2<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="333" translate="yes">
				<segment state="initial">
					<source>Pixel shader input</source>
					<target>Pixel shader input</target>
				</segment>
			</unit>
			<unit id="334" translate="yes">
				<segment state="initial">
					<source>The pixel or sample position in screen space</source>
					<target>The pixel or sample position in screen space</target>
				</segment>
			</unit>
			<unit id="335" translate="yes">
				<segment state="initial">
					<source>for example - float4 pos : SV_Position</source>
					<target>for example - float4 pos : SV_Position</target>
				</segment>
			</unit>
			<unit id="336" translate="yes">
				<segment state="initial">
					<source>gl_FragDepth</source>
					<target>gl_FragDepth</target>
				</segment>
			</unit>
			<unit id="337" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>This variable is type <ph dataRef="id1" id="ph1" />float<ph dataRef="id2" id="ph2" />.</source>
					<target>This variable is type <ph dataRef="id1" id="ph1" />float<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="338" translate="yes">
				<segment state="initial">
					<source>Depth buffer data</source>
					<target>Depth buffer data</target>
				</segment>
			</unit>
			<unit id="339" translate="yes">
				<segment state="initial">
					<source>SV_Depth</source>
					<target>SV_Depth</target>
				</segment>
			</unit>
			<unit id="340" translate="yes">
				<segment state="initial">
					<source>DEPTH in Direct3D 9</source>
					<target>DEPTH in Direct3D 9</target>
				</segment>
			</unit>
			<unit id="341" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>SV_Depth is type <ph dataRef="id1" id="ph1" />float<ph dataRef="id2" id="ph2" />.</source>
					<target>SV_Depth is type <ph dataRef="id1" id="ph1" />float<ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="342" translate="yes">
				<segment state="initial">
					<source>Pixel shader output</source>
					<target>Pixel shader output</target>
				</segment>
			</unit>
			<unit id="343" translate="yes">
				<segment state="initial">
					<source>Depth buffer data</source>
					<target>Depth buffer data</target>
				</segment>
			</unit>
			<unit id="344" translate="yes">
				<segment state="initial">
					<source>You use semantics to specify position, color, and so on for vertex shader input and pixel shader input.</source>
					<target>You use semantics to specify position, color, and so on for vertex shader input and pixel shader input.</target>
				</segment>
			</unit>
			<unit id="345" translate="yes">
				<segment state="initial">
					<source>You must match the semantics values in the input layout with the vertex shader input.</source>
					<target>You must match the semantics values in the input layout with the vertex shader input.</target>
				</segment>
			</unit>
			<unit id="346" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#example1)</data>
				</originalData>
				<segment state="initial">
					<source>For examples, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Examples of porting GLSL variables to HLSL</pc>.</source>
					<target>For examples, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Examples of porting GLSL variables to HLSL</pc>.</target>
				</segment>
			</unit>
			<unit id="347" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509647)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about the HLSL semantics, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Semantics</pc>.</source>
					<target>For more info about the HLSL semantics, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Semantics</pc>.</target>
				</segment>
			</unit>
			<unit id="348" translate="yes">
				<segment state="initial">
					<source>Examples of porting GLSL variables to HLSL</source>
					<target>Examples of porting GLSL variables to HLSL</target>
				</segment>
			</unit>
			<unit id="349" translate="yes">
				<segment state="initial">
					<source>Here we show examples of using GLSL variables in OpenGL/GLSL code and then the equivalent example in Direct3D/HLSL code.</source>
					<target>Here we show examples of using GLSL variables in OpenGL/GLSL code and then the equivalent example in Direct3D/HLSL code.</target>
				</segment>
			</unit>
			<unit id="350" translate="yes">
				<segment state="initial">
					<source>Uniform, attribute, and varying in GLSL</source>
					<target>Uniform, attribute, and varying in GLSL</target>
				</segment>
			</unit>
			<unit id="351" translate="yes">
				<segment state="initial">
					<source>OpenGL app code</source>
					<target>OpenGL app code</target>
				</segment>
			</unit>
			<unit id="352" translate="yes">
				<segment state="initial">
					<source>GLSL vertex shader code</source>
					<target>GLSL vertex shader code</target>
				</segment>
			</unit>
			<unit id="353" translate="yes">
				<segment state="initial">
					<source>GLSL fragment shader code</source>
					<target>GLSL fragment shader code</target>
				</segment>
			</unit>
			<unit id="354" translate="yes">
				<segment state="initial">
					<source>Constant buffers and data transfers in HLSL</source>
					<target>Constant buffers and data transfers in HLSL</target>
				</segment>
			</unit>
			<unit id="355" translate="yes">
				<segment state="initial">
					<source>Here is an example of how you pass data to the HLSL vertex shader that then flows through to the pixel shader.</source>
					<target>Here is an example of how you pass data to the HLSL vertex shader that then flows through to the pixel shader.</target>
				</segment>
			</unit>
			<unit id="356" translate="yes">
				<segment state="initial">
					<source>In your app code, define a vertex and a constant buffer.</source>
					<target>In your app code, define a vertex and a constant buffer.</target>
				</segment>
			</unit>
			<unit id="357" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509581)</data>
				</originalData>
				<segment state="initial">
					<source>Then, in your vertex shader code, define the constant buffer as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">cbuffer</pc> and store the per-vertex data and the pixel shader input data.</source>
					<target>Then, in your vertex shader code, define the constant buffer as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">cbuffer</pc> and store the per-vertex data and the pixel shader input data.</target>
				</segment>
			</unit>
			<unit id="358" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Here we use structures called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">VertexShaderInput</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">PixelShaderInput</pc>.</source>
					<target>Here we use structures called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">VertexShaderInput</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">PixelShaderInput</pc>.</target>
				</segment>
			</unit>
			<unit id="359" translate="yes">
				<segment state="initial">
					<source>Direct3D app code</source>
					<target>Direct3D app code</target>
				</segment>
			</unit>
			<unit id="360" translate="yes">
				<segment state="initial">
					<source>HLSL vertex shader code</source>
					<target>HLSL vertex shader code</target>
				</segment>
			</unit>
			<unit id="361" translate="yes">
				<segment state="initial">
					<source>HLSL pixel shader code</source>
					<target>HLSL pixel shader code</target>
				</segment>
			</unit>
			<unit id="362" translate="yes">
				<segment state="initial">
					<source>Examples of porting OpenGL rendering code to Direct3D</source>
					<target>Examples of porting OpenGL rendering code to Direct3D</target>
				</segment>
			</unit>
			<unit id="363" translate="yes">
				<segment state="initial">
					<source>Here we show an example of rendering in OpenGL ES 2.0 code and then the equivalent example in Direct3D 11 code.</source>
					<target>Here we show an example of rendering in OpenGL ES 2.0 code and then the equivalent example in Direct3D 11 code.</target>
				</segment>
			</unit>
			<unit id="364" translate="yes">
				<segment state="initial">
					<source>OpenGL rendering code</source>
					<target>OpenGL rendering code</target>
				</segment>
			</unit>
			<unit id="365" translate="yes">
				<segment state="initial">
					<source>Direct3D rendering code</source>
					<target>Direct3D rendering code</target>
				</segment>
			</unit>
			<unit id="366" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
					<target>Related topics</target>
				</segment>
			</unit>
			<unit id="367" translate="yes">
				<segment state="initial">
					<source>Port from OpenGL ES 2.0 to Direct3D 11</source>
					<target>Port from OpenGL ES 2.0 to Direct3D 11</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>