<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="it-it" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">6d5eb84a3884e57f72357a48f04826174179a709</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\marble-maze-sample-fundamentals.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">e056d2deded4d4d1229bf49e02138470519d21b9</mda:meta><mda:meta type="olxliffhash">2c05e73c294be8773173b8a0881c1305c0a9f957</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Marble Maze sample fundamentals</source>
					<target>Marble Maze sample fundamentals</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>This document describes the fundamental characteristics of the Marble Maze project, for example, how it uses Visual C++ in the Windows Runtime environment, how it is created and structured, and how it is built.</source>
					<target>This document describes the fundamental characteristics of the Marble Maze project, for example, how it uses Visual C++ in the Windows Runtime environment, how it is created and structured, and how it is built.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Marble Maze sample fundamentals</source>
					<target>Marble Maze sample fundamentals</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>This document describes the fundamental characteristics of the Marble Maze project, for example, how it uses Visual C++ in the Windows Runtime environment, how it is created and structured, and how it is built.</source>
					<target>This document describes the fundamental characteristics of the Marble Maze project, for example, how it uses Visual C++ in the Windows Runtime environment, how it is created and structured, and how it is built.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>The document also describes several of the conventions that are used in the code.</source>
					<target>The document also describes several of the conventions that are used in the code.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](http://go.microsoft.com/fwlink/?LinkId=624011)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The sample code that corresponds to this document is found in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectX Marble Maze game sample</pc>.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The sample code that corresponds to this document is found in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectX Marble Maze game sample</pc>.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Here are some of the key points that this document discusses for when you plan and develop your Universal Windows Platform (UWP) game.</source>
					<target>Here are some of the key points that this document discusses for when you plan and develop your Universal Windows Platform (UWP) game.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectX 11 App (Universal Windows)</pc> template in a C++ application to create your DirectX UWP game.</source>
					<target>Use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectX 11 App (Universal Windows)</pc> template in a C++ application to create your DirectX UWP game.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>Use Visual Studio to build a UWP app project as you would build a standard project.</source>
					<target>Use Visual Studio to build a UWP app project as you would build a standard project.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>The Windows Runtime provides classes and interfaces so that you can develop UWP apps in a more modern, object-oriented manner.</source>
					<target>The Windows Runtime provides classes and interfaces so that you can develop UWP apps in a more modern, object-oriented manner.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br244983.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/bb982026.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/ee410601.aspx)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>Use object references with the hat (^) symbol to manage the lifetime of Windows Runtime variables, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Microsoft::WRL::ComPtr</pc></pc> to manage the lifetime of COM objects, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">std::shared\_ptr</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">std::unique\_ptr</pc></pc> to manage the lifetime of all other heap-allocated C++ objects.</source>
					<target>Use object references with the hat (^) symbol to manage the lifetime of Windows Runtime variables, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Microsoft::WRL::ComPtr</pc></pc> to manage the lifetime of COM objects, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">std::shared\_ptr</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">std::unique\_ptr</pc></pc> to manage the lifetime of all other heap-allocated C++ objects.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>In most cases, use exception handling, instead of result codes, to deal with unexpected errors.</source>
					<target>In most cases, use exception handling, instead of result codes, to deal with unexpected errors.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>Use SAL annotations together with code analysis tools to help discover errors in your app.</source>
					<target>Use SAL annotations together with code analysis tools to help discover errors in your app.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Creating the Visual Studio project</source>
					<target>Creating the Visual Studio project</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>If you've downloaded and extracted the sample, you can open the MarbleMaze.sln solution file in Visual Studio, and you'll have the code in front of you.</source>
					<target>If you've downloaded and extracted the sample, you can open the MarbleMaze.sln solution file in Visual Studio, and you'll have the code in front of you.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/?LinkId=624011)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can also view the source on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectX Marble Maze game sample</pc> MSDN Samples Gallery page by selecting the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Browse Code</pc> tab.</source>
					<target>You can also view the source on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectX Marble Maze game sample</pc> MSDN Samples Gallery page by selecting the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Browse Code</pc> tab.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>When we created the Visual Studio project for Marble Maze, we started with an existing project.</source>
					<target>When we created the Visual Studio project for Marble Maze, we started with an existing project.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>However, if you do not already have an existing project that provides the basic functionality that your DirectX UWP game requires, we recommend that you create a project based on the Visual Studio <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectX 11 App (Universal Windows)</pc> template because it provides a basic working 3-D application.</source>
					<target>However, if you do not already have an existing project that provides the basic functionality that your DirectX UWP game requires, we recommend that you create a project based on the Visual Studio <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectX 11 App (Universal Windows)</pc> template because it provides a basic working 3-D application.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>One important project setting in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectX 11 App (Universal Windows)</pc> template is the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">/ZW</pc> option, which enables the program to use the Windows Runtime language extensions.</source>
					<target>One important project setting in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectX 11 App (Universal Windows)</pc> template is the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">/ZW</pc> option, which enables the program to use the Windows Runtime language extensions.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>This option is enabled by default when you use the Visual Studio template.</source>
					<target>This option is enabled by default when you use the Visual Studio template.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>   The <pc dataRefEnd="id4" dataRefStart="id3" id="p2">/ZW</pc> option is not compatible with options such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3">/clr</pc>.In the case of <pc dataRefEnd="id8" dataRefStart="id7" id="p4">/clr</pc>, this means that you cannot target both the .NET Framework and the Windows Runtime from the same Visual C++ project.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>   The <pc dataRefEnd="id4" dataRefStart="id3" id="p2">/ZW</pc> option is not compatible with options such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3">/clr</pc>.In the case of <pc dataRefEnd="id8" dataRefStart="id7" id="p4">/clr</pc>, this means that you cannot target both the .NET Framework and the Windows Runtime from the same Visual C++ project.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Every UWP app that you acquire from the Windows Store comes in the form of an app package.</source>
					<target>Every UWP app that you acquire from the Windows Store comes in the form of an app package.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>An app package contains a package manifest, which contains information about your app.</source>
					<target>An app package contains a package manifest, which contains information about your app.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>For example, you can specify the capabilities (that is, the required access to protected system resources or user data) of your app.</source>
					<target>For example, you can specify the capabilities (that is, the required access to protected system resources or user data) of your app.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>If you determine that your app requires certain capabilities, use the package manifest to declare the required capabilities.</source>
					<target>If you determine that your app requires certain capabilities, use the package manifest to declare the required capabilities.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>The manifest also lets you specify project properties such as supported device rotations, tile images, and the splash screen.</source>
					<target>The manifest also lets you specify project properties such as supported device rotations, tile images, and the splash screen.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt270969)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about app packages, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Packaging apps</pc>.</source>
					<target>For more info about app packages, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Packaging apps</pc>.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>Building, deploying, and running the game</source>
					<target>Building, deploying, and running the game</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Build a UWP app project as you would build a standard project.</source>
					<target>Build a UWP app project as you would build a standard project.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>(On the menu bar, choose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Build, Build Solution</pc>.) The build step compiles the code and also packages it for use as a UWP app.</source>
					<target>(On the menu bar, choose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Build, Build Solution</pc>.) The build step compiles the code and also packages it for use as a UWP app.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>After you build the project, you must deploy it.(On the menu bar, choose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Build, Deploy Solution</pc>.) Visual Studio also deploys the project when you run the game from the debugger.</source>
					<target>After you build the project, you must deploy it.(On the menu bar, choose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Build, Deploy Solution</pc>.) Visual Studio also deploys the project when you run the game from the debugger.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>After you deploy the project, pick the Marble Maze tile to run the game.</source>
					<target>After you deploy the project, pick the Marble Maze tile to run the game.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Alternatively, from Visual Studio, on the menu bar, choose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Debug, Start Debugging</pc>.</source>
					<target>Alternatively, from Visual Studio, on the menu bar, choose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Debug, Start Debugging</pc>.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>Controlling the game</source>
					<target>Controlling the game</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>You can use touch, the accelerometer, the Xbox 360 controller, or the mouse to control Marble Maze.</source>
					<target>You can use touch, the accelerometer, the Xbox 360 controller, or the mouse to control Marble Maze.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Use the directional pad on the controller to change the active menu item.</source>
					<target>Use the directional pad on the controller to change the active menu item.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>Use touch, the A button, the Start button, or the mouse to pick a menu item.</source>
					<target>Use touch, the A button, the Start button, or the mouse to pick a menu item.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Use touch, the accelerometer, the left thumbstick, or the mouse to tilt the maze.</source>
					<target>Use touch, the accelerometer, the left thumbstick, or the mouse to tilt the maze.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Use touch, the A button, the Start button, or the mouse to close menus such as the high score table.</source>
					<target>Use touch, the A button, the Start button, or the mouse to close menus such as the high score table.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>Use the Start button or the P key to pause or resume the game.</source>
					<target>Use the Start button or the P key to pause or resume the game.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>Use the Back button on the controller or the Home key on the keyboard to restart the game.</source>
					<target>Use the Back button on the controller or the Home key on the keyboard to restart the game.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>When the high-score table is visible, use the Back button or Home key to clear all scores.</source>
					<target>When the high-score table is visible, use the Back button or Home key to clear all scores.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>Code conventions</source>
					<target>Code conventions</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>The Windows Runtime is a programming interface that you can use to create UWP apps that run only in a special application environment.</source>
					<target>The Windows Runtime is a programming interface that you can use to create UWP apps that run only in a special application environment.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Such apps use authorized functions, data types, and devices, and are distributed from the Windows Store.</source>
					<target>Such apps use authorized functions, data types, and devices, and are distributed from the Windows Store.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>At the lowest level, the Windows Runtime consists of an Application Binary Interface (ABI).</source>
					<target>At the lowest level, the Windows Runtime consists of an Application Binary Interface (ABI).</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>The ABI is a low-level binary contract that makes Windows Runtime APIs accessible to multiple programming languages such as JavaScript, the .NET languages, and Visual C++.</source>
					<target>The ABI is a low-level binary contract that makes Windows Runtime APIs accessible to multiple programming languages such as JavaScript, the .NET languages, and Visual C++.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>In order to call Windows Runtime APIs from JavaScript and .NET, those languages require projections that are specific to each language environment.</source>
					<target>In order to call Windows Runtime APIs from JavaScript and .NET, those languages require projections that are specific to each language environment.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>When you call a Windows Runtime API from JavaScript or .NET, you are invoking the projection, which in turn calls the underlying ABI function.</source>
					<target>When you call a Windows Runtime API from JavaScript or .NET, you are invoking the projection, which in turn calls the underlying ABI function.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>Although you can call the ABI functions directly in C++, Microsoft provides projections for C++ as well, because they make it much simpler to consume the Windows Runtime APIs, while still maintaining high performance.</source>
					<target>Although you can call the ABI functions directly in C++, Microsoft provides projections for C++ as well, because they make it much simpler to consume the Windows Runtime APIs, while still maintaining high performance.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>Microsoft also provides language extensions to Visual C++ that specifically support the Windows Runtime projections.</source>
					<target>Microsoft also provides language extensions to Visual C++ that specifically support the Windows Runtime projections.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Many of these language extensions resemble the syntax for the C++/CLI language.</source>
					<target>Many of these language extensions resemble the syntax for the C++/CLI language.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>However, instead of targeting the common language runtime (CLR), native apps use this syntax to target the Windows Runtime.</source>
					<target>However, instead of targeting the common language runtime (CLR), native apps use this syntax to target the Windows Runtime.</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>The object reference, or hat (^), modifier is an important part of this new syntax because it enables the automatic deletion of runtime objects by means of reference counting.</source>
					<target>The object reference, or hat (^), modifier is an important part of this new syntax because it enables the automatic deletion of runtime objects by means of reference counting.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Instead of calling methods such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AddRef</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Release</pc> to manage the lifetime of a Windows Runtime object, the runtime deletes the object when no other component references it, for example, when it leaves scope or you set all references to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">nullptr</pc>.</source>
					<target>Instead of calling methods such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AddRef</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Release</pc> to manage the lifetime of a Windows Runtime object, the runtime deletes the object when no other component references it, for example, when it leaves scope or you set all references to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">nullptr</pc>.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Another important part of using Visual C++ to create UWP apps is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ref new</pc> keyword.</source>
					<target>Another important part of using Visual C++ to create UWP apps is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ref new</pc> keyword.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ref new</pc> instead of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">new</pc> to create reference-counted Windows Runtime objects.</source>
					<target>Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ref new</pc> instead of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">new</pc> to create reference-counted Windows Runtime objects.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh755822)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Type System (C++/CX)</pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Type System (C++/CX)</pc>.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>Important</source>
					<target>Important</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">^</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
				</originalData>
				<segment state="initial">
					<source>You only have to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><ph dataRef="id3" id="ph1" /></pc> and <pc dataRefEnd="id5" dataRefStart="id4" id="p2">ref new</pc> when you create Windows Runtime objects or create Windows Runtime components.</source>
					<target>You only have to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><ph dataRef="id3" id="ph1" /></pc> and <pc dataRefEnd="id5" dataRefStart="id4" id="p2">ref new</pc> when you create Windows Runtime objects or create Windows Runtime components.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>You can use the standard C++ syntax when you write core application code that does not use the Windows Runtime.</source>
					<target>You can use the standard C++ syntax when you write core application code that does not use the Windows Runtime.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">^</data>
					<data id="id4">[</data>
					<data id="id5">](https://msdn.microsoft.com/library/windows/apps/br244983.aspx)</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
				</originalData>
				<segment state="initial">
					<source>Marble Maze uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><ph dataRef="id3" id="ph1" /></pc> together with <pc dataRefEnd="id5" dataRefStart="id4" id="p2"><pc dataRefEnd="id7" dataRefStart="id6" id="p3">Microsoft::WRL::ComPtr</pc></pc> to manage heap-allocated objects and minimize memory leaks.</source>
					<target>Marble Maze uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><ph dataRef="id3" id="ph1" /></pc> together with <pc dataRefEnd="id5" dataRefStart="id4" id="p2"><pc dataRefEnd="id7" dataRefStart="id6" id="p3">Microsoft::WRL::ComPtr</pc></pc> to manage heap-allocated objects and minimize memory leaks.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/bb982026)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/ee410601)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>We recommend that you use ^ to manage the lifetime of Windows Runtime variables, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ComPtr</pc> to manage the lifetime of COM variables (such as when you use DirectX), and std::<pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">std::shared\_ptr</pc></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">std::unique\_ptr</pc></pc> to manage the lifetime of all other heap-allocated C++ objects.</source>
					<target>We recommend that you use ^ to manage the lifetime of Windows Runtime variables, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ComPtr</pc> to manage the lifetime of COM variables (such as when you use DirectX), and std::<pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">std::shared\_ptr</pc></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">std::unique\_ptr</pc></pc> to manage the lifetime of all other heap-allocated C++ objects.</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh699871)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about the language extensions that are available to a C++ UWP app, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Visual C++ Language Reference (C++/CX)</pc>.</source>
					<target>For more info about the language extensions that are available to a C++ UWP app, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Visual C++ Language Reference (C++/CX)</pc>.</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Error handling</source>
					<target>Error handling</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>Marble Maze uses exception handling as the primary way to deal with unexpected errors.</source>
					<target>Marble Maze uses exception handling as the primary way to deal with unexpected errors.</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Although game code traditionally uses logging or error codes, such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HRESULT</pc> values, to indicate errors, exception handling has two main advantages.</source>
					<target>Although game code traditionally uses logging or error codes, such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HRESULT</pc> values, to indicate errors, exception handling has two main advantages.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>First, it can make the code easier to read and maintain.</source>
					<target>First, it can make the code easier to read and maintain.</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>From a code perspective, exception handling is a more efficient way to propagate an error to a routine that can handle that error.</source>
					<target>From a code perspective, exception handling is a more efficient way to propagate an error to a routine that can handle that error.</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>The use of error codes typically requires each function to explicitly propagate errors.</source>
					<target>The use of error codes typically requires each function to explicitly propagate errors.</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>A second advantage is that you can configure the Visual Studio debugger to break when an exception occurs so that you can stop immediately at the location and context of the error.</source>
					<target>A second advantage is that you can configure the Visual Studio debugger to break when an exception occurs so that you can stop immediately at the location and context of the error.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>The Windows Runtime also uses exception handling extensively.</source>
					<target>The Windows Runtime also uses exception handling extensively.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>Therefore, by using exception handling in your code, you can combine all error handling into one model.</source>
					<target>Therefore, by using exception handling in your code, you can combine all error handling into one model.</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>We recommend that you use the following conventions in your error handling model:</source>
					<target>We recommend that you use the following conventions in your error handling model:</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>Use exceptions to communicate unexpected errors.</source>
					<target>Use exceptions to communicate unexpected errors.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>Do not use exceptions to control the flow of code.</source>
					<target>Do not use exceptions to control the flow of code.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>Catch only the exceptions that you can safely handle and recover from.</source>
					<target>Catch only the exceptions that you can safely handle and recover from.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>Otherwise, do not catch the exception and allow the app to terminate.</source>
					<target>Otherwise, do not catch the exception and allow the app to terminate.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When you call a DirectX routine that returns <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HRESULT</pc>, use the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DX::ThrowIfFailed</pc> function.</source>
					<target>When you call a DirectX routine that returns <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HRESULT</pc>, use the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DX::ThrowIfFailed</pc> function.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This function is defined in DirectXSample.h.<pc dataRefEnd="id2" dataRefStart="id1" id="p1">ThrowIfFailed</pc> throws an exception if the provided <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HRESULT</pc> is an error code.</source>
					<target>This function is defined in DirectXSample.h.<pc dataRefEnd="id2" dataRefStart="id1" id="p1">ThrowIfFailed</pc> throws an exception if the provided <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HRESULT</pc> is an error code.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh755823.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">E\_POINTER</pc> causes <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ThrowIfFailed</pc> to throw <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Platform::NullReferenceException</pc></pc>.</source>
					<target>For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">E\_POINTER</pc> causes <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ThrowIfFailed</pc> to throw <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Platform::NullReferenceException</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ThrowIfFailed</pc>, put the DirectX call on a separate line to help improve code readability, as shown in the following example.</source>
					<target>When you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ThrowIfFailed</pc>, put the DirectX call on a separate line to help improve code readability, as shown in the following example.</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Although we recommend that you avoid the use of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HRESULT</pc> for unexpected errors , it is more important to avoid the use of exception handling to control the flow of code.</source>
					<target>Although we recommend that you avoid the use of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HRESULT</pc> for unexpected errors , it is more important to avoid the use of exception handling to control the flow of code.</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Therefore, it is preferred to use an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HRESULT</pc> return value when necessary to control the flow of code.</source>
					<target>Therefore, it is preferred to use an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HRESULT</pc> return value when necessary to control the flow of code.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>SAL annotations</source>
					<target>SAL annotations</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Use SAL annotations together with code analysis tools to help discover errors in your app.</source>
					<target>Use SAL annotations together with code analysis tools to help discover errors in your app.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>By using Microsoft source-code annotation language (SAL), you can annotate, or describe, how a function uses its parameters.</source>
					<target>By using Microsoft source-code annotation language (SAL), you can annotate, or describe, how a function uses its parameters.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>SAL annotations also describe return values.</source>
					<target>SAL annotations also describe return values.</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>SAL annotations work with the C/C++ Code Analysis tool to discover possible defects in C and C++ source code.</source>
					<target>SAL annotations work with the C/C++ Code Analysis tool to discover possible defects in C and C++ source code.</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>Common coding errors reported by the tool include buffer overruns, uninitialized memory, null pointer dereferences, and memory and resource leaks.</source>
					<target>Common coding errors reported by the tool include buffer overruns, uninitialized memory, null pointer dereferences, and memory and resource leaks.</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Consider the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicLoader::LoadMesh</pc> method, which is declared in BasicLoader.h.</source>
					<target>Consider the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicLoader::LoadMesh</pc> method, which is declared in BasicLoader.h.</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
					<data id="id7">*</data>
					<data id="id8">*</data>
					<data id="id9">*</data>
					<data id="id10">*</data>
				</originalData>
				<segment state="initial">
					<source>This method uses \_In\_ to specify that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">filename</pc> is an input parameter (and therefore will only be read from), \_Out\_ to specify that <pc dataRefEnd="id4" dataRefStart="id3" id="p2">vertexBuffer</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">indexBuffer</pc> are output parameters (and therefore will only be written to), and \_Out\_opt\_ to specify that <pc dataRefEnd="id8" dataRefStart="id7" id="p4">vertexCount</pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5">indexCount</pc> are optional output parameters (and might be written to).</source>
					<target>This method uses \_In\_ to specify that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">filename</pc> is an input parameter (and therefore will only be read from), \_Out\_ to specify that <pc dataRefEnd="id4" dataRefStart="id3" id="p2">vertexBuffer</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">indexBuffer</pc> are output parameters (and therefore will only be written to), and \_Out\_opt\_ to specify that <pc dataRefEnd="id8" dataRefStart="id7" id="p4">vertexCount</pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5">indexCount</pc> are optional output parameters (and might be written to).</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Because <pc dataRefEnd="id2" dataRefStart="id1" id="p1">vertexCount</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">indexCount</pc> are optional output parameters, they are allowed to be <pc dataRefEnd="id6" dataRefStart="id5" id="p3">nullptr</pc>.</source>
					<target>Because <pc dataRefEnd="id2" dataRefStart="id1" id="p1">vertexCount</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">indexCount</pc> are optional output parameters, they are allowed to be <pc dataRefEnd="id6" dataRefStart="id5" id="p3">nullptr</pc>.</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>The C/C++ Code Analysis tool examines calls to this method to ensure that the parameters it passes meet these criteria.</source>
					<target>The C/C++ Code Analysis tool examines calls to this method to ensure that the parameters it passes meet these criteria.</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>To perform code analysis on your app, on the menu bar, choose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Build, Run Code Analysis on Solution</pc>.</source>
					<target>To perform code analysis on your app, on the menu bar, choose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Build, Run Code Analysis on Solution</pc>.</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/ms182025.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about code analysis, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Analyzing C/C++ Code Quality by Using Code Analysis</pc>.</source>
					<target>For more info about code analysis, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Analyzing C/C++ Code Quality by Using Code Analysis</pc>.</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>The complete list of available annotations is defined in sal.h.</source>
					<target>The complete list of available annotations is defined in sal.h.</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/ms235402.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SAL Annotations</pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SAL Annotations</pc>.</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>Next steps</source>
					<target>Next steps</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](marble-maze-application-structure.md)</data>
				</originalData>
				<segment state="initial">
					<source>Read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Marble Maze application structure</pc> for information about how the Marble Maze application code is structured and how the structure of a DirectX UWP app differs from that of a traditional desktop application.</source>
					<target>Read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Marble Maze application structure</pc> for information about how the Marble Maze application code is structured and how the structure of a DirectX UWP app differs from that of a traditional desktop application.</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
					<target>Related topics</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>Marble Maze application structure</source>
					<target>Marble Maze application structure</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>Developing Marble Maze, a UWP game in C++ and DirectX</source>
					<target>Developing Marble Maze, a UWP game in C++ and DirectX</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>