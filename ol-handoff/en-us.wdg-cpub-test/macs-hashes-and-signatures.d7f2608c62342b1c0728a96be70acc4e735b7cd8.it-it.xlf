<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="it-it" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-2eb3c86</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">cdc04311c9989db87d4179f91c0f2480f15c7f57</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\security\macs-hashes-and-signatures.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">c83966fb862ad0d7425861f50769578b12dd79d2</mda:meta><mda:meta type="olxliffhash">06ae3d22e8dc45b109c29c2feb6a72ffdf841ae1</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>MACs, hashes, and signatures</source>
					<target>MACs, hashes, and signatures</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>This article discusses how message authentication codes (MACs), hashes, and signatures can be used in Universal Windows Platform (UWP) apps to detect message tampering.</source>
					<target>This article discusses how message authentication codes (MACs), hashes, and signatures can be used in Universal Windows Platform (UWP) apps to detect message tampering.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>MACs, hashes, and signatures</source>
					<target>MACs, hashes, and signatures</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>This article discusses how message authentication codes (MACs), hashes, and signatures can be used in Universal Windows Platform (UWP) apps to detect message tampering.</source>
					<target>This article discusses how message authentication codes (MACs), hashes, and signatures can be used in Universal Windows Platform (UWP) apps to detect message tampering.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Message authentication codes (MACs)</source>
					<target>Message authentication codes (MACs)</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>Encryption helps prevent an unauthorized individual from reading a message, but it does not prevent that individual from tampering with the message.</source>
					<target>Encryption helps prevent an unauthorized individual from reading a message, but it does not prevent that individual from tampering with the message.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>An altered message, even if the alteration results in nothing but nonsense, can have real costs.</source>
					<target>An altered message, even if the alteration results in nothing but nonsense, can have real costs.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>A message authentication code (MAC) helps prevent message tampering.</source>
					<target>A message authentication code (MAC) helps prevent message tampering.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>For example, consider the following scenario:</source>
					<target>For example, consider the following scenario:</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>Bob and Alice share a secret key and agree on a MAC function to use.</source>
					<target>Bob and Alice share a secret key and agree on a MAC function to use.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Bob creates a message and inputs the message and the secret key into a MAC function to retrieve a MAC value.</source>
					<target>Bob creates a message and inputs the message and the secret key into a MAC function to retrieve a MAC value.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Bob sends the \[unencrypted\] message and the MAC value to Alice over a network.</source>
					<target>Bob sends the \[unencrypted\] message and the MAC value to Alice over a network.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>Alice uses the secret key and the message as input to the MAC function.</source>
					<target>Alice uses the secret key and the message as input to the MAC function.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>She compares the generated MAC value to the MAC value sent by Bob.</source>
					<target>She compares the generated MAC value to the MAC value sent by Bob.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>If they are the same, the message was not changed in transit.</source>
					<target>If they are the same, the message was not changed in transit.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Note that Eve, a third party eavesdropping on the conversation between Bob and Alice, cannot effectively manipulate the message.</source>
					<target>Note that Eve, a third party eavesdropping on the conversation between Bob and Alice, cannot effectively manipulate the message.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>Eve does not have access to the private key and cannot, therefore, create a MAC value which would make the tampered message appear legitimate to Alice.</source>
					<target>Eve does not have access to the private key and cannot, therefore, create a MAC value which would make the tampered message appear legitimate to Alice.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Creating a message authentication code ensures only that the original message was not altered and, by using a shared secret key, that the message hash was signed by someone with access to that private key.</source>
					<target>Creating a message authentication code ensures only that the original message was not altered and, by using a shared secret key, that the message hash was signed by someone with access to that private key.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241530)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MacAlgorithmProvider</pc></pc> to enumerate the available MAC algorithms and generate a symmetric key.</source>
					<target>You can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MacAlgorithmProvider</pc></pc> to enumerate the available MAC algorithms and generate a symmetric key.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241490)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use static methods on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CryptographicEngine</pc></pc> class to perform the necessary encryption that creates the MAC value.</source>
					<target>You can use static methods on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CryptographicEngine</pc></pc> class to perform the necessary encryption that creates the MAC value.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>Digital signatures are the public key equivalent of private key message authentication codes (MACs).</source>
					<target>Digital signatures are the public key equivalent of private key message authentication codes (MACs).</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Although MACs use private keys to enable a message recipient to verify that a message has not been altered during transmission, signatures use a private/public key pair.</source>
					<target>Although MACs use private keys to enable a message recipient to verify that a message has not been altered during transmission, signatures use a private/public key pair.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241530)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This example code shows how to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MacAlgorithmProvider</pc></pc> class to create a hashed message authentication code (HMAC).</source>
					<target>This example code shows how to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MacAlgorithmProvider</pc></pc> class to create a hashed message authentication code (HMAC).</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Hashes</source>
					<target>Hashes</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>A cryptographic hash function takes an arbitrarily long block of data and returns a fixed-size bit string.</source>
					<target>A cryptographic hash function takes an arbitrarily long block of data and returns a fixed-size bit string.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>Hash functions are typically used when signing data.</source>
					<target>Hash functions are typically used when signing data.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>Because most public key signature operations are computationally intensive, it is typically more efficient to sign (encrypt) a message hash than it is to sign the original message.</source>
					<target>Because most public key signature operations are computationally intensive, it is typically more efficient to sign (encrypt) a message hash than it is to sign the original message.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>The following procedure represents a common, albeit simplified, scenario:</source>
					<target>The following procedure represents a common, albeit simplified, scenario:</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Bob and Alice share a secret key and agree on a MAC function to use.</source>
					<target>Bob and Alice share a secret key and agree on a MAC function to use.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Bob creates a message and inputs the message and the secret key into a MAC function to retrieve a MAC value.</source>
					<target>Bob creates a message and inputs the message and the secret key into a MAC function to retrieve a MAC value.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Bob sends the \[unencrypted\] message and the MAC value to Alice over a network.</source>
					<target>Bob sends the \[unencrypted\] message and the MAC value to Alice over a network.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Alice uses the secret key and the message as input to the MAC function.</source>
					<target>Alice uses the secret key and the message as input to the MAC function.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>She compares the generated MAC value to the MAC value sent by Bob.</source>
					<target>She compares the generated MAC value to the MAC value sent by Bob.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>If they are the same, the message was not changed in transit.</source>
					<target>If they are the same, the message was not changed in transit.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Note that Alice sent an unencrypted message.</source>
					<target>Note that Alice sent an unencrypted message.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Only the hash was encrypted.</source>
					<target>Only the hash was encrypted.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>The procedure ensures only that the original message was not altered and, by using Alice's public key, that the message hash was signed by someone with access to Alice's private key, presumably Alice.</source>
					<target>The procedure ensures only that the original message was not altered and, by using Alice's public key, that the message hash was signed by someone with access to Alice's private key, presumably Alice.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241511)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br241498)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">HashAlgorithmProvider</pc></pc> class to enumerate the available hash algorithms and create a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CryptographicHash</pc></pc> value.</source>
					<target>You can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">HashAlgorithmProvider</pc></pc> class to enumerate the available hash algorithms and create a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CryptographicHash</pc></pc> value.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Digital signatures are the public key equivalent of private key message authentication codes (MACs).</source>
					<target>Digital signatures are the public key equivalent of private key message authentication codes (MACs).</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>Whereas MACs use private keys to enable a message recipient to verify that a message has not been altered during transmission, signatures use a private/public key pair.</source>
					<target>Whereas MACs use private keys to enable a message recipient to verify that a message has not been altered during transmission, signatures use a private/public key pair.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241498)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CryptographicHash</pc></pc> object can be used to repeatedly hash different data without having to re-create the object for each use.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CryptographicHash</pc></pc> object can be used to repeatedly hash different data without having to re-create the object for each use.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241499)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Append</pc></pc> method adds new data to a buffer to be hashed.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Append</pc></pc> method adds new data to a buffer to be hashed.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701376)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValueAndReset</pc></pc> method hashes the data and resets the object for another use.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValueAndReset</pc></pc> method hashes the data and resets the object for another use.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>This is shown by the following example.</source>
					<target>This is shown by the following example.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Digital signatures</source>
					<target>Digital signatures</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Digital signatures are the public key equivalent of private key message authentication codes (MACs).</source>
					<target>Digital signatures are the public key equivalent of private key message authentication codes (MACs).</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>Whereas MACs use private keys to enable a message recipient to verify that a message has not been altered during transmission, signatures use a private/public key pair.</source>
					<target>Whereas MACs use private keys to enable a message recipient to verify that a message has not been altered during transmission, signatures use a private/public key pair.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>Because most public key signature operations are computationally intensive, however, it is typically more efficient to sign (encrypt) a message hash than it is to sign the original message.</source>
					<target>Because most public key signature operations are computationally intensive, however, it is typically more efficient to sign (encrypt) a message hash than it is to sign the original message.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>The sender creates a message hash, signs it, and sends both the signature and the (unencrypted) message.</source>
					<target>The sender creates a message hash, signs it, and sends both the signature and the (unencrypted) message.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>The recipient calculates a hash over the message, decrypts the signature, and compares the decrypted signature to the hash value.</source>
					<target>The recipient calculates a hash over the message, decrypts the signature, and compares the decrypted signature to the hash value.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>If they match, the recipient can be fairly certain that the message did, in fact, come from the sender and was not altered during transmission.</source>
					<target>If they match, the recipient can be fairly certain that the message did, in fact, come from the sender and was not altered during transmission.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Signing ensures only that the original message was not altered and, by using the sender's public key, that the message hash was signed by someone with access to the private key.</source>
					<target>Signing ensures only that the original message was not altered and, by using the sender's public key, that the message hash was signed by someone with access to the private key.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241478)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AsymmetricKeyAlgorithmProvider</pc></pc> object to enumerate the available signature algorithms and generate or import a key pair.</source>
					<target>You can use an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AsymmetricKeyAlgorithmProvider</pc></pc> object to enumerate the available signature algorithms and generate or import a key pair.</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241498)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use static methods on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CryptographicHash</pc></pc> class to sign a message or verify a signature.</source>
					<target>You can use static methods on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CryptographicHash</pc></pc> class to sign a message or verify a signature.</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>