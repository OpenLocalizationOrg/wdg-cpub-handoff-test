<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="it-it" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-00ddeee</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">6012c225b320c480f8db94ad83ac6d832529b2fa</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\controls-and-patterns\resourcedictionary-and-xaml-resource-references.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">b036791d2c509cef0e4f7a501d961e597eb97d7e</mda:meta><mda:meta type="olxliffhash">79e383f28fae8ed929410e4e6c098467bbb58c78</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Explains how to define a ResourceDictionary element and keyed resources, and how XAML resources relate to other resources that you define as part of your app or app package.</source>
					<target>Explains how to define a ResourceDictionary element and keyed resources, and how XAML resources relate to other resources that you define as part of your app or app package.</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>ResourceDictionary and XAML resource references</source>
					<target>ResourceDictionary and XAML resource references</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>ResourceDictionary and XAML resource references</source>
					<target>ResourceDictionary and XAML resource references</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>You can define the UI or resources for your app using XAML.</source>
					<target>You can define the UI or resources for your app using XAML.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Resources are typically definitions of some object that you expect to use more than once.</source>
					<target>Resources are typically definitions of some object that you expect to use more than once.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>To refer to a XAML resource later, you specify a key for a resource that acts like its name.</source>
					<target>To refer to a XAML resource later, you specify a key for a resource that acts like its name.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>You can reference a resource throughout an app or from any XAML page within it.</source>
					<target>You can reference a resource throughout an app or from any XAML page within it.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can define your resources using a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> element from the Windows Runtime XAML.</source>
					<target>You can define your resources using a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> element from the Windows Runtime XAML.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](../xaml-platform/staticresource-markup-extension.md)</data>
					<data id="id3">[</data>
					<data id="id4">](../xaml-platform/themeresource-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source>Then, you can reference your resources by using a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource markup extension</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ThemeResource markup extension</pc>.</source>
					<target>Then, you can reference your resources by using a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource markup extension</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ThemeResource markup extension</pc>.</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208849)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209391)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br228076)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>The XAML elements you might want to declare most often as XAML resources include <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ControlTemplate</pc></pc>, animation components, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Brush</pc></pc> subclasses.</source>
					<target>The XAML elements you might want to declare most often as XAML resources include <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ControlTemplate</pc></pc>, animation components, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Brush</pc></pc> subclasses.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Here, we explain how to define a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> and keyed resources, and how XAML resources relate to other resources that you define as part of your app or app package.</source>
					<target>Here, we explain how to define a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> and keyed resources, and how XAML resources relate to other resources that you define as part of your app or app package.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208801)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208807)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>We also explain resource dictionary advanced features such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ThemeDictionaries</pc></pc>.</source>
					<target>We also explain resource dictionary advanced features such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ThemeDictionaries</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>Prerequisites</source>
					<target>Prerequisites</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt185595)</data>
				</originalData>
				<segment state="initial">
					<source>We assume that you understand XAML markup and have read the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML overview</pc>.</source>
					<target>We assume that you understand XAML markup and have read the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML overview</pc>.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Define and use XAML resources</source>
					<target>Define and use XAML resources</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>XAML resources are objects that are referenced from markup more than once.</source>
					<target>XAML resources are objects that are referenced from markup more than once.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Resources are defined in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>, typically in a separate file or at the top of the markup page, like this.</source>
					<target>Resources are defined in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>, typically in a separate file or at the top of the markup page, like this.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>In this example:</source>
					<target>In this example:</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>- Defines the resource dictionary.</source>
					<target>- Defines the resource dictionary.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>- Defines the resource with the key "greeting".</source>
					<target>- Defines the resource with the key "greeting".</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209676)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209652)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>- Looks up the resource with the key "greeting", which is assigned to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Text</pc></pc> property of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TextBlock</pc></pc>.</source>
					<target>- Looks up the resource with the key "greeting", which is assigned to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Text</pc></pc> property of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TextBlock</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">&amp;nbsp;&amp;nbsp;</data>
					<data id="id4">[</data>
					<data id="id5">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc><ph dataRef="id3" id="ph1" />Don't confuse the concepts related to <pc dataRefEnd="id5" dataRefStart="id4" id="p2"><pc dataRefEnd="id7" dataRefStart="id6" id="p3">ResourceDictionary</pc></pc> with the <pc dataRefEnd="id9" dataRefStart="id8" id="p4">Resource</pc> build action, resource (.resw) files, or other "resources" that are discussed in the context of structuring the code project that produces your app package.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc><ph dataRef="id3" id="ph1" />Don't confuse the concepts related to <pc dataRefEnd="id5" dataRefStart="id4" id="p2"><pc dataRefEnd="id7" dataRefStart="id6" id="p3">ResourceDictionary</pc></pc> with the <pc dataRefEnd="id9" dataRefStart="id8" id="p4">Resource</pc> build action, resource (.resw) files, or other "resources" that are discussed in the context of structuring the code project that produces your app package.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Resources don't have to be strings; they can be any shareable object, such as styles, templates, brushes, and colors.</source>
					<target>Resources don't have to be strings; they can be any shareable object, such as styles, templates, brushes, and colors.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208706)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>However, controls, shapes, and other <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement</pc></pc>s are not shareable, so they can't be declared as reusable resources.</source>
					<target>However, controls, shapes, and other <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement</pc></pc>s are not shareable, so they can't be declared as reusable resources.</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#xaml_resources_must_be_sharable)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about sharing, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML resources must be shareable</pc> section later in this topic.</source>
					<target>For more info about sharing, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML resources must be shareable</pc> section later in this topic.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>Here, both a brush and a string are declared as resources and used by controls in a page.</source>
					<target>Here, both a brush and a string are declared as resources and used by controls in a page.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>All resources need to have a key.</source>
					<target>All resources need to have a key.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">`x:Key=”myString”`</data>
				</originalData>
				<segment state="initial">
					<source>Usually that key is a string defined with <ph dataRef="id1" id="ph1" />.</source>
					<target>Usually that key is a string defined with <ph dataRef="id1" id="ph1" />.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>However, there are a few other ways to specify a key:</source>
					<target>However, there are a few other ways to specify a key:</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208849)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209391)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/mt204787)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ControlTemplate</pc></pc> require a <pc dataRefEnd="id10" dataRefStart="id9" id="p5">TargetType</pc>, and will use the <pc dataRefEnd="id12" dataRefStart="id11" id="p6">TargetType</pc> as the key if <pc dataRefEnd="id14" dataRefStart="id13" id="p7">x:Key</pc> is not specified.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ControlTemplate</pc></pc> require a <pc dataRefEnd="id10" dataRefStart="id9" id="p5">TargetType</pc>, and will use the <pc dataRefEnd="id12" dataRefStart="id11" id="p6">TargetType</pc> as the key if <pc dataRefEnd="id14" dataRefStart="id13" id="p7">x:Key</pc> is not specified.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>In this case, the key is the actual Type object, not a string.</source>
					<target>In this case, the key is the actual Type object, not a string.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>(See examples below)</source>
					<target>(See examples below)</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242348)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/mt204787)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataTemplate</pc></pc> resources that have a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">TargetType</pc> will use the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">TargetType</pc> as the key if <pc dataRefEnd="id10" dataRefStart="id9" id="p5">x:Key</pc> is not specified.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataTemplate</pc></pc> resources that have a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">TargetType</pc> will use the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">TargetType</pc> as the key if <pc dataRefEnd="id10" dataRefStart="id9" id="p5">x:Key</pc> is not specified.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>In this case, the key is the actual Type object, not a string.</source>
					<target>In this case, the key is the actual Type object, not a string.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt204788)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/mt204787)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Name</pc> can be used instead of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:Key</pc>.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Name</pc> can be used instead of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:Key</pc>.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>However, x:Name also generates a code behind field for the resource.</source>
					<target>However, x:Name also generates a code behind field for the resource.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>As a result, x:Name is less efficient than x:Key because that field needs to be initialized when the page is loaded.</source>
					<target>As a result, x:Name is less efficient than x:Key because that field needs to be initialized when the page is loaded.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](../xaml-platform/staticresource-markup-extension.md)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/mt204787)</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/mt204788)</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource markup extension</pc> can retrieve resources only with a string name (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:Key</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">x:Name</pc>).</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource markup extension</pc> can retrieve resources only with a string name (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:Key</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">x:Name</pc>).</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208743)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/br209369)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/br242830)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source>However, the XAML framework also looks for implicit style resources (those which use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TargetType</pc> rather than x:Key or x:Name) when it decides which style &amp; template to use for a control that hasn't set the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Style</pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ContentTemplate</pc></pc> or <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">ItemTemplate</pc></pc> properties.</source>
					<target>However, the XAML framework also looks for implicit style resources (those which use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TargetType</pc> rather than x:Key or x:Name) when it decides which style &amp; template to use for a control that hasn't set the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Style</pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ContentTemplate</pc></pc> or <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">ItemTemplate</pc></pc> properties.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208849)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/br209265)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/br208743)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>Here, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> has an implicit key of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">typeof(Button)</pc>, and since the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Button</pc></pc> at the bottom of the page doesn't specify a <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Style</pc></pc> property, it looks for a style with key of <pc dataRefEnd="id16" dataRefStart="id15" id="p8">typeof(Button)</pc>:</source>
					<target>Here, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> has an implicit key of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">typeof(Button)</pc>, and since the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Button</pc></pc> at the bottom of the page doesn't specify a <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Style</pc></pc> property, it looks for a style with key of <pc dataRefEnd="id16" dataRefStart="id15" id="p8">typeof(Button)</pc>:</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](styling-controls.md)</data>
					<data id="id3">[</data>
					<data id="id4">](control-templates.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about implicit styles and how they work, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Styling controls</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control templates</pc>.</source>
					<target>For more info about implicit styles and how they work, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Styling controls</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control templates</pc>.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>Look up resources in code</source>
					<target>Look up resources in code</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>You access members of the resource dictionary like any other dictionary.</source>
					<target>You access members of the resource dictionary like any other dictionary.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">&amp;nbsp;&amp;nbsp;</data>
					<data id="id4">`Page.Resources`</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc><ph dataRef="id3" id="ph1" />When you perform a resource lookup in code, only the resources in the <ph dataRef="id4" id="ph2" /> dictionary are looked at.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc><ph dataRef="id3" id="ph1" />When you perform a resource lookup in code, only the resources in the <ph dataRef="id4" id="ph2" /> dictionary are looked at.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](../xaml-platform/staticresource-markup-extension.md)</data>
					<data id="id3">`Application.Resources`</data>
				</originalData>
				<segment state="initial">
					<source>Unlike the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource markup extension</pc>, the code doesn't fall back to the <ph dataRef="id3" id="ph1" /> dictionary if the resources aren’t found in the first dictionary.</source>
					<target>Unlike the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource markup extension</pc>, the code doesn't fall back to the <ph dataRef="id3" id="ph1" /> dictionary if the resources aren’t found in the first dictionary.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<originalData>
					<data id="id1">`redButtonStyle`</data>
				</originalData>
				<segment state="initial">
					<source>This example shows how to retrieve the <ph dataRef="id1" id="ph1" /> resource out of a page’s resource dictionary:</source>
					<target>This example shows how to retrieve the <ph dataRef="id1" id="ph1" /> resource out of a page’s resource dictionary:</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>To look up app-wide resources from code, use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Application.Current.Resources</pc> to get the app's resource dictionary, as shown here.</source>
					<target>To look up app-wide resources from code, use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Application.Current.Resources</pc> to get the app's resource dictionary, as shown here.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>You can also add an application resource in code.</source>
					<target>You can also add an application resource in code.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>There are two things to keep in mind when doing this.</source>
					<target>There are two things to keep in mind when doing this.</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>First, you need to add the resources before any page tries to use the resource.</source>
					<target>First, you need to add the resources before any page tries to use the resource.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>Second, you can’t add resources in the App’s constructor.</source>
					<target>Second, you can’t add resources in the App’s constructor.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242335)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can avoid both problems if you add the resource in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Application.OnLaunched</pc></pc> method, like this.</source>
					<target>You can avoid both problems if you add the resource in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Application.OnLaunched</pc></pc> method, like this.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Every FrameworkElement can have a ResourceDictionary</source>
					<target>Every FrameworkElement can have a ResourceDictionary</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208706)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208740)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement</pc></pc> is a base class that controls inherit from, and it has a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Resources</pc></pc> property.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement</pc></pc> is a base class that controls inherit from, and it has a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Resources</pc></pc> property.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>So, you can add a local resource dictionary to any <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FrameworkElement</pc>.</source>
					<target>So, you can add a local resource dictionary to any <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FrameworkElement</pc>.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>Here, a resource dictionary is added to a page element.</source>
					<target>Here, a resource dictionary is added to a page element.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227503)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209250)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Here, both the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Page</pc></pc> and the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Border</pc></pc> have resource dictionaries, and they both have a resource called "greeting".</source>
					<target>Here, both the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Page</pc></pc> and the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Border</pc></pc> have resource dictionaries, and they both have a resource called "greeting".</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209652)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/br242324)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBlock</pc></pc> is inside the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Border</pc>, so its resource lookup looks first to the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Border</pc>’s resources, then the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Page</pc>’s resources, and then the <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Application</pc></pc> resources.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBlock</pc></pc> is inside the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Border</pc>, so its resource lookup looks first to the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Border</pc>’s resources, then the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Page</pc>’s resources, and then the <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Application</pc></pc> resources.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TextBlock</pc> will read "Hola mundo".</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TextBlock</pc> will read "Hola mundo".</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208740)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To access that element’s resources from code, use that element’s <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Resources</pc></pc> property.</source>
					<target>To access that element’s resources from code, use that element’s <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Resources</pc></pc> property.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208706)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Accessing a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement</pc></pc>’s resources in code, rather than XAML, will look only in that dictionary, not in parent element’s dictionaries.</source>
					<target>Accessing a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement</pc></pc>’s resources in code, rather than XAML, will look only in that dictionary, not in parent element’s dictionaries.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>Merged resource dictionaries</source>
					<target>Merged resource dictionaries</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">merged resource dictionary</pc> combines one resource dictionary into another, usually in another file.</source>
					<target>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">merged resource dictionary</pc> combines one resource dictionary into another, usually in another file.</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">&amp;nbsp;&amp;nbsp;</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">&amp;gt;</data>
					<data id="id7">&amp;gt;</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc><ph dataRef="id3" id="ph1" />You can create a resource dictionary file in Microsoft Visual Studio by using the <pc dataRefEnd="id5" dataRefStart="id4" id="p2">Add <ph dataRef="id6" id="ph2" /> New Item… <ph dataRef="id7" id="ph3" /> Resource Dictionary</pc> option from the <pc dataRefEnd="id9" dataRefStart="id8" id="p3">Project</pc> menu.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc><ph dataRef="id3" id="ph1" />You can create a resource dictionary file in Microsoft Visual Studio by using the <pc dataRefEnd="id5" dataRefStart="id4" id="p2">Add <ph dataRef="id6" id="ph2" /> New Item… <ph dataRef="id7" id="ph3" /> Resource Dictionary</pc> option from the <pc dataRefEnd="id9" dataRefStart="id8" id="p3">Project</pc> menu.</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Here, you define a resource dictionary in a separate XAML file called Dictionary1.xaml.</source>
					<target>Here, you define a resource dictionary in a separate XAML file called Dictionary1.xaml.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>To use that dictionary, you merge it with your page’s dictionary:</source>
					<target>To use that dictionary, you merge it with your page’s dictionary:</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>Here's what happens in this example.</source>
					<target>Here's what happens in this example.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<originalData>
					<data id="id1">`&lt;Page.Resources&gt;`</data>
					<data id="id2">`&lt;ResourceDictionary&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>In <ph dataRef="id1" id="ph1" />, you declare <ph dataRef="id2" id="ph2" />.</source>
					<target>In <ph dataRef="id1" id="ph1" />, you declare <ph dataRef="id2" id="ph2" />.</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<originalData>
					<data id="id1">`&lt;Page.Resources&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>The XAML framework implicitly creates a resource dictionary for you when you add resources to <ph dataRef="id1" id="ph1" />; however, in this case, you don’t want just any resource dictionary, you want one that contains merged dictionaries.</source>
					<target>The XAML framework implicitly creates a resource dictionary for you when you add resources to <ph dataRef="id1" id="ph1" />; however, in this case, you don’t want just any resource dictionary, you want one that contains merged dictionaries.</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<originalData>
					<data id="id1">`&lt;ResourceDictionary&gt;`</data>
					<data id="id2">`&lt;ResourceDictionary.MergedDictionaries&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>So you declare <ph dataRef="id1" id="ph1" />, then add things to its <ph dataRef="id2" id="ph2" /> collection.</source>
					<target>So you declare <ph dataRef="id1" id="ph1" />, then add things to its <ph dataRef="id2" id="ph2" /> collection.</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<originalData>
					<data id="id1">`&lt;ResourceDictionary Source="Dictionary1.xaml"/&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>Each of those entries takes the form <ph dataRef="id1" id="ph1" />.</source>
					<target>Each of those entries takes the form <ph dataRef="id1" id="ph1" />.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<originalData>
					<data id="id1">`&lt;ResourceDictionary Source="Dictionary2.xaml"/&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>To add more than one dictionary, just add a <ph dataRef="id1" id="ph1" /> entry after the first entry.</source>
					<target>To add more than one dictionary, just add a <ph dataRef="id1" id="ph1" /> entry after the first entry.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<originalData>
					<data id="id1">`&lt;ResourceDictionary.MergedDictionaries&gt;…&lt;/ResourceDictionary.MergedDictionaries&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>After <ph dataRef="id1" id="ph1" />, you can optionally put additional resources in your main dictionary.</source>
					<target>After <ph dataRef="id1" id="ph1" />, you can optionally put additional resources in your main dictionary.</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>You use resources from a merged to dictionary just like a regular dictionary.</source>
					<target>You use resources from a merged to dictionary just like a regular dictionary.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<originalData>
					<data id="id1">`{StaticResource brush}`</data>
					<data id="id2">`{StaticResource greeting}`</data>
				</originalData>
				<segment state="initial">
					<source>In the example above, <ph dataRef="id1" id="ph1" /> finds the resource in the child/merged dictionary (Dictionary1.xaml), while <ph dataRef="id2" id="ph2" /> finds its resource in the main page dictionary.</source>
					<target>In the example above, <ph dataRef="id1" id="ph1" /> finds the resource in the child/merged dictionary (Dictionary1.xaml), while <ph dataRef="id2" id="ph2" /> finds its resource in the main page dictionary.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208801)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>In the resource-lookup sequence, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc> dictionary is checked only after a check of all the other keyed resources of that <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ResourceDictionary</pc></pc>.</source>
					<target>In the resource-lookup sequence, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc> dictionary is checked only after a check of all the other keyed resources of that <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ResourceDictionary</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>After searching that level, the lookup reaches the merged dictionaries, and each item in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MergedDictionaries</pc> is checked.</source>
					<target>After searching that level, the lookup reaches the merged dictionaries, and each item in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MergedDictionaries</pc> is checked.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If multiple merged dictionaries exist, these dictionaries are checked in the inverse of the order in which they are declared in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MergedDictionaries</pc> property.</source>
					<target>If multiple merged dictionaries exist, these dictionaries are checked in the inverse of the order in which they are declared in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MergedDictionaries</pc> property.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In the following example, if both Dictionary2.xaml and Dictionary1.xaml declared the same key, the key from Dictionary2.xaml is used first because it's last in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MergedDictionaries</pc> set.</source>
					<target>In the following example, if both Dictionary2.xaml and Dictionary1.xaml declared the same key, the key from Dictionary2.xaml is used first because it's last in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MergedDictionaries</pc> set.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Within the scope of any one <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>, the dictionary is checked for key uniqueness.</source>
					<target>Within the scope of any one <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>, the dictionary is checked for key uniqueness.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208801)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>However, that scope does not extend across different items in different <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc> files.</source>
					<target>However, that scope does not extend across different items in different <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc> files.</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use the combination of the lookup sequence and lack of unique key enforcement across merged-dictionary scopes to create a fallback value sequence of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> resources.</source>
					<target>You can use the combination of the lookup sequence and lack of unique key enforcement across merged-dictionary scopes to create a fallback value sequence of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> resources.</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>For example, you might store user preferences for a particular brush color in the last merged resource dictionary in the sequence, using a resource dictionary that synchronizes to your app's state and user preference data.</source>
					<target>For example, you might store user preferences for a particular brush color in the last merged resource dictionary in the sequence, using a resource dictionary that synchronizes to your app's state and user preference data.</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208801)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>However, if no user preferences exist yet, you can define that same key string for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> resource in the initial <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">MergedDictionaries</pc></pc> file, and it can serve as the fallback value.</source>
					<target>However, if no user preferences exist yet, you can define that same key string for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> resource in the initial <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">MergedDictionaries</pc></pc> file, and it can serve as the fallback value.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Remember that any value you provide in a primary resource dictionary is always checked before the merged dictionaries are checked, so if you want to use the fallback technique, don't define that resource in a primary resource dictionary.</source>
					<target>Remember that any value you provide in a primary resource dictionary is always checked before the merged dictionaries are checked, so if you want to use the fallback technique, don't define that resource in a primary resource dictionary.</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Theme resources and theme dictionaries</source>
					<target>Theme resources and theme dictionaries</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](../xaml-platform/themeresource-markup-extension.md)</data>
					<data id="id3">[</data>
					<data id="id4">](../xaml-platform/staticresource-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ThemeResource</pc> is similar to a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">StaticResource</pc>, but the resource lookup is reevaluated when the theme changes.</source>
					<target>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ThemeResource</pc> is similar to a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">StaticResource</pc>, but the resource lookup is reevaluated when the theme changes.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209652)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In this example, you set the foreground of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBlock</pc></pc> to a value from the current theme.</source>
					<target>In this example, you set the foreground of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBlock</pc></pc> to a value from the current theme.</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>A theme dictionary is a special type of merged dictionary that holds the resources that vary with the theme a user is currently using on his or her device.</source>
					<target>A theme dictionary is a special type of merged dictionary that holds the resources that vary with the theme a user is currently using on his or her device.</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>For example, the "light" theme might use a white color brush whereas the "dark" theme might use a dark color brush.</source>
					<target>For example, the "light" theme might use a white color brush whereas the "dark" theme might use a dark color brush.</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>The brush changes the resource that it resolves to, but otherwise the composition of a control that uses the brush as a resource could be the same.</source>
					<target>The brush changes the resource that it resolves to, but otherwise the composition of a control that uses the brush as a resource could be the same.</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208801)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208807)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>To reproduce the theme-switching behavior in your own templates and styles, instead of using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc> as the property to merge items into the main dictionaries, use the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ThemeDictionaries</pc></pc> property.</source>
					<target>To reproduce the theme-switching behavior in your own templates and styles, instead of using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc> as the property to merge items into the main dictionaries, use the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ThemeDictionaries</pc></pc> property.</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208807)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/mt204787)</data>
				</originalData>
				<segment state="initial">
					<source>Each <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> element within <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ThemeDictionaries</pc></pc> must have an <pc dataRefEnd="id10" dataRefStart="id9" id="p5">x:Key</pc> value.</source>
					<target>Each <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> element within <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ThemeDictionaries</pc></pc> must have an <pc dataRefEnd="id10" dataRefStart="id9" id="p5">x:Key</pc> value.</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>The value is a string that names the relevant theme—for example, "Default", "Dark", "Light", or "HighContrast".</source>
					<target>The value is a string that names the relevant theme—for example, "Default", "Dark", "Light", or "HighContrast".</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<originalData>
					<data id="id1">`Dictionary1`</data>
					<data id="id2">`Dictionary2`</data>
				</originalData>
				<segment state="initial">
					<source>Typically, <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> will define resources that have the same names but different values.</source>
					<target>Typically, <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> will define resources that have the same names but different values.</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>Here, you use red text for the light theme and blue text for the dark theme.</source>
					<target>Here, you use red text for the light theme and blue text for the dark theme.</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209652)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In this example, you set the foreground of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBlock</pc></pc> to a value from the current theme.</source>
					<target>In this example, you set the foreground of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBlock</pc></pc> to a value from the current theme.</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](../xaml-platform/themeresource-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source>For theme dictionaries, the active dictionary to be used for resource lookup changes dynamically, whenever <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ThemeResource markup extension</pc> is used to make the reference and the system detects a theme change.</source>
					<target>For theme dictionaries, the active dictionary to be used for resource lookup changes dynamically, whenever <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ThemeResource markup extension</pc> is used to make the reference and the system detects a theme change.</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt204787)</data>
				</originalData>
				<segment state="initial">
					<source>The lookup behavior that is done by the system is based on mapping the active theme to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Key</pc> of a specific theme dictionary.</source>
					<target>The lookup behavior that is done by the system is based on mapping the active theme to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Key</pc> of a specific theme dictionary.</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>It can be useful to examine the way that the theme dictionaries are structured in the default XAML design resources, which parallel the templates that the Windows Runtime uses by default for its controls.</source>
					<target>It can be useful to examine the way that the theme dictionaries are structured in the default XAML design resources, which parallel the templates that the Windows Runtime uses by default for its controls.</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>Open the XAML files in \\(Program Files)\\Windows Kits\\10\\DesignTime\\CommonConfiguration\\Neutral\\UAP\\<ph dataRef="id1" id="ph1" />SDK version<ph dataRef="id2" id="ph2" />\\Generic using a text editor or your IDE.</source>
					<target>Open the XAML files in \\(Program Files)\\Windows Kits\\10\\DesignTime\\CommonConfiguration\\Neutral\\UAP\\<ph dataRef="id1" id="ph1" />SDK version<ph dataRef="id2" id="ph2" />\\Generic using a text editor or your IDE.</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>Note how the theme dictionaries are defined first in generic.xaml, and how each theme dictionary defines the same keys.</source>
					<target>Note how the theme dictionaries are defined first in generic.xaml, and how each theme dictionary defines the same keys.</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>Each such key is then referenced by elements of composition in the various keyed elements that are outside the theme dictionaries and defined later in the XAML.</source>
					<target>Each such key is then referenced by elements of composition in the various keyed elements that are outside the theme dictionaries and defined later in the XAML.</target>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>There's also a separate themeresources.xaml file for design that contains only the theme resources and extra templates, not the default control templates.</source>
					<target>There's also a separate themeresources.xaml file for design that contains only the theme resources and extra templates, not the default control templates.</target>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>The theme areas are duplicates of what you'd see in generic.xaml.</source>
					<target>The theme areas are duplicates of what you'd see in generic.xaml.</target>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>When you use XAML design tools to edit copies of styles and templates, the design tools extract sections from the XAML design resource dictionaries and place them as local copies of XAML dictionary elements that are part of your app and project.</source>
					<target>When you use XAML design tools to edit copies of styles and templates, the design tools extract sections from the XAML design resource dictionaries and place them as local copies of XAML dictionary elements that are part of your app and project.</target>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](xaml-theme-resources.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info and for a list of the theme-specific and system resources that are available to your app, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML theme resources</pc>.</source>
					<target>For more info and for a list of the theme-specific and system resources that are available to your app, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML theme resources</pc>.</target>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>Lookup behavior for XAML resource references</source>
					<target>Lookup behavior for XAML resource references</target>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Lookup behavior</pc> is the term that describes how the XAML resources system tries to find a XAML resource.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Lookup behavior</pc> is the term that describes how the XAML resources system tries to find a XAML resource.</target>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>The lookup occurs when a key is referenced as a XAML resource reference from somewhere in the app's XAML.</source>
					<target>The lookup occurs when a key is referenced as a XAML resource reference from somewhere in the app's XAML.</target>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>First, the resources system has predictable behavior for where it will check for the existence of a resource based on scope.</source>
					<target>First, the resources system has predictable behavior for where it will check for the existence of a resource based on scope.</target>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>If a resource isn't found in the initial scope, the scope expands.</source>
					<target>If a resource isn't found in the initial scope, the scope expands.</target>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>The lookup behavior continues on throughout the locations and scopes that a XAML resource could possibly be defined by an app or by the system.</source>
					<target>The lookup behavior continues on throughout the locations and scopes that a XAML resource could possibly be defined by an app or by the system.</target>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<segment state="initial">
					<source>If all possible resource lookup attempts fail, an error often results.</source>
					<target>If all possible resource lookup attempts fail, an error often results.</target>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>It's usually possible to eliminate these errors during the development process.</source>
					<target>It's usually possible to eliminate these errors during the development process.</target>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208740)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The lookup behavior for XAML resource references starts with the object where the actual usage is applied and its own <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Resources</pc></pc> property.</source>
					<target>The lookup behavior for XAML resource references starts with the object where the actual usage is applied and its own <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Resources</pc></pc> property.</target>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>If a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> exists there, that <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ResourceDictionary</pc> is checked for an item that has the requested key.</source>
					<target>If a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> exists there, that <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ResourceDictionary</pc> is checked for an item that has the requested key.</target>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>This first level of lookup is rarely relevant because you usually do not define and then reference a resource on the same object.</source>
					<target>This first level of lookup is rarely relevant because you usually do not define and then reference a resource on the same object.</target>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In fact, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Resources</pc> property often doesn't exist here.</source>
					<target>In fact, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Resources</pc> property often doesn't exist here.</target>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208706)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can make XAML resource references from nearly anywhere in XAML; you aren't limited to properties of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement</pc></pc> subclasses.</source>
					<target>You can make XAML resource references from nearly anywhere in XAML; you aren't limited to properties of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement</pc></pc> subclasses.</target>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>The lookup sequence then checks the next parent object in the runtime object tree of the app.</source>
					<target>The lookup sequence then checks the next parent object in the runtime object tree of the app.</target>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208740)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>If a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.Resources</pc></pc> exists and holds a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ResourceDictionary</pc></pc>, the dictionary item with the specified key string is requested.</source>
					<target>If a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.Resources</pc></pc> exists and holds a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ResourceDictionary</pc></pc>, the dictionary item with the specified key string is requested.</target>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>If the resource is found, the lookup sequence stops and the object is provided to the location where the reference was made.</source>
					<target>If the resource is found, the lookup sequence stops and the object is provided to the location where the reference was made.</target>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<segment state="initial">
					<source>Otherwise, the lookup behavior advances to the next parent level towards the object tree root.</source>
					<target>Otherwise, the lookup behavior advances to the next parent level towards the object tree root.</target>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>The search continues recursively upwards until the root element of the XAML is reached, exhausting the search of all possible immediate resource locations.</source>
					<target>The search continues recursively upwards until the root element of the XAML is reached, exhausting the search of all possible immediate resource locations.</target>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">&amp;nbsp;&amp;nbsp;</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc><ph dataRef="id3" id="ph1" />It is a common practice to define all the immediate resources at the root level of a page, both to take advantage of this resource-lookup behavior and also as a convention of XAML markup style.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc><ph dataRef="id3" id="ph1" />It is a common practice to define all the immediate resources at the root level of a page, both to take advantage of this resource-lookup behavior and also as a convention of XAML markup style.</target>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242338)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If the requested resource is not found in the immediate resources, the next lookup step is to check the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Application.Resources</pc></pc> property.</source>
					<target>If the requested resource is not found in the immediate resources, the next lookup step is to check the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Application.Resources</pc></pc> property.</target>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Application.Resources</pc> is the best place to put any app-specific resources that are referenced by multiple pages in your app's navigation structure.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Application.Resources</pc> is the best place to put any app-specific resources that are referenced by multiple pages in your app's navigation structure.</target>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>Control templates have another possible location in the reference lookup: theme dictionaries.</source>
					<target>Control templates have another possible location in the reference lookup: theme dictionaries.</target>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A theme dictionary is a single XAML file that has a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> element as its root.</source>
					<target>A theme dictionary is a single XAML file that has a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> element as its root.</target>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242338)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The theme dictionary might be a merged dictionary from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Application.Resources</pc></pc>.</source>
					<target>The theme dictionary might be a merged dictionary from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Application.Resources</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>The theme dictionary might also be the control-specific theme dictionary for a templated custom control.</source>
					<target>The theme dictionary might also be the control-specific theme dictionary for a templated custom control.</target>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>Finally, there is a resource lookup against platform resources.</source>
					<target>Finally, there is a resource lookup against platform resources.</target>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>Platform resources include the control templates that are defined for each of the system UI themes, and which define the default appearance of all the controls that you use for UI in a Windows Runtime app.</source>
					<target>Platform resources include the control templates that are defined for each of the system UI themes, and which define the default appearance of all the controls that you use for UI in a Windows Runtime app.</target>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>Platform resources also include a set of named resources that relate to system-wide appearance and themes.</source>
					<target>Platform resources also include a set of named resources that relate to system-wide appearance and themes.</target>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208801)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>These resources are technically a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc> item, and thus are available for lookup from XAML or code once the app has loaded.</source>
					<target>These resources are technically a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc> item, and thus are available for lookup from XAML or code once the app has loaded.</target>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh673723)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, the system theme resources include a resource named "SystemColorWindowTextColor" that provides a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Color</pc></pc> definition to match app text color to a system window's text color that comes from the operating system and user preferences.</source>
					<target>For example, the system theme resources include a resource named "SystemColorWindowTextColor" that provides a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Color</pc></pc> definition to match app text color to a system window's text color that comes from the operating system and user preferences.</target>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Other XAML styles for your app can refer to this style, or your code can get a resource lookup value (and cast it to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Color</pc> in the example case).</source>
					<target>Other XAML styles for your app can refer to this style, or your code can get a resource lookup value (and cast it to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Color</pc> in the example case).</target>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](xaml-theme-resources.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info and for a list of the theme-specific and system resources that are available to a Windows Store app that uses XAML, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML theme resources</pc>.</source>
					<target>For more info and for a list of the theme-specific and system resources that are available to a Windows Store app that uses XAML, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML theme resources</pc>.</target>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>If the requested key is still not found in any of these locations, a XAML parsing error/exception occurs.</source>
					<target>If the requested key is still not found in any of these locations, a XAML parsing error/exception occurs.</target>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>In certain circumstances, the XAML parse exception may be a run-time exception that is not detected either by a XAML markup compile action, or by a XAML design environment.</source>
					<target>In certain circumstances, the XAML parse exception may be a run-time exception that is not detected either by a XAML markup compile action, or by a XAML design environment.</target>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<segment state="initial">
					<source>Because of the tiered lookup behavior for resource dictionaries, you can deliberately define multiple resource items that each have the same string value as the key, as long as each resource is defined at a different level.</source>
					<target>Because of the tiered lookup behavior for resource dictionaries, you can deliberately define multiple resource items that each have the same string value as the key, as long as each resource is defined at a different level.</target>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In other words, although keys must be unique within any given <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>, the uniqueness requirement does not extend to the lookup behavior sequence as a whole.</source>
					<target>In other words, although keys must be unique within any given <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>, the uniqueness requirement does not extend to the lookup behavior sequence as a whole.</target>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>During lookup, only the first such object that's successfully retrieved is used for the XAML resource reference, and then the lookup stops.</source>
					<target>During lookup, only the first such object that's successfully retrieved is used for the XAML resource reference, and then the lookup stops.</target>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>You could use this behavior to request the same XAML resource by key at various positions within your app's XAML but get different resources back, depending on the scope from which the XAML resource reference was made and how that particular lookup behaves.</source>
					<target>You could use this behavior to request the same XAML resource by key at various positions within your app's XAML but get different resources back, depending on the scope from which the XAML resource reference was made and how that particular lookup behaves.</target>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>Forward references within a ResourceDictionary</source>
					<target>Forward references within a ResourceDictionary</target>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>XAML resource references within a particular resource dictionary must reference a resource that has already been defined with a key, and that resource must appear lexically before the resource reference.</source>
					<target>XAML resource references within a particular resource dictionary must reference a resource that has already been defined with a key, and that resource must appear lexically before the resource reference.</target>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>Forward references cannot be resolved by a XAML resource reference.</source>
					<target>Forward references cannot be resolved by a XAML resource reference.</target>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>For this reason, if you use XAML resource references from within another resource, you must design your resource dictionary structure so that the resources that are used by other resources are defined first in a resource dictionary.</source>
					<target>For this reason, if you use XAML resource references from within another resource, you must design your resource dictionary structure so that the resources that are used by other resources are defined first in a resource dictionary.</target>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<segment state="initial">
					<source>Resources defined at the app level cannot make references to immediate resources.</source>
					<target>Resources defined at the app level cannot make references to immediate resources.</target>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>This is equivalent to attempting a forward reference, because the app resources are actually processed first (when the app first starts, and before any navigation-page content is loaded).</source>
					<target>This is equivalent to attempting a forward reference, because the app resources are actually processed first (when the app first starts, and before any navigation-page content is loaded).</target>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<segment state="initial">
					<source>However, any immediate resource can make a reference to an app resource, and this can be a useful technique for avoiding forward-reference situations.</source>
					<target>However, any immediate resource can make a reference to an app resource, and this can be a useful technique for avoiding forward-reference situations.</target>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<segment state="initial">
					<source>XAML resources must be shareable</source>
					<target>XAML resources must be shareable</target>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
				</originalData>
				<segment state="initial">
					<source>For an object to exist in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>, that object must be <pc dataRefEnd="id6" dataRefStart="id5" id="p3">shareable</pc>.</source>
					<target>For an object to exist in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>, that object must be <pc dataRefEnd="id6" dataRefStart="id5" id="p3">shareable</pc>.</target>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>Being shareable is required because, when the object tree of an app is constructed and used at run time, objects cannot exist at multiple locations in the tree.</source>
					<target>Being shareable is required because, when the object tree of an app is constructed and used at run time, objects cannot exist at multiple locations in the tree.</target>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>Internally, the resource system creates copies of resource values to use in the object graph of your app when each XAML resource is requested.</source>
					<target>Internally, the resource system creates copies of resource values to use in the object graph of your app when each XAML resource is requested.</target>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> and Windows Runtime XAML in general supports these objects for shareable usage:</source>
					<target>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> and Windows Runtime XAML in general supports these objects for shareable usage:</target>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208849)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208753)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Styles and templates (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> and classes derived from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkTemplate</pc></pc>)</source>
					<target>Styles and templates (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> and classes derived from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkTemplate</pc></pc>)</target>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228076)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh673723)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Brushes and colors (classes derived from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Brush</pc></pc>, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Color</pc></pc> values)</source>
					<target>Brushes and colors (classes derived from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Brush</pc></pc>, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Color</pc></pc> values)</target>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br210490)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Animation types including <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Storyboard</pc></pc></source>
					<target>Animation types including <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Storyboard</pc></pc></target>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br210034)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Transforms (classes derived from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GeneralTransform</pc></pc>)</source>
					<target>Transforms (classes derived from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GeneralTransform</pc></pc>)</target>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br210127)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br243266)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Matrix</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Matrix3D</pc></pc></source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Matrix</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Matrix3D</pc></pc></target>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br225870)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Point</pc></pc> values</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Point</pc></pc> values</target>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208864)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242343)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Certain other UI-related structures such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Thickness</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CornerRadius</pc></pc></source>
					<target>Certain other UI-related structures such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Thickness</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CornerRadius</pc></pc></target>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>XAML intrinsic data types</source>
					<target>XAML intrinsic data types</target>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>You can also use custom types as a shareable resource if you follow the necessary implementation patterns.</source>
					<target>You can also use custom types as a shareable resource if you follow the necessary implementation patterns.</target>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>You define such classes in your backing code (or in runtime components that you include) and then instantiate those classes in XAML as a resource.</source>
					<target>You define such classes in your backing code (or in runtime components that you include) and then instantiate those classes in XAML as a resource.</target>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209903)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Examples are object data sources and <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IValueConverter</pc></pc> implementations for data binding.</source>
					<target>Examples are object data sources and <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IValueConverter</pc></pc> implementations for data binding.</target>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<segment state="initial">
					<source>Custom types must have a default constructor, because that's what a XAML parser uses to instantiate a class.</source>
					<target>Custom types must have a default constructor, because that's what a XAML parser uses to instantiate a class.</target>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208911)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Custom types used as resources can't have the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> class in their inheritance, because a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">UIElement</pc> can never be shareable (it's always intended to represent exactly one UI element that exists at one position in the object graph of your runtime app).</source>
					<target>Custom types used as resources can't have the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> class in their inheritance, because a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">UIElement</pc> can never be shareable (it's always intended to represent exactly one UI element that exists at one position in the object graph of your runtime app).</target>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>UserControl usage scope</source>
					<target>UserControl usage scope</target>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227647)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UserControl</pc></pc> element has a special situation for resource-lookup behavior because it has the inherent concepts of a definition scope and a usage scope.</source>
					<target>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UserControl</pc></pc> element has a special situation for resource-lookup behavior because it has the inherent concepts of a definition scope and a usage scope.</target>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UserControl</pc> that makes a XAML resource reference from its definition scope must be able to support the lookup of that resource within its own definition-scope lookup sequence—that is, it cannot access app resources.</source>
					<target>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UserControl</pc> that makes a XAML resource reference from its definition scope must be able to support the lookup of that resource within its own definition-scope lookup sequence—that is, it cannot access app resources.</target>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>From a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UserControl</pc> usage scope, a resource reference is treated as being within the lookup sequence towards its usage page root (just like any other resource reference made from an object in a loaded object tree) and can access app resources.</source>
					<target>From a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UserControl</pc> usage scope, a resource reference is treated as being within the lookup sequence towards its usage page root (just like any other resource reference made from an object in a loaded object tree) and can access app resources.</target>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<segment state="initial">
					<source>ResourceDictionary and XamlReader.Load</source>
					<target>ResourceDictionary and XamlReader.Load</target>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br228048)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> as either the root or a part of the XAML input for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">XamlReader.Load</pc></pc> method.</source>
					<target>You can use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> as either the root or a part of the XAML input for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">XamlReader.Load</pc></pc> method.</target>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>You can also include XAML resource references in that XAML if all such references are completely self-contained in the XAML submitted for loading.</source>
					<target>You can also include XAML resource references in that XAML if all such references are completely self-contained in the XAML submitted for loading.</target>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242338)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlReader.Load</pc> parses the XAML in a context that is not aware of any other <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc> objects, not even <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Application.Resources</pc></pc>.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlReader.Load</pc> parses the XAML in a context that is not aware of any other <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc> objects, not even <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Application.Resources</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<originalData>
					<data id="id1">`{ThemeResource}`</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
				</originalData>
				<segment state="initial">
					<source>Also, don't use <ph dataRef="id1" id="ph1" /> from within XAML submitted to <pc dataRefEnd="id3" dataRefStart="id2" id="p1">XamlReader.Load</pc>.</source>
					<target>Also, don't use <ph dataRef="id1" id="ph1" /> from within XAML submitted to <pc dataRefEnd="id3" dataRefStart="id2" id="p1">XamlReader.Load</pc>.</target>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<segment state="initial">
					<source>Using a ResourceDictionary from code</source>
					<target>Using a ResourceDictionary from code</target>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Most of the scenarios for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> are handled exclusively in XAML.</source>
					<target>Most of the scenarios for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> are handled exclusively in XAML.</target>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You declare the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> container and the resources within as a XAML file or set of XAML nodes in a UI definition file.</source>
					<target>You declare the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> container and the resources within as a XAML file or set of XAML nodes in a UI definition file.</target>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<segment state="initial">
					<source>And then you use XAML resource references to request those resources from other parts of XAML.</source>
					<target>And then you use XAML resource references to request those resources from other parts of XAML.</target>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Still, there are certain scenarios where your app might want to adjust the contents of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> using code that executes while the app is running, or at least to query the contents of a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc> to see if a resource is already defined.</source>
					<target>Still, there are certain scenarios where your app might want to adjust the contents of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> using code that executes while the app is running, or at least to query the contents of a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc> to see if a resource is already defined.</target>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208740)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">`Application.Current.Resources`</data>
				</originalData>
				<segment state="initial">
					<source>These code calls are made on a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> instance, so you must first retrieve one—either an immediate <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc> somewhere in the object tree by getting <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement.Resources</pc></pc>, or <ph dataRef="id9" id="ph1" />.</source>
					<target>These code calls are made on a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> instance, so you must first retrieve one—either an immediate <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc> somewhere in the object tree by getting <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement.Resources</pc></pc>, or <ph dataRef="id9" id="ph1" />.</target>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/jj603134)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>In C\# or Microsoft Visual Basic code, you can reference a resource in a given <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> by using the indexer (<pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Item</pc></pc>).</source>
					<target>In C\# or Microsoft Visual Basic code, you can reference a resource in a given <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> by using the indexer (<pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Item</pc></pc>).</target>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> is a string-keyed dictionary, so the indexer uses the string key instead of an integer index.</source>
					<target>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> is a string-keyed dictionary, so the indexer uses the string key instead of an integer index.</target>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208800)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In Visual C++ component extensions (C++/CX) code, use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Lookup</pc></pc>.</source>
					<target>In Visual C++ component extensions (C++/CX) code, use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Lookup</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208800)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/jj603134)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>When using code to examine or change a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>, the behavior for APIs like <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Lookup</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Item</pc></pc> does not traverse from immediate resources to app resources; that's a XAML parser behavior that only happens as XAML pages are loaded.</source>
					<target>When using code to examine or change a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>, the behavior for APIs like <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Lookup</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Item</pc></pc> does not traverse from immediate resources to app resources; that's a XAML parser behavior that only happens as XAML pages are loaded.</target>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>At run time, scope for keys is self-contained to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> instance that you are using at the time.</source>
					<target>At run time, scope for keys is self-contained to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> instance that you are using at the time.</target>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208801)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>However, that scope does extend into <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc>.</source>
					<target>However, that scope does extend into <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Also, if you request a key that does not exist in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>, there may not be an error; the return value may simply be provided as <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc>.</source>
					<target>Also, if you request a key that does not exist in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>, there may not be an error; the return value may simply be provided as <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc>.</target>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You may still get an error, though, if you try to use the returned <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> as a value.</source>
					<target>You may still get an error, though, if you try to use the returned <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> as a value.</target>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The error would come from the property's setter, not your <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> call.</source>
					<target>The error would come from the property's setter, not your <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> call.</target>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The only way you'd avoid an error is if the property accepted <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> as a valid value.</source>
					<target>The only way you'd avoid an error is if the property accepted <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> as a valid value.</target>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Note how this behavior contrasts with XAML lookup behavior at XAML parse time; a failure to resolve the provided key from XAML at parse time results in a XAML parse error, even in cases where the property could have accepted <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc>.</source>
					<target>Note how this behavior contrasts with XAML lookup behavior at XAML parse time; a failure to resolve the provided key from XAML at parse time results in a XAML parse error, even in cases where the property could have accepted <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc>.</target>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<segment state="initial">
					<source>Merged resource dictionaries are included into the index scope of the primary resource dictionary that references the merged dictionary at run time.</source>
					<target>Merged resource dictionaries are included into the index scope of the primary resource dictionary that references the merged dictionary at run time.</target>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208800)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>In other words, you can use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Item</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Lookup</pc></pc> of the primary dictionary to find any objects that were actually defined in the merged dictionary.</source>
					<target>In other words, you can use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Item</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Lookup</pc></pc> of the primary dictionary to find any objects that were actually defined in the merged dictionary.</target>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>In this case, the lookup behavior does resemble the parse-time XAML lookup behavior: if there are multiple objects in merged dictionaries that each have the same key, the object from the last-added dictionary is returned.</source>
					<target>In this case, the lookup behavior does resemble the parse-time XAML lookup behavior: if there are multiple objects in merged dictionaries that each have the same key, the object from the last-added dictionary is returned.</target>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/br208799)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>You are permitted to add items to an existing <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> by calling <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Add</pc> (C\# or Visual Basic) or <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Insert</pc></pc> (C++/CX).</source>
					<target>You are permitted to add items to an existing <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> by calling <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Add</pc> (C\# or Visual Basic) or <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Insert</pc></pc> (C++/CX).</target>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<segment state="initial">
					<source>You could add the items to either immediate resources or app resources.</source>
					<target>You could add the items to either immediate resources or app resources.</target>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Either of these API calls requires a key, which satisfies the requirement that each item in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> must have a key.</source>
					<target>Either of these API calls requires a key, which satisfies the requirement that each item in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> must have a key.</target>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>However, items that you add to a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> at run time are not relevant to XAML resource references.</source>
					<target>However, items that you add to a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> at run time are not relevant to XAML resource references.</target>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<segment state="initial">
					<source>The necessary lookup for XAML resource references happens when that XAML is first parsed as the app is loaded (or a theme change is detected).</source>
					<target>The necessary lookup for XAML resource references happens when that XAML is first parsed as the app is loaded (or a theme change is detected).</target>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Resources added to collections at run time weren't available then, and altering the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> doesn't invalidate an already retrieved resource from it even if you change the value of that resource.</source>
					<target>Resources added to collections at run time weren't available then, and altering the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> doesn't invalidate an already retrieved resource from it even if you change the value of that resource.</target>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You also can remove items from a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> at run time, make copies of some or all items, or other operations.</source>
					<target>You also can remove items from a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> at run time, make copies of some or all items, or other operations.</target>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The members listing for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> indicates which APIs are available.</source>
					<target>The members listing for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> indicates which APIs are available.</target>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Note that because <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> has a projected API to support its underlying collection interfaces, your API options differ depending on whether you are using C\# or Visual Basic versus C++/CX.</source>
					<target>Note that because <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> has a projected API to support its underlying collection interfaces, your API options differ depending on whether you are using C\# or Visual Basic versus C++/CX.</target>
				</segment>
			</unit>
			<unit id="311" translate="yes">
				<segment state="initial">
					<source>ResourceDictionary and localization</source>
					<target>ResourceDictionary and localization</target>
				</segment>
			</unit>
			<unit id="312" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A XAML <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> might initially contain strings that are to be localized.</source>
					<target>A XAML <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> might initially contain strings that are to be localized.</target>
				</segment>
			</unit>
			<unit id="313" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If so, store these strings as project resources instead of in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc>.</source>
					<target>If so, store these strings as project resources instead of in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc>.</target>
				</segment>
			</unit>
			<unit id="314" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt204791)</data>
				</originalData>
				<segment state="initial">
					<source>Take the strings out of the XAML, and instead give the owning element an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Uid directive</pc> value.</source>
					<target>Take the strings out of the XAML, and instead give the owning element an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Uid directive</pc> value.</target>
				</segment>
			</unit>
			<unit id="315" translate="yes">
				<segment state="initial">
					<source>Then, define a resource in a resources file.</source>
					<target>Then, define a resource in a resources file.</target>
				</segment>
			</unit>
			<unit id="316" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
				</originalData>
				<segment state="initial">
					<source>Provide a resource name in the form <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XUIDValue</pc>.<pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyName</pc> and a resource value of the string that should be localized.</source>
					<target>Provide a resource name in the form <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XUIDValue</pc>.<pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyName</pc> and a resource value of the string that should be localized.</target>
				</segment>
			</unit>
			<unit id="317" translate="yes">
				<segment state="initial">
					<source>Custom resource lookup</source>
					<target>Custom resource lookup</target>
				</segment>
			</unit>
			<unit id="318" translate="yes">
				<segment state="initial">
					<source>For advanced scenarios, you can implement a class that can have different behavior than the XAML resource reference lookup behavior described in this topic.</source>
					<target>For advanced scenarios, you can implement a class that can have different behavior than the XAML resource reference lookup behavior described in this topic.</target>
				</segment>
			</unit>
			<unit id="319" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br243327)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/mt185580)</data>
					<data id="id7">[</data>
					<data id="id8">](../xaml-platform/staticresource-markup-extension.md)</data>
					<data id="id9">[</data>
					<data id="id10">](../xaml-platform/themeresource-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source>To do this, you implement the class <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CustomXamlResourceLoader</pc></pc>, and then you can access that behavior by using the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CustomResource markup extension</pc> for resource references rather than using <pc dataRefEnd="id8" dataRefStart="id7" id="p4">StaticResource</pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5">ThemeResource</pc>.</source>
					<target>To do this, you implement the class <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CustomXamlResourceLoader</pc></pc>, and then you can access that behavior by using the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CustomResource markup extension</pc> for resource references rather than using <pc dataRefEnd="id8" dataRefStart="id7" id="p4">StaticResource</pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5">ThemeResource</pc>.</target>
				</segment>
			</unit>
			<unit id="320" translate="yes">
				<segment state="initial">
					<source>Most apps won't have scenarios that require this.</source>
					<target>Most apps won't have scenarios that require this.</target>
				</segment>
			</unit>
			<unit id="321" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br243327)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CustomXamlResourceLoader</pc></pc>.</source>
					<target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CustomXamlResourceLoader</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="322" translate="yes">
				<segment state="initial">
					<source>Note</source>
					<target>Note</target>
				</segment>
			</unit>
			<unit id="323" translate="yes">
				<segment state="initial">
					<source>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</source>
					<target>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</target>
				</segment>
			</unit>
			<unit id="324" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>If you’re developing for Windows 8.x or Windows Phone 8.x, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archived documentation</pc>.</source>
					<target>If you’re developing for Windows 8.x or Windows Phone 8.x, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archived documentation</pc>.</target>
				</segment>
			</unit>
			<unit id="325" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
					<target>Related topics</target>
				</segment>
			</unit>
			<unit id="326" translate="yes">
				<segment state="initial">
					<source>ResourceDictionary</source>
					<target>ResourceDictionary</target>
				</segment>
			</unit>
			<unit id="327" translate="yes">
				<segment state="initial">
					<source>XAML overview</source>
					<target>XAML overview</target>
				</segment>
			</unit>
			<unit id="328" translate="yes">
				<segment state="initial">
					<source>StaticResource markup extension</source>
					<target>StaticResource markup extension</target>
				</segment>
			</unit>
			<unit id="329" translate="yes">
				<segment state="initial">
					<source>ThemeResource markup extension</source>
					<target>ThemeResource markup extension</target>
				</segment>
			</unit>
			<unit id="330" translate="yes">
				<segment state="initial">
					<source>XAML theme resources</source>
					<target>XAML theme resources</target>
				</segment>
			</unit>
			<unit id="331" translate="yes">
				<segment state="initial">
					<source>Styling controls</source>
					<target>Styling controls</target>
				</segment>
			</unit>
			<unit id="332" translate="yes">
				<segment state="initial">
					<source>x:Key attribute</source>
					<target>x:Key attribute</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>