<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="it-it" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-00ddeee</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">bb15668e1b1e02d8c5087839776ff38a69ec2310</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\tutorial--adding-a-user-interface.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">e8c9f6b187563c9e7f8a56bb824a1d50308fcd45</mda:meta><mda:meta type="olxliffhash">a22474cb5be8041b03cd451aadd4883d815bde36</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Add a user interface</source>
					<target>Add a user interface</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>You've seen how the sample game implements the main game object as well as the basic rendering framework.</source>
					<target>You've seen how the sample game implements the main game object as well as the basic rendering framework.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Add a user interface</source>
					<target>Add a user interface</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>You've seen how the sample game implements the main game object as well as the basic rendering framework.</source>
					<target>You've seen how the sample game implements the main game object as well as the basic rendering framework.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Now, let's look at how the sample game provides feedback about game state to the player.</source>
					<target>Now, let's look at how the sample game provides feedback about game state to the player.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>Here, you learn how you can add simple menu options and heads-up display components on top of the 3-D graphics pipeline output.</source>
					<target>Here, you learn how you can add simple menu options and heads-up display components on top of the 3-D graphics pipeline output.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Objective</source>
					<target>Objective</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>To add basic user interface graphics and behaviors to a Universal Windows Platform (UWP) DirectX game.</source>
					<target>To add basic user interface graphics and behaviors to a Universal Windows Platform (UWP) DirectX game.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>The user interface overlay</source>
					<target>The user interface overlay</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dd370990.aspx)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/dd368038)</data>
				</originalData>
				<segment state="initial">
					<source>While there are many ways to display text and user interface elements in a DirectX game, we are going to focus on one, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Direct2D</pc> (with <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectWrite</pc> for the text elements).</source>
					<target>While there are many ways to display text and user interface elements in a DirectX game, we are going to focus on one, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Direct2D</pc> (with <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectWrite</pc> for the text elements).</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>First, let's be clear about what Direct2D is not.</source>
					<target>First, let's be clear about what Direct2D is not.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>It's not specifically designed for user interfaces or layouts, like HTML or XAML.</source>
					<target>It's not specifically designed for user interfaces or layouts, like HTML or XAML.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>It doesn't provide user interface components, like list boxes or buttons; and it doesn't provide layout components like divs, tables, or grids.</source>
					<target>It doesn't provide user interface components, like list boxes or buttons; and it doesn't provide layout components like divs, tables, or grids.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Direct2D is a set of 2-D drawing APIs used to draw pixel-based primitives and effects.</source>
					<target>Direct2D is a set of 2-D drawing APIs used to draw pixel-based primitives and effects.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>When starting out with Direct2D, keep it simple.</source>
					<target>When starting out with Direct2D, keep it simple.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Complex layouts and interface behaviors need time and planning.</source>
					<target>Complex layouts and interface behaviors need time and planning.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>If your game requires a complex user interface to play, like those found in simulation and strategy games, consider XAML instead.</source>
					<target>If your game requires a complex user interface to play, like those found in simulation and strategy games, consider XAML instead.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial-resources.md)</data>
				</originalData>
				<segment state="initial">
					<source>(For info about developing a user interface with XAML in a UWP DirectX game, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Extending the game sample</pc>.)</source>
					<target>(For info about developing a user interface with XAML in a UWP DirectX game, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Extending the game sample</pc>.)</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>In this game sample, we have two major UI components: the heads-up display for the score and in-game controls; and an overlay used to display game state text and options (such as pause info and level start options).</source>
					<target>In this game sample, we have two major UI components: the heads-up display for the score and in-game controls; and an overlay used to display game state text and options (such as pause info and level start options).</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>Using Direct2D for a heads-up display</source>
					<target>Using Direct2D for a heads-up display</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>This is the in-game heads-up display for the game sample without the game visuals.</source>
					<target>This is the in-game heads-up display for the game sample without the game visuals.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>It's simple and uncluttered, allowing the player to focus on navigating the 3-D world and shooting the targets.</source>
					<target>It's simple and uncluttered, allowing the player to focus on navigating the 3-D world and shooting the targets.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>A good interface or heads-up display must never obfuscate the ability of the player to process and react to the events in the game.</source>
					<target>A good interface or heads-up display must never obfuscate the ability of the player to process and react to the events in the game.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>a screen shot of the game overlay</source>
					<target>a screen shot of the game overlay</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--adding-controls.md)</data>
				</originalData>
				<segment state="initial">
					<source>As you can see, the overlay consists of basic primitives: two intersecting line segments for the cross hairs, and two rectangles for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">move-look controller</pc>.</source>
					<target>As you can see, the overlay consists of basic primitives: two intersecting line segments for the cross hairs, and two rectangles for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">move-look controller</pc>.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>In the upper-right corner, DirectWrite text informs the player of the current number of successful hits, the number of shots the player has made, the time remaining in the level, and the current level number.</source>
					<target>In the upper-right corner, DirectWrite text informs the player of the current number of successful hits, the number of shots the player has made, the time remaining in the level, and the current level number.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The in-game heads-up display state of the overlay is drawn in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Render</pc> method of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GameHud</pc> class, and is coded like this:</source>
					<target>The in-game heads-up display state of the overlay is drawn in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Render</pc> method of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GameHud</pc> class, and is coded like this:</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>In this code, the Direct2D render target established for the overlay is updated to reflect the changes in the number of hits, the time remaining, and the level number.</source>
					<target>In this code, the Direct2D render target established for the overlay is updated to reflect the changes in the number of hits, the time remaining, and the level number.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/dd371902)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/dd371895)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The rectangles are drawn with calls to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DrawRect</pc></pc>, and the cross hairs are drawn with a pair of calls to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DrawLine</pc></pc>.</source>
					<target>The rectangles are drawn with calls to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DrawRect</pc></pc>, and the cross hairs are drawn with a pair of calls to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DrawLine</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br225994)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   You probably noticed the call to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GameHud::Render</pc> takes a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Windows::Foundation::Rect</pc></pc> parameter, which contains the size of the main window rectangle.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   You probably noticed the call to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GameHud::Render</pc> takes a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Windows::Foundation::Rect</pc></pc> parameter, which contains the size of the main window rectangle.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>This demonstrates an essential part of UI programming: obtaining the size of window in a measurement called DIPs (device independent pixels), where a DIP is defined as 1/96 of an inch.</source>
					<target>This demonstrates an essential part of UI programming: obtaining the size of window in a measurement called DIPs (device independent pixels), where a DIP is defined as 1/96 of an inch.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Direct2D scales the drawing units to actual pixels when the drawing occurs, and it does so by using the Windows dots per inch (DPI) setting.</source>
					<target>Direct2D scales the drawing units to actual pixels when the drawing occurs, and it does so by using the Windows dots per inch (DPI) setting.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>Similarly, when you draw text using DirectWrite, you specify DIPs rather than points for the size of the font.</source>
					<target>Similarly, when you draw text using DirectWrite, you specify DIPs rather than points for the size of the font.</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>DIPs are expressed as floating point numbers.</source>
					<target>DIPs are expressed as floating point numbers.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Displaying game state information with an overlay</source>
					<target>Displaying game state information with an overlay</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Besides the heads-up display, the game sample has an overlay that represents five game states, and all of which feature a large black rectangle primitive with text for the player to read.</source>
					<target>Besides the heads-up display, the game sample has an overlay that represents five game states, and all of which feature a large black rectangle primitive with text for the player to read.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>(Be aware that the move-look controller rectangles are not drawn, because they are not active in these states.) These overlay states are:</source>
					<target>(Be aware that the move-look controller rectangles are not drawn, because they are not active in these states.) These overlay states are:</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>The game start overlay.</source>
					<target>The game start overlay.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>We show this when the player starts the game.</source>
					<target>We show this when the player starts the game.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>It contains the high score across game sessions.</source>
					<target>It contains the high score across game sessions.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>a screen shot of the start screen for simple3dgamedx</source>
					<target>a screen shot of the start screen for simple3dgamedx</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>The pause state.</source>
					<target>The pause state.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>a screen shot of the pause screen for simple3dgamedx</source>
					<target>a screen shot of the pause screen for simple3dgamedx</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>The level start state.</source>
					<target>The level start state.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>We show this when the player starts a new level.</source>
					<target>We show this when the player starts a new level.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>a screen shot of the level start screen for simple3dgamedx</source>
					<target>a screen shot of the level start screen for simple3dgamedx</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>The game over state.</source>
					<target>The game over state.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>We show this when the player fails a level.</source>
					<target>We show this when the player fails a level.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>a screen shot of the game over screen for simple3dgamedx</source>
					<target>a screen shot of the game over screen for simple3dgamedx</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>The game stat display state.</source>
					<target>The game stat display state.</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>We show this when the player wins.</source>
					<target>We show this when the player wins.</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>It contains the final score the player has achieved.</source>
					<target>It contains the final score the player has achieved.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>the victory screen for simple3dgamedx</source>
					<target>the victory screen for simple3dgamedx</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Let's look at how we initialize and draw the overlay for these five states.</source>
					<target>Let's look at how we initialize and draw the overlay for these five states.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>Initializing and drawing the overlay</source>
					<target>Initializing and drawing the overlay</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>The five explicit states have some things in common: one, they all use a black rectangle in the center of the screen as their background; two, the displayed text is either title text or body text; and three, the text uses the Segoe UI font and is drawn on top of the back rectangle.</source>
					<target>The five explicit states have some things in common: one, they all use a black rectangle in the center of the screen as their background; two, the displayed text is either title text or body text; and three, the text uses the Segoe UI font and is drawn on top of the back rectangle.</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>As a result, the resources they need and the methods that implement them are very similar.</source>
					<target>As a result, the resources they need and the methods that implement them are very similar.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The game sample has four methods( <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameInfoOverlay::Initialize</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GameInfoOverlay::SetDpi</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">GameInfoOverlay::RecreateDirectXResources</pc>, and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">GameInfoOverlay::RecreateDpiDependentResources</pc>) that it uses to initialize, set the dots per inch, recreate the DirectWrite resources (the text elements), and construct this overlay for display, respectively.</source>
					<target>The game sample has four methods( <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameInfoOverlay::Initialize</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GameInfoOverlay::SetDpi</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">GameInfoOverlay::RecreateDirectXResources</pc>, and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">GameInfoOverlay::RecreateDpiDependentResources</pc>) that it uses to initialize, set the dots per inch, recreate the DirectWrite resources (the text elements), and construct this overlay for display, respectively.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>This is the code for these four methods:</source>
					<target>This is the code for these four methods:</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/hh404478)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/desktop/hh404479)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/desktop/dd368183)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Initialize</pc> method obtains a factory from the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID2D1Device</pc></pc> object passed to it, which it uses to create an <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ID2D1DeviceContext</pc></pc> that the overlay object itself can draw into, and sets the <pc dataRefEnd="id12" dataRefStart="id11" id="p6">m\_dWriteFactory</pc> field to the provided <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">IDWriteFactory</pc></pc> reference.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Initialize</pc> method obtains a factory from the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID2D1Device</pc></pc> object passed to it, which it uses to create an <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ID2D1DeviceContext</pc></pc> that the overlay object itself can draw into, and sets the <pc dataRefEnd="id12" dataRefStart="id11" id="p6">m\_dWriteFactory</pc> field to the provided <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">IDWriteFactory</pc></pc> reference.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>It also sets the DPI for the context.</source>
					<target>It also sets the DPI for the context.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Then, it calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RecreateDeviceResources</pc> to assemble and draw the overlay.</source>
					<target>Then, it calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RecreateDeviceResources</pc> to assemble and draw the overlay.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">RecreateDeviceResources</pc> uses the DirectWrite factory object to create formatters (brushes) for the title and body text strings that will be displayed on the overlay.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">RecreateDeviceResources</pc> uses the DirectWrite factory object to create formatters (brushes) for the title and body text strings that will be displayed on the overlay.</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>It creates a white brush to draw the text, a black brush to draw the background, and an orange brush to draw action messages.</source>
					<target>It creates a white brush to draw the text, a black brush to draw the background, and an orange brush to draw action messages.</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/hh404480)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Then, it calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RecreateDpiDependentResources</pc> to prepare a bitmap to draw the text on by calling <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID2D1DeviceContext::CreateBitmap</pc></pc>.</source>
					<target>Then, it calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RecreateDpiDependentResources</pc> to prepare a bitmap to draw the text on by calling <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID2D1DeviceContext::CreateBitmap</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Lastly, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RecreateDpiDependentResources</pc> sets the render target for the Direct2D device context to the bitmap and clears it, which then sets each pixel in the bitmap to the color black.</source>
					<target>Lastly, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RecreateDpiDependentResources</pc> sets the render target for the Direct2D device context to the bitmap and clears it, which then sets each pixel in the bitmap to the color black.</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>Now, all the overlay needs is some text to display!</source>
					<target>Now, all the overlay needs is some text to display!</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>Representing game state in the overlay</source>
					<target>Representing game state in the overlay</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Each of the five overlay states in the game sample has a corresponding method on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameInfoOverlay</pc> object.</source>
					<target>Each of the five overlay states in the game sample has a corresponding method on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameInfoOverlay</pc> object.</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>These methods draw a variation of the overlay to communicate explicit info to the player about the game itself.</source>
					<target>These methods draw a variation of the overlay to communicate explicit info to the player about the game itself.</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>This communication is, of course, represented as two strings: a title string, and a body string.</source>
					<target>This communication is, of course, represented as two strings: a title string, and a body string.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Because the sample already configured the resources and layout for this info in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RecreateDeviceResources</pc> method, it only needs to provide the overlay state-specific strings.</source>
					<target>Because the sample already configured the resources and layout for this info in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RecreateDeviceResources</pc> method, it only needs to provide the overlay state-specific strings.</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Now, in the definition of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameInfoOverlay</pc> class, the sample declared three rectangular areas that correspond to specific regions of the overlay, as shown here:</source>
					<target>Now, in the definition of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameInfoOverlay</pc> class, the sample declared three rectangular areas that correspond to specific regions of the overlay, as shown here:</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>These areas each have a specific purpose:</source>
					<target>These areas each have a specific purpose:</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">titleRectangle</pc> is where the title text is drawn.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">titleRectangle</pc> is where the title text is drawn.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">bodyRectangle</pc> is where the body text is drawn.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">bodyRectangle</pc> is where the body text is drawn.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">actionRectangle</pc> is where the text that informs the player to take a specific action is drawn.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">actionRectangle</pc> is where the text that informs the player to take a specific action is drawn.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>(It's in the bottom left of the overlay bitmap.)</source>
					<target>(It's in the bottom left of the overlay bitmap.)</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>With these areas in mind, let's look at one of the state-specific methods, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameInfoOverlay::SetGameStats</pc>, and see how the overlay is drawn.</source>
					<target>With these areas in mind, let's look at one of the state-specific methods, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameInfoOverlay::SetGameStats</pc>, and see how the overlay is drawn.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Using the Direct2D device context that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameInfoOverlay</pc> object initialized and configured using <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Initialize</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">RecreateDirectXResources</pc>, this method fills the title and body rectangles with black using the background brush.</source>
					<target>Using the Direct2D device context that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameInfoOverlay</pc> object initialized and configured using <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Initialize</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">RecreateDirectXResources</pc>, this method fills the title and body rectangles with black using the background brush.</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>It draws the text for the "High Score" string to the title rectangle and a string containing the updates game state information to the body rectangle using the white text brush.</source>
					<target>It draws the text for the "High Score" string to the title rectangle and a string containing the updates game state information to the body rectangle using the white text brush.</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The action rectangle is updated by a subsequent call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameInfoOverlay::SetAction</pc> from a method on the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectXApp</pc> object, which provides the game state info needed by <pc dataRefEnd="id6" dataRefStart="id5" id="p3">SetAction</pc> to determine the right message to the player (such as "Tap to continue").</source>
					<target>The action rectangle is updated by a subsequent call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameInfoOverlay::SetAction</pc> from a method on the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectXApp</pc> object, which provides the game state info needed by <pc dataRefEnd="id6" dataRefStart="id5" id="p3">SetAction</pc> to determine the right message to the player (such as "Tap to continue").</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The overlay for any given state is chosen in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetGameInfoOverlay</pc> method on <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectXApp</pc>, like this:</source>
					<target>The overlay for any given state is chosen in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetGameInfoOverlay</pc> method on <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectXApp</pc>, like this:</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>And now the game sample has a way to communicate text info to the player based on game state.</source>
					<target>And now the game sample has a way to communicate text info to the player based on game state.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Next steps</source>
					<target>Next steps</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--adding-controls.md)</data>
				</originalData>
				<segment state="initial">
					<source>In the next topic, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Adding controls</pc>, we look at how the player interacts with the game sample, and how input changes game state.</source>
					<target>In the next topic, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Adding controls</pc>, we look at how the player interacts with the game sample, and how input changes game state.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>Complete sample code for this section</source>
					<target>Complete sample code for this section</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>GameHud.h</source>
					<target>GameHud.h</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>GameHud.cpp</source>
					<target>GameHud.cpp</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>GameInfoOverlay.h</source>
					<target>GameInfoOverlay.h</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>GameInfoOverlay.cpp</source>
					<target>GameInfoOverlay.cpp</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
					<target>Related topics</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>Create a simple UWP game with DirectX</source>
					<target>Create a simple UWP game with DirectX</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>