<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">af817df780f291b6367a374e535cce22a84ba4c1</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci1\xaml-platform\xaml-syntax-guide.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">ce7f0eeeb36a8f550e22d429947ed5dc9ca4df43</mda:meta><mda:meta type="olxliffhash">bc9ce2f709b46c071b28dba10f23bd07436900cd</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>We explain XAML syntax rules and the terminology that describes the restrictions or choices available for XAML syntax.</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>XAML syntax guide</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>XAML syntax guide</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>We explain XAML syntax rules and the terminology that describes the restrictions or choices available for XAML syntax.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>You'll find this topic useful if you are new to using the XAML language, you want a refresher on the terminology or parts of syntax, or you are curious about how the XAML language works and want more background and context.</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>XAML is XML</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Extensible Application Markup Language (XAML) has a basic syntax that builds on XML, and by definition valid XAML must be valid XML.</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>But XAML also has its own syntax concepts that extend XML.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>A given XML entity might be valid in plain XML, but that syntax might have a different and more complete meaning as XAML.</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>This topic explains these XAML syntax concepts.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>XAML vocabularies</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>One area where XAML differs from most XML usages is that XAML is not typically enforced with a schema, such as an XSD file.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>That's because XAML is intended to be extensible, that's what the "X" in the acronym XAML means.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Once XAML is parsed, the elements and attributes you reference in XAML are expected to exist in some backing code representation, either in the core types defined by the Windows Runtime, or in types that extend or are based off the Windows Runtime.</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>The SDK documentation sometimes refers to the types that are already built-in to the Windows Runtime and can be used in XAML as being the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML vocabulary</pc> for the Windows Runtime.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Microsoft Visual Studio helps you to produce markup that's valid within this XAML vocabulary.</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>Visual Studio can also include your custom types for XAML usage so long as the source of those types is referenced correctly in the project.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](xaml-namespaces-and-namespace-mapping.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about XAML and custom types, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML namespaces and namespace mapping</pc>.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>Declaring objects</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>Programmers often think in terms of objects and members, whereas a markup language is conceptualized as elements and attributes.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>In the most basic sense, an element that you declare in XAML markup becomes an object in a backing runtime object representation.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>To create a run-time object for your app, you declare a XAML element in the XAML markup.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>The object is created when the Windows Runtime loads your XAML.</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>A XAML file always has exactly one element serving as its root, which declares an object that will be the conceptual root of some programming structure such as a page, or the object graph of the entire run-time definition of an application.</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>In terms of XAML syntax, there are three ways to declare objects in XAML:</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Directly, using object element syntax:</pc> This uses opening and closing tags to instantiate an object as an XML-form element.</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>You can use this syntax to declare root objects or to create nested objects that set property values.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Indirectly, using attribute syntax:</pc> This uses an inline string value that has instructions for how to create an object.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>The XAML parser uses this string to set the value of a property to a newly created reference value.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Support for it is limited to certain common objects and properties.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Using a markup extension.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>This does not mean that you always have the choice of any syntax for object creation in a XAML vocabulary.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>Some objects can be created only by using object element syntax.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>Some objects can be created only by being initially set in an attribute.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>In fact, objects that can be created with either object element or attribute syntax are comparatively rare in XAML vocabularies.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Even if both syntax forms are possible, one of the syntaxes will be more common as a matter of style.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>There are also techniques you can use in XAML to reference existing objects rather than creating new values.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>The existing objects might be defined either in other areas of XAML, or might exist implicitly through some behavior of the platform and its application or programming models.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Declaring an object by using object element syntax</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<originalData>
					<data id="id1">`&lt;objectName&gt;  &lt;/objectName&gt;`</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
				</originalData>
				<segment state="initial">
					<source>To declare an object with object element syntax, you write tags like this: <ph dataRef="id1" id="ph1" />, where <pc dataRefEnd="id3" dataRefStart="id2" id="p1">objectName</pc> is the type name for the object you want to instantiate.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209267)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's object element usage to declare a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Canvas</pc></pc> object:</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>If the object does not contain other objects, you can declare the object element by using one self-closing tag instead of an opening/closing pair:</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>Containers</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209267)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Many objects used as UI elements, such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Canvas</pc></pc>, can contain other objects.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>These are sometimes referred to as containers.</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br243371)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Canvas</pc> container that contains one element, a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Rectangle</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>Declaring an object by using attribute syntax</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>Because this behavior is tied to property setting, we'll talk about this more in upcoming sections.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Initialization text</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>For some objects you can declare new values using inner text that's used as initialization values for construction.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>In XAML, this technique and syntax is called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">initialization text</pc>.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Conceptually, initialization text is similar to calling a constructor that has parameters.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Initialization text is useful for setting initial values of certain structures.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>You often use an object element syntax with initialization text if you want a structure value with an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Key</pc>, so it can exist in a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ResourceDictionary</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>You might do this if you share that structure value among multiple target properties.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242343)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208864)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br208754)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/hh673723)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>For some structures, you can't use attribute syntax to set the structure's values: initialization text is the only way to produce a useful and shareable <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CornerRadius</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Thickness</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">GridLength</pc></pc> or <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Color</pc></pc> resource.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208864)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>This abbreviated example uses initialization text to specify values for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Thickness</pc></pc>, in this case specifying values that set both <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Left</pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Right</pc> to 20, and both <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Top</pc> and <pc dataRefEnd="id12" dataRefStart="id11" id="p6">Bottom</pc> to 10.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This example shows the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Thickness</pc> created as a keyed resource, and then the reference to that resource.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208864)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208864)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For more info on <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Thickness</pc></pc> initialization text, see <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Thickness</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Some structures can't be declared as object elements.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>Initialization text isn't supported and they can't be used as resources.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>You must use an attribute syntax in order to set properties to these values in XAML.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242377)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br210411)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br225870)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/br225994)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
					<data id="id17">[</data>
					<data id="id18">](https://msdn.microsoft.com/library/windows/apps/br225995)</data>
					<data id="id19">**</data>
					<data id="id20">**</data>
				</originalData>
				<segment state="initial">
					<source>These types are: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Duration</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">RepeatBehavior</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Point</pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Rect</pc></pc> and <pc dataRefEnd="id18" dataRefStart="id17" id="p9"><pc dataRefEnd="id20" dataRefStart="id19" id="p10">Size</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>Setting properties</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>You can set properties on objects that you declared by using object element syntax.</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>There are multiple ways to set properties in XAML:</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>By using attribute syntax.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>By using property element syntax.</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>By using element syntax where the content (inner text or child elements) is setting the XAML content property of an object.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>By using a collection syntax (which is usually the implicit collection syntax).</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>As with object declaration, this list doesn't imply that any property could be set with each of the techniques.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>Some properties support only one of the techniques.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>Some properties support more than one form; for example, there are properties that can use property element syntax, or attribute syntax.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>What's possible depends both on the property and on the object type that the property uses.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In the Windows Runtime API reference, you'll see the XAML usages you can use in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Syntax</pc> section.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>Sometimes there is an alternative usage that would work but would be more verbose.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>Those verbose usages aren't always shown because we are trying to show you the best practices or the real world scenarios for using that property in XAML.</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Guidance for XAML syntax is provided in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML Usage</pc> sections of reference pages for properties that can be set in XAML.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Some properties on objects that cannot be set in XAML by any means, and can only be set using code.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>Usually these are properties that are more appropriate to work with in the code-behind, not in XAML.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>A read-only property cannot be set in XAML.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>Even in code, the owning type would have to support some other way to set it, like a constructor overload, helper method, or calculated property support.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>A calculated property relies on the values of other settable properties plus sometimes an event with built-in handling; these features are available in the dependency property system.</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](dependency-properties-overview.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info on how dependency properties are useful for calculated property support, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dependency properties overview</pc>.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Collection syntax in XAML gives an appearance that you are setting a read-only property, but in fact you are not.</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>See "Setting a Property by Using a Collection Syntax" section later in this topic.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>Setting a property by using attribute syntax</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>Setting an attribute value is the typical means by which you set a property value in a markup language, for example in XML or HTML.</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>Setting XAML attributes is similar to how you set attribute values in XML.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>The attribute name is specified at any point within the tags following the element name, separated from element name by at least one whitespace.</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>The attribute name is followed by an equals sign.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>The attribute value is contained within a pair of quotes.</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>The quotes can be either double quotes or single quotes so long as they match and enclose the value.</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>The attribute value itself must be expressible as a string.</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>The string often contains numerals, but to XAML, all attribute values are string values until the XAML parser gets involved and does some basic value conversion.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208735)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208751)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br208718)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/br243378)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
					<data id="id17">[</data>
					<data id="id18">](https://msdn.microsoft.com/library/windows/apps/br243371)</data>
					<data id="id19">**</data>
					<data id="id20">**</data>
				</originalData>
				<segment state="initial">
					<source>This example uses attribute syntax for four attributes to set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Name</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Width</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Height</pc></pc>, and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Fill</pc></pc> properties of a <pc dataRefEnd="id18" dataRefStart="id17" id="p9"><pc dataRefEnd="id20" dataRefStart="id19" id="p10">Rectangle</pc></pc> object.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>Setting a property by using property element syntax</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>Many properties of an object can be set by using property element syntax.</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<originalData>
					<data id="id1">`&lt;`</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">`.`</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
					<data id="id7">`&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>A property element looks like this: <ph dataRef="id1" id="ph1" /><pc dataRefEnd="id3" dataRefStart="id2" id="p1">object</pc><ph dataRef="id4" id="ph2" /><pc dataRefEnd="id6" dataRefStart="id5" id="p2">property</pc><ph dataRef="id7" id="ph3" />.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>To use property element syntax, you create XAML property elements for the property that you want to set.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>In standard XML, this element would just be considered an element that has a dot in its name.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
				</originalData>
				<segment state="initial">
					<source>However, in XAML, the dot in the element name identifies the element as a property element, with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">property</pc> expected to a member of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">object</pc> in a backing object model implementation.</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>To use property element syntax, it must be possible to specify an object element in order to "fill" the property element tags.</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>A property element will always have some content (single element, multiple elements, or inner text); there's no point in having a self-closing property element.</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
				</originalData>
				<segment state="initial">
					<source>In the following grammar, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">property</pc> is the name of the property that you want to set and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">propertyValueAsObjectElement</pc> is a single object element, that's expected to satisfy the value type requirements of the property.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>object</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">`.`</data>
					<data id="id4">*</data>
					<data id="id5">*</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">object</pc><ph dataRef="id3" id="ph1" /><pc dataRefEnd="id5" dataRefStart="id4" id="p2">property</pc></source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>propertyValueAsObjectElement</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">`.`</data>
					<data id="id4">*</data>
					<data id="id5">*</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">object</pc><ph dataRef="id3" id="ph1" /><pc dataRefEnd="id5" dataRefStart="id4" id="p2">property</pc></source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>object</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br243378)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br243371)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br242962)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example uses property element syntax to set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Fill</pc></pc> of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Rectangle</pc></pc> with a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">SolidColorBrush</pc></pc> object element.</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242963)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>(Within the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SolidColorBrush</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Color</pc></pc> is set as an attribute.) The parsed result of this XAML is identical to the previous XAML example that set <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Fill</pc> using attribute syntax.</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>XAML vocabularies and object-oriented programming</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<segment state="initial">
					<source>Properties and events as they appear as XAML members of a Windows Runtime XAML type are often inherited from base types.</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<originalData>
					<data id="id1">`&lt;Button Background="Blue" .../&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>Consider this example: <ph dataRef="id1" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209395)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209265)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Background</pc></pc> property is not an immediately declared property on the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Button</pc></pc> class.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br209390)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Instead, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Background</pc> is inherited from the base <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Control</pc></pc> class.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br227736)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/br209390)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/br208706)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
					<data id="id15">[</data>
					<data id="id16">](https://msdn.microsoft.com/library/windows/apps/br208911)</data>
					<data id="id17">**</data>
					<data id="id18">**</data>
					<data id="id19">[</data>
					<data id="id20">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id21">**</data>
					<data id="id22">**</data>
				</originalData>
				<segment state="initial">
					<source>In fact, if you look at the reference topic for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Button</pc> you'll see that the members lists contain at least one inherited member from each of a chain of successive base classes: <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ButtonBase</pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Control</pc></pc>, <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">FrameworkElement</pc></pc>, <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">UIElement</pc></pc>, <pc dataRefEnd="id20" dataRefStart="id19" id="p10"><pc dataRefEnd="id22" dataRefStart="id21" id="p11">DependencyObject</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Properties</pc> list, all the read-write properties and collection properties are inherited in a XAML vocabulary sense.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208911)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Events (like the various <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> events) are inherited too.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>If you use the Windows Runtime reference for XAML guidance, the element name that's shown in a syntax or even in example code is sometimes for the type that originally defines the property, because that reference topic is shared by all the possible types that inherit it from a base class.</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>If you use Visual Studio's IntelliSense for XAML in the XML editor, the IntelliSense and its drop-downs do a great job of coalescing the inheritance and providing an accurate list of attributes that are available for setting once you've started with an object element for a class instance.</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>XAML content properties</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<segment state="initial">
					<source>Some types define one of their properties such that the property enables a XAML content syntax.</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>For the XAML content property of a type, you can omit the property element for that property when specifying it in XAML.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>Or, you can set the property to an inner text value by providing that inner text directly within the owning type's object element tags.</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<segment state="initial">
					<source>XAML content properties support straightforward markup syntax for that property and makes the XAML more human-readable by reducing the nesting.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If a XAML content syntax is available, that syntax will be shown in the "XAML" sections of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Syntax</pc> for that property in the Windows Runtime reference documentation.</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209258)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209250)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Child</pc></pc> property page for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Border</pc></pc> shows XAML content syntax instead of property element syntax to set the single-object <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Border.Child</pc> value of a <pc dataRefEnd="id12" dataRefStart="id11" id="p6">Border</pc>, like this:</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If the property that is declared as the XAML content property is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Object</pc> type, or is type <pc dataRefEnd="id4" dataRefStart="id3" id="p2">String</pc>, then the XAML content syntax supports what's basically inner text in the XML document model: a string between the opening and closing object tags.</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209676)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209652)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Text</pc></pc> property page for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TextBlock</pc></pc> shows XAML content syntax that has an inner text value to set <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Text</pc>, but the string "Text" never appears in the markup.</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>Here's an example usage:</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>If a XAML content property exists for a class, that's indicated in the reference topic for the class, in the "Attributes" section.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228011)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Look for the value of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentPropertyAttribute</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>This attribute uses a named field "Name".</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>The value of "Name" is the name of the property of that class that is the XAML content property.</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209250)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Border</pc></pc> reference page, you'll see this: ContentProperty("Name=Child").</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<segment state="initial">
					<source>One important XAML syntax rule we should mention is that you can't intermix the XAML content property and other property elements you set on the element.</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<segment state="initial">
					<source>The XAML content property must be set entirely before any property elements, or entirely after.</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>For example this is invalid XAML:</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>Collection syntax</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<segment state="initial">
					<source>All of the syntaxes shown thus far are setting properties to single objects.</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>But many UI scenarios require that a given parent element can have multiple child elements.</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>For example, a UI for an input form needs several text box elements, some labels, and perhaps a "Submit" button.</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>Still, if you were to use a programming object model to access these multiple elements, they would typically be items in a single collection property, rather than each item being the value of different properties.</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>XAML supports multiple child elements as well as supporting a typical backing collection model by treating properties that use a collection type as implicit, and performing special handling for any child elements of a collection type.</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>Many collection properties are also identified as the XAML content property for the class.</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>The combination of implicit collection processing and XAML content syntax is frequently seen in types used for control compositing, such as panels, views, or items controls.</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209635)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, the following examples show the simplest possible XAML for compositing two peer UI elements within a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StackPanel</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<segment state="initial">
					<source>The mechanism of XAML collection syntax</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>It might at first appear that XAML is enabling a "set" of the read-only collection property.</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<segment state="initial">
					<source>In reality, what XAML enables here is adding items to an existing collection.</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<segment state="initial">
					<source>The XAML language and XAML processors implementing XAML support rely on a convention in backing collection types to enable this syntax.</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Typically there is a backing property such as an indexer or <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Items</pc> property that refers to specific items of the collection.</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>Generally, that property is not explicit in the XAML syntax.</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For collections, the underlying mechanism for XAML parsing is not a property, but a method: specifically, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Add</pc> method in most cases.</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When the XAML processor encounters one or more object elements within a XAML collection syntax, each such object is first created from an element, then each new object is added in order to the containing collection by calling the collection's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Add</pc> method.</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When a XAML parser adds items to a collection, it is the logic of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Add</pc> method that determines whether a given XAML element is a permissible item child of the collection object.</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Many collection types are strongly typed by the backing implementation, meaning that the input parameter of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Add</pc> expects that whatever is passed must be a type match with the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Add</pc> parameter type.</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<segment state="initial">
					<source>For collection properties, be careful about when you try to specify the collection explicitly as an object element.</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>A XAML parser will create a new object whenever it encounters an object element.</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<segment state="initial">
					<source>If the collection property you're trying to use is read-only, this can throw a XAML parse exception.</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<segment state="initial">
					<source>Just use the implicit collection syntax, and you won't see that exception.</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>When to use attribute or property element syntax</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>All properties that support being set in XAML will support attribute or property element syntax for direct value setting, but potentially will not support either syntax interchangeably.</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>Some properties do support either syntax, and some properties support additional syntax options like a XAML content property.</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>The type of XAML syntax supported by a property depends on the type of object that the property uses as its property type.</source>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<segment state="initial">
					<source>If the property type is a primitive type, such as a double (float or decimal), integer, Boolean, or string, the property always supports attribute syntax.</source>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<segment state="initial">
					<source>You can also use attribute syntax to set a property if the object type you use to set that property can be created by processing a string.</source>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<segment state="initial">
					<source>For primitives, this is always the case, the type conversion is built in to the parser.</source>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>However, certain other object types can also be created by using a string specified as an attribute value, rather than an object element within a property element.</source>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<segment state="initial">
					<source>For this to work, there has to be an underlying type conversion, supported either by that particular property or supported generally for all values that use that property type.</source>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<segment state="initial">
					<source>The string value of the attribute is used to set properties that are important for the initialization of the new object value.</source>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<segment state="initial">
					<source>Potentially, a specific type converter can also create different subclasses of a common property type, depending on how it uniquely processes information in the string.</source>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<segment state="initial">
					<source>Object types that support this behavior will have a special grammar listed in the syntax section of the reference documentation.</source>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228076)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242962)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>As an example, the XAML syntax for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Brush</pc></pc> shows how an attribute syntax can be used to create a new <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SolidColorBrush</pc></pc> value for any property of type <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Brush</pc> (and there are many <pc dataRefEnd="id12" dataRefStart="id11" id="p6">Brush</pc> properties in Windows Runtime XAML).</source>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>XAML parsing logic and rules</source>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<segment state="initial">
					<source>Sometime's it's informative to read the XAML in a similar way to how a XAML parser must read it: as a set of string tokens encountered in a linear order.</source>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>A XAML parser must interpret these tokens under a set of rules that are part of the definition of how XAML works.</source>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<segment state="initial">
					<source>Setting an attribute value is the typical means by which you set a property value in a markup language, for example in XML or HTML.</source>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
				</originalData>
				<segment state="initial">
					<source>In the following syntax, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">objectName</pc> is the object you want to instantiate, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">propertyName</pc> is the name of the property that you want to set on that object, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">propertyValue</pc> is the value to set.</source>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<segment state="initial">
					<source>Either syntax enables you to declare an object and set a property on that object.</source>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<segment state="initial">
					<source>Although the first example is a single element in markup, there are actually discrete steps here with regard to how a XAML processor parses this markup.</source>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>First, the presence of the object element indicates that a new <pc dataRefEnd="id2" dataRefStart="id1" id="p1">objectName</pc> object must be instantiated.</source>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>Only after such an instance exists can the instance property <pc dataRefEnd="id2" dataRefStart="id1" id="p1">propertyName</pc> can be set on it.</source>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<segment state="initial">
					<source>Another rule of XAML is that attributes of an element must be able to be set in any order.</source>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<originalData>
					<data id="id1">`&lt;Rectangle Height="50" Width="100" /&gt;`</data>
					<data id="id2">`&lt;Rectangle Width="100"  Height="50" /&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>For example, there's no difference between <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" />.</source>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<segment state="initial">
					<source>Which order you use is a matter of style.</source>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  XAML designers often promote ordering conventions if you use design surfaces other than the XML editor, but you can freely edit that XAML later, to reorder the attributes or introduce new ones.</source>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<segment state="initial">
					<source>Attached properties</source>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>XAML extends XML by adding a syntax element known as an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">attached property</pc>.</source>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<segment state="initial">
					<source>Similar to the property element syntax, the attached property syntax contains a dot, and the dot holds special meaning to XAML parsing.</source>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<segment state="initial">
					<source>Specifically, the dot separates the owner provider of the attached property, and the property name.</source>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh759771)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>In XAML, you set attached properties by using the syntax <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AttachedPropertyProvider</pc>.<pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyName</pc> Here is an example of how you can set the attached property <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Canvas.Left</pc></pc> in XAML:</source>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You can set the attached property on elements that don't have a property of that name in the backing type, and in that way they function somewhat like a global property, or an attribute defined by a different XML namespace like the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xml:space</pc> attribute.</source>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<segment state="initial">
					<source>In Windows Runtime XAML you'll see attached properties that support these scenarios:</source>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209267)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242704)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br227651)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>Child elements can inform parent container panels how they should behave in layout: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Canvas</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Grid</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">VariableSizedWrapGrid</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209527)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br227689)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Control usages can influence behavior of an important control part that comes from the control template: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollViewer</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">VirtualizingStackPanel</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702143)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209021)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br209081)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/br227609)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>Using a service that's available in a related class, where the service and the class that uses it don't share inheritance: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Typography</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">VisualStateManager</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">AutomationProperties</pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">ToolTipService</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br210490)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Animation targeting: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Storyboard</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](attached-properties-overview.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Attached properties overview</pc>.</source>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<segment state="initial">
					<source>Literal "{" values</source>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<segment state="initial">
					<source>Because the opening brace symbol \{ is the opening of the markup extension sequence, you use an escape sequence to specify a literal string value that starts with "\{".</source>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<segment state="initial">
					<source>The escape sequence is "\{\}".</source>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<segment state="initial">
					<source>For example, to specify a string value that is a single opening brace, specify the attribute value as "\{\}\{".</source>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can also use the alternative quotation marks (for example, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">'</pc> within an attribute value delimited by <pc dataRefEnd="id4" dataRefStart="id3" id="p2">""</pc>) to provide a "\{" value as a string.</source>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  "\\}" also works if it's inside a quoted attribute.</source>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<segment state="initial">
					<source>Enumeration values</source>
				</segment>
			</unit>
			<unit id="311" translate="yes">
				<segment state="initial">
					<source>Many properties in the Windows Runtime API use enumerations as values.</source>
				</segment>
			</unit>
			<unit id="312" translate="yes">
				<segment state="initial">
					<source>If the member is a read-write property you can set such a property by providing an attribute value.</source>
				</segment>
			</unit>
			<unit id="313" translate="yes">
				<segment state="initial">
					<source>You identify which enumeration value to use as the value of the property by using the unqualified name of the constant name .</source>
				</segment>
			</unit>
			<unit id="314" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208992)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">`&lt;Button Visibility="Visible"/&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>For example here's how to set <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement.Visibility</pc></pc> in XAML: <ph dataRef="id5" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="315" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209006)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Here the "Visible" as a string is directly mapped to a named constant of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Visibility</pc></pc> enumeration, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Visible</pc>.</source>
				</segment>
			</unit>
			<unit id="316" translate="yes">
				<segment state="initial">
					<source>Don't use a qualified form, it won't work.</source>
				</segment>
			</unit>
			<unit id="317" translate="yes">
				<originalData>
					<data id="id1">`&lt;Button Visibility="Visibility.Visible"/&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>For example, this is invalid XAML: <ph dataRef="id1" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="318" translate="yes">
				<segment state="initial">
					<source>Don't use the value of the constant.</source>
				</segment>
			</unit>
			<unit id="319" translate="yes">
				<segment state="initial">
					<source>In other words, don't rely on the integer value of the enumeration that's there explicitly or implicitly depending on how the enumeration was defined.</source>
				</segment>
			</unit>
			<unit id="320" translate="yes">
				<segment state="initial">
					<source>Although it might appear to work, it's a bad practice either in XAML or in code because you're relying on what could be a transient implementation detail.</source>
				</segment>
			</unit>
			<unit id="321" translate="yes">
				<originalData>
					<data id="id1">`&lt;Button Visibility="1"/&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>For example, don't do this: <ph dataRef="id1" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="322" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  In reference topics for APIs that use XAML and use enumerations, click the link to the enumeration type in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Property value</pc> section of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Syntax</pc>.</source>
				</segment>
			</unit>
			<unit id="323" translate="yes">
				<segment state="initial">
					<source>This links to the enumeration page where you can discover the named constants for that enumeration.</source>
				</segment>
			</unit>
			<unit id="324" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Enumerations can be flagwise, meaning that they are attributed with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FlagsAttribute</pc>.</source>
				</segment>
			</unit>
			<unit id="325" translate="yes">
				<segment state="initial">
					<source>If you need to specify a combination of values for a flagwise enumeration as a XAML attribute value, use the name of each enumeration constant, with a comma (,) between each name, and no intervening space characters.</source>
				</segment>
			</unit>
			<unit id="326" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227934)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Flagwise attributes aren't common in the Windows Runtime XAML vocabulary, but <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ManipulationModes</pc></pc> is an example where setting a flagwise enumeration value in XAML is supported.</source>
				</segment>
			</unit>
			<unit id="327" translate="yes">
				<segment state="initial">
					<source>Interfaces in XAML</source>
				</segment>
			</unit>
			<unit id="328" translate="yes">
				<segment state="initial">
					<source>In rare cases you'll see a XAML syntax where the type of a property is an interface.</source>
				</segment>
			</unit>
			<unit id="329" translate="yes">
				<segment state="initial">
					<source>In the XAML type system, a type that implements that interface is acceptable as a value when parsed.</source>
				</segment>
			</unit>
			<unit id="330" translate="yes">
				<segment state="initial">
					<source>There must be a created instance of such a type available to serve as the value.</source>
				</segment>
			</unit>
			<unit id="331" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227740)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br227741)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br227736)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>You'll see an interface used as a type in the XAML syntax for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Command</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CommandParameter</pc></pc> properties of <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ButtonBase</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="332" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>These properties support Model-View-ViewModel (MVVM) design patterns where the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ICommand</pc> interface is the contract for how the views and models interact.</source>
				</segment>
			</unit>
			<unit id="333" translate="yes">
				<segment state="initial">
					<source>XAML placeholder conventions in Windows Runtime reference</source>
				</segment>
			</unit>
			<unit id="334" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If you've examined any of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Syntax</pc> section of reference topics for Windows Runtime APIs that can use XAML, you've probably seen that the syntax includes quite a few placeholders.</source>
				</segment>
			</unit>
			<unit id="335" translate="yes">
				<segment state="initial">
					<source>XAML syntax is different than the C#, Microsoft Visual Basic or Visual C++ component extensions (C++/CX) syntax because the XAML syntax is a usage syntax.</source>
				</segment>
			</unit>
			<unit id="336" translate="yes">
				<segment state="initial">
					<source>It's hinting at your eventual usage in your own XAML files, but without being over-prescriptive about the values you can use.</source>
				</segment>
			</unit>
			<unit id="337" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>So usually the usage describes a type of grammar that mixes literals and placeholders, and defines some of the placeholders in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML Values</pc> section.</source>
				</segment>
			</unit>
			<unit id="338" translate="yes">
				<segment state="initial">
					<source>When you see type names / element names in a XAML syntax for a property, the name that's shown is for the type that originally defines the property.</source>
				</segment>
			</unit>
			<unit id="339" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>But Windows Runtime XAML supports a class inheritance model for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>-based classes.</source>
				</segment>
			</unit>
			<unit id="340" translate="yes">
				<segment state="initial">
					<source>So you can often use an attribute on a class that's not literally the defining class, but instead derives from a class that first defined the property/attribute.</source>
				</segment>
			</unit>
			<unit id="341" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208992)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208911)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, you can set <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Visibility</pc></pc> as an attribute on any <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">UIElement</pc></pc> derived class using a deep inheritance.</source>
				</segment>
			</unit>
			<unit id="342" translate="yes">
				<originalData>
					<data id="id1">`&lt;Button Visibility="Visible" /&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>For example: <ph dataRef="id1" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="343" translate="yes">
				<segment state="initial">
					<source>So don't take the element name shown in any XAML usage syntax too literally; the syntax may be viable for elements representing that class, and also elements that represent a derived class.</source>
				</segment>
			</unit>
			<unit id="344" translate="yes">
				<segment state="initial">
					<source>In cases where it's rare or impossible for the type shown as the defining element to be in a real-world usage, that type name is deliberately lowercased in the syntax.</source>
				</segment>
			</unit>
			<unit id="345" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, the syntax you see for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UIElement.Visibility</pc> is :</source>
				</segment>
			</unit>
			<unit id="346" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Many XAML syntax sections include placeholders in the "Usage" that are then defined in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML Values</pc> section that's directly under the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Syntax</pc> section.</source>
				</segment>
			</unit>
			<unit id="347" translate="yes">
				<segment state="initial">
					<source>XAML usage sections also use various generalized placeholders.</source>
				</segment>
			</unit>
			<unit id="348" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>These placeholders aren't redefined every time in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML Values</pc>, because you'll guess or eventually learn what they represent.</source>
				</segment>
			</unit>
			<unit id="349" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>We think most readers would get tired of seeing them in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML Values</pc> again and again so we left them out of the definitions.</source>
				</segment>
			</unit>
			<unit id="350" translate="yes">
				<segment state="initial">
					<source>For reference, here's a list of some of these placeholders and what they mean in a general sense:</source>
				</segment>
			</unit>
			<unit id="351" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">object</pc>: theoretically any object value, but often practically limited to certain types of objects such as a string-or-object choice, and you should check the Remarks on the reference page for more info.</source>
				</segment>
			</unit>
			<unit id="352" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
					<data id="id7">*</data>
					<data id="id8">*</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">object</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="p2">property</pc>: <pc dataRefEnd="id6" dataRefStart="id5" id="p3">object</pc> <pc dataRefEnd="id8" dataRefStart="id7" id="p4">property</pc> in combination is used for cases where the syntax being shown is the syntax for a type that can be used as an attribute value for many properties.</source>
				</segment>
			</unit>
			<unit id="353" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br228076)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">*</data>
					<data id="id8">*</data>
					<data id="id9">*</data>
					<data id="id10">*</data>
					<data id="id11">*</data>
					<data id="id12">*</data>
				</originalData>
				<segment state="initial">
					<source>For example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Xaml Attribute Usage</pc> shown for <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Brush</pc></pc> includes: &lt;<pc dataRefEnd="id8" dataRefStart="id7" id="p4">object</pc> <pc dataRefEnd="id10" dataRefStart="id9" id="p5">property</pc>="<pc dataRefEnd="id12" dataRefStart="id11" id="p6">predefinedColorName</pc>"/&gt;</source>
				</segment>
			</unit>
			<unit id="354" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">eventhandler</pc>: This appears as the attribute value for every XAML syntax shown for an event attribute.</source>
				</segment>
			</unit>
			<unit id="355" translate="yes">
				<segment state="initial">
					<source>What you're supplying here is the function name for an event handler function.</source>
				</segment>
			</unit>
			<unit id="356" translate="yes">
				<segment state="initial">
					<source>That function must be defined in the code-behind for the XAML page.</source>
				</segment>
			</unit>
			<unit id="357" translate="yes">
				<segment state="initial">
					<source>At the programming level, that function must match the delegate signature of the event that you're handling, or your app code won't compile.</source>
				</segment>
			</unit>
			<unit id="358" translate="yes">
				<segment state="initial">
					<source>But that's really a programming consideration, not a XAML consideration, so we don't try to hint anything about the delegate type in the XAML syntax.</source>
				</segment>
			</unit>
			<unit id="359" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you want to know which delegate you should be implementing for an event, that's in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Event information</pc> section of the reference topic for the event, in a table row that's labeled <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Delegate</pc>.</source>
				</segment>
			</unit>
			<unit id="360" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">enumMemberName</pc>: shown in attribute syntax for all enumerations.</source>
				</segment>
			</unit>
			<unit id="361" translate="yes">
				<segment state="initial">
					<source>There's a similar placeholder for properties that use an enumeration value, but it usually prefixes the placeholder with a hint of the enumeration's name.</source>
				</segment>
			</unit>
			<unit id="362" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208716)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">*</data>
					<data id="id10">*</data>
				</originalData>
				<segment state="initial">
					<source>For example, the syntax shown for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.FlowDirection</pc></pc> is &lt;<pc dataRefEnd="id6" dataRefStart="id5" id="p3">frameworkElement</pc><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FlowDirection</pc>="<pc dataRefEnd="id10" dataRefStart="id9" id="p5">flowDirectionMemberName</pc>"/&gt;.</source>
				</segment>
			</unit>
			<unit id="363" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you're on one of those property reference pages, click the link to the enumeration type that appears in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Property Value</pc> section, next to the text <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Type:</pc>.</source>
				</segment>
			</unit>
			<unit id="364" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For the attribute value of a property that uses that enumeration, you can use any string that is listed in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Member</pc> column of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Members</pc> list.</source>
				</segment>
			</unit>
			<unit id="365" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
					<data id="id7">*</data>
					<data id="id8">*</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">double</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">int</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">string</pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p4">bool</pc>: These are primitive types known to the XAML language.</source>
				</segment>
			</unit>
			<unit id="366" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/system.double.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/xaml/system.int32.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/xaml/system.string.aspx)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/xaml/system.boolean.aspx)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>If you're programming using C# or Visual Basic, these types are projected to Microsoft .NET equivalent types such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Double</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Int32</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">String</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Boolean</pc></pc>, and you can use any members on those .NET types when you work with your XAML-defined values in .NET code-behind.</source>
				</segment>
			</unit>
			<unit id="367" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh710417.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/xaml/hh755812.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>If you're programming using C++/CX, you'll use the C++ primitive types but you can also consider these equivalent to types defined by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Platform</pc></pc> namespace, for example <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Platform::String</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="368" translate="yes">
				<segment state="initial">
					<source>There will sometimes be additional value restrictions for particular properties.</source>
				</segment>
			</unit>
			<unit id="369" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>But you'll usually see these noted in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Property value</pc> section or Remarks section and not in a XAML section, because any such restrictions apply both to code usages and XAML usages.</source>
				</segment>
			</unit>
			<unit id="370" translate="yes">
				<segment state="initial">
					<source>Tips and tricks, notes on style</source>
				</segment>
			</unit>
			<unit id="371" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](xaml-overview.md)</data>
				</originalData>
				<segment state="initial">
					<source>Markup extensions in general are described in the main <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML overview</pc>.</source>
				</segment>
			</unit>
			<unit id="372" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](staticresource-markup-extension.md)</data>
					<data id="id3">[</data>
					<data id="id4">](themeresource-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source>But the markup extension that most impacts the guidance given in this topic is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource</pc> markup extension (and related <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ThemeResource</pc>).</source>
				</segment>
			</unit>
			<unit id="373" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The function of the StaticResource markup extension is to enable factoring your XAML into reusable resources that come from a XAML <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="374" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You almost always define control templates and related styles in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc>.</source>
				</segment>
			</unit>
			<unit id="375" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242962)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>You often define the smaller parts of a control template definition or app-specific style in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary</pc> too, for example a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">SolidColorBrush</pc></pc> for a color that your app uses more than once for different parts of UI.</source>
				</segment>
			</unit>
			<unit id="376" translate="yes">
				<segment state="initial">
					<source>By using a StaticResource, any property that would otherwise require a property element usage to set can now be set in attribute syntax.</source>
				</segment>
			</unit>
			<unit id="377" translate="yes">
				<segment state="initial">
					<source>But the benefits of factoring XAML for reuse go beyond just simplifying the page-level syntax.</source>
				</segment>
			</unit>
			<unit id="378" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt187273)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary and XAML resource references</pc>.</source>
				</segment>
			</unit>
			<unit id="379" translate="yes">
				<segment state="initial">
					<source>You'll see several different conventions for how white space and line feeds are applied in XAML examples.</source>
				</segment>
			</unit>
			<unit id="380" translate="yes">
				<segment state="initial">
					<source>In particular, there are different conventions for how to break up object elements that have a lot of different attributes set.</source>
				</segment>
			</unit>
			<unit id="381" translate="yes">
				<segment state="initial">
					<source>That's just a matter of style.</source>
				</segment>
			</unit>
			<unit id="382" translate="yes">
				<segment state="initial">
					<source>The Visual Studio XML editor applies some default style rules when you edit XAML, but you can change these in the settings.</source>
				</segment>
			</unit>
			<unit id="383" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](xaml-and-whitespace.md)</data>
				</originalData>
				<segment state="initial">
					<source>There are a small number of cases where the white space in a XAML file is considered significant; for more info see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML and whitespace</pc>.</source>
				</segment>
			</unit>
			<unit id="384" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="385" translate="yes">
				<segment state="initial">
					<source>XAML overview</source>
				</segment>
			</unit>
			<unit id="386" translate="yes">
				<segment state="initial">
					<source>XAML namespaces and namespace mapping</source>
				</segment>
			</unit>
			<unit id="387" translate="yes">
				<segment state="initial">
					<source>ResourceDictionary and XAML resource references</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>