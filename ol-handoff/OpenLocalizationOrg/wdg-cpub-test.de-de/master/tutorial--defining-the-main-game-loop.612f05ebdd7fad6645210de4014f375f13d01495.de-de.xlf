<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">9661b9e5622483883d4887d99076610a41aa06d9</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\tutorial--defining-the-main-game-loop.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">5cdd758e80ae07996d3425b97b3bca75e670e3ad</mda:meta><mda:meta type="olxliffhash">ae2c34d7d3e61df6130396f37ea6954476966003</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Define the main game object</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Now, we look at the details of the game sample's main object and how the rules it implements translate into interactions with the game world.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Define the main game object</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>At this point, we've laid out the basic framework of the sample game, and we implemented a state machine that handles the high-level user and system behaviors.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>But we haven't examined the part that makes the game sample an actual game: the rules and mechanics, and how they're implemented!</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>Now, we look at the details of the game sample's main object and how the rules it implements translate into interactions with the game world.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Objective</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>To apply the basic development techniques when implementing the rules and mechanics of a simple Universal Windows Platform (UWP) game using DirectX.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>Considering the game's flow</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>The majority of the game's basic structure is defined in these files:</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>App.cpp</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Simple3DGame.cpp</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--building-the-games-metro-style-app-framework.md)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Defining the game's UWP app framework</pc>, we reviewed the game framework defined in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">App.cpp</pc>.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Simple3DGame.cpp</pc> provides the code for a class, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Simple3DGame</pc>, which specifies the implementation of the game play itself.</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Earlier, we considered the treatment of the sample game as a UWP app.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Now, we look at the code that makes it a game.</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](#code_sample)</data>
				</originalData>
				<segment state="initial">
					<source>The complete code for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Simple3DGame.h/.cpp</pc> is provided in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Complete sample code for this section</pc>.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Let's take a look at the definition of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Simple3DGame</pc> class.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>Defining the core game object</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When the app singleton starts, the view provider's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Initialize</pc> method creates an instance of the main game class, the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Simple3DGame</pc> object.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>This object contains the methods that communicate changes in game state to the state machine defined in the app framework, or from the app to the game object itself.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>It also contains methods that return info for updating the game's overlay bitmap and heads-up display, and for updating the animations and physics (the dynamics) in the game.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--assembling-the-rendering-pipeline.md)</data>
				</originalData>
				<segment state="initial">
					<source>The code for obtaining the graphics device resources used by the game is found in GameRenderer.cpp, which we discuss next in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Assembling the rendering framework</pc>.</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The code for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Simple3DGame</pc> looks like this:</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>First, let's review the internal methods defined on <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Simple3DGame</pc>.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Initialize</pc>.</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>Sets the starting values of the global variables and initializes the game objects.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">LoadGame</pc>.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Initializes a new level and starts loading it.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">LoadLevelAsync</pc>.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dd492418.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>Starts an async task (see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Parallel Patterns Library</pc> for more details) to initialize the level and then invoke an async task on the renderer to load the device specific level resources.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>This method runs in a separate thread; as a result, only <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device</pc></pc> methods (as opposed to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceContext</pc></pc> methods) can be called from this thread.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Any device context methods are called in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FinalizeLoadLevel</pc> method.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">FinalizeLoadLevel</pc>.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Completes any work for level loading that needs to be done on the main thread.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This includes any calls to Direct3D 11 device context (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext</pc></pc>) methods.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">StartLevel</pc>.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Starts the game play for a new level.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">PauseGame</pc>.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>Pauses the game.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">RunGame</pc>.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>Runs an iteration of the game loop.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>It's called from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">App::Update</pc> one time every iteration of the game loop if the game state is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Active</pc>.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">OnSuspending</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnResuming</pc>.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Suspends and resumes the game's audio, respectively.</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>And the private methods:</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">LoadSavedState</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SaveState</pc>.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>Loads and saves the current state of the game, respectively.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">SaveHighScore</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">LoadHighScore</pc>.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>Saves and loads the high score across games, respectively.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">InitializeAmmo</pc>.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Resets the state of each sphere object used as ammunition back to its original state for the beginning of each round.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">UpdateDynamics</pc>.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>This is an important method, because it updates all the game objects based on canned animation routines, physics, and control input.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>This is the heart of the interactivity that defines the game.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#update_game)</data>
				</originalData>
				<segment state="initial">
					<source>We talk about it more in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Updating the game</pc> section.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>The other public methods are property getters that return game play and overlay specific information to the app framework for display.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>Defining the game state variables</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>One function of the game object is to serve as a container for the data that defines a game session, level, or lifetime, depending on how you define your game at a high level.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>In this case, the game state data is for the lifetime of the game, initialized one time when a user launches the game.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>Here's the complete set of definitions for the game object's state variables.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>At the top of the code example, there are four objects whose instances are updated as the game loop runs.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MoveLookController</pc> object.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>This object represents the player input.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](tutorial--adding-controls.md)</data>
				</originalData>
				<segment state="initial">
					<source>(For more info about the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MoveLookController</pc> object, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Adding controls</pc>.)</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameRenderer</pc> object.</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This object represents the Direct3D 11 renderer derived from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXBase</pc> class that handles all the device-specific objects and their rendering.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--assembling-the-rendering-pipeline.md)</data>
				</originalData>
				<segment state="initial">
					<source>(For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Assembling the rendering pipeline</pc>).</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Camera</pc> object.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>This object represents the player's first-person view of the game world.</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](tutorial--assembling-the-rendering-pipeline.md)</data>
				</originalData>
				<segment state="initial">
					<source>(For more info about the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Camera</pc> object, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Assembling the rendering pipeline</pc>.)</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Audio</pc> object.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>This object controls the audio playback for the game.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](tutorial--adding-sound.md)</data>
				</originalData>
				<segment state="initial">
					<source>(For more info about the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Audio</pc> object, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Adding sound</pc>.)</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>The rest of the game variables contain the lists of the primitives and their respective in-game amounts, and game play specific data and constraints.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>Let's see how the sample configures these variables when the game is initialized.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>Initializing and starting the game</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>When a player starts the game, the game object must initialize its state, create and add the overlay, set the variables that track the player's performance, and instantiate the objects that it will use to build the levels.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>The sample game sets up the components of the game object in this order:</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>A new audio playback object is created.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>Arrays for the game's graphic primitives are created, including arrays for the level primitives, ammo, and obstacles.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br241619)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>A location for saving game state data is created, named <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Game</pc>, and placed in the app data settings storage location specified by <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ApplicationData::Current</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>A game timer and the initial in-game overlay bitmap are created.</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>A new camera is created with a specific set of view and projection parameters.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>The input device (the controller) is set to the same starting pitch and yaw as the camera, so the player has a 1-to-1 correspondence between the starting control position and the camera position.</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>The player object is created and set to active.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>We use a sphere object to detect the player's proximity to walls and obstacles and to keep the camera from getting put in a position that might break immersion.</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>The game world primitive is created.</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>The cylinder obstacles are created.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The targets (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Face</pc> objects) are created and numbered.</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>The ammo spheres are created.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>The levels are created.</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>The high score is loaded.</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>Any prior saved game state is loaded.</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>The game now has instances of all the key components: the world, the player, the obstacles, the targets, and the ammo spheres.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>It also has instances of the levels, which represent configurations of all of the above components and their behaviors for each specific level.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>Let's see how the game builds the levels.</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>Building and loading the game's levels</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Most of the heavy lifting for the level construction is done in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Level.h/.cpp</pc> file, which we won't delve into, because it focuses on a very specific implementation.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The important thing is that the code for each level is run as a separate <pc dataRefEnd="id2" dataRefStart="id1" id="p1">LevelN</pc> object.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If you'd like to extend the game, you can create a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Level</pc> object that took an assigned number as a parameter and randomly placed the obstacles and targets.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>Or, you can have it load level configuration data from a resource file, or even the Internet!</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](#code_sample)</data>
				</originalData>
				<segment state="initial">
					<source>The complete code for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Level.h/.cpp</pc> is provided in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Complete sample code for this section</pc>.</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>Defining the game play</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>At this point, we have all the components we need to assemble the game.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>The levels have been constructed in memory from the primitives, and are ready for the player to start interacting with them in some fashion.</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>Now, the best games react instantly to player input, and provide immediate feedback.</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>This is true for any type of a game, from twitch-action, real-time shoot-em-ups to thoughtful, turn-based strategy games.</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--building-the-games-metro-style-app-framework.md)</data>
				</originalData>
				<segment state="initial">
					<source>In <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Defining the game's UWP framework</pc>, we looked at the overall state machine that governs the flow of the game.</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702093)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Remember, the sample implements this flow as a loop inside the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Run</pc></pc> method of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">App</pc> class, which itself is an implementation of a DirectX view provider.</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>The important state transitions must be controlled by the player, and must provide clear feedback.</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>Any delay in this feedback breaks the sense of immersion.</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>Here is a diagram representing the basic flow of the game and its high-level states.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<segment state="initial">
					<source>a diagram showing the main state machine for our game</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>When the sample game starts play, the game object can be in one of three states:</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Waiting for resources</pc>.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>This state is activated when the game object is initialized or when the components of a level are being loaded.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>If this state was triggered by a request to load a prior game, the game stats overlay is displayed; if it was triggered by a request to play a level, the level start overlay is displayed.</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The completion of resource loading causes the game to pass through the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Resources loaded</pc> state and then transition into the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Waiting for press</pc> state.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Waiting for press</pc>.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>This state is activated when the game is paused, either by the player or by the system (after, say, loading resources).</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>When the player is ready to exit this state, the player is prompted to load a new game state (LoadGame), start or restart the loaded level (StartLevel), or continue the current level (ContinueGame).</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dynamics</pc>.</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>If a player's press input is completed and the resulting action is to start or continue a level, the game object transitions into the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dynamics</pc> state.</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>The game is played in this state, and the game world and player objects are updated here based on animation routines and player input.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>This state is left when the player triggers a pause event, either by pressing P, by taking an action that deactivates the main window, or by completing a level or the game.</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](tutorial--building-the-games-metro-style-app-framework.md)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Now, let's look at specific code in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">App</pc> class (see: <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Defining the game's UWP framework</pc>) for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Update</pc> method that implements this state machine.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--adding-controls.md)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The first thing this method does is call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MoveLookController</pc> instance's own <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Update</pc> method, which updates the data from the controller.</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>This data includes the direction the player's view (the camera) is facing and the velocity of the player's movement.</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When the game is in the Dynamics state, that is, when the player is playing, the work is handled in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RunGame</pc> method, with this call:</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">RunGame</pc> handles the set of data that defines the current state of the game play for the current iteration of the game loop.</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>It flows like this:</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>The method updates the timer that counts down the seconds until the level is completed, and tests to see if the level's time has expired.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>This is one of the rules of the game: when time runs out without all the targets getting shot, the game is over.</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If time has run out, the method sets the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TimeExpired</pc> game state, and returns to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Update</pc> method in the previous code.</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>If time remains, the move-look controller is polled for an update to the camera position; specifically, an update to the angle of the view normal projecting from the camera plane (where the player is looking), and the distance that angle has moved from the previous time the controller was polled.</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>The camera is updated based on the new data from the move-look controller.</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<segment state="initial">
					<source>The dynamics, or the animations and behaviors of objects in the game world independent of player control, are updated.</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<segment state="initial">
					<source>In the game sample, this is the motion of the ammo spheres that have been fired, the animation of the pillar obstacles and the movement of the targets.</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>The method checks to see if the criteria for the successful completion of a level have been met.</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>If so, it finalizes the score for the level and checks to see if this is the last level (of 6).</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If it's the last level, the method returns the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameComplete</pc> game state; otherwise, it returns the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">LevelComplete</pc> game state.</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If the level isn't complete, the method sets the game state to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Active</pc> and returns.</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's what <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RunGame</pc>, found in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Simple3DGame.cpp</pc>, looks like in code.</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<originalData>
					<data id="id1">`UpdateDynamics()`</data>
				</originalData>
				<segment state="initial">
					<source>Here's the key call: <ph dataRef="id1" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>It's what brings the game world to life.</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>Let's review it!</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>Updating the game world</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>A fast and fluid game experience is one where the world feels <pc dataRefEnd="id2" dataRefStart="id1" id="p1">alive</pc>, where the game itself is in motion independent of player input.</source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<segment state="initial">
					<source>Trees wave in the wind, waves crest along shore lines, machinery smokes and shines, and alien monsters stretch and salivate.</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>Imagine what a game would be like if everything was frozen, with the graphics only moving when the player provided input.</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<segment state="initial">
					<source>It'd be weird and not very, well, immersive.</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<segment state="initial">
					<source>Immersion, for the player, comes from the feeling of being an agent in a living, breathing world.</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>The game loop should always keep updating the game world and running the animation routines, be they canned or based on physical algorithms or just plain random, except when the game is specifically paused.</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>In the game sample, this principle is called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">dynamics</pc>, and it encompasses the rise and fall of the pillar obstacles, and the motion and physical behaviors of the ammo spheres as they are fired.</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>It also encompasses the interaction between objects, including collisions between the player sphere and the world, or between the ammo and the obstacles and targets.</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<segment state="initial">
					<source>The code that implements these dynamics looks like this:</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<segment state="initial">
					<source>(This code example has been abbreviated for readability.</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>The full working code is found in the complete code sample at the bottom of this topic.)</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<segment state="initial">
					<source>This method deals with four sets of computations:</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>The positions of the fired ammo spheres in the world.</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<segment state="initial">
					<source>The animation of the pillar obstacles.</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<segment state="initial">
					<source>The intersection of the player and the world boundaries.</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>The collisions of the ammo spheres with the obstacles, the targets, other ammo spheres, and the world.</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The animation of the obstacles is a loop defined in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Animate.h/.cpp</pc>.</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>The behavior of the ammo and any collisions are defined by simplified physics algorithms, supplied in the previous code and parameterized by a set of global constants for the game world, including gravity and material properties.</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>This is all computed in the game world coordinate space.</source>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<segment state="initial">
					<source>Now that we've updated all the objects in the scene and calculated any collisions, we need to use that info to draw the corresponding visual changes.</source>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>After Update completes in the current iteration of the game loop, the sample immediately calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Render</pc> to take the updated object data and generate a new scene to present to the player.</source>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<segment state="initial">
					<source>Let's look at the render method now.</source>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>Rendering the game world's graphics</source>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<segment state="initial">
					<source>We recommend that the graphics in a game update as often as possible, which, at maximum, is every time the main game loop iterates.</source>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<segment state="initial">
					<source>As the loop iterates, the game is updated, with or without player input.</source>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<segment state="initial">
					<source>This allows the animations and behaviors that are calculated to be displayed smoothly.</source>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<segment state="initial">
					<source>Imagine if we had a simple scene of water that only moved when the player pressed a button.</source>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<segment state="initial">
					<source>That would make for terribly boring visuals.</source>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>A good game looks smooth and fluid.</source>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<segment state="initial">
					<source>Recall the sample game's loop, as shown here.</source>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>If the game's main window is visible, and isn't snapped or deactivated, the game continues to update and render the results of that update.</source>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The method we examine now renders a representation of that state immediately after the state is updated in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Run</pc> with a call to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Update</pc>, which we discussed in the previous section.</source>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--assembling-the-rendering-pipeline.md)</data>
				</originalData>
				<segment state="initial">
					<source>The complete code for this method is in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Assembling the rendering framework</pc>.</source>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<segment state="initial">
					<source>This method draws the projection of the 3D world, and then draws the Direct2D overlay on top of it.</source>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<segment state="initial">
					<source>When completed, it presents the final swap chain with the combined buffers for display.</source>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<segment state="initial">
					<source>Be aware that there are two states for the sample game's Direct2D overlay: one where the game displays the game info overlay that contains the bitmap for the pause menu, and one where the game displays the cross hairs along with the rectangles for the touchscreen move-look controller.</source>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<segment state="initial">
					<source>The score text is drawn in both states.</source>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<segment state="initial">
					<source>Next steps</source>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>By now, you're probably curious about the actual rendering engine: how those calls to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Render</pc> methods on the updated primitives get turned into pixels on your screen.</source>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--assembling-the-rendering-pipeline.md)</data>
				</originalData>
				<segment state="initial">
					<source>We cover that in detail in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Assembling the rendering framework</pc>.</source>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--adding-controls.md)</data>
				</originalData>
				<segment state="initial">
					<source>If you're more interested in how the player controls update the game state, then check out <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Adding controls</pc>.</source>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<segment state="initial">
					<source>Complete code sample for this section</source>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<segment state="initial">
					<source>Simple3DGame.h</source>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<segment state="initial">
					<source>Simple3DGame.cpp</source>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<segment state="initial">
					<source>Level.h</source>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<segment state="initial">
					<source>Level.cpp</source>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<segment state="initial">
					<source>Level1.h</source>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<segment state="initial">
					<source>Level1.cpp</source>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<segment state="initial">
					<source>Level2.h</source>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<segment state="initial">
					<source>Level2.cpp</source>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>Level3.h</source>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<segment state="initial">
					<source>Level3.cpp</source>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<segment state="initial">
					<source>Level4.h</source>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<segment state="initial">
					<source>Level4.cpp</source>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<segment state="initial">
					<source>Level5.h</source>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<segment state="initial">
					<source>Level5.cpp</source>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<segment state="initial">
					<source>Level6.h</source>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<segment state="initial">
					<source>Level6.cpp</source>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<segment state="initial">
					<source>Animate.h</source>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<segment state="initial">
					<source>Animate.cpp</source>
				</segment>
			</unit>
			<unit id="311" translate="yes">
				<segment state="initial">
					<source>Note</source>
				</segment>
			</unit>
			<unit id="312" translate="yes">
				<segment state="initial">
					<source>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</source>
				</segment>
			</unit>
			<unit id="313" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>If you’re developing for Windows 8.x or Windows Phone 8.x, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archived documentation</pc>.</source>
				</segment>
			</unit>
			<unit id="314" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="315" translate="yes">
				<segment state="initial">
					<source>Create a simple UWP game with DirectX</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>