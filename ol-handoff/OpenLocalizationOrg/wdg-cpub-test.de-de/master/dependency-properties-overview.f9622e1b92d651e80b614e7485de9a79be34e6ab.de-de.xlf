<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">6535ae83d4ff031c9515487fb6201694c3c95745</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci1\xaml-platform\dependency-properties-overview.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">f842ba996c2e12e9327a6fcd73a22e6d1daa687a</mda:meta><mda:meta type="olxliffhash">4491cd68cbbc3dd1bba13d9e1341c490163a6eff</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>This topic explains the dependency property system that is available when you write a Windows Runtime app using C++, C#, or Visual Basic along with XAML definitions for UI.</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Dependency properties overview</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Dependency properties overview</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>This topic explains the dependency property system that is available when you write a Windows Runtime app using C++, C#, or Visual Basic along with XAML definitions for UI.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>What is a dependency property?</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>A dependency property is a specialized type of property.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Specifically it's a property where the property's value is tracked and influenced by a dedicated property system that is part of the Windows Runtime.</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>In order to support a dependency property, the object that defines the property must be a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> (in other words a class that has the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyObject</pc> base class somewhere in its inheritance).</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Many of the types you use for your UI definitions for a Windows Store app with XAML will be a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> subclass, and will support dependency properties.</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>However, any type that comes from a Windows Runtime namespace that doesn't have "XAML" in its name won't support dependency properties; properties of such types are ordinary properties that won't have the property system's dependency behavior.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>The purpose of dependency properties is to provide a systemic way to compute the value of a property based on other inputs (other properties, events and states that occur within your app while it runs).</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>These other inputs might include:</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>External input such as user preference</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Just-in-time property determination mechanisms such as data binding, animations and storyboards</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Multiple-use templating patterns such as resources and styles</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Values known through parent-child relationships with other elements in the object tree</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>A dependency property represents or supports a specific feature of the programming model for defining a Windows Runtime app with XAML for UI and C#, Microsoft Visual Basic or Visual C++ component extensions (C++/CX) for code.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>These features include:</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>Data binding</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>Styles</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>Storyboarded animations</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>"PropertyChanged" behavior; a dependency property can be implemented to provide callbacks that can propagate changes to other dependency properties</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Using a default value that comes from property metadata</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242357)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>General property system utility such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClearValue</pc></pc> and metadata lookup</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>Dependency properties and Windows Runtime properties</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>Dependency properties extend basic Windows Runtime property functionality by providing a global, internal property store that backs all of the dependency properties in an app at run time.</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>This is an alternative to the standard pattern of backing a property with a private field that's private in the property-definition class.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can think of this internal property store as being a set of property identifiers and values that exist for any particular object (so long as it's a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>).</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Rather than being identified by name, each property in the store is identified by a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> instance.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>However, the property system mostly hides this implementation detail: you can usually access dependency properties by using a simple name (the programmatic property name in the code language you're using, or an attribute name when you're writing XAML).</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The base type that provides the underpinnings of the dependency property system is <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> defines methods that can access the dependency property, and instances of a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc> derived class internally support the property store concept we mentioned earlier.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>Here is a summation of the terminology that we use in the documentation when discussing dependency properties:</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>Term</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Description</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Dependency property</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A property that exists on a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> identifier (see below).</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Usually this identifier is available as a static member of the defining <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> derived class.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Dependency property identifier</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetValue</pc></pc>, that's why it is typically public even though it is read-only.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>Property wrapper</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The callable <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">set</pc> implementations for a Windows Runtime property.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>Or, the language-specific projection of the original definition.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> property wrapper implementation calls <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">SetValue</pc></pc>, passing the relevant dependency property identifier as one input and the value to set as the second input.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>The property wrapper is not just convenience for callers, it also exposes the dependency property to any process, tool or projection that uses Windows Runtime definitions for properties.</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>The following example defines a custom "IsSpinning" dependency property as defined for C#, and shows the relationship of the dependency property identifier to the property wrapper.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The preceding example is not intended as the complete example for how to create a custom dependency property.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>It is intended to show dependency property concepts for anyone that prefers learning concepts through code.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](custom-dependency-properties.md)</data>
				</originalData>
				<segment state="initial">
					<source>For a more complete example, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom dependency properties</pc>.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>Dependency property value precedence</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>When you get the value of a dependency property, you are obtaining a value that was determined for that property through any one of the inputs that participate in the Windows Runtime property system.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Dependency property value precedence exists so that the Windows Runtime property system can calculate values in a predictable way, and it's important that you be familiar with the basic precedence order too.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Otherwise, you might find yourself in a situation where you're trying to set a property at one level of precedence but something else (the system, third-party callers, some of your own code) is setting it at another level, and you'll get frustrated trying to figure out which property value is used and where that value came from.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>For example, styles and templates are intended to be a shared starting point for establishing property values and thus appearances of a control.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>But on a particular control instance you might want to change its value versus the common templated value, such as giving that control a different background color or a different text string as content.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>The Windows Runtime property system considers local values at higher precedence than values provided by styles and templates.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>That enables the scenario of having app-specific values overwrite the templates so that the controls are useful for your own use of them in app UI.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>Dependency property precedence list</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>The following is the definitive order that the property system uses when assigning the run-time value for a dependency property.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>Highest precedence is listed first.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>You'll find more detailed explanations just past this list.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br210306)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Animated values:</pc> Active animations, visual state animations, or animations with a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">HoldEnd</pc></pc> behavior.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>To have any practical effect, an animation applied to a property must have precedence over the base (unanimated) value, even if that value was set locally.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Local value:</pc> A local value might be set through the convenience of the property wrapper, which also equates to setting as an attribute or property element in XAML, or by a call to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">SetValue</pc></pc> method using a property of a specific instance.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>If you set a local value by using a binding or a static resource, these each act in the precedence as if a local value was set, and bindings or resource references are erased if a new local value is set.</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br209391)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/br242348)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Templated properties:</pc> An element has these if it was created as part of a template (from a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ControlTemplate</pc></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">DataTemplate</pc></pc>).</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208817)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Style setters:</pc> Values from a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Setter</pc></pc> within styles from page or application resources.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Default value:</pc> A dependency property can have a default value as part of its metadata.</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>Templated properties</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>Templated properties as a precedence item do not apply to any property of an element that you declare directly in XAML page markup.</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>The templated property concept exists only for objects that are created when the Windows Runtime applies a XAML template to a UI element and thus defines its visuals.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>All the properties that are set from a control template have values of some kind.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>These values are almost like an extended set of default values for the control and are often associated with values you can reset later by setting the property values directly.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Thus the template-set values must be distinguishable from a true local value, so that any new local value can overwrite it.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>Note</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](templatebinding-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source>In some cases the template might override even local values, if the template failed to expose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{TemplateBinding} markup extension</pc> references for properties that should have been settable on instances.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>This is usually done only if the property is really not intended to be set on instances, for example if it's only relevant to visuals and template behavior and not to the intended function or runtime logic of the control that uses the template.</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>Bindings and precedence</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Binding operations have the appropriate precedence for whatever scope they're used for.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](templatebinding-markup-extension.md)</data>
				</originalData>
				<segment state="initial">
					<source>For example, a binding applied to a local value acts as local value, and a binding (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{TemplateBinding} markup extension</pc>) for a property setter applies as a style setter does.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>Because bindings must wait until run-time to obtain values from data sources, the process of determining the property value precedence for any property extends into run-time as well.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>Not only do bindings operate at the same precedence as a local value, they really are a local value, where the binding is the placeholder for a value that is deferred.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>If you have a binding in place for a property value, and you set a local value on it at run-time, that replaces the binding entirely.</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br244257)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Similarly, if you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetBinding</pc></pc> to define a binding that only comes into existence at run-time, you replace any local value you might have applied in XAML or with previously executed code.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Storyboarded animations and base value</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>Storyboarded animations act on a concept of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">base value</pc>.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>The base value is the value that's determined by the property system using its precedence, but omitting that last step of looking for animations.</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>For example, a base value might come from a control's template, or it might come from setting a local value on an instance of a control.</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>Either way, applying an animation will overwrite this base value and apply the animated value for as long as your animation continues to run.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For an animated property, the base value can still have an effect on the animation's behavior, if that animation does not explicitly specify both <pc dataRefEnd="id2" dataRefStart="id1" id="p1">From</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">To</pc>, or if the animation reverts the property to its base value when completed.</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>In these cases, once an animation is no longer running, the rest of the precedence is used again.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br210306)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>However, an animation that specifies a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">To</pc> with a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">HoldEnd</pc></pc> behavior can override a local value until the animation is removed, even when it visually appears to be stopped.</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>Conceptually this is like an animation that's running forever even if there is not a visual animation in the UI.</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>Multiple animations can be applied to a single property.</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>Each of these animations might have been defined to replace base values that came from different points in the value precedence.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>However, these animations will all be running simultaneously at run time, and that often means that they must combine their values because each animation has equal influence on the value.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>This depends on exactly how the animations are defined, and the type of the value that is being animated.</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt187354)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc>.</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>Default values</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](custom-dependency-properties.md)</data>
				</originalData>
				<segment state="initial">
					<source>Establishing the default value for a dependency property with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc> value is explained in more detail in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Custom dependency properties</pc> topic.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>Dependency properties still have default values even if those default values weren't explicitly defined in that property's metadata.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>Unless they have been changed by metadata, default values for the Windows Runtime dependency properties are generally one of the following:</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>A property that uses a run-time object or the basic <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Object</pc> type (a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">reference type</pc>) has a default value of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc>.</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208713)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc></pc> is <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc> until it's deliberately set or is inherited.</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>A property that uses a basic value such as numbers or a Boolean value (a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">value type</pc>) uses an expected default for that value.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, 0 for integers and floating-point numbers, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">false</pc> for a Boolean.</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>A property that uses a Windows Runtime structure has a default value that's obtained by calling that structure's implicit default constructor.</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>This constructor uses the defaults for each of the basic value fields of the structure.</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br225870)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, a default for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Point</pc></pc> value is initialized with its <pc dataRefEnd="id6" dataRefStart="id5" id="p3">X</pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Y</pc> values as 0.</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>A property that uses an enumeration has a default value of the first defined member in that enumeration.</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>Check the reference for specific enumerations to see what the default value is.</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/system.string.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/xaml/hh755812.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>A property that uses a string (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">System.String</pc></pc> for .NET, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Platform::String</pc></pc> for C++/CX) has a default value of an empty string (<pc dataRefEnd="id10" dataRefStart="id9" id="p5">""</pc>).</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>Collection properties aren't typically implemented as dependency properties, for reasons discussed further on in this topic.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">[</data>
					<data id="id4">](custom-dependency-properties.md)</data>
				</originalData>
				<segment state="initial">
					<source>But if you implement a custom collection property and you want it to be a dependency property, make sure to avoid an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">unintentional singleton</pc> as described near the end of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Custom dependency properties</pc>.</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>Property functionality provided by a dependency property</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>Data binding</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>A dependency property can have its value set through applying a data binding.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](binding-markup-extension.md)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br209820)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Data binding uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding} markup extension</pc> syntax in XAML, or the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Binding</pc></pc> class in code.</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<segment state="initial">
					<source>For a databound property, the final property value determination is deferred until run time.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<segment state="initial">
					<source>At that time the value is obtained from a data source.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>The role that the dependency property system plays here is enabling a placeholder behavior for operations like loading XAML when the value is not yet known, and then supplying the value at run time by interacting with the Windows Runtime data binding engine.</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209676)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209652)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example sets the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Text</pc></pc> value for a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TextBlock</pc></pc> element, using a binding in XAML.</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>The binding uses an inherited data context and an object data source.</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt210946)</data>
				</originalData>
				<segment state="initial">
					<source>(Neither of these is shown in the shortened example; for a more complete sample that shows context and source, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.)</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>You can also establish bindings using code rather than XAML.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br244257)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetBinding</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Bindings like this are treated as a local value for purposes of dependency property value precedence.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209820)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you set another local value for a property that originally held a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Binding</pc></pc> value, you will overwrite the binding entirely, not just the binding's run-time value.</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>Binding sources, binding targets, the role of FrameworkElement</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>To be the source of a binding, a property does not need to be a dependency property; you can generally use any property as a binding source, although this depends on your programming language and each has certain edge cases.</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>However, to be the target of a binding, that property must be a dependency property.</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br244257)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208706)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>If you are creating a binding in code, note that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetBinding</pc></pc> API is defined only for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209823)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>However, you can create a binding definition using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BindingOperations</pc></pc> instead, and thus reference any <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyObject</pc></pc> property.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208713)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208706)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For either code or XAML, remember that <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc></pc> is a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement</pc></pc> property.</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>By using a form of parent-child property inheritance (typically established in XAML markup), the binding system can resolve a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DataContext</pc> that exists on a parent element.</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This inheritance can evaluate even if the child object (which has the target property) is not a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FrameworkElement</pc> and therefore does not hold its own <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> value.</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>However, the parent element being inherited must be a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FrameworkElement</pc> in order to set and hold the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc>.</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Alternatively, you must define the binding such that it can function with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> value for <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc>.</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<segment state="initial">
					<source>Wiring the binding is not the only thing that's needed for most data binding scenarios.</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>For a one-way or two-way binding to be effective, the source property must support change notifications that propagate to the binding system and thus the target.</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/system.componentmodel.inotifypropertychanged.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For custom binding sources, this means that the property must support <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyPropertyChanged</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/system.collections.specialized.inotifycollectionchanged.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Collections should support <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/ms668604.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">&amp;lt;</data>
					<data id="id6">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>Certain classes support these interfaces in their implementations so that they are useful as base classes for data binding scenarios; an example of such a class is <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ObservableCollection<ph dataRef="id5" id="ph1" />T<ph dataRef="id6" id="ph2" /></pc></pc>.</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt210946)</data>
				</originalData>
				<segment state="initial">
					<source>For more information on data binding and how data binding relates to the property system, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The types listed here support Microsoft .NET data sources.</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt210946)</data>
				</originalData>
				<segment state="initial">
					<source>C++/CX data sources use different interfaces for change notification or observable behavior, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>Styles and templates</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>Styles and templates are two of the scenarios for properties being defined as dependency properties.</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>Styles are useful for setting properties that define the app's UI.</source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208740)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Styles are defined as resources in XAML, either as an entry in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Resources</pc></pc> collection, or in separate XAML files such as theme resource dictionaries.</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>Styles interact with the property system because they contain setters for properties.</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209465)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209390)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>The most important property here is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control.Template</pc></pc> property of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Control</pc></pc>: it defines most of the visual appearance and visual state for a <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Control</pc>.</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208849)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/mt210950)</data>
				</originalData>
				<segment state="initial">
					<source>For more info on styles, and some example XAML that defines a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> and uses setters, see <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Styling controls</pc>.</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>Values that come from styles or templates are deferred values, similar to bindings.</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>This is so that control users can re-template controls or redefine styles.</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>And that's why property setters in styles can only act on dependency properties, not ordinary properties.</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<segment state="initial">
					<source>Storyboarded animations</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<segment state="initial">
					<source>You can animate a dependency property's value using a storyboarded animation.</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>Storyboarded animations in the Windows Runtime are not merely visual decorations.</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<segment state="initial">
					<source>It's more useful to think of animations as being a state machine technique that can set the values of individual properties or of all properties and visuals of a control, and change these values over time.</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>To be animated, the animation's target property must be a dependency property.</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br210517)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Also, to be animated, the target property's value type must be supported by one of the existing <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Timeline</pc></pc>-derived animation types.</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh673723)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](T:System.Double)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br225870)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>Values of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Color</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Double</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Point</pc></pc> can be animated using either interpolation or keyframe techniques.</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Most other values can be animated using discrete <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Object</pc> key frames.</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>When an animation is applied and running, the animated value operates at a higher precedence than any value (such as a local value) that the property otherwise has.</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br210306)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Animations also have an optional <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">HoldEnd</pc></pc> behavior that can cause animations to apply to property values even if the animation visually appears to be stopped.</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209021)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The state machine principle is embodied by the use of storyboarded animations as part of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VisualStateManager</pc></pc> state model for controls.</source>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt187354)</data>
				</originalData>
				<segment state="initial">
					<source>For more info on storyboarded animations, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc>.</source>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/xaml/jj819808)</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374)</data>
				</originalData>
				<segment state="initial">
					<source>For more info on <pc dataRefEnd="id2" dataRefStart="id1" id="p1">VisualStateManager</pc> and defining visual states for controls, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Storyboarded animations for visual states</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Quickstart: Control templates</pc>.</source>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<segment state="initial">
					<source>Property-changed behavior</source>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>Property-changed behavior is the origin of the "dependency" part of dependency property terminology.</source>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<segment state="initial">
					<source>Maintaining valid values for a property when another property can influence the first property's value is a difficult development problem in many frameworks.</source>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<segment state="initial">
					<source>In the Windows Runtime property system, each dependency property can specify a callback that is invoked whenever its property value changes.</source>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<segment state="initial">
					<source>This callback can be used to notify or change related property values, in a generally synchronous manner.</source>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<segment state="initial">
					<source>Many existing dependency properties have a property-changed behavior.</source>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<segment state="initial">
					<source>You can also add similar callback behavior to custom dependency properties, and implement your own property-changed callbacks.</source>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](custom-dependency-properties.md)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom dependency properties</pc> for an example.</source>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Default value and <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ClearValue</pc></source>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>A dependency property can have a default value defined as part of its property metadata.</source>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<segment state="initial">
					<source>For a dependency property, its default value doesn't become irrelevant after the property's been set the first time.</source>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<segment state="initial">
					<source>The default value might apply again at run-time whenever some other determinant in value precedence disappears.</source>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<segment state="initial">
					<source>(Dependency property value precedence is discussed in the next section.) For example, you might deliberately remove a style value or an animation that applies to a property, but you want the value to be a reasonable default after you do so.</source>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<segment state="initial">
					<source>The dependency property default value can provide this value, without needing to specifically set each property's value as an extra step.</source>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<segment state="initial">
					<source>You can deliberately set a property to the default value even after you have already set it with a local value.</source>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242357)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To reset a value to be the default again, and also to enable other participants in precedence that might override the default but not a local value, call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClearValue</pc></pc> method (reference the property to clear as a method parameter).</source>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<segment state="initial">
					<source>You don't always want the property to literally use the default value, but clearing the local value and reverting to the default value might enable another item in precedence that you want to act now, such as using the value that came from a style setter in a control template.</source>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> and threading</source>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209041)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>All <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> instances must be created on the UI thread which is associated with the current <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Window</pc></pc> that is shown by a Windows Runtime app.</source>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br230616)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Although each <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> must be created on the main UI thread, the objects can be accessed using a dispatcher reference from other threads, by accessing the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Dispatcher</pc></pc> property.</source>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh750317)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208211)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Then you can call methods such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RunAsync</pc></pc> on the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CoreDispatcher</pc></pc> object, and execute your code within the rules of thread restrictions on the UI thread.</source>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The threading aspects of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> are relevant because it generally means that only code that runs on the UI thread can change or even read the value of a dependency property.</source>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Threading issues can usually be avoided in typical UI code that makes correct use of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> patterns and background worker threads.</source>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>You typically only run into <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc>-related threading issues if you are defining your own <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc> types and you attempt to use them for data sources or other scenarios where a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyObject</pc> isn't necessarily appropriate.</source>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<segment state="initial">
					<source>Conceptual material</source>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<segment state="initial">
					<source>Custom dependency properties</source>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<segment state="initial">
					<source>Attached properties overview</source>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<segment state="initial">
					<source>Data binding in depth</source>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>Storyboarded animations</source>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<segment state="initial">
					<source>Creating Windows Runtime components</source>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=238581)</data>
					<data id="id3">
</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML user and custom controls sample</pc><ph dataRef="id3" id="ph1" /><pc dataRefEnd="id5" dataRefStart="id4" id="p2">APIs related to dependency properties</pc></source>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<segment state="initial">
					<source>DependencyObject</source>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<segment state="initial">
					<source>DependencyProperty</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>