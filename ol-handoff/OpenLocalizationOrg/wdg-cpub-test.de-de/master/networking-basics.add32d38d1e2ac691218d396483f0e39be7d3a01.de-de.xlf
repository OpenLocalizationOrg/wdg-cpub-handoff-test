<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">c2cb4cffdd8252207df28eab2484bc40c430efc9</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci1\networking\networking-basics.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">bf523d21eb4433b25ea1d146af142d553a2d945b</mda:meta><mda:meta type="olxliffhash">10f0ad5c11cab644f3f501d433e09541a513a57c</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Things you must do for any network-enabled app.</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Networking basics</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Networking basics</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Things you must do for any network-enabled app.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Capabilities</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>In order to use networking, you must add appropriate capability elements to your app manifest.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>If no network capability is specified in your app's manifest, your app will have no networking capability, and any attempt to connect to the network will fail.</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>The following are the most-used networking capabilities.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>Capability</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>Description</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>internetClient</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Provides outbound access to the Internet and networks in public places, like airports and coffee shop.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>Most apps that require Internet access should use this capability.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>internetClientServer</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Gives the app inbound and outbound network access from the Internet and networks in public places like airports and coffee shops.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>privateNetworkClientServer</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>Gives the app inbound and outbound network access at the user's trusted places, like home and work.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>There are other capabilities that might be necessary for your app, in certain circumstances.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>Capability</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>Description</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>pushNotifications</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>If your app uses socket activity triggers, you must specify this capability in the app manifest.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>enterpriseAuthentication</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Allows an app to connect to network resources that require domain credentials.</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>This capability will require a domain administrator to enable the functionality for all apps.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>An example would be an app that retrieves data from SharePoint servers on a private Intranet.</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>With this capability your credentials can be used to access network resources on a network that requires credentials.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>An app with this capability can impersonate you on the network.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>This capability is not required to allow an app to access the Internet via an authenticating proxy.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>proximity</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Required for near-field proximity communication with devices in close proximity to the computer.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Near-field proximity may be used to send or connect with an application on a nearby device.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>This capability allows an app to access the network to connect to a device in close proximity, with user consent to send an invite or accept an invite.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>sharedUserCertificates</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>This capability allows an app to access software and hardware certificates, such as smart card certificates.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>When this capability is invoked at runtime, the user must take action, such as inserting a card or selecting a certificate.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>With this capability, your software and hardware certificates or a smart card are used for identification in the app.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>This capability may be used by your employer, bank, or government services for identification.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Communicating when your app is not in the foreground</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt299103)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Support your app with background tasks</pc> contains general information about using background tasks to do work when your app is not in the foreground.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>More specifically, your code must take special steps to be notified when it is not the current foreground app and data arrives over the network for it.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>You used Control Channel Triggers for this purpose in Windows 8, and they are still supported in Windows 10.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701032)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Full information about using Control Channel Triggers is available <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">here</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>A new technology in Windows 10 provides better functionality with lower overhead for some scenarios, such as push-enabled stream sockets: the socket broker and socket activity triggers.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br241319)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br226882)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br226906)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>If your app uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DatagramSocket</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">StreamSocket</pc></pc>, or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">StreamSocketListener</pc></pc>, then your app can transfer ownership of an open socket to a socket broker provided by the system, and then leave the foreground, or even terminate.</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>When a connection is made on the transferred socket, or traffic arrives on that socket, then your app or its designated background task are activated.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>If your app is not running, it is started.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn806009)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The socket broker then notifies your app using a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SocketActivityTrigger</pc></pc> that new traffic has arrived.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Your app reclaims the socket from the socket broker and process the traffic on the socket.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>This means that your app consumes far less system resources when it is not actively processing network traffic.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>The socket broker is intended to replace Control Channel Triggers where it is applicable, because it provides the same functionality, but with fewer restrictions and a smaller memory footprint.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Socket broker can be used by apps that are not lock screen apps, and it is used the same way on phones as on other devices.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Apps need not be running when traffic arrives in order to be activated by the socket broker.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>And the socket broker supports listening on TCP sockets, which Control Channel Triggers do not support.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If your app uses socket activity triggers, you must specify the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">pushNotifications</pc> capability in the app manifest.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>Choosing a network trigger</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>There are some scenarios where either kind of trigger would be suitable.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>When you are choosing which kind of trigger to use in your app, consider the following advice.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh831151)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/dn298639)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](http://go.microsoft.com/fwlink/p/?linkid=241638)</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/hh701032)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source>If you are using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IXMLHTTPRequest2</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">System.Net.Http.HttpClient</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5">System.Net.Http.HttpClientHandler</pc>, you must use <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">ControlChannelTrigger</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/dn806009)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>If you are using push-enabled <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StreamSockets</pc>, you can use control channel triggers, but should prefer <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">SocketActivityTrigger</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>The latter choice allows the system to free up memory and reduce power requirements when the connection is not being actively used.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn806009)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you want to minimize the memory footprint of your app when it is not actively servicing network requests, prefer <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SocketActivityTrigger</pc></pc> when possible.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn806009)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you want your app to be able to receive data while the system is in Connected Standby mode, use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SocketActivityTrigger</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](network-communications-in-the-background.md)</data>
				</originalData>
				<segment state="initial">
					<source>For details and examples of how to use the socket broker, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Network communications in the background</pc>.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Secured connections</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>Secure Sockets Layer (SSL) and the more recent Transport Layer Security (TLS) are cryptographic protocols designed to provide authentication and encryption for network communication.</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>These protocols are designed to prevent eavesdropping and tampering when sending and receiving network data.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>These protocols use a client-server model for the protocol exchanges.</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>These protocols also use digital certificates and certificate authorities to verify that the server is who it claims to be.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>Creating secure socket connections</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226882)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StreamSocket</pc></pc> object can be configured to use SSL/TLS for communications between the client and the server.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This support for SSL/TLS is limited to using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StreamSocket</pc> object as the client in the SSL/TLS negotiation.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br226906)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>You cannot use SSL/TLS with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StreamSocket</pc> created by a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">StreamSocketListener</pc></pc> when incoming communications are received, because SSL/TLS negotiation as a server is not implemented by the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">StreamSocket</pc> class.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226882)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>There are two ways to secure a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StreamSocket</pc></pc> connection with SSL/TLS:</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701504)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConnectAsync</pc></pc> - Make the initial connection to a network service and negotiate immediately to use SSL/TLS for all communications.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226922)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UpgradeToSslAsync</pc></pc> - Connect initially to a network service without encryption.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>The app may send or receive data.</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>Then, upgrade the connection to use SSL/TLS for all further communications.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>The SocketProtectionLevel value that you provide sets the minimum protection level you are willing to allow.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>However, the eventual protection level of the established connection is determined in a negotiation process between both endpoints of the connection.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>The result can be a more-secure protection level than the one you specified, if the other endpoint requires a higher level.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701504)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br226922)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/hh967868)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>The SSL strength actually negotiated using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConnectAsync</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">UpgradeToSslAsync</pc></pc> can be determined by getting the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">StreamSocketinformation.ProtectionLevel</pc></pc> property after the async operation has completed successfully.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>Note</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>Your code should never implicitly depend on using a particular protection level, or on the assumption that a given security level is used by default.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>The security landscape changes constantly, and protocols and default protection levels will be changed over time in order to avoid the use of protocols with known weaknesses.</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Defaults can vary depending on individual machine configuration, or on which software is installed and which patches have been applied.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>If your app depends on the use of a particular security level, you must explicitly specify that level and then check to be sure that it is actually in use on the established connection.</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>Use ConnectAsync</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701504)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConnectAsync</pc></pc> can be used to establish the initial connection with a network service and then negotiate immediately to use SSL/TLS for all communications.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
				</originalData>
				<segment state="initial">
					<source>There are two <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConnectAsync</pc> methods that support passing a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">protectionLevel</pc> parameter:</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701511)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br226882)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/hh700953)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/br226880)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConnectAsync(EndpointPair, SocketProtectionLevel)</pc></pc> - Starts an asynchronous operation on a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">StreamSocket</pc></pc> object to connect to a remote network destination specified as an <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">EndpointPair</pc></pc> object and a <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">SocketProtectionLevel</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226916)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br226882)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br226880)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConnectAsync(HostName, String, SocketProtectionLevel)</pc></pc> - Starts an asynchronous operation on a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">StreamSocket</pc></pc> object to connect to a remote destination specified by a remote hostname, a remote service name, and a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">SocketProtectionLevel</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh701504)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br226882)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>If the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">protectionLevel</pc> parameter is set to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.Networking.Sockets.SocketProtectionLevel.Ssl</pc> when calling either of the above <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ConnectAsync</pc></pc> methods, the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">StreamSocket</pc></pc> must will be established to use SSL/TLS for encryption.</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>This value requires encryption and never allows a NULL cipher to be used.</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701504)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The normal sequence to use with one of these <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConnectAsync</pc></pc> methods is the same.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226882)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Create a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StreamSocket</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226917)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br226893)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br226882)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>If an advanced option on the socket is needed, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StreamSocket.Control</pc></pc> property to get the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">StreamSocketControl</pc></pc> instance associated with a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">StreamSocket</pc></pc> object.</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Set a property on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StreamSocketControl</pc>.</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701504)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Call one of the above <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConnectAsync</pc></pc> methods to start an operation to connect to a remote destination and immediately negotiate the use of SSL/TLS.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701504)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh967868)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The SSL strength actually negotiated using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConnectAsync</pc></pc> can be determined by getting the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">StreamSocketinformation.ProtectionLevel</pc></pc> property after the async operation has completed successfully.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226882)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example creates a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StreamSocket</pc></pc> and tries to establish a connection to the network service and negotiate immediately to use SSL/TLS.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If the negotiation is successful, all network communication using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StreamSocket</pc> between the client the network server will be encrypted.</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>Use UpgradeToSslAsync</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226922)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When your code uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UpgradeToSslAsync</pc></pc>, it first establishes a connection to a network service without encryption.</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>The app may send or receive some data, then upgrade the connection to use SSL/TLS for all further communications.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226922)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UpgradeToSslAsync</pc></pc> method takes two parameters.</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">protectionLevel</pc> parameter indicates the protection level desired.</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">validationHostName</pc> parameter is the hostname of the remote network destination that is used for validation when upgrading to SSL.</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>Normally the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">validationHostName</pc> would be the same hostname that the app used to initially establish the connection.</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/br226882)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>If the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">protectionLevel</pc> parameter is set to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.System.Socket.SocketProtectionLevel.Ssl</pc> when calling <pc dataRefEnd="id6" dataRefStart="id5" id="p3">UpgradeToSslAsync</pc>, the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">StreamSocket</pc></pc> must use the SSL/TLS for encryption on further communications over the socket.</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>This value requires encryption and never allows a NULL cipher to be used.</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226922)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The normal sequence to use with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UpgradeToSslAsync</pc></pc> method is as follows:</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226882)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Create a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StreamSocket</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226917)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br226893)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br226882)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>If an advanced option on the socket is needed, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StreamSocket.Control</pc></pc> property to get the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">StreamSocketControl</pc></pc> instance associated with a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">StreamSocket</pc></pc> object.</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Set a property on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StreamSocketControl</pc>.</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>If any data needs to be sent and received unencrypted, send it now.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226922)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UpgradeToSslAsync</pc></pc> method to start an operation to upgrade the connection to use SSL/TLS.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226922)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh967868)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The SSL strength actually negotiated using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UpgradeToSslAsync</pc></pc> can be determined by getting the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">StreamSocketinformation.ProtectionLevel</pc></pc> property after the async operation completes successfully.</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226882)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example creates a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StreamSocket</pc></pc>, tries to establish a connection to the network service, sends some initial data, and then negotiates to use SSL/TLS.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If the negotiation is successful, all network communication using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StreamSocket</pc> between the client and the network server will be encrypted.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>Creating secure WebSocket connections</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226923)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br226842)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Like traditional socket connections, WebSocket connections can also be encrypted with Transport Layer Security (TLS)/Secure Sockets Layer (SSL) when using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StreamWebSocket</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MessageWebSocket</pc></pc> features in Windows 8 for a Windows Store app.</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>In most cases you'll want to use a secure WebSocket connection.</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<segment state="initial">
					<source>This will increase the chances that your connection will succeed, as many proxies will reject unencrypted WebSocket connections.</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh994399)</data>
				</originalData>
				<segment state="initial">
					<source>For examples of how to create, or upgrade to, a secure socket connection to a network service, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">How to secure WebSocket connections with TLS/SSL</pc>.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In addition to TLS/SSL encryption, a server may require a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Sec-WebSocket-Protocol</pc> header value to complete the initial handshake.</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701514)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh701358)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>This value, represented by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StreamWebSocketInformation.Protocol</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MessageWebSocketInformation.Protocol</pc></pc> properties, indicate the protocol version of the connection and enables the server to correctly interpret the opening handshake and the data being exchanged afterwards.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>Using this protocol information, if at any point if the server cannot interpret the incoming data in a safe manner the connection can be closed.</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>If the initial request from the client either does not contain this value, or provides a value that doesn't match what the server expects, the expected value is sent from the server to the client on WebSocket handshake error.</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>Authentication</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>How to provide authentication credentials when connecting over the network.</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>Providing a client certificate with the StreamSocket class</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226882)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.Networking.StreamSocket</pc></pc> class supports using SSL/TLS to authenticate the server the app is talking to.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>In certain cases, the app also needs to authenticate itself to the server using a TLS client certificate.</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226893)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In Windows 10, you can provide a client certificate on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StreamSocket.Control</pc></pc> object (this must be set before the TLS handshake is started).</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>If the server requests the client certificate, Windows will respond with the certificate provided.</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>Here is a code snippet showing how to implement this:</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<segment state="initial">
					<source>Providing authentication credentials to a web service</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<segment state="initial">
					<source>The networking APIs that enable apps to interact with secure web services each provide their own methods to either initialize a client or set a request header with server and proxy authentication credentials.</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227061)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Each method is set with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PasswordCredential</pc></pc> object that indicates a user name, password, and the resource for which these credentials are used.</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>The following table provides a mapping of these APIs:</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<segment state="initial">
					<source>WebSockets</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>MessageWebSocketControl.ServerCredential</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>MessageWebSocketControl.ProxyCredential</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>StreamWebSocketControl.ServerCredential</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>StreamWebSocketControl.ProxyCredential</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>Background Transfer</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>BackgroundDownloader.ServerCredential</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>BackgroundDownloader.ProxyCredential</source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<segment state="initial">
					<source>BackgroundUploader.ServerCredential</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>BackgroundUploader.ProxyCredential</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<segment state="initial">
					<source>Syndication</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<segment state="initial">
					<source>SyndicationClient(PasswordCredential)</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>SyndicationClient.ServerCredential</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>SyndicationClient.ProxyCredential</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>AtomPub</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<segment state="initial">
					<source>AtomPubClient(PasswordCredential)</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<segment state="initial">
					<source>AtomPubClient.ServerCredential</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>AtomPubClient.ProxyCredential</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<segment state="initial">
					<source>Handling network exceptions</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>In most areas of programming, an exception indicates a significant problem or failure, caused by some flaw in the program.</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<segment state="initial">
					<source>In network programming, there is an additional source for exceptions: the network itself, and the nature of network communications.</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<segment state="initial">
					<source>Network communications are inherently unreliable and prone to unexpected failure.</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>For each of the ways your app uses networking, you must maintain some state information; and your app code must handle network exceptions by updating that state information and initiating appropriate logic for your app to re-establish or retry communication failures.</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>When Universal Windows apps throw an exception, your exception handler can retrieve more detailed information on the cause of the exception to better understand the failure and make appropriate decisions.</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>Each language projection supports a method to access this more detailed information.</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>An exception projects as an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HRESULT</pc> value in Universal Windows apps.</source>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Winerror.h</pc> include file contains a very large list of possible <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HRESULT</pc> values that includes network errors.</source>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<segment state="initial">
					<source>The networking APIs support different methods for retrieving this detailed information on the cause of an exception.</source>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Some APIs provide a helper method that converts the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HRESULT</pc> value from the exception to an enumeration value.</source>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Other APIs provide a method to retrieve the actual <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HRESULT</pc> value.</source>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<segment state="initial">
					<source>Networking API Improvements in Windows 10</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>