<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">1c448e5ef3e74c744ff8f5225e22616b5e49be80</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\get-started\universal-application-platform-guide.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">fefdc132806fdc158c2ff07c074a3c52d141b97b</mda:meta><mda:meta type="olxliffhash">1346e43b78ea69cc686c056f3834482dfd7c8508</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Guide to Universal Windows Platform (UWP) apps</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>In this guide, learn about Universal Windows Platform (UWP) apps that can run across a wide variety of devices.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Guide to Universal Windows Platform (UWP) apps</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>In this guide, you'll learn about:</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>What a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">device family</pc> is, and how to decide which one to target.</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>New UI controls and panels that allow you to adapt your UI to different device form factors.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>How to understand and control the API surface that is available to your app.</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>Windows 8 introduced the Windows Runtime (WinRT), which was an evolution of the Windows app model.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>It was intended to be a common application architecture.</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>When Windows Phone 8.1 became available, the Windows Runtime was aligned between Windows Phone 8.1 and Windows.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>This enabled developers to create <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Universal Windows 8 apps</pc> that target both Windows and Windows Phone using a shared codebase.</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Windows 10 introduces the Universal Windows Platform (UWP), which further evolves the Windows Runtime model and brings it into the Windows 10 unified core.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>As part of the core, the UWP now provides a common app platform available on every device that runs Windows 10.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>With this evolution, apps that target the UWP can call not only the WinRT APIs that are common to all devices, but also APIs (including Win32 and .NET APIs) that are specific to the device family the app is running on.</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>The UWP provides a guaranteed core API layer across devices.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>This means you can create a single app package that can be installed onto a wide range of devices.</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>And, with that single app package, the Windows Store provides a unified distribution channel to reach all the device types your app can run on.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>windows universal apps run on a variety of devices, support adaptive user interface, natural user input, one store, one dev center, and cloud services</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>Because your UWP app runs on a wide variety of devices with different form factors and input modalities, you want it to be tailored to each device and be able to unlock the unique capabilities of each device.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>Devices add their own unique APIs to the guaranteed API layer.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>You can write code to access those unique APIs conditionally so that your app lights up features specific to one type of device while presenting a different experience on other devices.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Adaptive UI controls and new layout panels help you to tailor your UI across a broad range of screen resolutions.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Device families</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Windows 8.1 and Windows Phone 8.1 apps target an operating system (OS): either Windows, or Windows Phone.</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>With Windows 10 you no longer target an operating system but you instead target your app to one or more device families.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>A device family identifies the APIs, system characteristics, and behaviors that you can expect across devices within the device family.</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>It also determines the set of devices on which your app can be installed from the Store.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>Here is the device family hierarchy.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>device families</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>A device family is a set of APIs collected together and given a name and a version number.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>A device family is the foundation of an OS.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>PCs run the desktop OS, which is based on the desktop device family.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>Phones and tablets, etc., run the mobile OS, which is based on the mobile device family.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>And so on.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>The universal device family is special.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>It is not, directly, the foundation of any OS.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>Instead, the set of APIs in the universal device family is inherited by child device families.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>The universal device family APIs are thus guaranteed to be present in every OS and consequently on every device.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Each child device family adds its own APIs to the ones it inherits.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>The resulting union of APIs in a child device family is guaranteed to be present in the OS based on that device family, and consequently on every device running that OS.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>One benefit of device families is that your app can run on any, or even all, of a variety of devices from phones, tablets, and desktop computers up to Surface Hubs and Xbox consoles.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>Your app can also use adaptive code to dynamically detect and use features of a device that are outside of the universal device family.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>The decision about which device family (or families) your app will target is yours to make.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>And that decision impacts your app in these important ways.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>It determines:</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>The set of APIs that your app can assume to be present when it runs (and can therefore call freely).</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>The set of API calls that are safe only inside conditional statements.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>The set of devices on which your app can be installed from the Store (and consequently the form factors that you need to consider).</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>There are two main consequences of making a device family choice: the API surface that can be called unconditionally by the app, and the number of devices the app can reach.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>These two factors involve tradeoffs and are inversely related.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>For example, a UWP app is an app that specifically targets the universal device family, and consequently is available to all devices.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>An app that targets the universal device family can assume the presence of only the APIs in the universal device family (because that's what it targets).</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Other APIs must be called conditionally.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Also, such an app must have a highly adaptive UI and comprehensive input capabilities because it can run on a wide variety of devices.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>A Windows mobile app is an app that specifically targets the mobile device family, and is available to devices whose OS is based on the mobile device family (which includes phones, tablets, and similar devices).</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>A mobile device family app can assume the presence of all APIs in the mobile device family, and its UI has to be moderately adaptive.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>An app that targets the IoT device family can be installed only on IoT devices and can assume the presence of all APIs in the IoT device family.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>That app can be very specialized in its UI and input capabilities because you know that it will run only on a specific type of device.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>Here are some considerations to help you decide which device family to target:</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>Maximizing your app's reach</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>To reach the maximum range of devices with your app, and to have it run on as many kinds of devices as possible, your app will target the universal device family.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>By doing so, the app automatically targets every device family that's based on universal (in the diagram, all the children of universal).</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>That means that the app runs on every OS based on those device families, and on all the devices that run those operating systems.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>The only APIs that are guaranteed to be available on all those devices is the set defined by the particular version of the universal device family that you target.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>(With this release, that version is always 10.0.x.0.) To find out how an app can call APIs outside of its target device family version, see Writing code later in this topic.</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>Limiting your app to one kind of device</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>You may not want your app to run on a wide range of devices; perhaps it's specialized for, say, a desktop PC or for an Xbox console.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>In that case you can choose to target your app at one of the child device families.</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>For example, if you target the desktop device family, the APIs guaranteed to be available to your app include the APIs inherited from the universal device family plus the APIs that are particular to the desktop device family.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>Limiting your app to a subset of all possible devices</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>Instead of targeting the universal device family, or targeting one of the child device families, you can instead target two (or more) child device families.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>Targeting desktop and mobile might make sense for your app.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>Or desktop and Xbox.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Or desktop, Xbox and Surface Hub.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>Excluding support for a particular version of a device family</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>In rare cases you may want your app to run everywhere except on devices with a particular version of a particular device family.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>For example, let's say your app targets version 10.0.x.0 of the universal device family.</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>When the operating system version changes in the future, say to 10.0.x.2, at that point you can specify that your app runs everywhere except version 10.0.x.1 of Xbox by targeting your app to 10.0.x.0 of universal and 10.0.x.1 of Xbox.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Your app will then be unavailable to the set of device family versions within Xbox 10.0.x.1 (inclusive) and earlier.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>By default, Microsoft Visual Studio specifies <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows.Universal</pc> as the target device family in the app package manifest file.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn986903)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To specify the device family or device families that your app is offered to from within the Store, manually configure the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TargetDeviceFamily</pc></pc> element in your Package.appxmanifest file.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>UI and universal input</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>A UWP app can run on many different kinds of devices that have different forms of input, screen resolutions, DPI density, and other unique characteristics.</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>Windows 10 provides new universal controls, layout panels, and tooling to help you adapt your UI to the devices your app may run on.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>For example, you can tailor the UI to take advantage of the difference in screen resolution when your app is running on a desktop computer versus on a mobile device.</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Some aspects of your app's UI will automatically adapt across devices.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>Controls such as buttons and sliders automatically adapt across device families and input modes.</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>Your app's user-experience design, however, may need to adapt depending on the device the app is running on.</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>For example, a photos app should adapt the UI when running on a small, hand-held device to ensure that usage is ideal for single-hand use.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>When the photos app is running on a desktop computer, the UI should adapt to take advantage of the additional screen space.</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>Windows helps you target your UI to multiple devices with the following features:</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>Universal controls and layout panels help you to optimize your UI for the screen resolution of the device</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>Common input handling allows you to receive input through touch, a pen, a mouse, or a keyboard, or a controller such as a Microsoft Xbox controller</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>Tooling helps you to design UI that can adapt to different screen resolutions</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>Adaptive scaling adjusts to resolution and DPI differences across devices</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>Universal controls and layout panels</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>Windows 10 includes new controls such as the calendar and split view.</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>The pivot control, which was previously available only for Windows Phone, is also now available for the universal device family.</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>Controls have been updated to work well on larger screens, adapt themselves based on the number of screen pixels available on the device, and work well with multiple types of input such as keyboard, mouse, touch, pen, and controllers such as the Xbox controller.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>You may find that you need to adapt your overall UI layout based on the screen resolution of the device your app will be running on.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>For example, a communication app running on the desktop may include a picture-in-picture of the caller and controls well suited to mouse input:</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>desktop communication app ui</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>However, when the app runs on a phone, because there is less screen real-estate to work with, your app may eliminate the picture-in-picture view and make the call button larger to facilitate one-handed operation:</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>phone communication app ui</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>To help you adapt your overall UI layout based on the amount of available screen space,Windows 10 introduces adaptive panels and design states.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>Design adaptive UI with adaptive panels</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>Layout panels give sizes and positions to their children, depending on available space.</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209635)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StackPanel</pc></pc> orders its children sequentially (horizontally or vertically).</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242704)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Grid</pc></pc> is like a CSS grid that places its children into cells.</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn879546)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The new <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RelativePanel</pc></pc> implements a style of layout that is defined by the relationships between its child elements.</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>It's intended for use in creating app layouts that can adapt to changes in screen resolution.</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RelativePanel</pc> eases the process of rearranging elements by defining relationships between elements, which allows you to build more dynamic UI without using nested layouts.</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>In the following example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">blueButton</pc> will appear to the right of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">textBox1</pc> regardless of changes in orientation or layout, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">orangeButton</pc> will appear immediately below, and aligned with, <pc dataRefEnd="id8" dataRefStart="id7" id="p4">blueButton</pc>—even as the width of <pc dataRefEnd="id10" dataRefStart="id9" id="p5">textBox1</pc> changes as text is typed into it.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>It would previously have required rows and columns in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Grid</pc> to achieve this effect, but now it can be done using far less markup.</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>relativepanel example</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>Use visual state triggers to build UI that can adapt to available screen space</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>Your UI may need to adapt to changes in window size.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>Adaptive visual states allows you to change the visual state in response to changes in the size of the window.</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<segment state="initial">
					<source>StateTriggers define a threshold at which a visual state is activated, which then sets layout properties as appropriate for the window size that triggered the state change.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>In the following example, when the window size is 720 pixels or more in width, the visual state named <pc dataRefEnd="id2" dataRefStart="id1" id="p1">wideView</pc> is triggered, which then arranges the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Best-rated games</pc> panel to appear to the right of, and aligned with the top of, the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Top free games</pc> panel.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>visual state trigger example.</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>wide view</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When the window is less than 720 pixels, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">narrowView</pc> visual state is triggered because the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">wideView</pc> trigger is no longer satisfied and so no longer in effect.</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">narrowView</pc> visual state positions the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Best-rated games</pc> panel below, and aligned with the left of, the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Top paid games</pc> panel:</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>visual state trigger example.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>narrow view</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<segment state="initial">
					<source>Here is the XAML for the visual state triggers described above.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<originalData>
					<data id="id1">`...`</data>
				</originalData>
				<segment state="initial">
					<source>The definition of the panels, alluded to by "<ph dataRef="id1" id="ph1" />" below, has been removed for brevity.</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>Tooling</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>By default, you'll probably want to target the broadest possible device family.</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>When you're ready to see how your app looks and lays out on a particular device, use the device preview toolbar in Visual Studio to preview your UI on a small or medium mobile device, on a PC, or on a large TV screen.</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>That way you can tailor and test your adaptive visual states:</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>visual studio 2015 device preview toolbar</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>You don’t have to make a decision up front about every device type that you'll support.</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>You can add an additional device size to your project later.</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>Adaptive scaling</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>Windows 10 introduces an evolution of the existing scaling model.</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<segment state="initial">
					<source>In addition to scaling vector content, there is a unified set of scale factors that provides a consistent size for UI elements across a variety of screen sizes and display resolutions.</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<segment state="initial">
					<source>The scale factors are also compatible with the scale factors of other operating systems such as iOS and Android.</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>This makes it easier to share assets between these platforms.</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>The Store picks the assets to download based in part of the DPI of the device.</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<segment state="initial">
					<source>Only the assets that best match the device are downloaded.</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>Common input handling</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>You can build a Universal Windows app using universal controls that handle various inputs such as mouse, keyboard, touch, pen, and controller (such as the Xbox controller).</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>Traditionally, inking has been associated only with pen input, but with Windows 10, you can ink with touch on some devices, and with any pointer input.</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>Inking is supported on many devices (including mobile devices) and can easily be incorporated with a just few lines of code.</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>The following APIs provide access to input:</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn298460)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreIndependentInputSource</pc></pc> is a new API that allows you to consume raw input on the main thread or a background thread.</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242038)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerPoint</pc></pc> unifies raw touch, mouse, and pen data into a single, consistent set of interfaces and events that can be consumed on the main thread or background thread by using <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CoreInput.</pc></source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br225633)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerDevice</pc></pc> is a device API that supports querying device capabilities so that you can determine what input modalities are available on the device.</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn858535)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/dn922011)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The new <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">InkCanvas</pc></pc> XAML control and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">InkPresenter</pc></pc> Windows Runtime APIs allow you to access ink stroke data.</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<segment state="initial">
					<source>Writing code</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/dn609832.aspx#target_win10)</data>
				</originalData>
				<segment state="initial">
					<source>Your programming language options for your <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows 10 project in Visual Studio</pc> include Visual C++, C#, Visual Basic, and JavaScript.</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>For Visual C++, C#, and Visual Basic, you can use XAML for a full-fidelity, native UI experience.</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>For Visual C++ you can choose to draw with DirectX either instead of or as well as using XAML.</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>For JavaScript, your presentation layer will be HTML, and HTML is of course a cross-platform web standard.</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<segment state="initial">
					<source>Much of your code and UI will be universal and it will run the same way everywhere.</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<segment state="initial">
					<source>But for code tailored to particular device families, and for UI tailored to particular form factors, you'll have the option to use adaptive code and adaptive UI.</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>Let's look at these different cases.</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<segment state="initial">
					<source>Calling an API that's implemented by your target device family</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>Whenever you want to call an API, you'll need to know whether the API is implemented by the device family that your app is targeting.</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<segment state="initial">
					<source>If in doubt, you can look it up in the API reference documentation.</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<segment state="initial">
					<source>If you open the relevant topic and look at the Requirements section, you'll see what the implementing device family is.</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn893595)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Let's say that your app is targeting version 10.0.x.0 of the universal device family and you want to call members of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Core.SystemNavigationManager</pc></pc> class.</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>In this example, the device family is "Universal".</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>It's a good idea to further confirm that the class members that you want to call are also within your target, and in this case they are.</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>So in this example, you now know that the APIs are guaranteed to be present on every device that your app can be installed on, and you can call the APIs in your code just like you normally would.</source>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<segment state="initial">
					<source>As another example, imagine that your app is targeting version 10.0.x.0 of the Xbox device family, and the reference topic for an API that you want to call says that the API was introduced in version 10.0.x.0 of the Xbox device family.</source>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<segment state="initial">
					<source>In that case, again, the API is guaranteed to be present on every device that your app can be installed on.</source>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<segment state="initial">
					<source>So you would be able to call that API in your code in the normal way.</source>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>Note that Visual Studio's IntelliSense will not recognize APIs unless they are implemented by your app's target device family or any extension SDKs that you have referenced.</source>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<segment state="initial">
					<source>Consequently, if you haven't referenced any extension SDKs, you can be sure that any APIs that appear in IntelliSense must therefore be in your target device family and you can call them freely.</source>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<segment state="initial">
					<source>Calling an API that's NOT implemented by your target device family</source>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<segment state="initial">
					<source>There will be cases when you want to call an API, but your target device family is not listed in the documentation.</source>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<segment state="initial">
					<source>In that case you can opt to write adaptive code in order to call that API.</source>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<segment state="initial">
					<source>Writing adaptive code with the ApiInformation class</source>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>There are two steps to write adaptive code.</source>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<segment state="initial">
					<source>The first step is to make the APIs that you want to access available to your project.</source>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>To do that, add a reference to the extension SDK that represents the device family that owns the APIs that you want to conditionally call.</source>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](../porting/w8x-to-uwp-porting-to-a-uwp-project.md#extension-sdks)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Extension SDKs</pc>.</source>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn949001)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The second step is to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.Foundation.Metadata.ApiInformation</pc></pc> class in a condition in your code to test for the presence of the API you want to call.</source>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<segment state="initial">
					<source>This condition is evaluated wherever your app runs, but it evaluates to true only on devices where the API is present and therefore available to call.</source>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn949016)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you want to call just a small number of APIs, you could use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ApiInformation.IsTypePresent</pc></pc> method like this.</source>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/jj207557)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/dn653805)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>In this case we can be confident that the presence of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">HardwareButtons</pc></pc> class implies the presence of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CameraPressed</pc></pc> event, because the class and the member have the same requirements info.</source>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<segment state="initial">
					<source>But in time, new members will be added to already-introduced classes, and those members will have later "introduced in" version numbers.</source>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>In such cases, instead of using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IsTypePresent</pc>, you can test for the presence of individual members by using <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsEventPresent</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">IsMethodPresent</pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p4">IsPropertyPresent</pc>, and similar methods.</source>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<segment state="initial">
					<source>Here's an example.</source>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<segment state="initial">
					<source>The set of APIs within a device family is further broken down into subdivisions known as API contracts.</source>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ApiInformation.IsApiContractPresent</pc> method to test for the presence of an API contract.</source>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<segment state="initial">
					<source>This is useful if you want to test for the presence of a large number of APIs that all exist in the same version of an API contract.</source>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<segment state="initial">
					<source>Win32 APIs in the UWP</source>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<segment state="initial">
					<source>A UWP app or Windows Runtime Component written in C++/CX has access to the Win32 APIs that are part of the UWP.</source>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<segment state="initial">
					<source>These Win32 APIs are implemented by all Windows 10 device families.</source>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<segment state="initial">
					<source>Link your app with Windowsapp.lib.</source>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<segment state="initial">
					<source>Windowsapp.lib is an "umbrella" lib that provides the exports for the UWP APIs.</source>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<segment state="initial">
					<source>Linking to Windowsapp.lib will add to your app dependencies on dlls that are present on all Windows 10 device families.</source>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/mt186421)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/mt186422)</data>
				</originalData>
				<segment state="initial">
					<source>For the full list of Win32 APIs available to UWP apps, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">API Sets for UWP apps</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Dlls for UWP apps</pc>.</source>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<segment state="initial">
					<source>User experience</source>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>A Universal Windows app allows you to take advantage of the unique capabilities of the device on which it is running.</source>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/?LinkId=526365)</data>
				</originalData>
				<segment state="initial">
					<source>Your app can make use of all of the power of a desktop device, the natural interaction of direct manipulation on a tablet (including touch and pen input), the portability and convenience of mobile devices, and the collaborative power of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Surface Hub</pc>.</source>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/?LinkId=258848)</data>
				</originalData>
				<segment state="initial">
					<source>Good <pc dataRefEnd="id2" dataRefStart="id1" id="p1">design</pc> is the process of deciding how users will interact with your app, as well as how it will look and function.</source>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<segment state="initial">
					<source>User experience plays a huge part in determining how happy people will be with your app, so don't skimp on this step.</source>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://dev.windows.com/en-us/design)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Design basics</pc> introduce you to designing a Universal Windows app.</source>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn958439)</data>
				</originalData>
				<segment state="initial">
					<source>See the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Introduction to Universal Windows Platform (UWP) apps for designers</pc> for information on designing UWP apps that delight your users.</source>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](../input-and-devices/device-primer.md)</data>
				</originalData>
				<segment state="initial">
					<source>Before you start coding, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">device primer</pc> to help you think through the interaction experience of using your app on all the different form factors you want to target.</source>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<segment state="initial">
					<source>windows-powered devices</source>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh465427)</data>
				</originalData>
				<segment state="initial">
					<source>In addition to interaction on different devices, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">plan your app</pc> to embrace the benefits of working across multiple devices.</source>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<segment state="initial">
					<source>For example:</source>
				</segment>
			</unit>
			<unit id="311" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/?LinkId=526377)</data>
				</originalData>
				<segment state="initial">
					<source>Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">cloud services</pc> to sync across devices.</source>
				</segment>
			</unit>
			<unit id="312" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh761504)</data>
				</originalData>
				<segment state="initial">
					<source>Learn how to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">connect to web services</pc> in support of your app experience.</source>
				</segment>
			</unit>
			<unit id="313" translate="yes">
				<segment state="initial">
					<source>Consider how you can support users moving from one device to another, picking up where they left off.</source>
				</segment>
			</unit>
			<unit id="314" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt187203)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/mt219684)</data>
				</originalData>
				<segment state="initial">
					<source>Include <pc dataRefEnd="id2" dataRefStart="id1" id="p1">notifications</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">in-app purchases</pc> in your planning.</source>
				</segment>
			</unit>
			<unit id="315" translate="yes">
				<segment state="initial">
					<source>These features should work across devices.</source>
				</segment>
			</unit>
			<unit id="316" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn958438)</data>
				</originalData>
				<segment state="initial">
					<source>Design your workflow using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Navigation design basics for UWP apps</pc> to accommodate mobile, small-screen, and large-screen devices.</source>
				</segment>
			</unit>
			<unit id="317" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn958435)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Lay out your user interface</pc> to respond to different screen sizes and resolutions.</source>
				</segment>
			</unit>
			<unit id="318" translate="yes">
				<segment state="initial">
					<source>Consider whether there are features of your app that don’t make sense on a small mobile screen.</source>
				</segment>
			</unit>
			<unit id="319" translate="yes">
				<segment state="initial">
					<source>There may also be areas that don’t make sense on a stationary desktop machine and require a mobile device to light up.</source>
				</segment>
			</unit>
			<unit id="320" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt219698)</data>
				</originalData>
				<segment state="initial">
					<source>For example, most scenarios around <pc dataRefEnd="id2" dataRefStart="id1" id="p1">location</pc> imply a mobile device.</source>
				</segment>
			</unit>
			<unit id="321" translate="yes">
				<segment state="initial">
					<source>Consider how you'll accommodate multiple input modalities.</source>
				</segment>
			</unit>
			<unit id="322" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn611861)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/dn974233)</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/dn596121)</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/hh465370)</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/hh972345)</data>
				</originalData>
				<segment state="initial">
					<source>See the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Guidelines for interactions</pc> to learn how users can interact with your app by using <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Cortana</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Speech</pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Touch interactions</pc>, the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Touch keyboard</pc> and more.</source>
				</segment>
			</unit>
			<unit id="323" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dn611864)</data>
				</originalData>
				<segment state="initial">
					<source>See the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Guidelines for text and text input</pc> for more tradition interaction experiences.</source>
				</segment>
			</unit>
			<unit id="324" translate="yes">
				<segment state="initial">
					<source>Submit a Universal Windows app through your Dashboard</source>
				</segment>
			</unit>
			<unit id="325" translate="yes">
				<segment state="initial">
					<source>The new unified Windows Dev Center dashboard lets you manage and submit all of your apps for Windows devices in one place.</source>
				</segment>
			</unit>
			<unit id="326" translate="yes">
				<segment state="initial">
					<source>New features simplify processes while giving you more control.</source>
				</segment>
			</unit>
			<unit id="327" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt148522)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/dn986925)</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/mt148526)</data>
				</originalData>
				<segment state="initial">
					<source>You'll also find detailed <pc dataRefEnd="id2" dataRefStart="id1" id="p1">analytic reports</pc> combined <pc dataRefEnd="id4" dataRefStart="id3" id="p2">payout details</pc>, ways to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">promote your app and engage with your customers</pc>, and much more.</source>
				</segment>
			</unit>
			<unit id="328" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](../publish/using-the-windows-dev-center-dashboard.md)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Using the unified Windows Dev Center dashboard</pc> to learn how to submit your apps for publication in the Windows Store.</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>