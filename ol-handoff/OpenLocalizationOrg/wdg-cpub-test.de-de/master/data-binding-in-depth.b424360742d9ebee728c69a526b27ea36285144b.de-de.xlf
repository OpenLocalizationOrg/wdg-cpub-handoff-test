<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">a90f434035e360ed2caaadd1452f6cdaf60d4c4a</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci1\data-binding\data-binding-in-depth.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">aed8a7bd3f6d8260fefeb052e42aa201760f3fee</mda:meta><mda:meta type="olxliffhash">b28ddceb9b0b515376e7407d3143c0bd663d643a</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Data binding in depth</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Data binding is a way for your app's UI to display data, and optionally to stay in sync with that data.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Data binding in depth</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>** Important APIs **</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Binding class</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>DataContext</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>INotifyPropertyChanged</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  This topic describes data binding features in detail.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](data-binding-quickstart.md)</data>
				</originalData>
				<segment state="initial">
					<source>For a short, practical introduction, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding overview</pc>.</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>Data binding is a way for your app's UI to display data, and optionally to stay in sync with that data.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Data binding allows you to separate the concern of data from the concern of UI, and that results in a simpler conceptual model as well as better readability, testability, and maintainability of your app.</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>You can use data binding to simply display values from a data source when the UI is first shown, but not to respond to changes in those values.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>This is called one-time binding, and it works well for data whose values don't change during run-time.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Additionally, you can choose to "observe" the values and to update the UI when they change.</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>This is called one-way binding, and it works well for read-only data.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Ultimately, you can choose to both observe and update, so that changes that the user makes to values in the UI are automatically pushed back into the data source.</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>This is called two-way binding, and it works well for read-write data.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Here are some examples.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242752)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You could use one-time binding to bind an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Image</pc></pc> to the current user's photo.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You could use one-way binding to bind a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> to a collection of real-time news articles grouped by newspaper section.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209683)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You could use two-way binding to bind a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBox</pc></pc> to a customer's name in a form.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>There are two kinds of binding, and they're both typically declared in UI markup.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
				</originalData>
				<segment state="initial">
					<source>You can choose to use either the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind} markup extension</pc> or the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding} markup extension</pc>.</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>And you can even use a mixture of the two in the same app—even on the same UI element.</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>{x:Bind} is new for Windows 10 and it has better performance.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>{Binding} has more features.</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>All the details described in this topic apply to both kinds of binding unless we explicitly say otherwise.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>Sample apps that demonstrate {x:Bind}</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619989)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind} sample</pc>.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://github.com/Microsoft/Windows-appsample-quizgame)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">QuizGame</pc>.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619992)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML UI Basics sample</pc>.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Sample apps that demonstrate {Binding}</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/?linkid=532950)</data>
				</originalData>
				<segment state="initial">
					<source>Download the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Bookstore1</pc> app.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/?linkid=532952)</data>
				</originalData>
				<segment state="initial">
					<source>Download the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Bookstore2</pc> app.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Every binding involves these pieces</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">binding source</pc>.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>This is the source of the data for the binding, and it can be an instance of any class that has members whose values you want to display in your UI.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">binding target</pc>.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242362)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208706)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>This is a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement</pc></pc> in your UI that displays the data.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">binding object</pc>.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>This is the piece that transfers data values from the source to the target, and optionally from the target back to the source.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
				</originalData>
				<segment state="initial">
					<source>The binding object is created at XAML load time from your <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> markup extension.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>In the following sections, we'll take a closer look at the binding source, the binding target, and the binding object.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>And we'll link the sections together with the example of binding a button's content to a string property named <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NextButtonText</pc>, which belongs to a class named <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HostViewModel</pc>.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Binding source</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Here's a very rudimentary implementation of a class that we could use as a binding source.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/Hh701872)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you're using <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> with Visual C++ component extensions (C++/CX) then you'll need to add the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">BindableAttribute</pc></pc> attribute to your binding source class.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
				</originalData>
				<segment state="initial">
					<source>If you're using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> then you don't need that attribute.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](data-binding-quickstart.md#adding-a-details-view)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Adding a details view</pc> for a code snippet.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>That implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HostViewModel</pc>, and its property <pc dataRefEnd="id4" dataRefStart="id3" id="p2">NextButtonText</pc>, are only appropriate for one-time binding.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>But one-way and two-way bindings are extremely common, and in those kinds of binding the UI automatically updates in response to changes in the data values of the binding source.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>In order for those kinds of binding to work correctly, you need to make your binding source "observable" to the binding object.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>So in our example, if we want to one-way or two-way bind to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NextButtonText</pc> property, then any changes that happen at run-time to the value of that property need to be made observable to the binding object.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242362)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>One way of doing that is to derive the class that represents your binding source from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>, and expose a data value through a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyProperty</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208706)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>That's how a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement</pc></pc> becomes observable.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">FrameworkElements</pc> are good binding sources right out of the box.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.ComponentModel.INotifyPropertyChanged)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A more lightweight way of making a class observable—and a necessary one for classes that already have a base class—is to implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">System.ComponentModel.INotifyPropertyChanged</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This really just involves implementing a single event named <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PropertyChanged</pc>.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>An example using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HostViewModel</pc> is below.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR209899)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/Hh701872)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/BR209878)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For C++/CX, you implement <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Windows::UI::Xaml::Data::INotifyPropertyChanged</pc></pc>, and the binding source class must either have the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">BindableAttribute</pc></pc> or implement <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">ICustomPropertyProvider</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Now the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NextButtonText</pc> property is observable.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When you author a one-way or a two-way binding to that property (we'll show how later), the resulting binding object subscribes to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PropertyChanged</pc> event.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>When that event is raised, the binding object's handler receives an argument containing the name of the property that has changed.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>That's how the binding object knows which property's value to go and read again.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://github.com/Microsoft/Windows-appsample-quizgame)</data>
				</originalData>
				<segment state="initial">
					<source>So that you don't have to implement the pattern shown above multiple times, you can just derive from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BindableBase</pc> bass class that you'll find in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">QuizGame</pc> sample (in the "Common" folder).</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>Here's an example of how that looks.</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](T:System.String)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Raising the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PropertyChanged</pc> event with an argument of <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">String.Empty</pc></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">null</pc> indicates that all non-indexer properties on the object should be re-read.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
				</originalData>
				<segment state="initial">
					<source>You can raise the event to indicate that indexer properties on the object have changed by using an argument of "Item\[<pc dataRefEnd="id2" dataRefStart="id1" id="p1">indexer</pc>\]" for specific indexers (where <pc dataRefEnd="id4" dataRefStart="id3" id="p2">indexer</pc> is the index value), or a value of "Item\[\]" for all indexers.</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>A binding source can be treated either as a single object whose properties contain data, or as a collection of objects.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.Collections.Generic.List%601)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In C# and Visual Basic code, you can one-time bind to an object that implements <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">List(Of T)</pc></pc> to display a collection that does not change at run-time.</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.Collections.ObjectModel.ObservableCollection%601)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For an observable collection (observing when items are added to and removed from the collection), one-way bind to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ObservableCollection(Of T)</pc></pc> instead.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/dn858385.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">&amp;lt;</data>
					<data id="id6">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>In C++ code, you can bind to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Vector<ph dataRef="id5" id="ph1" />T<ph dataRef="id6" id="ph2" /></pc></pc> for both observable and non-observable collections.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>To bind to your own collection classes, use the guidance in the following table.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Scenario</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>C# and VB (CLR)</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>C++/CX</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>Bind to an object.</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>Can be any object.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh701872)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209878)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Object must have <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BindableAttribute</pc></pc> or implement <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ICustomPropertyProvider</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>Get property change updates from a bound object.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.ComponentModel.INotifyPropertyChanged)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Object must implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">System.ComponentModel. INotifyPropertyChanged</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209899)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Object must implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Data. INotifyPropertyChanged</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>Bind to a collection.</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>List(Of T)</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>Platform::Collections::Vector<ph dataRef="id1" id="ph1" />T</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Get collection change updates from a bound collection.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>ObservableCollection(Of T)</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>Platform::Collections::Vector<ph dataRef="id1" id="ph1" />T</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>Implement a collection that supports binding.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.Collections.Generic.List%601)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](T:System.Collections.IList)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](T:System.Collections.Generic.IList%601)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](T:System.Object)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
					<data id="id17">[</data>
					<data id="id18">](T:System.Collections.IEnumerable)</data>
					<data id="id19">**</data>
					<data id="id20">**</data>
					<data id="id21">[</data>
					<data id="id22">](T:System.Collections.Generic.IEnumerable%601)</data>
					<data id="id23">**</data>
					<data id="id24">**</data>
					<data id="id25">**</data>
					<data id="id26">**</data>
				</originalData>
				<segment state="initial">
					<source>Extend <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">List(Of T)</pc></pc> or implement <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IList</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IList</pc></pc>(Of <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Object</pc></pc>), <pc dataRefEnd="id18" dataRefStart="id17" id="p9"><pc dataRefEnd="id20" dataRefStart="id19" id="p10">IEnumerable</pc></pc>, or <pc dataRefEnd="id22" dataRefStart="id21" id="p11"><pc dataRefEnd="id24" dataRefStart="id23" id="p12">IEnumerable</pc></pc>(Of <pc dataRefEnd="id26" dataRefStart="id25" id="p13">Object</pc>).</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Binding to generic <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IList(Of T)</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IEnumerable(Of T)</pc> is not supported.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh701979)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/Hh701957)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR206631)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">&amp;lt;</data>
					<data id="id14">[</data>
					<data id="id15">](T:System.Object)</data>
					<data id="id16">**</data>
					<data id="id17">**</data>
					<data id="id18">^&amp;gt;</data>
					<data id="id19">[</data>
					<data id="id20">](https://msdn.microsoft.com/library/windows/apps/BR226024)</data>
					<data id="id21">**</data>
					<data id="id22">**</data>
					<data id="id23">&amp;lt;</data>
					<data id="id24">**</data>
					<data id="id25">**</data>
					<data id="id26">^&amp;gt;</data>
					<data id="id27">**</data>
					<data id="id28">**</data>
					<data id="id29">&amp;lt;</data>
					<data id="id30">[</data>
					<data id="id31">](https://msdn.microsoft.com/library/BR205821)</data>
					<data id="id32">**</data>
					<data id="id33">**</data>
					<data id="id34">\*&amp;gt;</data>
					<data id="id35">**</data>
					<data id="id36">**</data>
					<data id="id37">&amp;lt;</data>
					<data id="id38">**</data>
					<data id="id39">**</data>
					<data id="id40">\*&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>Implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IBindableVector</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IBindableIterable</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IVector</pc></pc><ph dataRef="id13" id="ph1" /><pc dataRefEnd="id15" dataRefStart="id14" id="p7"><pc dataRefEnd="id17" dataRefStart="id16" id="p8">Object</pc></pc><ph dataRef="id18" id="ph2" />, <pc dataRefEnd="id20" dataRefStart="id19" id="p9"><pc dataRefEnd="id22" dataRefStart="id21" id="p10">IIterable</pc></pc><ph dataRef="id23" id="ph3" /><pc dataRefEnd="id25" dataRefStart="id24" id="p11">Object</pc><ph dataRef="id26" id="ph4" />, <pc dataRefEnd="id28" dataRefStart="id27" id="p12">IVector</pc><ph dataRef="id29" id="ph5" /><pc dataRefEnd="id31" dataRefStart="id30" id="p13"><pc dataRefEnd="id33" dataRefStart="id32" id="p14">IInspectable</pc></pc><ph dataRef="id34" id="ph6" />, or <pc dataRefEnd="id36" dataRefStart="id35" id="p15">IIterable</pc><ph dataRef="id37" id="ph7" /><pc dataRefEnd="id39" dataRefStart="id38" id="p16">IInspectable</pc><ph dataRef="id40" id="ph8" />.</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">&amp;lt;</data>
					<data id="id8">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>Binding to generic <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IVector<ph dataRef="id3" id="ph1" />T<ph dataRef="id4" id="ph2" /></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p2">IIterable<ph dataRef="id7" id="ph3" />T<ph dataRef="id8" id="ph4" /></pc> is not supported.</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>Implement a collection that supports collection change updates.</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.Collections.ObjectModel.ObservableCollection%601)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](T:System.Collections.IList)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](T:System.Collections.Specialized.INotifyCollectionChanged)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>Extend <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ObservableCollection(Of T)</pc></pc> or implement (non-generic) <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IList</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">INotifyCollectionChanged</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh701979)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/Hh701974)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IBindableVector</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IBindableObservableVector</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>Implement a collection that supports incremental loading.</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.Collections.ObjectModel.ObservableCollection%601)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](T:System.Collections.IList)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](T:System.Collections.Specialized.INotifyCollectionChanged)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>Extend <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ObservableCollection(Of T)</pc></pc> or implement (non-generic) <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IList</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">INotifyCollectionChanged</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh701916)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Additionally, implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISupportIncrementalLoading</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh701979)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/Hh701974)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/Hh701916)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>Implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IBindableVector</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IBindableObservableVector</pc></pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ISupportIncrementalLoading</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>You can bind list controls to arbitrarily large data sources, and still achieve high performance, by using incremental loading.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>For example, you can bind list controls to Bing image query results without having to load all the results at once.</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>Instead, you load only some results immediately, and load additional results as needed.</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh701916)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To support incremental loading, you must implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISupportIncrementalLoading</pc></pc> on a data source that supports collection change notification.</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>When the data binding engine requests more data, your data source must make the appropriate requests, integrate the results, and then send the appropriate notifications in order to update the UI.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>Binding target</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In the two examples below, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Button.Content</pc> property is the binding target, and its value is set to a markup extension which declares the binding object.</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
				</originalData>
				<segment state="initial">
					<source>First <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> is shown, and then <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc>.</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>Declaring bindings in markup is the common case (it's convenient, readable, and toolable).</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209820)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>But you can avoid markup and imperatively (programmatically) create an instance of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Binding</pc></pc> class instead if you need to.</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>Binding object declared using {x:Bind}</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
				</originalData>
				<segment state="initial">
					<source>There's one step we need to do before we author our <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> markup.</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>We need to expose our binding source class from the class that represents our page of markup.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>We do that by adding a property (of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HostViewModel</pc> in this case) to our <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HostView</pc> page class.</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>That done, we can now take a closer look at the markup that declares the binding object.</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The example below uses the same <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Button.Content</pc> binding target we used in the "Binding target" section earlier, and shows it being bound to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HostViewModel.NextButtonText</pc> property.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Notice the value that we specify for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Path</pc>.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This value is interpreted in the context of the page itself, and in this case the path begins by referencing the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ViewModel</pc> property that we just added to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HostView</pc> page.</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>That property returns a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HostViewModel</pc> instance, and so we can dot into that object to access the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HostViewModel.NextButtonText</pc> property.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
				</originalData>
				<segment state="initial">
					<source>And we specify <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Mode</pc>, to override the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{x:Bind}</pc> default of one-time.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209820-path)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Path</pc></pc> property supports a variety of syntax options for binding to nested properties, attached properties, and integer and string indexers.</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt185586)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Property-path syntax</pc>.</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209878)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Binding to string indexers gives you the effect of binding to dynamic properties without having to implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ICustomPropertyProvider</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
				</originalData>
				<segment state="initial">
					<source>For other settings, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind} markup extension</pc>.</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR209683-text)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR209683)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Changes to <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">TextBox.Text</pc></pc> are sent to a two-way bound source when the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">TextBox</pc></pc> loses focus, and not after every user keystroke.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>DataTemplate and x:DataType</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242348)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Inside a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataTemplate</pc></pc> (whether used as an item template, a content template, or a header template), the value of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Path</pc> is not interpreted in the context of the page, but in the context of the data object being templated.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>So that its bindings can be validated (and efficient code generated for them) at compile-time, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DataTemplate</pc> needs to declare the type of its data object using <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:DataType</pc>.</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The example given below could be used as the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ItemTemplate</pc> of an items control bound to a collection of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SampleDataGroup</pc> objects.</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>Weakly-typed objects in your Path</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>Consider for example that you have a type named SampleDataGroup, which implements a string property named Title.</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>And you have a property MainPage.SampleDataGroupAsObject, which is of type object but which actually returns an instance of SampleDataGroup.</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<originalData>
					<data id="id1">`&lt;TextBlock Text="{x:Bind SampleDataGroupAsObject.Title}"/&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>The binding <ph dataRef="id1" id="ph1" /> will result in a compile error because the Title property is not found on the type object.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<originalData>
					<data id="id1">`&lt;TextBlock Text="{x:Bind SampleDataGroupAsObject.(data:SampleDataGroup.Title)}"/&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>The remedy for this is to add a cast to your Path syntax like this: <ph dataRef="id1" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<originalData>
					<data id="id1">`&lt;TextBlock Text="{x:Bind Element.Text}"/&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>Here's another example where Element is declared as object but is actually a TextBlock: <ph dataRef="id1" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<originalData>
					<data id="id1">`&lt;TextBlock Text="{x:Bind Element.(TextBlock.Text)}"/&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>And a cast remedies the issue: <ph dataRef="id1" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>If your data loads asynchronously</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Code to support <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> is generated at compile-time in the partial classes for your pages.</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<originalData>
					<data id="id1">`obj`</data>
					<data id="id2">`&lt;view name&gt;.g.cs`</data>
				</originalData>
				<segment state="initial">
					<source>These files can be found in your <ph dataRef="id1" id="ph1" /> folder, with names like (for C#) <ph dataRef="id2" id="ph2" />.</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208706-loading)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The generated code includes a handler for your page's <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Loading</pc></pc> event, and that handler calls the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Initialize</pc> method on a generated class that represent's your page's bindings.</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Initialize</pc> in turn calls <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Update</pc> to begin moving data between the binding source and the target.</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Loading</pc> is raised just before the first measure pass of the page or user control.</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>So if your data is loaded asynchronously it may not be ready by the time <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Initialize</pc> is called.</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<originalData>
					<data id="id1">`this-&gt;Bindings-&gt;Update();`</data>
				</originalData>
				<segment state="initial">
					<source>So, after you've loaded data, you can force one-time bindings to be initialized by calling <ph dataRef="id1" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>If you only need one-time bindings for asynchronously-loaded data then it’s much cheaper to initialize them this way than it is to have one-way bindings and to listen for changes.</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If your data does not undergo fine-grained changes, and if it's likely to be updated as part of a specific action, then you can make your bindings one-time, and force a manual update at any time with a call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Update</pc>.</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>Limitations</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> is not suited to late-bound scenarios, such as navigating the dictionary structure of a JSON object, nor duck typing which is a weak form of typing based on lexical matches on property names ("if it walks, swims, and quacks like a duck then it's a duck").</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>With duck typing, a binding to the Age property would be equally satisfied with a Person or a Wine object.</source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For these scenarios, use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc>.</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>Binding object declared using {Binding}</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR208713)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc> assumes, by default, that you're binding to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DataContext</pc></pc> of your markup page.</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>So we'll set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DataContext</pc> of our page to be an instance of our binding source class (of type <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HostViewModel</pc> in this case).</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>The example below shows the markup that declares the binding object.</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>We use the same <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Button.Content</pc> binding target we used in the "Binding target" section earlier, and we bind to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HostViewModel.NextButtonText</pc> property.</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Notice the value that we specify for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Path</pc>.</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208713)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>This value is interpreted in the context of the page's <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc></pc>, which in this example is set to an instance of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">HostViewModel</pc>.</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The path references the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HostViewModel.NextButtonText</pc> property.</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
				</originalData>
				<segment state="initial">
					<source>We can omit <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Mode</pc>, because the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> default of one-way works here.</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208713)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The default value of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc></pc> for a UI element is the inherited value of its parent.</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You can of course override that default by setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DataContext</pc> explicitly, which is in turn inherited by children by default.</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DataContext</pc> explicitly on an element is useful when you want to have multiple bindings that use the same source.</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR208713)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>A binding object has a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Source</pc> property, which defaults to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DataContext</pc></pc> of the UI element on which the binding is declared.</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
				</originalData>
				<segment state="initial">
					<source>You can override this default by setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Source</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">RelativeSource</pc>, or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ElementName</pc> explicitly on the binding (see <pc dataRefEnd="id8" dataRefStart="id7" id="p4">{Binding}</pc> for details).</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242348)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208713)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Inside a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataTemplate</pc></pc>, the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DataContext</pc></pc> is set to the data object being templated.</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The example given below could be used as the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ItemTemplate</pc> of an items control bound to a collection of any type that has string properties named <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Title</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Description</pc>.</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR209683-text)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR209683)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  By default, changes to <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">TextBox.Text</pc></pc> are sent to a two-way bound source when the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">TextBox</pc></pc> loses focus.</source>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To cause changes to be sent after every user keystroke, set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UpdateSourceTrigger</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyChanged</pc> on the binding in markup.</source>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can also completely take control of when changes are sent to the source by setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UpdateSourceTrigger</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Explicit</pc>.</source>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209683-textchanged)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208706-getbindingexpression)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR209820expression)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR209820expression-updatesource)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>You then handle events on the text box (typically <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBox.TextChanged</pc></pc>), call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetBindingExpression</pc></pc> on the target to get a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">BindingExpression</pc></pc> object, and finally call <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">BindingExpression.UpdateSource</pc></pc> to programmatically update the data source.</source>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209820-path)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Path</pc></pc> property supports a variety of syntax options for binding to nested properties, attached properties, and integer and string indexers.</source>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt185586)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Property-path syntax</pc>.</source>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209878)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Binding to string indexers gives you the effect of binding to dynamic properties without having to implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ICustomPropertyProvider</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209820-elementname)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ElementName</pc></pc> property is useful for element-to-element binding.</source>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209820-relativesource)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209391)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RelativeSource</pc></pc> property has several uses, one of which is as a more powerful alternative to template binding inside a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ControlTemplate</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR209820)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>For other settings, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding} markup extension</pc> and the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Binding</pc></pc> class.</source>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>What if the source and the target are not the same type?</source>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<segment state="initial">
					<source>If you want to control the visibility of a UI element based on the value of a boolean property, or if you want to render a UI element with a color that's a function of a numeric value's range or trend, or if you want to display a date and/or time value in a UI element property that expects a string, then you'll need to convert values from one type to another.</source>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>There will be cases where the right solution is to expose another property of the right type from your binding source class, and keep the conversion logic encapsulated and testable there.</source>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<segment state="initial">
					<source>But that isn't flexible nor scalable when you have large numbers, or large combinations, of source and target properties.</source>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<segment state="initial">
					<source>In that case you'll want to use something known as a value converter.</source>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<segment state="initial">
					<source>This section describes how to implement and consume a value converter.</source>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.DateTime)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's a value converter, suitable for a one-time or a one-way binding, that converts a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DateTime</pc></pc> value to a string value containing the month.</source>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209903)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The class implements <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IValueConverter</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<segment state="initial">
					<source>And here's how you consume that value converter in your binding object markup.</source>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209903-convert)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209903-convertback)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR209820-converter)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>The binding engine calls the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Convert</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ConvertBack</pc></pc> methods if the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Converter</pc></pc> parameter is defined for the binding.</source>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When data is passed from the source, the binding engine calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Convert</pc> and passes the returned data to the target.</source>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When data is passed from the target (for a two-way binding), the binding engine calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConvertBack</pc> and passes the returned data to the source.</source>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209820-converterlanguage)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209820-converterparameter)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The converter also has optional parameters: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConverterLanguage</pc></pc>, which allows specifying the language to be used in the conversion, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ConverterParameter</pc></pc>, which allows passing a parameter for the conversion logic.</source>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209903)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For an example that uses a converter parameter, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IValueConverter</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If there is an error in the conversion, do not throw an exception.</source>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242362-unsetvalue)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Instead, return <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty.UnsetValue</pc></pc>, which will stop the data transfer.</source>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>To display a default value to use whenever the binding source cannot be resolved, set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FallbackValue</pc> property on the binding object in markup.</source>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<segment state="initial">
					<source>This is useful to handle conversion and formatting errors.</source>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<segment state="initial">
					<source>It is also useful to bind to source properties that might not exist on all objects in a bound collection of heterogeneous types.</source>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<segment state="initial">
					<source>If you bind a text control to a value that is not a string, the data binding engine will convert the value to a string.</source>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209878-getstringrepresentation)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/Dn302136)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](M:System.Object.ToString)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>If the value is a reference type, the data binding engine will retrieve the string value by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ICustomPropertyProvider.GetStringRepresentation</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IStringable.ToString</pc></pc> if available, and will otherwise call <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Object.ToString</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Note, however, that the binding engine will ignore any <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ToString</pc> implementation that hides the base-class implementation.</source>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Subclass implementations should override the base class <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ToString</pc> method instead.</source>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209878)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/Dn302135)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Similarly, in native languages, all managed objects appear to implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ICustomPropertyProvider</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IStringable</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>However, all calls to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetStringRepresentation</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IStringable.ToString</pc> are routed to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Object.ToString</pc> or an override of that method, and never to a new <pc dataRefEnd="id8" dataRefStart="id7" id="p4">ToString</pc> implementation that hides the base-class implementation.</source>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<segment state="initial">
					<source>Resource dictionaries with {x:Bind}</source>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind} markup extension</pc> depends on code generation, so it needs a code-behind file containing a constructor that calls <pc dataRefEnd="id4" dataRefStart="id3" id="p2">InitializeComponent</pc> (to initialize the generated code).</source>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You re-use the resource dictionary by instantiating its type (so that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InitializeComponent</pc> is called) instead of referencing its filename.</source>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<segment state="initial">
					<source>Here's an example of what to do if you have an existing resource dictionary and you want to use {x:Bind} in it.</source>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<segment state="initial">
					<source>TemplatesResourceDictionary.xaml</source>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<segment state="initial">
					<source>TemplatesResourceDictionary.xaml.cs</source>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<segment state="initial">
					<source>MainPage.xaml</source>
				</segment>
			</unit>
			<unit id="311" translate="yes">
				<segment state="initial">
					<source>Event binding and ICommand</source>
				</segment>
			</unit>
			<unit id="312" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> supports a feature called event binding.</source>
				</segment>
			</unit>
			<unit id="313" translate="yes">
				<segment state="initial">
					<source>With this feature, you can specify the handler for an event using a binding, which is an additional option on top of handling events with a method on the code-behind file.</source>
				</segment>
			</unit>
			<unit id="314" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Let's say you have a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RootFrame</pc> property on your <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MainPage</pc> class.</source>
				</segment>
			</unit>
			<unit id="315" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>You can then bind a button's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Click</pc> event to a method on the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Frame</pc> object returned by the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">RootFrame</pc> property like this.</source>
				</segment>
			</unit>
			<unit id="316" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Note that we also bind the button's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IsEnabled</pc> property to another member of the same <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Frame</pc>.</source>
				</segment>
			</unit>
			<unit id="317" translate="yes">
				<segment state="initial">
					<source>Overloaded methods cannot be used to handle an event with this technique.</source>
				</segment>
			</unit>
			<unit id="318" translate="yes">
				<segment state="initial">
					<source>Also, if the method that handles the event has parameters then they must all be assignable from the types of all of the event's parameters, respectively.</source>
				</segment>
			</unit>
			<unit id="319" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242693)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>In this case, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Frame.GoForward</pc></pc> is not overloaded and it has no parameters (but it would still be valid even if it took two <pc dataRefEnd="id6" dataRefStart="id5" id="p3">object</pc> parameters).</source>
				</segment>
			</unit>
			<unit id="320" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn996568)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Frame.GoBack</pc></pc> is overloaded, though, so we can't use that method with this technique.</source>
				</segment>
			</unit>
			<unit id="321" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.Windows.Input.ICommand)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The event binding technique is similar to implementing and consuming commands (a command is a property that returns an object that implements the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ICommand</pc></pc> interface).</source>
				</segment>
			</unit>
			<unit id="322" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
				</originalData>
				<segment state="initial">
					<source>Both <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> work with commands.</source>
				</segment>
			</unit>
			<unit id="323" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://github.com/Microsoft/Windows-appsample-quizgame)</data>
				</originalData>
				<segment state="initial">
					<source>So that you don't have to implement the command pattern multiple times, you can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DelegateCommand</pc> helper class that you'll find in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">QuizGame</pc> sample (in the "Common" folder).</source>
				</segment>
			</unit>
			<unit id="324" translate="yes">
				<segment state="initial">
					<source>Binding to a collection of folders or files</source>
				</segment>
			</unit>
			<unit id="325" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227346)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use the APIs in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.Storage</pc></pc> namespace to retrieve folder and file data.</source>
				</segment>
			</unit>
			<unit id="326" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>However, the various <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetFilesAsync</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetFoldersAsync</pc>, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">GetItemsAsync</pc> methods do not return values that are suitable for binding to list controls.</source>
				</segment>
			</unit>
			<unit id="327" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh701422)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/Hh701428)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/Hh701430)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR207501)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>Instead, you must bind to the return values of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetVirtualizedFilesVector</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetVirtualizedFoldersVector</pc></pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">GetVirtualizedItemsVector</pc></pc> methods of the <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">FileInformationFactory</pc></pc> class.</source>
				</segment>
			</unit>
			<unit id="328" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=228621)</data>
				</originalData>
				<segment state="initial">
					<source>The following code example from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StorageDataSource and GetVirtualizedFilesVector sample</pc> shows the typical usage pattern.</source>
				</segment>
			</unit>
			<unit id="329" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Remember to declare the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">picturesLibrary</pc> capability in your app package manifest, and confirm that there are pictures in your Pictures library folder.</source>
				</segment>
			</unit>
			<unit id="330" translate="yes">
				<segment state="initial">
					<source>You will typically use this approach to create a read-only view of file and folder info.</source>
				</segment>
			</unit>
			<unit id="331" translate="yes">
				<segment state="initial">
					<source>You can create two-way bindings to the file and folder properties, for example to let users rate a song in a music view.</source>
				</segment>
			</unit>
			<unit id="332" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR207760)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>However, any changes are not persisted until you call the appropriate <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SavePropertiesAsync</pc> method (for example, <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">MusicProperties.SavePropertiesAsync</pc></pc>).</source>
				</segment>
			</unit>
			<unit id="333" translate="yes">
				<segment state="initial">
					<source>You should commit changes when the item loses focus because this triggers a selection reset.</source>
				</segment>
			</unit>
			<unit id="334" translate="yes">
				<segment state="initial">
					<source>Note that two-way binding using this technique works only with indexed locations, such as Music.</source>
				</segment>
			</unit>
			<unit id="335" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR207627)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can determine whether a location is indexed by calling the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FolderInformation.GetIndexedStateAsync</pc></pc> method.</source>
				</segment>
			</unit>
			<unit id="336" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Note also that a virtualized vector can return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> for some items before it populates their value.</source>
				</segment>
			</unit>
			<unit id="337" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR209770)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR209768)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, you should check for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> before you use the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">SelectedItem</pc></pc> value of a list control bound to a virtualized vector, or use <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">SelectedIndex</pc></pc> instead.</source>
				</segment>
			</unit>
			<unit id="338" translate="yes">
				<segment state="initial">
					<source>Binding to data grouped by a key</source>
				</segment>
			</unit>
			<unit id="339" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you take a flat collection of items—books, for example, represented by a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BookSku</pc> class—and you group the items by using a common property as a key—the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">BookSku.AuthorName</pc> property, for example—then the result is called grouped data.</source>
				</segment>
			</unit>
			<unit id="340" translate="yes">
				<segment state="initial">
					<source>When you group data, it is no longer a flat collection.</source>
				</segment>
			</unit>
			<unit id="341" translate="yes">
				<segment state="initial">
					<source>Grouped data is a collection of group objects, where each group object has a) a key and b) a collection of items whose property matches that key.</source>
				</segment>
			</unit>
			<unit id="342" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To take the books example again, the result of grouping the books by author name results in a collection of author name groups where each group has a) a key, which is an author name, and b) a collection of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BookSku</pc>s whose <pc dataRefEnd="id4" dataRefStart="id3" id="p2">AuthorName</pc> property matches the group's key.</source>
				</segment>
			</unit>
			<unit id="343" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242828)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242705)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>In general, to display a collection, you bind the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsSource</pc></pc> of an items control (such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ListView</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">GridView</pc></pc>) directly to a property that returns a collection.</source>
				</segment>
			</unit>
			<unit id="344" translate="yes">
				<segment state="initial">
					<source>If that's a flat collection of items then you don't need to do anything special.</source>
				</segment>
			</unit>
			<unit id="345" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209833)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>But if it's a collection of group objects (as it is when binding to grouped data) then you need the services of an intermediary object called a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CollectionViewSource</pc></pc> which sits between the items control and the binding source.</source>
				</segment>
			</unit>
			<unit id="346" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You bind the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CollectionViewSource</pc> to the property that returns grouped data, and you bind the items control to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CollectionViewSource</pc>.</source>
				</segment>
			</unit>
			<unit id="347" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>An extra value-add of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CollectionViewSource</pc> is that it keeps track of the current item, so you can keep more than one items control in sync by binding them all to the same <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CollectionViewSource</pc>.</source>
				</segment>
			</unit>
			<unit id="348" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209857)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209833-view)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>You can also access the current item programmatically through the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ICollectionView.CurrentItem</pc></pc> property of the object returned by the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CollectionViewSource.View</pc></pc> property.</source>
				</segment>
			</unit>
			<unit id="349" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209833)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209833-issourcegrouped)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>To activate the grouping facility of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CollectionViewSource</pc></pc>, set <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IsSourceGrouped</pc></pc> to <pc dataRefEnd="id10" dataRefStart="id9" id="p5">true</pc>.</source>
				</segment>
			</unit>
			<unit id="350" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209833-itemspath)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Whether you also need to set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsPath</pc></pc> property depends on exactly how you author your group objects.</source>
				</segment>
			</unit>
			<unit id="351" translate="yes">
				<segment state="initial">
					<source>There are two ways to author a group object: the "is-a-group" pattern, and the "has-a-group" pattern.</source>
				</segment>
			</unit>
			<unit id="352" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>In the "is-a-group" pattern, the group object derives from a collection type (for example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">List<ph dataRef="id3" id="ph1" />T<ph dataRef="id4" id="ph2" /></pc>), so the group object actually is itself the group of items.</source>
				</segment>
			</unit>
			<unit id="353" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>With this pattern you do not need to set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ItemsPath</pc>.</source>
				</segment>
			</unit>
			<unit id="354" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>In the "has-a-group" pattern, the group object has one or more properties of a collection type (such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">List<ph dataRef="id3" id="ph1" />T<ph dataRef="id4" id="ph2" /></pc>), so the group "has a" group of items in the form of a property (or several groups of items in the form of several properties).</source>
				</segment>
			</unit>
			<unit id="355" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>With this pattern you need to set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ItemsPath</pc> to the name of the property that contains the group of items.</source>
				</segment>
			</unit>
			<unit id="356" translate="yes">
				<segment state="initial">
					<source>The example below illustrates the "has-a-group" pattern.</source>
				</segment>
			</unit>
			<unit id="357" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208713)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The page class has a property named <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ViewModel</pc></pc>, which returns an instance of our view model.</source>
				</segment>
			</unit>
			<unit id="358" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209833)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CollectionViewSource</pc></pc> binds to the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Authors</pc> property of the view model (<pc dataRefEnd="id8" dataRefStart="id7" id="p4">Authors</pc> is the collection of group objects) and also specifies that it's the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Author.BookSkus</pc> property that contains the grouped items.</source>
				</segment>
			</unit>
			<unit id="359" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242705)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Finally, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GridView</pc></pc> is bound to the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CollectionViewSource</pc>, and has its group style defined so that it can render the items in groups.</source>
				</segment>
			</unit>
			<unit id="360" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242828)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>Note that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsSource</pc></pc> must use <pc dataRefEnd="id6" dataRefStart="id5" id="p3">{Binding}</pc> (and not <pc dataRefEnd="id8" dataRefStart="id7" id="p4">{x:Bind}</pc>) because it needs to set the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Source</pc> property to a resource.</source>
				</segment>
			</unit>
			<unit id="361" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/?linkid=532952)</data>
				</originalData>
				<segment state="initial">
					<source>To see the above example in the context of the complete app, download the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Bookstore2</pc> sample app.</source>
				</segment>
			</unit>
			<unit id="362" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/?linkid=532952)</data>
				</originalData>
				<segment state="initial">
					<source>Unlike the markup shown above, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Bookstore2</pc> uses {Binding} exclusively.</source>
				</segment>
			</unit>
			<unit id="363" translate="yes">
				<segment state="initial">
					<source>You can implement the "is-a-group" pattern in one of two ways.</source>
				</segment>
			</unit>
			<unit id="364" translate="yes">
				<segment state="initial">
					<source>One way is to author your own group class.</source>
				</segment>
			</unit>
			<unit id="365" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
				</originalData>
				<segment state="initial">
					<source>Derive the class from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">List<ph dataRef="id3" id="ph1" />T<ph dataRef="id4" id="ph2" /></pc> (where <pc dataRefEnd="id6" dataRefStart="id5" id="p2">T</pc> is the type of the items).</source>
				</segment>
			</unit>
			<unit id="366" translate="yes">
				<originalData>
					<data id="id1">`public class Author : List&lt;BookSku&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>For example, <ph dataRef="id1" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="367" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://msdn.microsoft.com/library/bb397926.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The second way is to use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">LINQ</pc> expression to dynamically create group objects (and a group class) from like property values of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">BookSku</pc> items.</source>
				</segment>
			</unit>
			<unit id="368" translate="yes">
				<segment state="initial">
					<source>This approach—maintaining only a flat list of items and grouping them together on the fly—is typical of an app that accesses data from a cloud service.</source>
				</segment>
			</unit>
			<unit id="369" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You get the flexibility to group books by author or by genre (for example) without needing special group classes such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Author</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Genre</pc>.</source>
				</segment>
			</unit>
			<unit id="370" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://msdn.microsoft.com/library/bb397926.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>The example below illustrates the "is-a-group" pattern using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">LINQ</pc>.</source>
				</segment>
			</unit>
			<unit id="371" translate="yes">
				<segment state="initial">
					<source>This time we group books by genre, displayed with the genre name in the group headers.</source>
				</segment>
			</unit>
			<unit id="372" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](P:System.Linq.IGrouping%602.Key)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This is indicated by the "Key" property path in reference to the group <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Key</pc></pc> value.</source>
				</segment>
			</unit>
			<unit id="373" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Remember that when using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> with data templates we need to indicate the type being bound to by setting an <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:DataType</pc> value.</source>
				</segment>
			</unit>
			<unit id="374" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
				</originalData>
				<segment state="initial">
					<source>If the type is generic then we can't express that in markup so we need to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc> instead in the group style header template.</source>
				</segment>
			</unit>
			<unit id="375" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh702601)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SemanticZoom</pc></pc> control is a great way for your users to view and navigate grouped data.</source>
				</segment>
			</unit>
			<unit id="376" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/?linkid=532952)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Bookstore2</pc> sample app illustrates how to use the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SemanticZoom</pc>.</source>
				</segment>
			</unit>
			<unit id="377" translate="yes">
				<segment state="initial">
					<source>In that app, you can view a list of books grouped by author (the zoomed-in view) or you can zoom out to see a jump list of authors (the zoomed-out view).</source>
				</segment>
			</unit>
			<unit id="378" translate="yes">
				<segment state="initial">
					<source>The jump list affords much quicker navigation than scrolling through the list of books.</source>
				</segment>
			</unit>
			<unit id="379" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The zoomed-in and zoomed-out views are actually <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GridView</pc> controls bound to the same <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CollectionViewSource</pc>.</source>
				</segment>
			</unit>
			<unit id="380" translate="yes">
				<segment state="initial">
					<source>An illustration of a SemanticZoom</source>
				</segment>
			</unit>
			<unit id="381" translate="yes">
				<segment state="initial">
					<source>When you bind to hierarchical data—such as subcategories within categories—you can choose to display the hierarchical levels in your UI with a series of items controls.</source>
				</segment>
			</unit>
			<unit id="382" translate="yes">
				<segment state="initial">
					<source>A selection in one items control determines the contents of subsequent items controls.</source>
				</segment>
			</unit>
			<unit id="383" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209833)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>You can keep the lists synchronized by binding each list to its own <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CollectionViewSource</pc></pc> and binding the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CollectionViewSource</pc> instances together in a chain.</source>
				</segment>
			</unit>
			<unit id="384" translate="yes">
				<segment state="initial">
					<source>This is called a master/details (or list/details) view.</source>
				</segment>
			</unit>
			<unit id="385" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](how-to-bind-to-hierarchical-data-and-create-a-master-details-view.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">How to bind to hierarchical data and create a master/details view</pc>.</source>
				</segment>
			</unit>
			<unit id="386" translate="yes">
				<segment state="initial">
					<source>Diagnosing and debugging data binding problems</source>
				</segment>
			</unit>
			<unit id="387" translate="yes">
				<segment state="initial">
					<source>Your binding markup contains the names of properties (and, for C#, sometimes fields and methods).</source>
				</segment>
			</unit>
			<unit id="388" translate="yes">
				<segment state="initial">
					<source>So when you rename a property, you'll also need to change any binding that references it.</source>
				</segment>
			</unit>
			<unit id="389" translate="yes">
				<segment state="initial">
					<source>Forgetting to do that leads to a typical example of a data binding bug, and your app either won't compile or won't run correctly.</source>
				</segment>
			</unit>
			<unit id="390" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
				</originalData>
				<segment state="initial">
					<source>The binding objects created by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> are largely functionally equivalent.</source>
				</segment>
			</unit>
			<unit id="391" translate="yes">
				<segment state="initial">
					<source>But {x:Bind} has type information for the binding source, and it generates source code at compile-time.</source>
				</segment>
			</unit>
			<unit id="392" translate="yes">
				<segment state="initial">
					<source>With {x:Bind} you get the same kind of problem detection that you get with the rest of your code.</source>
				</segment>
			</unit>
			<unit id="393" translate="yes">
				<segment state="initial">
					<source>That includes compile-time validation of your binding expressions, and debugging by setting breakpoints in the source code generated as the partial class for your page.</source>
				</segment>
			</unit>
			<unit id="394" translate="yes">
				<originalData>
					<data id="id1">`obj`</data>
					<data id="id2">`&lt;view name&gt;.g.cs`</data>
				</originalData>
				<segment state="initial">
					<source>These classes can be found in the files in your <ph dataRef="id1" id="ph1" /> folder, with names like (for C#) <ph dataRef="id2" id="ph2" />).</source>
				</segment>
			</unit>
			<unit id="395" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If you have a problem with a binding then turn on <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Break On Unhandled Exceptions</pc> in the Microsoft Visual Studio debugger.</source>
				</segment>
			</unit>
			<unit id="396" translate="yes">
				<segment state="initial">
					<source>The debugger will break execution at that point, and you can then debug what has gone wrong.</source>
				</segment>
			</unit>
			<unit id="397" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The code generated by {x:Bind} follows the same pattern for each part of the graph of binding source nodes, and you can use the info in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Call Stack</pc> window to help determine the sequence of calls that led up to the problem.</source>
				</segment>
			</unit>
			<unit id="398" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc> does not have type information for the binding source.</source>
				</segment>
			</unit>
			<unit id="399" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>But when you run your app with the debugger attached, any binding errors appear in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Output</pc> window in Visual Studio.</source>
				</segment>
			</unit>
			<unit id="400" translate="yes">
				<segment state="initial">
					<source>Creating bindings in code</source>
				</segment>
			</unit>
			<unit id="401" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  This section only applies to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc>, because you can't create <pc dataRefEnd="id6" dataRefStart="id5" id="p3">{x:Bind}</pc> bindings in code.</source>
				</segment>
			</unit>
			<unit id="402" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242356-registerpropertychangedcallback)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>However, some of the same benefits of {x:Bind} can be achieved with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty.RegisterPropertyChangedCallback</pc></pc>, which enables you to register for change notifications on any dependency property.</source>
				</segment>
			</unit>
			<unit id="403" translate="yes">
				<segment state="initial">
					<source>You can also connect UI elements to data using procedural code instead of XAML.</source>
				</segment>
			</unit>
			<unit id="404" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209820)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208706-setbinding)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR209820operations-setbinding)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>To do this, create a new <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Binding</pc></pc> object, set the appropriate properties, then call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement.SetBinding</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">BindingOperations.SetBinding</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="405" translate="yes">
				<segment state="initial">
					<source>Creating bindings programmatically is useful when you want to choose the binding property values at run-time or share a single binding among multiple controls.</source>
				</segment>
			</unit>
			<unit id="406" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Note, however, that you cannot change the binding property values after you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetBinding</pc>.</source>
				</segment>
			</unit>
			<unit id="407" translate="yes">
				<segment state="initial">
					<source>The following example shows how to implement a binding in code.</source>
				</segment>
			</unit>
			<unit id="408" translate="yes">
				<segment state="initial">
					<source>{x:Bind} and {Binding} feature comparison</source>
				</segment>
			</unit>
			<unit id="409" translate="yes">
				<segment state="initial">
					<source>Feature</source>
				</segment>
			</unit>
			<unit id="410" translate="yes">
				<segment state="initial">
					<source>{x:Bind}</source>
				</segment>
			</unit>
			<unit id="411" translate="yes">
				<segment state="initial">
					<source>{Binding}</source>
				</segment>
			</unit>
			<unit id="412" translate="yes">
				<segment state="initial">
					<source>Notes</source>
				</segment>
			</unit>
			<unit id="413" translate="yes">
				<segment state="initial">
					<source>Path is the default property</source>
				</segment>
			</unit>
			<unit id="414" translate="yes">
				<segment state="initial">
					<source>Path property</source>
				</segment>
			</unit>
			<unit id="415" translate="yes">
				<segment state="initial">
					<source>In x:Bind, Path is rooted at the Page by default, not the DataContext.</source>
				</segment>
			</unit>
			<unit id="416" translate="yes">
				<segment state="initial">
					<source>Indexer</source>
				</segment>
			</unit>
			<unit id="417" translate="yes">
				<segment state="initial">
					<source>Binds to the specified item in the collection.</source>
				</segment>
			</unit>
			<unit id="418" translate="yes">
				<segment state="initial">
					<source>Only integer-based indexes are supported.</source>
				</segment>
			</unit>
			<unit id="419" translate="yes">
				<segment state="initial">
					<source>Attached properties</source>
				</segment>
			</unit>
			<unit id="420" translate="yes">
				<segment state="initial">
					<source>Attached properties are specified using parentheses.</source>
				</segment>
			</unit>
			<unit id="421" translate="yes">
				<segment state="initial">
					<source>If the property is not declared in a XAML namespace, then prefix it with an xml namespace, which should be mapped to a code namespace at the head of the document.</source>
				</segment>
			</unit>
			<unit id="422" translate="yes">
				<segment state="initial">
					<source>Casting</source>
				</segment>
			</unit>
			<unit id="423" translate="yes">
				<segment state="initial">
					<source>Not needed&lt;</source>
				</segment>
			</unit>
			<unit id="424" translate="yes">
				<segment state="initial">
					<source>Casts are specified using parentheses.</source>
				</segment>
			</unit>
			<unit id="425" translate="yes">
				<segment state="initial">
					<source>If the property is not declared in a XAML namespace, then prefix it with an xml namespace, which should be mapped to a code namespace at the head of the document.</source>
				</segment>
			</unit>
			<unit id="426" translate="yes">
				<segment state="initial">
					<source>Converter</source>
				</segment>
			</unit>
			<unit id="427" translate="yes">
				<segment state="initial">
					<source>Converters must be declared at the root of the Page/ResourceDictionary, or in App.xaml.</source>
				</segment>
			</unit>
			<unit id="428" translate="yes">
				<segment state="initial">
					<source>ConverterParameter, ConverterLanguage</source>
				</segment>
			</unit>
			<unit id="429" translate="yes">
				<segment state="initial">
					<source>Converters must be declared at the root of the Page/ResourceDictionary, or in App.xaml.</source>
				</segment>
			</unit>
			<unit id="430" translate="yes">
				<segment state="initial">
					<source>TargetNullValue</source>
				</segment>
			</unit>
			<unit id="431" translate="yes">
				<segment state="initial">
					<source>Used when the leaf of the binding expression is null.</source>
				</segment>
			</unit>
			<unit id="432" translate="yes">
				<segment state="initial">
					<source>Use single quotes for a string value.</source>
				</segment>
			</unit>
			<unit id="433" translate="yes">
				<segment state="initial">
					<source>FallbackValue</source>
				</segment>
			</unit>
			<unit id="434" translate="yes">
				<segment state="initial">
					<source>Used when any part of the path for the binding (except for the leaf) is null.</source>
				</segment>
			</unit>
			<unit id="435" translate="yes">
				<segment state="initial">
					<source>ElementName</source>
				</segment>
			</unit>
			<unit id="436" translate="yes">
				<segment state="initial">
					<source>{Binding Value, ElementName=slider1}`</source>
				</segment>
			</unit>
			<unit id="437" translate="yes">
				<segment state="initial">
					<source>With {x:Bind} you're binding to a field; Path is rooted at the Page by default, so any named element can be accessed via its field.</source>
				</segment>
			</unit>
			<unit id="438" translate="yes">
				<segment state="initial">
					<source>RelativeSource: Self</source>
				</segment>
			</unit>
			<unit id="439" translate="yes">
				<segment state="initial">
					<source>With {x:Bind}, name the element and use its name in Path.</source>
				</segment>
			</unit>
			<unit id="440" translate="yes">
				<segment state="initial">
					<source>RelativeSource: TemplatedParent</source>
				</segment>
			</unit>
			<unit id="441" translate="yes">
				<segment state="initial">
					<source>Not supported</source>
				</segment>
			</unit>
			<unit id="442" translate="yes">
				<segment state="initial">
					<source>Regular template binding can be used in control templates for most uses.</source>
				</segment>
			</unit>
			<unit id="443" translate="yes">
				<segment state="initial">
					<source>But use TemplatedParent where you need to use a converter, or a two-way binding.&lt;</source>
				</segment>
			</unit>
			<unit id="444" translate="yes">
				<segment state="initial">
					<source>Source</source>
				</segment>
			</unit>
			<unit id="445" translate="yes">
				<segment state="initial">
					<source>Not supported</source>
				</segment>
			</unit>
			<unit id="446" translate="yes">
				<segment state="initial">
					<source>For {x:Bind} use a property or a static path instead.</source>
				</segment>
			</unit>
			<unit id="447" translate="yes">
				<segment state="initial">
					<source>Mode</source>
				</segment>
			</unit>
			<unit id="448" translate="yes">
				<segment state="initial">
					<source>Mode can be OneTime, OneWay, or TwoWay.</source>
				</segment>
			</unit>
			<unit id="449" translate="yes">
				<segment state="initial">
					<source>{x:Bind} defaults to OneTime; {Binding} defaults to OneWay.</source>
				</segment>
			</unit>
			<unit id="450" translate="yes">
				<segment state="initial">
					<source>UpdateSourceTrigger</source>
				</segment>
			</unit>
			<unit id="451" translate="yes">
				<segment state="initial">
					<source>Not supported</source>
				</segment>
			</unit>
			<unit id="452" translate="yes">
				<segment state="initial">
					<source>'`&lt;Binding UpdateSourceTrigger="[Default</source>
				</segment>
			</unit>
			<unit id="453" translate="yes">
				<segment state="initial">
					<source>PropertyChanged</source>
				</segment>
			</unit>
			<unit id="454" translate="yes">
				<segment state="initial">
					<source>Explicit]"/&gt;'</source>
				</segment>
			</unit>
			<unit id="455" translate="yes">
				<segment state="initial">
					<source>{x:Bind} uses PropertyChanged behavior for all cases except TextBox.Text where it waits for lost focus to update the source.</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>