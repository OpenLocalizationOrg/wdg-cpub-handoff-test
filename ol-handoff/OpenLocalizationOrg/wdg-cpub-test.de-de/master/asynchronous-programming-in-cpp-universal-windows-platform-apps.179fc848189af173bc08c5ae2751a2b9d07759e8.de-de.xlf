<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">dfb615b990e140b99a70c4978f7d660fc6d77178</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci1\threading-async\asynchronous-programming-in-cpp-universal-windows-platform-apps.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">1d606d9ae1ab3a205fda69cefdab964f239dcebd</mda:meta><mda:meta type="olxliffhash">ecb98901d1ed2063150756ab2c0b5aa73b836c8a</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the task class defined in the concurrency namespace in ppltasks.h.</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Asynchronous programming in C++</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Asynchronous programming in C++</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>** Important APIs **</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>[task class]</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">concurrencyNamespace]</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">concurrency namespace</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc></source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">IAsyncOperation]</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncOperation</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc></source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<originalData>
					<data id="id1">`task`</data>
					<data id="id2">`concurrency`</data>
				</originalData>
				<segment state="initial">
					<source>This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the <ph dataRef="id1" id="ph1" /> class that's defined in the <ph dataRef="id2" id="ph2" /> namespace in ppltasks.h.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>Universal Windows Platform (UWP) asynchronous types</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>The Universal Windows Platform (UWP) features a well-defined model for calling asynchronous methods and provides the types that you need to consume such methods.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">[</data>
					<data id="id4">AsyncProgramming]</data>
				</originalData>
				<segment state="initial">
					<source>If you are not familiar with the UWP asynchronous model, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Asynchronous Programming</pc><pc dataRefEnd="id4" dataRefStart="id3" id="p2"></pc> before you read the rest of this article.</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">task-class]</data>
					<data id="id7">[</data>
					<data id="id8">]</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">concurrencyNamespace]</data>
					<data id="id13">`&lt;ppltasks.h&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>Although you can consume the asynchronous UWP APIs directly in C++, the preferred approach is to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task class</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> and its related types and functions, which are contained in the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">concurrency</pc></pc><pc dataRefEnd="id12" dataRefStart="id11" id="p6"></pc> namespace and defined in <ph dataRef="id13" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">concurrency::task</pc> is a general-purpose type, but when the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">/ZW</pc> compiler switch—which is required for Universal Windows Platform (UWP) apps and components—is used, the task class encapsulates the UWP asynchronous types so that it's easier to:</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>chain multiple asynchronous and synchronous operations together</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>handle exceptions in task chains</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>perform cancellation in task chains</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>ensure that individual tasks run in the appropriate thread context or apartment</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This article provides basic guidance about how to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task</pc> class with the UWP asynchronous APIs.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">]</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">createTask]</data>
					<data id="id9">[</data>
					<data id="id10">]</data>
					<data id="id11">[</data>
					<data id="id12">taskParallelism]</data>
				</originalData>
				<segment state="initial">
					<source>For more complete documentation about <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task</pc> and its related methods including <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">create\_task</pc></pc><pc dataRefEnd="id8" dataRefStart="id7" id="p4"></pc>, see <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Task Parallelism (Concurrency Runtime)</pc><pc dataRefEnd="id12" dataRefStart="id11" id="p6"></pc>.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">[</data>
					<data id="id4">createAsyncCpp]</data>
				</originalData>
				<segment state="initial">
					<source>For more information about how to create asynchronous public methods for consumption by JavaScript or other UWP-compatible languages, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Creating Asynchronous Operations in C++ for Windows Runtime apps</pc><pc dataRefEnd="id4" dataRefStart="id3" id="p2"></pc>.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>Consuming an async operation by using a task</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">]</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">IAsyncOperation]</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how to use the task class to consume an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> method that returns an <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IAsyncOperation</pc></pc><pc dataRefEnd="id8" dataRefStart="id7" id="p4"></pc> interface and whose operation produces a value.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Here are the basic steps:</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">`create_task`</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
				</originalData>
				<segment state="initial">
					<source>Call the <ph dataRef="id1" id="ph1" /> method and pass it the <pc dataRefEnd="id3" dataRefStart="id2" id="p1">IAsyncOperation^</pc> object.</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">taskThen]</data>
				</originalData>
				<segment state="initial">
					<source>Call the member function <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task::then</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> on the task and supply a lambda that will be invoked when the asynchronous operation completes.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">taskThen]</data>
					<data id="id7">*</data>
					<data id="id8">*</data>
				</originalData>
				<segment state="initial">
					<source>The task that's created and returned by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task::then</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> function is known as a <pc dataRefEnd="id8" dataRefStart="id7" id="p4">continuation</pc>.</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>The input argument (in this case) to the user-provided lambda is the result that the task operation produces when it completes.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br206600)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>It's the same value that would be retrieved by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncOperation::GetResults</pc></pc> if you were using the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">IAsyncOperation</pc> interface directly.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">taskThen]</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task::then</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> method returns immediately, and its delegate doesn't run until the asynchronous work completes successfully.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>In this example, if the asynchronous operation causes an exception to be thrown, or ends in the canceled state as a result of a cancellation request, the continuation will never execute.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Later, we’ll describe how to write continuations that execute even if the previous task was cancelled or failed.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Although you declare the task variable on the local stack, it manages its lifetime so that it is not deleted until all of its operations complete and all references to it go out of scope, even if the method returns before the operations complete.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>Creating a chain of tasks</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>In asynchronous programming, it's common to define a sequence of operations, also known as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task chains</pc>, in which each continuation executes only when the previous one completes.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>In some cases, the previous (or <pc dataRefEnd="id2" dataRefStart="id1" id="p1">antecedent</pc>) task produces a value that the continuation accepts as input.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">taskThen]</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">&lt;T&gt;</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
				</originalData>
				<segment state="initial">
					<source>By using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task::then</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> method, you can create task chains in an intuitive and straightforward manner; the method returns a <pc dataRefEnd="id8" dataRefStart="id7" id="p4">task<ph dataRef="id9" id="ph1" /></pc> where <pc dataRefEnd="id11" dataRefStart="id10" id="p5">T</pc> is the return type of the lambda function.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>You can compose multiple continuations into a task chain:</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Task chains are especially useful when a continuation creates a new asynchronous operation; such a task is known as an asynchronous task.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>The following example illustrates a task chain that has two continuations.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>The initial task acquires the handle to an existing file, and when that operation completes, the first continuation starts up a new asynchronous operation to delete the file.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>When that operation completes, the second continuation runs, and outputs a confirmation message.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>The previous example illustrates four important points:</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">IAsyncAction]</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">&lt;void&gt;</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
				</originalData>
				<segment state="initial">
					<source>The first continuation converts the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncAction^</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> object to a <pc dataRefEnd="id8" dataRefStart="id7" id="p4">task<ph dataRef="id9" id="ph1" /></pc> and returns the <pc dataRefEnd="id11" dataRefStart="id10" id="p5">task</pc>.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">&lt;void&gt;</data>
				</originalData>
				<segment state="initial">
					<source>The second continuation performs no error handling, and therefore takes <pc dataRefEnd="id2" dataRefStart="id1" id="p1">void</pc> and not <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task<ph dataRef="id5" id="ph1" /></pc> as input.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>It is a value-based continuation.</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">deleteAsync]</data>
				</originalData>
				<segment state="initial">
					<source>The second continuation doesn't execute until the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DeleteAsync</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> operation completes.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">deleteAsync]</data>
				</originalData>
				<segment state="initial">
					<source>Because the second continuation is value-based, if the operation that was started by the call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DeleteAsync</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> throws an exception, the second continuation doesn't execute at all.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Creating a task chain is just one of the ways to use the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task</pc> class to compose asynchronous operations.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">&amp;&amp;</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">||</data>
				</originalData>
				<segment state="initial">
					<source>You can also compose operations by using join and choice operators <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><ph dataRef="id3" id="ph1" /></pc> and <pc dataRefEnd="id5" dataRefStart="id4" id="p2"><ph dataRef="id6" id="ph2" /></pc>.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">[</data>
					<data id="id4">taskParallelism]</data>
				</originalData>
				<segment state="initial">
					<source>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Task Parallelism (Concurrency Runtime)</pc><pc dataRefEnd="id4" dataRefStart="id3" id="p2"></pc>.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>Lambda function return types and task return types</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In a task continuation, the return type of the lambda function is wrapped in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task</pc> object.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">&lt;double&gt;</data>
				</originalData>
				<segment state="initial">
					<source>If the lambda returns a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">double</pc>, then the type of the continuation task is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task<ph dataRef="id5" id="ph1" /></pc>.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>However, the task object is designed so that it doesn't produce needlessly nested return types.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>If a lambda returns an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IAsyncOperation&lt;SyndicationFeed^&gt;^</pc>, the continuation returns a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task&lt;SyndicationFeed^&gt;</pc>, not a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">task&lt;task&lt;SyndicationFeed^&gt;&gt;</pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">task&lt;IAsyncOperation&lt;SyndicationFeed^&gt;^&gt;^</pc>.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>This process is known as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">asynchronous unwrapping</pc> and it also ensures that the asynchronous operation inside the continuation completes before the next continuation is invoked.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">&lt;void&gt;</data>
					<data id="id4">[</data>
					<data id="id5">]</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">[</data>
					<data id="id9">IAsyncInfo]</data>
				</originalData>
				<segment state="initial">
					<source>In the previous example, notice that the task returns a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task<ph dataRef="id3" id="ph1" /></pc> even though its lambda returned an <pc dataRefEnd="id5" dataRefStart="id4" id="p2"><pc dataRefEnd="id7" dataRefStart="id6" id="p3">IAsyncInfo</pc></pc><pc dataRefEnd="id9" dataRefStart="id8" id="p4"></pc> object.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>The following table summarizes the type conversions that occur between a lambda function and the enclosing task:</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>lambda return type</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>return type</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>TResult</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>task</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>IAsyncOperation</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>task</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>IAsyncOperationWithProgress&lt;TResult, TProgress&gt;^</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>task</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>IAsyncAction^</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>task</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>IAsyncActionWithProgress</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>task</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>task</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>task</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>Canceling tasks</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>It is often a good idea to give the user the option to cancel an asynchronous operation.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>And in some cases you might have to cancel an operation programmatically from outside the task chain.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">]</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">IAsyncInfoCancel]</data>
					<data id="id9">[</data>
					<data id="id10">]</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">IAsyncInfo]</data>
				</originalData>
				<segment state="initial">
					<source>Although each \*<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Async</pc> return type has a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Cancel</pc></pc><pc dataRefEnd="id8" dataRefStart="id7" id="p4"></pc> method that it inherits from <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IAsyncInfo</pc></pc><pc dataRefEnd="id14" dataRefStart="id13" id="p7"></pc>, it's awkward to expose it to outside methods.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749985.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749975.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The preferred way to support cancellation in a task chain is to use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">cancellation\_token\_source</pc></pc> to create a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">cancellation\_token</pc></pc>, and then pass the token to the constructor of the initial task.</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750076.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>If an asynchronous task is created with a cancellation token, and <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">cancellation\_token\_source::cancel</pc></pc> is called, the task automatically calls <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Cancel</pc> on the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">IAsync\*</pc> operation and passes the cancellation request down its continuation chain.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>The following pseudocode demonstrates the basic approach.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">taskCanceled]</data>
				</originalData>
				<segment state="initial">
					<source>When a task is canceled, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task\_canceled</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> exception is propagated down the task chain.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">taskGet]</data>
				</originalData>
				<segment state="initial">
					<source>Value-based continuations will simply not execute, but task-based continuations will cause the exception to be thrown when <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task::get</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> is called.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If you have an error-handling continuation, make sure that it catches the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task\_canceled</pc> exception explicitly.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh755825.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>(This exception is not derived from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Platform::Exception</pc></pc>.)</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>Cancellation is cooperative.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>If your continuation does some long-running work beyond just invoking a UWP method, then it is your responsibility to check the state of the cancellation token periodically and stop execution if it is canceled.</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749945.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>After you clean up all resources that were allocated in the continuation, call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">cancel\_current\_task</pc></pc> to cancel that task and propagate the cancellation down to any value-based continuations that follow it.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR207871)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's another example: you can create a task chain that represents the result of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FileSavePicker</pc></pc> operation.</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">]</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">IAsyncInfoCancel]</data>
				</originalData>
				<segment state="initial">
					<source>If the user chooses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Cancel</pc> button, the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IAsyncInfo::Cancel</pc></pc><pc dataRefEnd="id8" dataRefStart="id7" id="p4"></pc> method is not called.</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Instead, the operation succeeds but returns <pc dataRefEnd="id2" dataRefStart="id1" id="p1">nullptr</pc>.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The continuation can test the input parameter and call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">cancel\_current\_task</pc> if the input is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">nullptr</pc>.</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/dd984117.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Cancellation in the PPL</pc></source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>Handling errors in a task chain</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">&lt;TResult&gt;</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">&lt;void&gt;</data>
					<data id="id7">[</data>
					<data id="id8">]</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">IAsyncAction]</data>
				</originalData>
				<segment state="initial">
					<source>If you want a continuation to execute even if the antecedent was canceled or threw an exception, then make the continuation a task-based continuation by specifying the input to its lambda function as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task<ph dataRef="id3" id="ph1" /></pc> or <pc dataRefEnd="id5" dataRefStart="id4" id="p2">task<ph dataRef="id6" id="ph2" /></pc> if the lambda of the antecedent task returns an <pc dataRefEnd="id8" dataRefStart="id7" id="p3"><pc dataRefEnd="id10" dataRefStart="id9" id="p4">IAsyncAction^</pc></pc><pc dataRefEnd="id12" dataRefStart="id11" id="p5"></pc>.</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<originalData>
					<data id="id1">`try…catch`</data>
				</originalData>
				<segment state="initial">
					<source>To handle errors and cancellation in a task chain, you don't have to make every continuation task-based or enclose every operation that might throw within a <ph dataRef="id1" id="ph1" /> block.</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>Instead, you can add a task-based continuation at the end of the chain and handle all errors there.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">taskCanceled]</data>
				</originalData>
				<segment state="initial">
					<source>Any exception—this includes a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task\_canceled</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> exception—will propagate down the task chain and bypass any value-based continuations, so that you can handle it in the error-handling task-based continuation.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>We can rewrite the previous example to use an error-handling task-based continuation:</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">taskGet]</data>
				</originalData>
				<segment state="initial">
					<source>In a task-based continuation, we call the member function <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task::get</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> to get the results of the task.</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">]</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">IAsyncAction]</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>We still have to call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::get</pc> even if the operation was an <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IAsyncAction</pc></pc><pc dataRefEnd="id8" dataRefStart="id7" id="p4"></pc> that produces no result because <pc dataRefEnd="id10" dataRefStart="id9" id="p5">task::get</pc> also gets any exceptions that have been transported down to the task.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If the input task is storing an exception, it is thrown at the call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::get</pc>.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you don't call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::get</pc>, or don't use a task-based continuation at the end of the chain, or don't catch the exception type that was thrown, then an <pc dataRefEnd="id4" dataRefStart="id3" id="p2">unobserved\_task\_exception</pc> is thrown when all references to the task have been deleted.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>Only catch the exceptions that you can handle.</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>If your app encounters an error that you can't recover from, it's better to let the app crash than to let it continue to run in an unknown state.</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Also, in general, don't attempt to catch the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">unobserved\_task\_exception</pc> itself.</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>This exception is mainly intended for diagnostic purposes.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When <pc dataRefEnd="id2" dataRefStart="id1" id="p1">unobserved\_task\_exception</pc> is thrown, it usually indicates a bug in the code.</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>Often the cause is either an exception that should be handled, or an unrecoverable exception that's caused by some other error in the code.</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>Managing the thread context</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>The UI of a UWP app runs in a single-threaded apartment (STA).</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">IAsyncAction]</data>
					<data id="id7">[</data>
					<data id="id8">]</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">IAsyncOperation]</data>
				</originalData>
				<segment state="initial">
					<source>A task whose lambda returns either an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncAction</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">IAsyncOperation</pc></pc><pc dataRefEnd="id12" dataRefStart="id11" id="p6"></pc> is apartment-aware.</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>If the task is created in the STA, then all of its continuations will run also run in it by default, unless you specify otherwise.</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>In other words, the entire task chain inherits apartment-awareness from the parent task.</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>This behavior helps simplify interactions with UI controls, which can only be accessed from the STA.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242868)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">]</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">taskThen]</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/BR208211)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, in a UWP app, in the member function of any class that represents a XAML page, you can populate a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListBox</pc></pc> control from within a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">task::then</pc></pc><pc dataRefEnd="id10" dataRefStart="id9" id="p5"></pc> method without having to use the <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Dispatcher</pc></pc> object.</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">IAsyncAction]</data>
					<data id="id7">[</data>
					<data id="id8">]</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">IAsyncOperation]</data>
				</originalData>
				<segment state="initial">
					<source>If a task doesn't return an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncAction</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">IAsyncOperation</pc></pc><pc dataRefEnd="id12" dataRefStart="id11" id="p6"></pc>, then it's not apartment-aware and, by default, its continuations are run on the first available background thread.</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">taskThen]</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749968.aspx)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>You can override the default thread context for either kind of task by using the overload of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task::then</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> that takes a <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">task\_continuation\_context</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>For example, in some cases, it might be desirable to schedule the continuation of an apartment-aware task on a background thread.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">useArbitrary]</data>
				</originalData>
				<segment state="initial">
					<source>In such a case, you can pass <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task\_continuation\_context::use\_arbitrary</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> to schedule the task’s work on the next available thread in a multi-threaded apartment.</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<segment state="initial">
					<source>This can improve the performance of the continuation because its work doesn't have to be synchronized with other work that's happening on the UI thread.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">useArbitrary]</data>
				</originalData>
				<segment state="initial">
					<source>The following example demonstrates when it's useful to specify the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task\_continuation\_context::use\_arbitrary</pc></pc><pc dataRefEnd="id6" dataRefStart="id5" id="p3"></pc> option, and it also shows how the default continuation context is useful for synchronizing concurrent operations on non-thread-safe collections.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>In this code, we loop through a list of URLs for RSS feeds, and for each URL, we start up an async operation to retrieve the feed data.</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>We can’t control the order in which the feeds are retrieved, and we don't really care.</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR210642)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR243485)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">`FeedData^`</data>
				</originalData>
				<segment state="initial">
					<source>When each <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RetrieveFeedAsync</pc></pc> operation completes, the first continuation accepts the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SyndicationFeed^</pc></pc> object and uses it to initialize an app-defined <ph dataRef="id9" id="ph1" /> object.</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Because each of these operations is independent from the others, we can potentially speed things up by specifying the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task\_continuation\_context::use\_arbitrary</pc> continuation context.</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<originalData>
					<data id="id1">`FeedData`</data>
					<data id="id2">[</data>
					<data id="id3">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh441570.aspx)</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
				</originalData>
				<segment state="initial">
					<source>However, after each <ph dataRef="id1" id="ph1" /> object is initialized, we have to add it to a <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">Vector</pc></pc>, which is not a thread-safe collection.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750085.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR206632)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Therefore, we create a continuation and specify <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task\_continuation\_context::use\_current</pc></pc> to ensure that all the calls to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Append</pc></pc> occur in the same Application Single-Threaded Apartment (ASTA) context.</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750085.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Because <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task\_continuation\_context::use\_default</pc></pc> is the default context, we don’t have to specify it explicitly, but we do so here for the sake of clarity.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>Nested tasks, which are new tasks that are created inside a continuation, don't inherit apartment-awareness of the initial task.</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>Handing progress updates</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR206594)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR206580withprogress_1)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Methods that support <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncOperationWithProgress</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IAsyncActionWithProgress</pc></pc> provide progress updates periodically while the operation is in progress, before it completes.</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>Progress reporting is independent from the notion of tasks and continuations.</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br206594)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You just supply the delegate for the object’s <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Progress</pc></pc> property.</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>A typical use of the delegate is to update a progress bar in the UI.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">[</data>
					<data id="id4">createAsyncCpp]</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Creating Asynchronous Operations in C++ for Windows Store apps</pc><pc dataRefEnd="id4" dataRefStart="id3" id="p2"></pc></source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>Visual C++ Language Reference</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">[</data>
					<data id="id4">AsyncProgramming]</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Asynchronous Programming</pc><pc dataRefEnd="id4" dataRefStart="id3" id="p2"></pc></source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">[</data>
					<data id="id4">taskParallelism]</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Task Parallelism (Concurrency Runtime)</pc><pc dataRefEnd="id4" dataRefStart="id3" id="p2"></pc></source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]</data>
					<data id="id3">[</data>
					<data id="id4">task-class]</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">task class</pc><pc dataRefEnd="id4" dataRefStart="id3" id="p2"></pc></source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>