<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-00ddeee</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">7f0abd09a83f5d47aa1263f2d2d9ee71edde20ea</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\adding-input-and-interactivity-to-the-marble-maze-sample.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">a2c8fbb89223db23dbc9170fd6186bcec644f6d5</mda:meta><mda:meta type="olxliffhash">656101701d819fd03267245a71237d669e216c5e</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Adding input and interactivity to the Marble Maze sample</source>
					<target>Adding input and interactivity to the Marble Maze sample</target>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Universal Windows Platform (UWP) app games run on a wide variety of devices, such as desktop computers, laptops, and tablets.</source>
					<target>Universal Windows Platform (UWP) app games run on a wide variety of devices, such as desktop computers, laptops, and tablets.</target>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Adding input and interactivity to the Marble Maze sample</source>
					<target>Adding input and interactivity to the Marble Maze sample</target>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
					<target>\[ Updated for UWP apps on Windows 10.</target>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
					<target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Universal Windows Platform (UWP) app games run on a wide variety of devices, such as desktop computers, laptops, and tablets.</source>
					<target>Universal Windows Platform (UWP) app games run on a wide variety of devices, such as desktop computers, laptops, and tablets.</target>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>A device can have a wide variety of input and control mechanisms.</source>
					<target>A device can have a wide variety of input and control mechanisms.</target>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>Support multiple input devices to enable your game to accommodate a wider range of preferences and abilities among your customers.</source>
					<target>Support multiple input devices to enable your game to accommodate a wider range of preferences and abilities among your customers.</target>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>This document describes the key practices to keep in mind when you work with input devices and shows how Marble Maze applies these practices.</source>
					<target>This document describes the key practices to keep in mind when you work with input devices and shows how Marble Maze applies these practices.</target>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](http://go.microsoft.com/fwlink/?LinkId=624011)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The sample code that corresponds to this document is found in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectX Marble Maze game sample</pc>.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The sample code that corresponds to this document is found in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectX Marble Maze game sample</pc>.</target>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>Here are some of the key points that this document discusses for when you work with input in your game:</source>
					<target>Here are some of the key points that this document discusses for when you work with input in your game:</target>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>When possible, support multiple input devices to enable your game to accommodate a wider range of preferences and abilities among your customers.</source>
					<target>When possible, support multiple input devices to enable your game to accommodate a wider range of preferences and abilities among your customers.</target>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Although game controller and sensor usage is optional, we strongly recommend it to enhance the player experience.</source>
					<target>Although game controller and sensor usage is optional, we strongly recommend it to enhance the player experience.</target>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>We designed the game controller and sensor API to help you more easily integrate these input devices.</source>
					<target>We designed the game controller and sensor API to help you more easily integrate these input devices.</target>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>To initialize touch, you must register for window events such as when the pointer is activated, released, and moved.</source>
					<target>To initialize touch, you must register for window events such as when the pointer is activated, released, and moved.</target>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br225687)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To initialize the accelerometer, create a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::Devices::Sensors::Accelerometer</pc></pc> object when you initialize the application.</source>
					<target>To initialize the accelerometer, create a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::Devices::Sensors::Accelerometer</pc></pc> object when you initialize the application.</target>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>The Xbox 360 controller doesn't require initialization.</source>
					<target>The Xbox 360 controller doesn't require initialization.</target>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>For single-player games, consider whether to combine input from all possible Xbox 360 controllers.</source>
					<target>For single-player games, consider whether to combine input from all possible Xbox 360 controllers.</target>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>This way, you don’t have to track what input comes from which controller.</source>
					<target>This way, you don’t have to track what input comes from which controller.</target>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Process Windows events before you process input devices.</source>
					<target>Process Windows events before you process input devices.</target>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>The Xbox 360 controller and the accelerometer support polling.</source>
					<target>The Xbox 360 controller and the accelerometer support polling.</target>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>That is, you can poll for data when you need it.</source>
					<target>That is, you can poll for data when you need it.</target>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>For touch, record touch events in data structures that are available to your input processing code.</source>
					<target>For touch, record touch events in data structures that are available to your input processing code.</target>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Consider whether to normalize input values to a common format.</source>
					<target>Consider whether to normalize input values to a common format.</target>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Doing so can simplify how input is interpreted by other components of your game, such as physics simulation, and can make it easier to write games that work on different screen resolutions.</source>
					<target>Doing so can simplify how input is interpreted by other components of your game, such as physics simulation, and can make it easier to write games that work on different screen resolutions.</target>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Input devices supported by Marble Maze</source>
					<target>Input devices supported by Marble Maze</target>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>Marble Maze supports Xbox 360 common controller devices, mouse, and touch to select menu items, and the Xbox 360 controller, mouse, touch, and the accelerometer to control game play.</source>
					<target>Marble Maze supports Xbox 360 common controller devices, mouse, and touch to select menu items, and the Xbox 360 controller, mouse, touch, and the accelerometer to control game play.</target>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>Marble Maze uses the XInput API to poll the controller for input.</source>
					<target>Marble Maze uses the XInput API to poll the controller for input.</target>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>Touch enables applications to track and respond to fingertip input.</source>
					<target>Touch enables applications to track and respond to fingertip input.</target>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>An accelerometer is a sensor that measures the force that is applied along the x, y, and z axes.</source>
					<target>An accelerometer is a sensor that measures the force that is applied along the x, y, and z axes.</target>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>By using the Windows Runtime, you can poll the current state of the accelerometer device, as well as receive touch events through the Windows Runtime event-handling mechanism.</source>
					<target>By using the Windows Runtime, you can poll the current state of the accelerometer device, as well as receive touch events through the Windows Runtime event-handling mechanism.</target>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  This document uses touch to refer to both touch and mouse input and pointer to refer to any device that uses pointer events.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  This document uses touch to refer to both touch and mouse input and pointer to refer to any device that uses pointer events.</target>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Because touch and the mouse use standard pointer events, you can use either device to select menu items and control game play.</source>
					<target>Because touch and the mouse use standard pointer events, you can use either device to select menu items and control game play.</target>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The package manifest sets Landscape as the supported rotation for the game to prevent the orientation from changing when you rotate the device to roll the marble.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The package manifest sets Landscape as the supported rotation for the game to prevent the orientation from changing when you rotate the device to roll the marble.</target>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>Initializing input devices</source>
					<target>Initializing input devices</target>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>The Xbox 360 controller does not require initialization.</source>
					<target>The Xbox 360 controller does not require initialization.</target>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>To initialize touch, you must register for windowing events such as when the pointer is activated (for example, your user presses the mouse button or touches the screen), released, and moved.</source>
					<target>To initialize touch, you must register for windowing events such as when the pointer is activated (for example, your user presses the mouse button or touches the screen), released, and moved.</target>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br225687)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To initialize the accelerometer, you have to create a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::Devices::Sensors::Accelerometer</pc></pc> object when you initialize the application.</source>
					<target>To initialize the accelerometer, you have to create a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::Devices::Sensors::Accelerometer</pc></pc> object when you initialize the application.</target>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/dn298471)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/dn298472)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/dn298469)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
					<data id="id15">[</data>
					<data id="id16">](https://msdn.microsoft.com/library/windows/apps/dn252834)</data>
					<data id="id17">**</data>
					<data id="id18">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXPage</pc> constructor registers for the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Windows::UI::Core::CoreIndependentInputSource::PointerPressed</pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Windows::UI::Core::CoreIndependentInputSource::PointerReleased</pc></pc>, and <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Windows::UI::Core::CoreIndependentInputSource::PointerMoved</pc></pc> pointer events for the <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">SwapChainPanel</pc></pc>.</source>
					<target>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXPage</pc> constructor registers for the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Windows::UI::Core::CoreIndependentInputSource::PointerPressed</pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Windows::UI::Core::CoreIndependentInputSource::PointerReleased</pc></pc>, and <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Windows::UI::Core::CoreIndependentInputSource::PointerMoved</pc></pc> pointer events for the <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">SwapChainPanel</pc></pc>.</target>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>These events are registered during app initialization and before the game loop.</source>
					<target>These events are registered during app initialization and before the game loop.</target>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>These events are handled in a separate thread that invokes the event handlers.</source>
					<target>These events are handled in a separate thread that invokes the event handlers.</target>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](marble-maze-application-structure.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about how the application is initialized, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Marble Maze application structure</pc>.</source>
					<target>For more information about how the application is initialized, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Marble Maze application structure</pc>.</target>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>The MarbleMaze class also creates a std::map object to hold touch events.</source>
					<target>The MarbleMaze class also creates a std::map object to hold touch events.</target>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>The key for this map object is a value that uniquely identifies the input pointer.</source>
					<target>The key for this map object is a value that uniquely identifies the input pointer.</target>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>Each key maps to the distance between every touch point and the center of the screen.</source>
					<target>Each key maps to the distance between every touch point and the center of the screen.</target>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>Marble Maze later uses these values to calculate the amount by which the maze is tilted.</source>
					<target>Marble Maze later uses these values to calculate the amount by which the maze is tilted.</target>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>The MarbleMaze class holds an Accelerometer object.</source>
					<target>The MarbleMaze class holds an Accelerometer object.</target>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>The Accelerometer object is initialized in the MarbleMaze::Initialize method, as shown in the following example.</source>
					<target>The Accelerometer object is initialized in the MarbleMaze::Initialize method, as shown in the following example.</target>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>The Windows::Devices::Sensors::Accelerometer::GetDefault method returns an instance of the default accelerometer.</source>
					<target>The Windows::Devices::Sensors::Accelerometer::GetDefault method returns an instance of the default accelerometer.</target>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>If there is no default accelerometer, Accelerometer::GetDefault the value of m\_accelerometer remains nullptr.</source>
					<target>If there is no default accelerometer, Accelerometer::GetDefault the value of m\_accelerometer remains nullptr.</target>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Navigating the menus</source>
					<target>Navigating the menus</target>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>Tracking Xbox 360 controller input</source>
					<target>Tracking Xbox 360 controller input</target>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>You can use the mouse, touch, or the Xbox 360 controller to navigate the menus, as follows:</source>
					<target>You can use the mouse, touch, or the Xbox 360 controller to navigate the menus, as follows:</target>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Use the directional pad to change the active menu item.</source>
					<target>Use the directional pad to change the active menu item.</target>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Use touch, the A button, or the Start button to pick a menu item or close the current menu, such as the high-score table.</source>
					<target>Use touch, the A button, or the Start button to pick a menu item or close the current menu, such as the high-score table.</target>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Use the Start button to pause or resume the game.</source>
					<target>Use the Start button to pause or resume the game.</target>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>Click on a menu item with the mouse to choose that action.</source>
					<target>Click on a menu item with the mouse to choose that action.</target>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>Tracking touch and mouse input</source>
					<target>Tracking touch and mouse input</target>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>To track Xbox 360 controller input, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method defines an array of buttons that define the input behaviors.</source>
					<target>To track Xbox 360 controller input, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method defines an array of buttons that define the input behaviors.</target>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>XInput provides only the current state of the controller.</source>
					<target>XInput provides only the current state of the controller.</target>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Therefore, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> also defines two arrays that track, for each possible Xbox 360 controller, whether each button was pressed during the previous frame and whether each button is currently pressed.</source>
					<target>Therefore, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> also defines two arrays that track, for each possible Xbox 360 controller, whether each button was pressed during the previous frame and whether each button is currently pressed.</target>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>You can connect up to four Xbox 360 controllers to a Windows device.</source>
					<target>You can connect up to four Xbox 360 controllers to a Windows device.</target>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>To avoid having to figure out which controller is the active one, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method combines input across all controllers.</source>
					<target>To avoid having to figure out which controller is the active one, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method combines input across all controllers.</target>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>If your game supports more than one player, you have to track input for each player separately.</source>
					<target>If your game supports more than one player, you have to track input for each player separately.</target>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In a loop, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method polls each controller for input and reads the state of each button.</source>
					<target>In a loop, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method polls each controller for input and reads the state of each button.</target>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>After the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method polls for input, it updates the combined input array.</source>
					<target>After the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method polls for input, it updates the combined input array.</target>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>The combined input array tracks only which buttons are pressed but were not previously pressed.</source>
					<target>The combined input array tracks only which buttons are pressed but were not previously pressed.</target>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>This enables the game to perform an action only at the time a button is initially pressed, and not when the button is held.</source>
					<target>This enables the game to perform an action only at the time a button is initially pressed, and not when the button is held.</target>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>After the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method collects button input, it performs any actions that must happen.</source>
					<target>After the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method collects button input, it performs any actions that must happen.</target>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>For example, when the Start button (XINPUT\_GAMEPAD\_START) is pressed, the game state changes from active to paused or from paused to active.</source>
					<target>For example, when the Start button (XINPUT\_GAMEPAD\_START) is pressed, the game state changes from active to paused or from paused to active.</target>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>If the main menu is active, the active menu item changes when the directional pad is pressed up or down.</source>
					<target>If the main menu is active, the active menu item changes when the directional pad is pressed up or down.</target>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>If the user chooses the current selection, the appropriate UI element is marked as being chosen.</source>
					<target>If the user chooses the current selection, the appropriate UI element is marked as being chosen.</target>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>After the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method processes controller input, it saves the current input state for the next frame.</source>
					<target>After the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method processes controller input, it saves the current input state for the next frame.</target>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>Tracking touch and mouse input</source>
					<target>Tracking touch and mouse input</target>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>For touch and mouse input, a menu item is chosen when the user touches or clicks it.</source>
					<target>For touch and mouse input, a menu item is chosen when the user touches or clicks it.</target>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method processes pointer input to select menu items.</source>
					<target>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method processes pointer input to select menu items.</target>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_pointQueue</pc> member variable tracks the locations where the user touched or clicked on the screen.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_pointQueue</pc> member variable tracks the locations where the user touched or clicked on the screen.</target>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>The way in which Marble Maze collects pointer input is described in greater detail later in this document in the section Processing pointer input.</source>
					<target>The way in which Marble Maze collects pointer input is described in greater detail later in this document in the section Processing pointer input.</target>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UserInterface::HitTest</pc> method determines whether the provided point is located in the bounds of any UI element.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UserInterface::HitTest</pc> method determines whether the provided point is located in the bounds of any UI element.</target>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>Any UI elements that pass this test are marked as being touched.</source>
					<target>Any UI elements that pass this test are marked as being touched.</target>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This method uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PointInRect</pc> helper function to determine whether the provided point is located in the bounds of each UI element.</source>
					<target>This method uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PointInRect</pc> helper function to determine whether the provided point is located in the bounds of each UI element.</target>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>Updating the game state</source>
					<target>Updating the game state</target>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>After the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method processes controller and touch input, it updates the game state if any button was pressed.</source>
					<target>After the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method processes controller and touch input, it updates the game state if any button was pressed.</target>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>Controlling game play</source>
					<target>Controlling game play</target>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The game loop and the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method work together to update the state of game objects.</source>
					<target>The game loop and the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method work together to update the state of game objects.</target>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>If your game accepts input from multiple devices, you can accumulate the input from all devices into one set of variables so that you can write code that's easier to maintain.</source>
					<target>If your game accepts input from multiple devices, you can accumulate the input from all devices into one set of variables so that you can write code that's easier to maintain.</target>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method defines one set of variables that accumulates movement from all devices.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method defines one set of variables that accumulates movement from all devices.</target>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>The input mechanism can vary from one input device to another.</source>
					<target>The input mechanism can vary from one input device to another.</target>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>For example, pointer input is handled by using the Windows Runtime event-handling model.</source>
					<target>For example, pointer input is handled by using the Windows Runtime event-handling model.</target>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>Conversely, you poll for input data from the Xbox 360 controller when you need it.</source>
					<target>Conversely, you poll for input data from the Xbox 360 controller when you need it.</target>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>We recommend that you always follow the input mechanism that is prescribed for a given device.</source>
					<target>We recommend that you always follow the input mechanism that is prescribed for a given device.</target>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>This section describes how Marble Maze reads input from each device, how it updates the combined input values, and how it uses the combined input values to update the state of the game.</source>
					<target>This section describes how Marble Maze reads input from each device, how it updates the combined input values, and how it uses the combined input values to update the state of the game.</target>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>Processing pointer input</source>
					<target>Processing pointer input</target>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208217)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When you work with pointer input, call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::UI::Core::CoreDispatcher::ProcessEvents</pc></pc> method to process window events.</source>
					<target>When you work with pointer input, call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::UI::Core::CoreDispatcher::ProcessEvents</pc></pc> method to process window events.</target>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>Call this method in your game loop before you update or render the scene.</source>
					<target>Call this method in your game loop before you update or render the scene.</target>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Marble Maze passes <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CoreProcessEventsOption::ProcessAllIfPresent</pc> to this method to process all queued events, and then immediately return.</source>
					<target>Marble Maze passes <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CoreProcessEventsOption::ProcessAllIfPresent</pc> to this method to process all queued events, and then immediately return.</target>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>After events are processed, Marble Maze renders and presents the next frame.</source>
					<target>After events are processed, Marble Maze renders and presents the next frame.</target>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>The Windows Runtime calls the registered handler for each event that occurred.</source>
					<target>The Windows Runtime calls the registered handler for each event that occurred.</target>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXApp</pc> class registers for events and forwards pointer information to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MarbleMaze</pc> class.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXApp</pc> class registers for events and forwards pointer information to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MarbleMaze</pc> class.</target>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze</pc> class reacts to pointer events by updating the map object that holds touch events.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze</pc> class reacts to pointer events by updating the map object that holds touch events.</target>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::AddTouch</pc> method is called when the pointer is first pressed, for example, when the user initially touches the screen on a touch-enabled device.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::AddTouch</pc> method is called when the pointer is first pressed, for example, when the user initially touches the screen on a touch-enabled device.</target>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::AddTouch</pc> method is called when the pointer position moves.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::AddTouch</pc> method is called when the pointer position moves.</target>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::RemoveTouch</pc> method is called when the pointer is released, for example, when the user stops touching the screen.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::RemoveTouch</pc> method is called when the pointer is released, for example, when the user stops touching the screen.</target>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>The PointToTouch function translates the current pointer position so that the origin is in the center of the screen, and then scales the coordinates so that they range approximately between -1.0 and +1.0.</source>
					<target>The PointToTouch function translates the current pointer position so that the origin is in the center of the screen, and then scales the coordinates so that they range approximately between -1.0 and +1.0.</target>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>This makes it easier to calculate the tilt of the maze in a consistent way across different input methods.</source>
					<target>This makes it easier to calculate the tilt of the maze in a consistent way across different input methods.</target>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method updates the combined input values by incrementing the tilt factor by a constant scaling value.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method updates the combined input values by incrementing the tilt factor by a constant scaling value.</target>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>This scaling value was determined by experimenting with several different values.</source>
					<target>This scaling value was determined by experimenting with several different values.</target>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>Processing accelerometer input</source>
					<target>Processing accelerometer input</target>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br225699)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>To process accelerometer input, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method calls the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Windows::Devices::Sensors::Accelerometer::GetCurrentReading</pc></pc> method.</source>
					<target>To process accelerometer input, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method calls the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Windows::Devices::Sensors::Accelerometer::GetCurrentReading</pc></pc> method.</target>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br225688)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This method returns a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::Devices::Sensors::AccelerometerReading</pc></pc> object, which represents an accelerometer reading.</source>
					<target>This method returns a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::Devices::Sensors::AccelerometerReading</pc></pc> object, which represents an accelerometer reading.</target>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows::Devices::Sensors::AccelerometerReading::AccelerationX</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::Devices::Sensors::AccelerometerReading::AccelerationY</pc> properties hold the g-force acceleration along the x and y axes, respectively.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows::Devices::Sensors::AccelerometerReading::AccelerationX</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::Devices::Sensors::AccelerometerReading::AccelerationY</pc> properties hold the g-force acceleration along the x and y axes, respectively.</target>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method polls the accelerometer and updates the combined input values.</source>
					<target>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method polls the accelerometer and updates the combined input values.</target>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>As you tilt the device, gravity causes the marble to move faster.</source>
					<target>As you tilt the device, gravity causes the marble to move faster.</target>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>Because you cannot be sure that an accelerometer is present on the user’s computer, always ensure that you have a valid Accelerometer object before you poll the accelerometer.</source>
					<target>Because you cannot be sure that an accelerometer is present on the user’s computer, always ensure that you have a valid Accelerometer object before you poll the accelerometer.</target>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>Processing Xbox 360 controller input</source>
					<target>Processing Xbox 360 controller input</target>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method reads from the Xbox 360 controller and updates the combined input values.</source>
					<target>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method reads from the Xbox 360 controller and updates the combined input values.</target>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method uses a for loop to enable input to be received from any connected controller.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method uses a for loop to enable input to be received from any connected controller.</target>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XInputGetState</pc> method fills an XINPUT\_STATE object with current state of the controller.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XInputGetState</pc> method fills an XINPUT\_STATE object with current state of the controller.</target>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">combinedTiltX</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">combinedTiltY</pc> values are updated according to the x and y values of the left thumbstick.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">combinedTiltX</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">combinedTiltY</pc> values are updated according to the x and y values of the left thumbstick.</target>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>XInput defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XINPUT\_GAMEPAD\_LEFT\_THUMB\_DEADZONE</pc> constant for the left thumbstick.</source>
					<target>XInput defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XINPUT\_GAMEPAD\_LEFT\_THUMB\_DEADZONE</pc> constant for the left thumbstick.</target>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<segment state="initial">
					<source>This is an appropriate dead zone threshold for most games.</source>
					<target>This is an appropriate dead zone threshold for most games.</target>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>  When you work with the Xbox 360 controller, always account for the dead zone.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>  When you work with the Xbox 360 controller, always account for the dead zone.</target>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>The dead zone refers to the variance among gamepads in their sensitivity to initial movement.</source>
					<target>The dead zone refers to the variance among gamepads in their sensitivity to initial movement.</target>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>In some controllers, a small movement may generate no reading, but in others it may generate a measurable reading.</source>
					<target>In some controllers, a small movement may generate no reading, but in others it may generate a measurable reading.</target>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>To account for this in your game, create a zone of non-movement for initial thumbstick movement.</source>
					<target>To account for this in your game, create a zone of non-movement for initial thumbstick movement.</target>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ee417001)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about the dead zone, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Getting Started With XInput.</pc></source>
					<target>For more information about the dead zone, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Getting Started With XInput.</pc></target>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>Applying input to the game state</source>
					<target>Applying input to the game state</target>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>Devices report input values in different ways.</source>
					<target>Devices report input values in different ways.</target>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<segment state="initial">
					<source>For example, pointer input might be in screen coordinates, and controller input might be in a completely different format.</source>
					<target>For example, pointer input might be in screen coordinates, and controller input might be in a completely different format.</target>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>One challenge with combining input from multiple devices into one set of input values is normalization, or converting values to a common format.</source>
					<target>One challenge with combining input from multiple devices into one set of input values is normalization, or converting values to a common format.</target>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>Marble Maze normalizes values by scaling them to the range \[-1.0, 1.0\].</source>
					<target>Marble Maze normalizes values by scaling them to the range \[-1.0, 1.0\].</target>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>To normalize Xbox 360 controller input, Marble Maze divides the input values by 32768 because thumbstick input values always fall between -32768 and 32767.</source>
					<target>To normalize Xbox 360 controller input, Marble Maze divides the input values by 32768 because thumbstick input values always fall between -32768 and 32767.</target>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PointToTouch</pc> function, which is previously described in this section, achieves a similar result by converting screen coordinates to normalized values that range approximately between -1.0 and +1.0.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PointToTouch</pc> function, which is previously described in this section, achieves a similar result by converting screen coordinates to normalized values that range approximately between -1.0 and +1.0.</target>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc>  Even if your application uses one input method, we recommend that you always normalize input values.</source>
					<target><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc>  Even if your application uses one input method, we recommend that you always normalize input values.</target>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>Doing so can simplify how input is interpreted by other components of your game, such as physics simulation, and makes it easier to write games that work on different screen resolutions.</source>
					<target>Doing so can simplify how input is interpreted by other components of your game, such as physics simulation, and makes it easier to write games that work on different screen resolutions.</target>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>After the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method processes input, it creates a vector that represents the effect of the tilt of the maze on the marble.</source>
					<target>After the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method processes input, it creates a vector that represents the effect of the tilt of the maze on the marble.</target>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how Marble Maze uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XMVector3Normalize</pc> function to create a normalized gravity vector.</source>
					<target>The following example shows how Marble Maze uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XMVector3Normalize</pc> function to create a normalized gravity vector.</target>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MaxTilt</pc> variable constrains the amount by which the maze tilts and prevents the maze from tilting on its side.</source>
					<target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MaxTilt</pc> variable constrains the amount by which the maze tilts and prevents the maze from tilting on its side.</target>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>To complete the update of scene objects, Marble Maze passes the updated gravity vector to the physics simulation, updates the physics simulation for the time that has elapsed since the previous frame, and updates the position and orientation of the marble.</source>
					<target>To complete the update of scene objects, Marble Maze passes the updated gravity vector to the physics simulation, updates the physics simulation for the time that has elapsed since the previous frame, and updates the position and orientation of the marble.</target>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If the marble has fallen through the maze, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method places the marble back at the last checkpoint that the marble touched and resets the state of the physics simulation.</source>
					<target>If the marble has fallen through the maze, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method places the marble back at the last checkpoint that the marble touched and resets the state of the physics simulation.</target>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<segment state="initial">
					<source>This section does not describe how the physics simulation works.</source>
					<target>This section does not describe how the physics simulation works.</target>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>For details about that, see Physics.h and Physics.cpp in the Marble Maze sources.</source>
					<target>For details about that, see Physics.h and Physics.cpp in the Marble Maze sources.</target>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>Next steps</source>
					<target>Next steps</target>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](adding-audio-to-the-marble-maze-sample.md)</data>
				</originalData>
				<segment state="initial">
					<source>Read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Adding audio to the Marble Maze sample</pc> for information about some of the key practices to keep in mind when you work with audio.</source>
					<target>Read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Adding audio to the Marble Maze sample</pc> for information about some of the key practices to keep in mind when you work with audio.</target>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>The document discusses how Marble Maze uses Microsoft Media Foundation and XAudio2 to load, mix, and play audio resources.</source>
					<target>The document discusses how Marble Maze uses Microsoft Media Foundation and XAudio2 to load, mix, and play audio resources.</target>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
					<target>Related topics</target>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>Adding audio to the Marble Maze sample</source>
					<target>Adding audio to the Marble Maze sample</target>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>Adding visual content to the Marble Maze sample</source>
					<target>Adding visual content to the Marble Maze sample</target>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>Developing Marble Maze, a UWP game in C++ and DirectX</source>
					<target>Developing Marble Maze, a UWP game in C++ and DirectX</target>
				</segment>
			</unit>
		</group>
	</file>
</xliff>