<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">7e60d43a9d5322b26ea59994de9cf9f528bcd2a0</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\tutorial--building-the-games-metro-style-app-framework.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">198f8fe405541658915faad3900f112aa8fe9d62</mda:meta><mda:meta type="olxliffhash">acd003d60a98622517a85e0a3e82491c94ccdd3a</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Define the game's Universal Windows Platform (UWP) app framework</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>The first part of coding a Universal Windows Platform (UWP) with DirectX game is building the framework that lets the game object interact with Windows.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Define the game's Universal Windows Platform (UWP) app framework</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>The first part of coding a Universal Windows Platform (UWP) with DirectX game is building the framework that lets the game object interact with Windows.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>This includes Windows Runtime properties like suspend/resume event handling, window focus, and snapping, plus as the events, interactions and transitions for the user interface.</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>We go over how the sample game is structured, and how it defines the high-level state machine for the player and system interaction.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Objective</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>To set up the framework for a UWP DirectX game, and implement the state machine that defines the overall game flow.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>Initializing and starting the view provider</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>In any UWP DirectX game, you must obtain a view provider that the app singleton, the Windows Runtime object that defines an instance of your running app, can use to access the graphics resources it needs.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Through the Windows Runtime, your app has a direct connection with the graphics interface, but you need to specify the resources you need and how to handle them.</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--setting-up-the-games-infrastructure.md)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>As we discussed in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Setting up the game project</pc>, Microsoft Visual Studio 2015 provides an implementation of a basic renderer for DirectX in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Sample3DSceneRenderer.cpp</pc> file that is available when you pick the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DirectX 11 App (Universal Windows)</pc> template.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh465077)</data>
				</originalData>
				<segment state="initial">
					<source>For more details about understanding and creating a view provider and renderer, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">How to set up your UWP with C++ and DirectX to display a DirectX view</pc>.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Suffice to say, you must provide the implementation for 5 methods that the app singleton calls:</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Initialize</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>SetWindow</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>Load</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Run</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>Uninitialize</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](#code_sample)</data>
				</originalData>
				<segment state="initial">
					<source>In the DirectX11 App (Universal Windows) template, these 5 methods are defined on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">App</pc> object in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">App.h</pc>.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>Let's take a look at the way they are implemented in this game.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>The Initialize method of the view provider</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The app singleton first calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Initialize</pc>.</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Therefore, it is crucial that this method handles the most fundamental behaviors of a UWP game, such as handling the activation of the main window and making sure that the game can handle a sudden suspend (and a possible later resume) event.</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>When the game app is initialized, it allocates specific memory for the controller to allow the player to begin providing input.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>It also creates new, uninitialized instances of the game's renderer and state machine.</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--defining-the-main-game-loop.md)</data>
				</originalData>
				<segment state="initial">
					<source>We discuss the details in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Defining the main game object</pc>.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>At this point, the game app can handle a suspend (or resume) message, and has memory allocated for the controller, the renderer, and the game itself.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>But there's no window to work with, and the game is uninitialized.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>There's a few more things that need to happen!</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>The SetWindow method of the view provider</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh700509)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208225)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Now, with a call to an implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetWindow</pc></pc>, the app singleton provides a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CoreWindow</pc></pc> object that represents the game's main window, and makes its resources and events available to the game.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>Because there's a window to work with, the game can now start adding in the basic user interface components and events: a pointer (used by both mouse and touch controls), and the basic events for window resizing, closing, and DPI changes (if the display device changes).</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>The game app also initializes the controller, because there's a window to interact with, and initializes the game object itself.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>It can read input from the controller (touch, mouse, or XBox 360 controller).</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>After the controller is initialized, the app defines two rectangular areas in the lower-left and lower-right corners of the screen for the move and camera touch controls, respectively.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The player uses the lower-left rectangle, defined by the call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetMoveRect</pc>, as a virtual control pad for moving the camera forward and backward, and side to side.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The lower-right rectangle, defined by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetFireRect</pc> method, is used as a virtual button to fire the ammo.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>It's all starting to come together.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>The Load method of the view provider</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>After the main window is set, the app singleton calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Load</pc>.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/dd492418.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>In the sample, this method uses a set of asynchronous tasks (the syntax for which is defined in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Parallel Patterns Library</pc>) to create the game objects, load graphics resources, and initialize the game’s state machine.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>By using the async task pattern, the Load method completes quickly and allows the app to start processing input.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>In this method, the app also displays a progress bar as the resource files load.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>We break resource loading into two separate stages, because access to the Direct3D 11 device context is restricted to the thread the device context was created on, while access to the Direct3D 11 device for object creation is free-threaded.</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateGameDeviceResourcesAsync</pc> task runs on a separate thread from the completion task (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">FinalizeCreateGameDeviceResources</pc>), which runs on the original thread.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>We use a similar pattern for loading level resources with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">LoadLevelAsync</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">FinalizeLoadLevel</pc>.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>After we create the game’s objects and load the graphics resources, we initialize the game's state machine to the starting conditions (for example: setting the initial ammo count, level number, and object positions).</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>If the game state indicates that the player is resuming a game, we load the current level (the level that player was on when the game was suspended).</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Load</pc> method, we do any necessary preparations before the game begins, like setting any starting states or global values.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you want to pre-fetch game data or assets, this is a better place for it rather than in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetWindow</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Initialize</pc>.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Use async tasks in your game for any loading as Windows imposes restrictions on the time your game can take before it must start processing input.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>If loading takes awhile—if there are lots of resources — then provide your users with a regularly updated progress bar.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>When developing your own game, design your startup code around these methods.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>Here's a simple list of basic suggestions for each method:</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Initialize</pc> to allocate your main classes and connect up the basic event handlers.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetWindow</pc> to create your main window and connect any window-specific events.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Load</pc> to handle any remaining setup, and to initiate the async creation of objects and loading of resources.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>If you need to create any temporary files or data, such as procedurally generated assets, do it here too.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>So, the sample game creates an instance of the game's state machine and sets it to the starting configuration.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>It handles all the system and input events.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>It provides a window to display content in.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>The gameplay code is now ready to run.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>The Run method of the view provider</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Here's where we get to the play part of the game app.</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Having run the 3 methods and set the stage, the game app runs the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Run</pc> method, starting the fun!</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>In the game sample, we start a while loop that terminates when the player closes the game window.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>The sample code transitions to one of two states in the game engine state machine:</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>The game window gets deactivated (loses focus) or snapped.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>When this happens, the game suspends event processing and waits for the window to focus or unsnap.</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>Otherwise, the game updates its own state and renders the graphics for display.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208215)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>When your game has focus, you must handle every event in the message queue as it arrives, and so you must call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindowDispatch.ProcessEvents</pc></pc> with the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ProcessAllIfPresent</pc> option.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>Other options can cause delays in processing message events, which makes your game feel unresponsive, or result in touch behaviors that feel sluggish and not "sticky".</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Of course, when the app is not visible, suspended or snapped, we don't want it to consume any resources cycling to dispatch messages that will never arrive.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>So your game must use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ProcessOneAndAllPending</pc>, which blocks until it gets an event, and then processes that event and any others that arrive in the process queue during the processing of the first.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208215)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ProcessEvents</pc></pc> then immediately returns after the queue has been processed.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>The game is running!</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>The events that it uses to transition between game states are being dispatched and processed.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>The graphics are being updated as the game loop cycles.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>We hope the player is having fun.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>But eventually, the fun has to end...</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>...and we need to clean up the place.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This is where <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Uninitialize</pc> comes in.</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>The Uninitialize method of the view provider</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>In the game sample, we let the app singleton for the game clean everything up after the game is terminated.</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>In Windows 10, closing the app window doesn't kill the app's process, but instead writes the state of the app singleton to memory.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>If anything special must happen when the system must reclaim this memory, any special cleanup of resources, then put the code for that cleanup in this method.</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>We refer back to these 5 methods in this tutorial, so keep them in mind.</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>Now, let's look at the game engine's overall structure and the state machines that define it.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>Initializing the game engine state</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>Because a user can resume a UWP game app from a suspended state at any time, the app can have any number of possible states.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>The game sample can be in one of the three states when it starts:</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>The game loop was running and was in the middle of a level.</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>The game loop was not running because a game had just been completed.</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>(The high score is set.)</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>No game has been started, or the game was between levels.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>(The high score is 0.)</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>Obviously, in your own game, you could have more or fewer states.</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>Again, always be aware that your UWP game can be terminated at any time, and when it resumes, the player expects the game to behave as though they had never stopped playing.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>In the game sample, the code flow looks like this.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>Initialization is less about cold starting the app, and more about restarting the app after it has been terminated.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>The sample game always saves state, which gives the appearance that the app is always running.</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>The suspended state is just that: the game play is suspended, but the resources of the game are still in memory.</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>Likewise, the resume event indicates that the sample game is picking up where it was last suspended or terminated.</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>When the sample game restarts after termination, it starts up normally and then determines the last known state so the player can immediately continue playing.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>The flowchart lays out the initial states and transitions for the game sample's initialization process.</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>the process for initializing and preparing our game before the main loop starts</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>Depending on the state, different options are presented to the player.</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>If the game resumes mid-level, it appears as paused, and the overlay presents a continue option.</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>If the game resumed in a state where the game is completed, it displays the high scores and an option to play a new game.</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>Lastly, if the game resumes before a level has started, the overlay presents a start option to the user.</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>The game sample doesn't distinguish between the game itself cold starting, that is a game that is launching for the first time without a suspend event, and the game resuming from a suspended state.</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>This is proper design for any UWP app.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<segment state="initial">
					<source>Handling events</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Our sample code registered a number of handlers for specific events in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Initialize</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetWindow</pc>, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Load</pc>.</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>You probably guessed that these were important events, because the code sample did this work well before it got into any game mechanics or graphics development.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>You're right!</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>These events are fundamental to a proper UWP app experience, and because a UWP app can be activated, deactivated, resized, snapped, unsnapped, suspended, or resumed at any time, the game must register for those very events as soon as it can, and handle them in a way that keeps the experience smooth and predictable for the player.</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<segment state="initial">
					<source>Here's the event handlers in the sample, and the events they handle.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#code_sample)</data>
				</originalData>
				<segment state="initial">
					<source>You can find the full code for these event handlers in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Complete code for this section</pc>.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>Event handler</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>Description</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>OnActivated</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>Handles [<ph dataRef="id1" id="ph1" />CoreApplicationView::Activated<ph dataRef="id2" id="ph2" />](https://msdn.microsoft.com/library/windows/apps/br225018).</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>The game app has been brought to the foreground, so the main window is activated.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>OnLogicalDpiChanged</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>Handles [<ph dataRef="id1" id="ph1" />DisplayProperties::LogicalDpiChanged<ph dataRef="id2" id="ph2" />](https://msdn.microsoft.com/library/windows/apps/br226150).</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>The DPI for the main game window has changed, and the game app adjusts its resources accordingly.</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<originalData>
					<data id="id1">&lt;/strong&gt;</data>
					<data id="id2">&lt;strong&gt;</data>
					<data id="id3">&lt;/strong&gt;</data>
					<data id="id4">[</data>
					<data id="id5">](https://msdn.microsoft.com/library/windows/desktop/dd370987)</data>
				</originalData>
				<segment state="initial">
					<source>Note<ph dataRef="id1" id="ph1" />  [<ph dataRef="id2" id="ph2" />CoreWindow<ph dataRef="id3" id="ph3" />](https://msdn.microsoft.com/library/windows/desktop/hh404559) coordinates are in DIPs (Device Independent Pixels), as in <pc dataRefEnd="id5" dataRefStart="id4" id="p1">Direct2D</pc>.</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>As a result, you must notify Direct2D of the change in DPI to display any 2D assets or primitives correctly.</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>OnResuming</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>Handles [<ph dataRef="id1" id="ph1" />CoreApplication::Resuming<ph dataRef="id2" id="ph2" />](https://msdn.microsoft.com/library/windows/apps/br205859).</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>The game app restores the game from a suspended state.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>OnSuspending</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>Handles [<ph dataRef="id1" id="ph1" />CoreApplication::Suspending<ph dataRef="id2" id="ph2" />](https://msdn.microsoft.com/library/windows/apps/br205860).</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>The game app saves its state to disk.</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>It has 5 seconds to save state to storage.</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<segment state="initial">
					<source>OnVisibilityChanged</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>Handles [<ph dataRef="id1" id="ph1" />CoreWindow::VisibilityChanged<ph dataRef="id2" id="ph2" />](https://msdn.microsoft.com/library/windows/apps/hh701591).</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>The game app has changed visibility, and has either become visible or been made invisible by another app becoming visible.</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>OnWindowActivationChanged</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>Handles [<ph dataRef="id1" id="ph1" />CoreWindow::Activated<ph dataRef="id2" id="ph2" />](https://msdn.microsoft.com/library/windows/apps/br208255).</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>The game app's main window has been deactivated or activated, so it must remove focus and pause the game, or regain focus.</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>In both cases, the overlay indicates that the game is paused.</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>OnWindowClosed</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>Handles [<ph dataRef="id1" id="ph1" />CoreWindow::Closed<ph dataRef="id2" id="ph2" />](https://msdn.microsoft.com/library/windows/apps/br208261).</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>The game app closes the main window and suspends the game.</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>OnWindowSizeChanged</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<originalData>
					<data id="id1">&lt;strong&gt;</data>
					<data id="id2">&lt;/strong&gt;</data>
				</originalData>
				<segment state="initial">
					<source>Handles [<ph dataRef="id1" id="ph1" />CoreWindow::SizeChanged<ph dataRef="id2" id="ph2" />](https://msdn.microsoft.com/library/windows/apps/br208283).</source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<segment state="initial">
					<source>The game app reallocates the graphics resources and overlay to accommodate the size change, and then updates the render target.</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>Your own game must handle these events, because they are part of UWP app design.</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<segment state="initial">
					<source>Updating the game engine</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Within the game loop in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Run</pc>, the sample has implemented a basic state machine for handling all the major actions the player can take.</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>The highest level of this state machine deals with loading a game, playing a specific level, or continuing a level after the game has been paused (by the system or the player).</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>In the game sample, there are 3 major states (UpdateEngineState) the game can be in:</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Waiting for resources</pc>.</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<segment state="initial">
					<source>The game loop is cycling, unable to transition until resources (specifically graphics resources) are available.</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When the async tasks for loading resources completes, it updates the state to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourcesLoaded</pc>.</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>This usually happens between levels when the level needs to load new resources from disk.</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<segment state="initial">
					<source>In the game sample, we simulate this behavior because the sample doesn't need any additional per-level resources at that time.</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Waiting for press</pc>.</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<segment state="initial">
					<source>The game loop is cycling, waiting for specific user input.</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<segment state="initial">
					<source>This input is a player action to load a game, start a level, or continue a level.</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>The sample code refers to these sub-states as PressResultState enumeration values.</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dynamics</pc>.</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>The game loop is running with the user playing.</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>While the user is playing, the game checks for 3 conditions that it can transition on: the expiration of the set time for a level, the completion of a level by the player, or the completion of all levels by the player.</source>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<segment state="initial">
					<source>Here's the code structure.</source>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#code_sample)</data>
				</originalData>
				<segment state="initial">
					<source>The complete code is in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Complete code for this section</pc>.</source>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<segment state="initial">
					<source>The structure of the state machine used to update the game engine</source>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>Visually, the main game state machine looks like this:</source>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<segment state="initial">
					<source>the main state machine for our game</source>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--defining-the-main-game-loop.md)</data>
				</originalData>
				<segment state="initial">
					<source>We talk about the game logic itself in more detail in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Defining the main game object</pc>.</source>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<segment state="initial">
					<source>For now, the important takeaway is that your game is a state machine.</source>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<segment state="initial">
					<source>Each specific state must have very specific criteria to define it, and the transitions from one state to another must be based on discrete user input or system actions (such as graphics resource loading).</source>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<segment state="initial">
					<source>When you are planning your game, draw out a diagram like the one we use, making sure you address all possible actions the user or system can take at a high level.</source>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>Games can be very complicated, and the state machine is a powerful tool to visualize this complexity and make it very manageable.</source>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<segment state="initial">
					<source>Of course, as you saw, there are state machines within state machines.</source>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>There's one for the controller, that handles all of the acceptable inputs the player can generate.</source>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<segment state="initial">
					<source>In the diagram, a press is some form of user input.</source>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<segment state="initial">
					<source>This state machine doesn't care what it is, because it works at a higher level; it assumes that the state machine for the controller will handle any transitions that affect movement and shooting behaviors, and the associated rendering updates.</source>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--adding-controls.md)</data>
				</originalData>
				<segment state="initial">
					<source>We talk about managing input states in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Adding controls</pc>.</source>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<segment state="initial">
					<source>Updating the user interface</source>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<segment state="initial">
					<source>We need to keep the player apprised of the state of the system, and allow him to change the high-level state according to the rules of the game.</source>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<segment state="initial">
					<source>For most games, this game sample included, this is done with a heads-up display that contains representations of game state, and other play-specific info such as score, or ammo, or the number of chances remaining.</source>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<segment state="initial">
					<source>We call this the overlay, because it is rendered separate from the main graphics pipeline and placed on top the 3D projection.</source>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<segment state="initial">
					<source>In the sample game, we create this overlay using the Direct2D APIs.</source>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial-resources.md)</data>
				</originalData>
				<segment state="initial">
					<source>We can also create this overlay using XAML, which we discuss in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Extending the game sample</pc>.</source>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<segment state="initial">
					<source>There are two components to the user interface:</source>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<segment state="initial">
					<source>The heads-up display that contains the score and info about the current state of game play.</source>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<segment state="initial">
					<source>The pause bitmap, which is a black rectangle with text overlaid during the paused/suspended state of the game.</source>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<segment state="initial">
					<source>This is the game overlay.</source>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--adding-a-user-interface.md)</data>
				</originalData>
				<segment state="initial">
					<source>We discuss it further in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Adding a user interface</pc>.</source>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<segment state="initial">
					<source>Unsurprisingly, the overlay has a state machine too.</source>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<segment state="initial">
					<source>The overlay can display a level start or game over message.</source>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<segment state="initial">
					<source>It is essentially a canvas to output any info about game state that we display to the player when the game is paused or suspended.</source>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<segment state="initial">
					<source>Here's how the game sample structures the overlay's state machine.</source>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<segment state="initial">
					<source>There are 6 state screens that the overlay displays, depending on the state of the game itself: a resources loading screen at the start of the game, a game play screen, a level start message screen, a game over screen when all of the levels are competed without time running out, a game over screen when time runs out, and a pause menu screen.</source>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>Separating your user interface from your game's graphics pipeline allows you to work on it independent of the game's graphics rendering engine and decreases the complexity of your game's code significantly.</source>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<segment state="initial">
					<source>Next steps</source>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<segment state="initial">
					<source>This covers the basic structure of the game sample, and presents a good model for UWP game app development with DirectX.</source>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<segment state="initial">
					<source>Of course, there's more to it than this.</source>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<segment state="initial">
					<source>We only walked through the skeleton of the game.</source>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<segment state="initial">
					<source>Now, we take an in-depth look at the game and its mechanics, and how those mechanics are implemented as the core game object.</source>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--defining-the-main-game-loop.md)</data>
				</originalData>
				<segment state="initial">
					<source>We review that part in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Defining the main game object</pc>.</source>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<segment state="initial">
					<source>It's also time to consider the sample game's graphics engine in greater detail.</source>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--assembling-the-rendering-pipeline.md)</data>
				</originalData>
				<segment state="initial">
					<source>That part is covered in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Assembling the rendering pipeline</pc>.</source>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<segment state="initial">
					<source>Complete sample code for this section</source>
				</segment>
			</unit>
			<unit id="311" translate="yes">
				<segment state="initial">
					<source>App.h</source>
				</segment>
			</unit>
			<unit id="312" translate="yes">
				<segment state="initial">
					<source>App.cpp</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>