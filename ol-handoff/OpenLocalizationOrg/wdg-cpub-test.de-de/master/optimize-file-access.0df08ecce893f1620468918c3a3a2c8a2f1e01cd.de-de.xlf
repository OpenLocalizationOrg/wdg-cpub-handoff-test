<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">8753f4bcff9dc358f14351c8110176352a22f793</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci1\debug-test-perf\optimize-file-access.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">7bf844e270afda374e2df279eb259112ca21a6f5</mda:meta><mda:meta type="olxliffhash">a2534b3c2584e696a8bd4a1e50faa9c3f8b0b82c</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Optimize file access</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Create Universal Windows Platform (UWP) apps that access the file system efficiently, avoiding performance issues due to disk latency and memory/CPU cycles.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Optimize file access</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Create Universal Windows Platform (UWP) apps that access the file system efficiently, avoiding performance issues due to disk latency and memory/CPU cycles.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR207995)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR207995-setpropertyprefetch)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>When you want to access a large collection of files and you want to access property values other than the typical Name, FileType, and Path properties, access them by creating <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">QueryOptions</pc></pc> and calling <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetPropertyPrefetch</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetPropertyPrefetch</pc> method can dramatically improve the performance of apps that display a collection of items obtained from the file system, such as a collection of images.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>The next set of examples shows a few ways to access multiple files.</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227273)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The first example uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.Storage.StorageFolder.GetFilesAsync</pc></pc> to retrieve the name info for a set of files.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>This approach provides good performance, because the example accesses only the name property.</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227273)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The second example uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.Storage.StorageFolder.GetFilesAsync</pc></pc> and then retrieves the image properties for each file.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>This approach provides poor performance.</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR207995)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The third example uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">QueryOptions</pc></pc> to get info about a set of files.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>This approach provides much better performance than the previous example.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<originalData>
					<data id="id1">`Windows.Storage.ApplicationData.Current.LocalFolder`</data>
				</originalData>
				<segment state="initial">
					<source>If you're performing multiple operations on Windows.Storage objects such as <ph dataRef="id1" id="ph1" />, create a local variable to reference that storage source so that you don't recreate intermediate objects each time you access it.</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Stream performance in C# and Visual Basic</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Buffering between UWP and .NET streams</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR241718)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR241728)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.aspx)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>There are many scenarios when you might want to convert a UWP stream (such as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.Storage.Streams.IInputStream</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IOutputStream</pc></pc>) to a .NET stream (<pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">System.IO.Stream</pc></pc>).</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>For example, this is useful when you are writing a UWP app and want to use existing .NET code that works on streams with the UWP file system.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>In order to enable this, .NET APIs for Windows Store apps provides extension methods that allow you to convert between .NET and UWP stream types.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.windowsruntimestreamextensions.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">WindowsRuntimeStreamExtensions</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>When you convert a UWP stream to a .NET stream, you effectively create an adapter for the underlying UWP stream.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Under some circumstances, there is a runtime cost associated with invoking methods on UWP streams.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>This may affect the speed of your app, especially in scenarios where you perform many small, frequent read or write operations.</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>In order to speed up apps, the UWP stream adapters contain a data buffer.</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>The following code sample demonstrates small consecutive reads using a UWP stream adapter with a default buffer size.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>This default buffering behavior is desirable in most scenarios where you convert a UWP stream to a .NET stream.</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>However, in some scenarios you may want to tweak the buffering behavior in order to increase performance.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>Working with large data sets</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStream)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>When reading or writing larger sets of data you may be able to increase your read or write throughput by providing a large buffer size to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AsStreamForRead</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">AsStreamForWrite</pc></pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">AsStream</pc></pc> extension methods.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>This gives the stream adapter a larger internal buffer size.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>For instance, when passing a stream that comes from a large file to an XML parser, the parser can make many sequential small reads from the stream.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>A large buffer can reduce the number of calls to the underlying UWP stream and boost performance.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](improve-garbage-collection-performance.md)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   You should be careful when setting a buffer size that is larger than approximately 80 KB, as this may cause fragmentation on the garbage collector heap (see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Improve garbage collection performance</pc>).</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>The following code example creates a managed stream adapter with an 81,920 byte buffer.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.copyto.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.copytoasync.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Stream.CopyTo</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CopyToAsync</pc></pc> methods also allocate a local buffer for copying between streams.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.windowsruntimestreamextensions.asstreamforread.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>As with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AsStreamForRead</pc></pc> extension method, you may be able to get better performance for large stream copies by overriding the default buffer size.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The following code example demonstrates changing the default buffer size of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CopyToAsync</pc> call.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>This example uses a buffer size of 1 MB, which is greater than the 80 KB previously recommended.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Using such a large buffer can improve throughput of the copy operation for very large data sets (that is, several hundred megabytes).</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>However, this buffer is allocated on the large object heap and could potentially degrade garbage collection performance.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>You should only use large buffer sizes if it will noticeably improve the performance of your app.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>When you are working with a large number of streams simultaneously, you might want to reduce or eliminate the memory overhead of the buffer.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>You can specify a smaller buffer, or set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">bufferSize</pc> parameter to 0 to turn off buffering entirely for that stream adapter.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>You can still achieve good throughput performance without buffering if you perform large reads and writes to the managed stream.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Performing latency-sensitive operations</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>You might also want to avoid buffering if you want low-latency reads and writes and do not want to read in large blocks out of the underlying UWP stream.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>For example, you might want low-latency reads and writes if you are using the stream for network communications.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>In a chat app you might use a stream over a network interface to send messages back in forth.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>In this case you want to send messages as soon as they are ready and not wait for the buffer to fill up.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStream)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>If you set the buffer size to 0 when calling the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AsStreamForRead</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">AsStreamForWrite</pc></pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">AsStream</pc></pc> extension methods, then the resulting adapter will not allocate a buffer, and all calls will manipulate the underlying UWP stream directly.</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>