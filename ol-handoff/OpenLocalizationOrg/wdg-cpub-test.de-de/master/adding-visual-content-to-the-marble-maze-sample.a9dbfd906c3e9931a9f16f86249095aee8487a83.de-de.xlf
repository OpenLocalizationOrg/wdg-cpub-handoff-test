<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">edd8e5ecff66111f51de2dbf29e6464cdfee2a82</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\adding-visual-content-to-the-marble-maze-sample.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">11a127120ed2862e3545f31d8e7939cb46d60be0</mda:meta><mda:meta type="olxliffhash">752ec534c2f520b8039ccb962a0f85aa6f4db088</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Adding visual content to the Marble Maze sample</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>This document describes how the Marble Maze game uses Direct3D and Direct2D in the Universal Windows Platform (UWP) app environment so that you can learn the patterns and adapt them when you work with your own game content.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Adding visual content to the Marble Maze sample</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>This document describes how the Marble Maze game uses Direct3D and Direct2D in the Universal Windows Platform (UWP) app environment so that you can learn the patterns and adapt them when you work with your own game content.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](marble-maze-application-structure.md)</data>
				</originalData>
				<segment state="initial">
					<source>To learn how visual game components fit in the overall application structure of Marble Maze, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Marble Maze application structure</pc>.</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>We followed these basic steps as we developed the visual aspects of Marble Maze:</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Create a basic framework that initializes the Direct3D and Direct2D environments.</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>Use image and model editing programs to design the 2-D and 3-D assets that appear in the game.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>Ensure that 2-D and 3-D assets properly load and appear in the game.</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>Integrate vertex and pixel shaders that enhance the visual quality of the game assets.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Integrate game logic, such as animation and user input.</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>We also focused first on adding 3-D assets and then on 2-D assets.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>For example, we focused on core game logic before we added the menu system and timer.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>We also needed to iterate through some of these steps multiple times during the development process.</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>For example, as we make changes to the mesh and marble models, we had to also change some of the shader code that supports those models.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](http://go.microsoft.com/fwlink/?LinkId=624011)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The sample code that corresponds to this document is found in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectX Marble Maze game sample</pc>.</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>Here are some of the key points that this document discusses for when you work with DirectX and visual game content, namely, when you initialize the DirectX graphics libraries, load scene resources, and update and render the scene:</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Adding game content typically involves many steps.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>These steps also often require iteration.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>Game developers often focus first on adding 3-D game content and then on adding 2-D content.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>Reach more customers and give them all a great experience by supporting the greatest range of graphics hardware as possible.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Cleanly separate design-time and run-time formats.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Structure your design-time assets to maximize flexibility and enable rapid iterations on content.</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Format and compress your assets to load and render as efficiently as possible at run time.</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>You create the Direct3D and Direct2D devices in a UWP app much like you do in a classic Windows desktop app.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>One important difference is how the swap chain is associated with the output window.</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>When you design your game, ensure that the mesh format that you choose supports your key scenarios.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>For example, if your game requires collision, make sure that you can obtain collision data from your meshes.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Separate game logic from rendering logic by first updating all scene objects before you render them.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>You typically draw your 3-D scene objects, and then any 2-D objects that appear in front of the scene.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Synchronize drawing to the vertical blank to ensure that your game does not spend time drawing frames that will never be actually shown on the display.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Getting started with DirectX graphics</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>When we planned the Marble Maze Universal Windows Platform (UWP) game, we chose C++ and Direct3D 11.1 because they are the best choices for creating 3-D games that require maximum control over rendering and high performance.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>DirectX 11.1 supports hardware from DirectX 9 to DirectX 11, and therefore can help you reach more customers more efficiently because you don't have to rewrite code for each of the earlier DirectX versions.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Marble Maze uses Direct3D 11.1 to render the 3-D game assets, namely the marble and the maze.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Marble Maze also uses Direct2D, DirectWrite, and Windows Imaging Component (WIC) to draw the 2-D game assets, such as the menus and the timer.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>Finally, Marble Maze uses XAML to provide an app bar and allows you to add XAML controls.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Game development requires planning.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>If you are new to DirectX graphics, we recommend that you read Creating a DirectX game to familiarize yourself with the basic concepts of creating a UWP DirectX game.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>As you read this document and work through the Marble Maze source code, you can refer to the following resources for more in-depth information about DirectX graphics.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476080)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Direct3D 11 Graphics</pc> Describes Direct3D 11, a powerful, hardware-accelerated 3-D graphics API for rendering 3-D geometry on the Windows platform.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/dd370990)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Direct2D</pc> Describes Direct2D, a hardware-accelerated, 2-D graphics API that provides high performance and high-quality rendering for 2-D geometry, bitmaps, and text.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/dd368038)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectWrite</pc> Describes DirectWrite, which supports high-quality text rendering.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ee719902)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows Imaging Component</pc> Describes WIC, an extensible platform that provides low-level API for digital images.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Feature levels</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Direct3D 11 introduces a paradigm named feature levels.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>A feature level is a well-defined set of GPU functionality.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>Use feature levels to target your game to run on earlier versions of Direct3D hardware.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Marble Maze supports feature level 9.1 because it requires no advanced features from the higher levels.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>We recommend that you support the greatest range of hardware possible and scale your game content so that your customers that have either high or low-end computers all have a great experience.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476872)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about feature levels, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Direct3D 11 on Downlevel Hardware</pc>.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Initializing Direct3D and Direct2D</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>A device represents the display adapter.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>You create the Direct3D and Direct2D devices in a UWP app much like you do in a classic Windows desktop app.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>The main difference is how you connect the Direct3D swap chain to the windowing system.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectX 11 and XAML App (Universal Windows)</pc> factors out some generic operating system and 3-D rendering functions from the game-specific functions.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeviceResources</pc> class is a foundation for managing Direct3D and Direct2D.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>This class handles general infrastructure, and not game-specific assets.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Marble Maze defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze</pc> class to handle game-specific assets, which has a reference to a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DeviceResources</pc> object to give it access to Direct3D and Direct2D.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>During initialization, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeviceResources::Initialize</pc> method creates device-independent resources and the Direct3D and Direct2D devices.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeviceResources</pc> class separates this functionality so that it can more easily respond when the environment changes.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, it calls the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateWindowSizeDependentResources</pc> method when the window size changes.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>Initializing the Direct2D, DirectWrite, and WIC factories</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeviceResources::CreateDeviceIndependentResources</pc> method creates the factories for Direct2D, DirectWrite, and WIC.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>In DirectX graphics, factories are the starting points for creating graphics resources.</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Marble Maze specifies <pc dataRefEnd="id2" dataRefStart="id1" id="p1">D2D1\_FACTORY\_TYPE\_SINGLE\_THREADED</pc> because it performs all drawing on the main thread.</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>Creating the Direct3D and Direct2D devices</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeviceResources::CreateDeviceResources</pc> method calls <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">D3D11CreateDevice</pc></pc> to create the device object that represents the Direct3D display adapter.</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">\\</data>
				</originalData>
				<segment state="initial">
					<source>Because Marble Maze supports feature level 9.1 and above, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeviceResources::CreateDeviceResources</pc> method specifies levels 9.1 through 11.1 in the array of <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><ph dataRef="id5" id="ph1" /></pc> values.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>Direct3D walks the list in order and gives the app the first feature level that is available.</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Therefore the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">D3D\_FEATURE\_LEVEL</pc> array entries are listed from highest to lowest so that the app will get the highest level feature level available.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeviceResources::CreateDeviceResources</pc> method obtains the Direct3D 11.1 device by querying the Direct3D 11 device that's returned from <pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11CreateDevice</pc>.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeviceResources::CreateDeviceResources</pc> method then creates the Direct2D device.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Direct2D uses Microsoft DirectX Graphics Infrastructure (DXGI) to interoperate with Direct3D.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>DXGI enables video memory surfaces to be shared between graphics runtimes.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>Marble Maze uses the underlying DXGI device from the Direct3D device to create the Direct2D device from the Direct2D factory.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb205075)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/dd370966)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about DXGI and interoperability between Direct2D and Direct3D, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DXGI Overview</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Direct2D and Direct3D Interoperability Overview</pc>.</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>Associating Direct3D with the view</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeviceResources::CreateWindowSizeDependentResources</pc> method creates the graphics resources that depend on a given window size such as the swap chain and Direct3D and Direct2D render targets.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>One important way that a DirectX UWP app differs from a desktop app is how the swap chain is associated with the output window.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>A swap chain is responsible for displaying the buffer to which the device renders on the monitor.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>The document Marble Maze application structure describes how the windowing system for a UWP app differs from a desktop app.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/hh404559)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Because a Windows Store app does not work with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HWND</pc> objects, Marble Maze must use the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IDXGIFactory2::CreateSwapChainForCoreWindow</pc></pc> method to associate the device output to the view.</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows the part of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeviceResources::CreateWindowSizeDependentResources</pc> method that creates the swap chain.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff471334)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>To minimize power consumption, which is important to do on battery-powered devices such as laptops and tablets, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeviceResources::CreateWindowSizeDependentResources</pc> method calls the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IDXGIDevice1::SetMaximumFrameLatency</pc></pc> method to ensure that the game is rendered only after the vertical blank.</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Synchronizing with the vertical blank is described in greater detail in the section Presenting the scene in this document.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeviceResources::CreateWindowSizeDependentResources</pc> method initializes graphics resources in a way that works for most games.</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The term <pc dataRefEnd="id4" dataRefStart="id3" id="p2">view</pc> has a different meaning in the Windows Runtime than it has in Direct3D.</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>In the Windows Runtime, a view refers to the collection of user interface settings for an app, including the display area and the input behaviors, plus the thread it uses for processing.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>You specify the configuration and settings you need when you create a view.</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](marble-maze-application-structure.md)</data>
				</originalData>
				<segment state="initial">
					<source>The process of setting up the app view is described in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Marble Maze application structure</pc>.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>In Direct3D, the term view has multiple meanings.</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>First, a resource view defines the subresources that a resource can access.</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>For example, when a texture object is associated with a shader resource view, that shader can later access the texture.</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>One advantage of a resource view is that you can interpret data in different ways at different stages in the rendering pipeline.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb205128)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about resource views, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Texture Views (Direct3D 10)</pc>.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>When used in the context of a view transform or view transform matrix, view refers to the location and orientation of the camera.</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>A view transform relocates objects in the world around the camera’s position and orientation.</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb206342)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about view transforms, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">View Transform (Direct3D 9)</pc>.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>How Marble Maze uses resource and matrix views is described in greater detail in this topic.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>Loading scene resources</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Marble Maze uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicLoader</pc> class, which is declared in BasicLoader.h, to load textures and shaders.</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Marble Maze uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SDKMesh</pc> class to load the 3-D meshes for the maze and the marble.</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>To ensure a responsive app, Marble Maze loads scene resources asynchronously, or in the background.</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>As assets load in the background, your game can respond to window events.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](marble-maze-application-structure.md#loading_game_assets)</data>
				</originalData>
				<segment state="initial">
					<source>This process is explained in greater detail in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Loading game assets in the background</pc> in this guide.</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>Loading the 2-D overlay and user interface</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>In Marble Maze, the overlay is the image that appears at the top of the screen.</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>The overlay always appears in front of the scene.</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>In Marble Maze, the overlay contains the Windows logo and the text string "DirectX Marble Maze game sample".</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The management of the overlay is performed by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SampleOverlay</pc> class, which is defined in SampleOverlay.h.</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>Although we use the overlay as part of the Direct3D samples, you can adapt this code to display any image that appears in front of your scene.</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/hh404349)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>One important aspect of the overlay is that, because its contents do not change, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SampleOverlay</pc> class draws, or caches, its contents to an <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID2D1Bitmap1</pc></pc> object during initialization.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>At draw time, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SampleOverlay</pc> class only has to draw the bitmap to the screen.</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>In this way, expensive routines such as text drawing do not have to be performed for every frame.</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>The user interface (UI) consists of 2-D components, such as menus and heads-up displays (HUDs), which appear in front of your scene.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>Marble Maze defines the following UI elements:</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>Menu items that enable the user to start the game or view high scores.</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<segment state="initial">
					<source>A timer that counts down for three seconds before play begins.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<segment state="initial">
					<source>A timer that tracks the elapsed play time.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>A table that lists the fastest finish times.</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>Text that reads "Paused" when the game is paused.</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>Marble Maze defines game-specific UI elements in UserInterface.h.</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Marble Maze defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ElementBase</pc> class as a base type for all UI elements.</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ElementBase</pc> class defines attributes such as the size, position, alignment, and visibility of a UI element.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>It also controls how elements are updated and rendered.</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>By providing a common base class for UI elements, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UserInterface</pc> class, which manages the user interface, need only hold a collection of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ElementBase</pc> objects, which simplifies UI management and provides a user interface manager that is reusable.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Marble Maze defines types that derive from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ElementBase</pc> that implement game-specific behaviors.</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HighScoreTable</pc> defines the behavior for the high score table.</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>For more info about these types, refer to the source code.</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   Because XAML enables you to more easily create complex user interfaces, like those found in simulation and strategy games, consider whether to use XAML to define your UI.</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial-resources.md)</data>
				</originalData>
				<segment state="initial">
					<source>For info about how to develop a user interface in XAML in a DirectX UWP game, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Extend the game sample (Windows)</pc>.</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>This document refers to the DirectX 3-D shooting game sample.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>Loading shaders</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Marble Maze uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicLoader::LoadShader</pc> method to load a shader from a file.</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>Shaders are the fundamental unit of GPU programming in games today.</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>Nearly all 3-D graphics processing is driven through shaders, whether it is model transformation and scene lighting, or more complex geometry processing, from character skinning to tessellation.</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509561)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about the shader programming model, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HLSL</pc>.</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<segment state="initial">
					<source>Marble Maze uses vertex and pixel shaders.</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>A vertex shader always operates on one input vertex and produces one vertex as output.</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>A pixel shader takes numeric values, texture data, interpolated per-vertex values, and other data to produce a pixel color as output.</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<segment state="initial">
					<source>Because a shader transforms one element at a time, graphics hardware that provides multiple shader pipelines can process sets of elements in parallel.</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>The number of parallel pipelines that are available to the GPU can be vastly greater than the number that is available to the CPU.</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>Therefore, even basic shaders can greatly improve throughput.</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::LoadDeferredResources</pc> method loads one vertex shader and one pixel shader after it loads the overlay.</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>The design-time versions of these shaders are defined in BasicVertexShader.hlsl and BasicPixelShader.hlsl, respectively.</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>Marble Maze applies these shaders to both the ball and the maze during the rendering phase.</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>The Marble Maze project includes both .hlsl (the design-time format) and .cso (the run-time format) versions of the shader files.</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>At build time, Visual Studio uses the fxc.exe effect-compiler to compile your .hlsl source file into a .cso binary shader.</source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb232919)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about the effect-compiler tool, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Effect-Compiler Tool</pc>.</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>The vertex shader uses the supplied model, view and projection matrices to transform the input geometry.</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<segment state="initial">
					<source>Position data from the input geometry is transformed and output twice: once in screen space, which is necessary for rendering, and again in world space to enable the pixel shader to perform lighting calculations.</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<segment state="initial">
					<source>The surface normal vector is transformed to world space, which is also used by the pixel shader for lighting.</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>The texture coordinates are passed through unchanged to the pixel shader.</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>The pixel shader receives the output of the vertex shader as input.</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>This shader performs lighting calculations to mimic a soft-edged spotlight that hovers over the maze and is aligned with the position of the marble.</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<segment state="initial">
					<source>Lighting is strongest for surfaces that point directly toward the light.</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<segment state="initial">
					<source>The diffuse component tapers off to zero as the surface normal becomes perpendicular to the light, and the ambient term diminishes as the normal points away from the light.</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>Points closer to the marble (and therefore closer to the center of the spotlight) are lit more strongly.</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<segment state="initial">
					<source>However, lighting is modulated for points underneath the marble to simulate a soft shadow.</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>In a real environment, an object like the white marble would diffusely reflect the spotlight onto other objects in the scene.</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<segment state="initial">
					<source>This is approximated for the surfaces that are in view of the bright half of the marble.</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<segment state="initial">
					<source>The additional illumination factors are in relative angle and distance to the marble.</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>The resulting pixel color is a composition of the sampled texture with the result of the lighting calculations.</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>  The compiled pixel shader contains 32 arithmetic instructions and 1 texture instruction.</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>This shader should perform well on desktop computers and higher-end tablets.</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>However, a lower-end computer might not be able to process this shader and still provide an interactive frame rate.</source>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<segment state="initial">
					<source>Consider the typical hardware of your target audience and design your shaders to meet the capabilities of that hardware.</source>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::LoadDeferredResources</pc> method uses the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">BasicLoader::LoadShader</pc> method to load the shaders.</source>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<segment state="initial">
					<source>The following example loads the vertex shader.</source>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>The run-time format for this shader is BasicVertexShader.cso.</source>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff476641)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_vertexShader</pc> member variable is an <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID3D11VertexShader</pc></pc> object.</source>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff476575)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_inputLayout</pc> member variable is an <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID3D11InputLayout</pc></pc> object.</source>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<segment state="initial">
					<source>The input-layout object encapsulates the input state of the input assembler (IA) stage.</source>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>One job of the IA stage is to make shaders more efficient by using system-generated values, also known as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">semantics</pc>, to process only those primitives or vertices that have not already been processed.</source>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476512)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device::CreateInputLayout</pc></pc> method to create an input-layout from an array of input-element descriptions.</source>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>The array contains one or more input elements; each input element describes one vertex-data element from one vertex buffer.</source>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<segment state="initial">
					<source>The entire set of input-element descriptions describes all of the vertex-data elements from all of the vertex buffers that will be bound to the IA stage.</source>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>The following example shows the layout description that Marble Maze uses.</source>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<segment state="initial">
					<source>The layout description describes a vertex buffer that contains four vertex-data elements.</source>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<segment state="initial">
					<source>The important parts of each entry in the array are the semantic name, data format, and byte offset .</source>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">POSITION</pc> element specifies the vertex position in object space.</source>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<segment state="initial">
					<source>It starts at byte offset 0 and contains three floating-point components (for a total of 12 bytes).</source>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NORMAL</pc> element specifies the normal vector.</source>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>It starts at byte offset 12 because it appears directly after <pc dataRefEnd="id2" dataRefStart="id1" id="p1">POSITION</pc> in the layout, which requires 12 bytes.</source>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NORMAL</pc> element contains a four-component, 32-bit unsigned-integer.</source>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Compare the input layout with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sVSInput</pc> structure that is defined by the vertex shader, as shown in the following example.</source>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sVSInput</pc> structure defines the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">POSITION</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">NORMAL</pc>, and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">TEXCOORD0</pc> elements.</source>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<segment state="initial">
					<source>The DirectX runtime maps each element in the layout to the input structure that is defined by the shader.</source>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509647)</data>
				</originalData>
				<segment state="initial">
					<source>The document <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Semantics</pc> describes each of the available semantics in greater detail.</source>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   In a layout, you can specify additional components that are not used to enable multiple shaders to share the same layout.</source>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TANGENT</pc> element is not used by the shader.</source>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TANGENT</pc> element if you want to experiment with techniques such as normal mapping.</source>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<segment state="initial">
					<source>By using normal mapping, also known as bump mapping, you can create the effect of bumps on the surfaces of objects.</source>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb172379)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about bump mapping, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Bump Mapping (Direct3D 9)</pc>.</source>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb205116)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/bb205117)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about the input assembly stage state, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Input-Assembler Stage</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Getting Started with the Input-Assembler Stage</pc>.</source>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#rendering_the_scene)</data>
				</originalData>
				<segment state="initial">
					<source>The process of using the vertex and pixel shaders to render the scene are described in the section <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Rendering the scene</pc> later in this document.</source>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<segment state="initial">
					<source>Creating the constant buffer</source>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>Direct3D buffer groups a collection of data.</source>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<segment state="initial">
					<source>A constant buffer is a kind of buffer that you can use to pass data to shaders.</source>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<segment state="initial">
					<source>Marble Maze uses a constant buffer to hold the model (or world) view, and the projection matrices for the active scene object.</source>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::LoadDeferredResources</pc> method creates a constant buffer that will later hold matrix data.</source>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The example creates a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">D3D11\_BUFFER\_DESC</pc> structure that uses the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11\_BIND\_CONSTANT\_BUFFER</pc> flag to specify usage as a constant buffer.</source>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This example then passes that structure to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device::CreateBuffer</pc></pc> method.</source>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff476351)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_constantBuffer</pc> variable is an <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID3D11Buffer</pc></pc> object.</source>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method later updates <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConstantBuffer</pc> objects, one for the maze and one for the marble.</source>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Render</pc> method then binds each <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConstantBuffer</pc> object to the constant buffer before each object is rendered.</source>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConstantBuffer</pc> structure, which is in MarbleMaze.h.</source>
				</segment>
			</unit>
			<unit id="311" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To better understand how constant buffers map to shader code, compare the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConstantBuffer</pc> structure to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SimpleConstantBuffer</pc> constant buffer that is defined by the vertex shader in BasicVertexShader.hlsl:</source>
				</segment>
			</unit>
			<unit id="312" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The layout of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConstantBuffer</pc> structure matches the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">cbuffer</pc> object.</source>
				</segment>
			</unit>
			<unit id="313" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">cbuffer</pc> variable specifies register b0, which means that the constant buffer data is stored in register 0.</source>
				</segment>
			</unit>
			<unit id="314" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Render</pc> method specifies register 0 when it activates the constant buffer.</source>
				</segment>
			</unit>
			<unit id="315" translate="yes">
				<segment state="initial">
					<source>This process is described in greater detail later in this document.</source>
				</segment>
			</unit>
			<unit id="316" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476898)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about constant buffers, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Introduction to Buffers in Direct3D 11</pc>.</source>
				</segment>
			</unit>
			<unit id="317" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/dd607359)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For more information about the register keyword, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">register</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="318" translate="yes">
				<segment state="initial">
					<source>Loading meshes</source>
				</segment>
			</unit>
			<unit id="319" translate="yes">
				<segment state="initial">
					<source>Marble Maze uses SDK-Mesh as the run-time format because this format provides a basic way to load mesh data for sample applications.</source>
				</segment>
			</unit>
			<unit id="320" translate="yes">
				<segment state="initial">
					<source>For production use, you should use a mesh format that meets the specific requirements of your game.</source>
				</segment>
			</unit>
			<unit id="321" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::LoadDeferredResources</pc> method loads mesh data after it loads the vertex and pixel shaders.</source>
				</segment>
			</unit>
			<unit id="322" translate="yes">
				<segment state="initial">
					<source>A mesh is a collection of vertex data that often includes information such as positions, normal data, colors, materials, and texture coordinates.</source>
				</segment>
			</unit>
			<unit id="323" translate="yes">
				<segment state="initial">
					<source>Meshes are typically created in 3-D authoring software and maintained in files that are separate from application code.</source>
				</segment>
			</unit>
			<unit id="324" translate="yes">
				<segment state="initial">
					<source>The marble and the maze are two examples of meshes that the game uses.</source>
				</segment>
			</unit>
			<unit id="325" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Marble Maze uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SDKMesh</pc> class to manage meshes.</source>
				</segment>
			</unit>
			<unit id="326" translate="yes">
				<segment state="initial">
					<source>This class is declared in SDKMesh.h.</source>
				</segment>
			</unit>
			<unit id="327" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">SDKMesh</pc> provides methods to load, render, and destroy mesh data.</source>
				</segment>
			</unit>
			<unit id="328" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>   Marble Maze uses the SDK-Mesh format and provides the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SDKMesh</pc> class for illustration only.</source>
				</segment>
			</unit>
			<unit id="329" translate="yes">
				<segment state="initial">
					<source>Although the SDK-Mesh format is useful for learning, and for creating prototypes, it is a very basic format that might not meet the requirements of most game development.</source>
				</segment>
			</unit>
			<unit id="330" translate="yes">
				<segment state="initial">
					<source>We recommend that you use a mesh format that meets the specific requirements of your game.</source>
				</segment>
			</unit>
			<unit id="331" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::LoadDeferredResources</pc> method uses the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SDKMesh::Create</pc> method to load mesh data for the maze and for the ball.</source>
				</segment>
			</unit>
			<unit id="332" translate="yes">
				<segment state="initial">
					<source>Loading collision data</source>
				</segment>
			</unit>
			<unit id="333" translate="yes">
				<segment state="initial">
					<source>Although this section does not focus on how Marble Maze implements the physics simulation between the marble and the maze, note that mesh geometry for the physics system is read when the meshes are loaded.</source>
				</segment>
			</unit>
			<unit id="334" translate="yes">
				<segment state="initial">
					<source>The way that you load collision data large depends on the run-time format that you use.</source>
				</segment>
			</unit>
			<unit id="335" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For more information about how Marble Maze loads the collision geometry from an SDK-Mesh file, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::ExtractTrianglesFromMesh</pc> method in the source code.</source>
				</segment>
			</unit>
			<unit id="336" translate="yes">
				<segment state="initial">
					<source>Updating game state</source>
				</segment>
			</unit>
			<unit id="337" translate="yes">
				<segment state="initial">
					<source>Marble Maze separates game logic from rendering logic by first updating all scene objects before rendering them.</source>
				</segment>
			</unit>
			<unit id="338" translate="yes">
				<segment state="initial">
					<source>The document Marble Maze application structure describes the main game loop.</source>
				</segment>
			</unit>
			<unit id="339" translate="yes">
				<segment state="initial">
					<source>Updating the scene, which is part of the game loop, happens after Windows events and input are processed and before the scene is rendered.</source>
				</segment>
			</unit>
			<unit id="340" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method handles the update of the UI and the game.</source>
				</segment>
			</unit>
			<unit id="341" translate="yes">
				<segment state="initial">
					<source>Updating the user interface</source>
				</segment>
			</unit>
			<unit id="342" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method calls the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">UserInterface::Update</pc> method to update the state of the UI.</source>
				</segment>
			</unit>
			<unit id="343" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UserInterface::Update</pc> method updates each element in the UI collection.</source>
				</segment>
			</unit>
			<unit id="344" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Classes that derive from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ElementBase</pc> implement the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Update</pc> method to perform specific behaviors.</source>
				</segment>
			</unit>
			<unit id="345" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StopwatchTimer::Update</pc> method updates the elapsed time by the provided amount and updates the text that it later displays.</source>
				</segment>
			</unit>
			<unit id="346" translate="yes">
				<segment state="initial">
					<source>Updating the scene</source>
				</segment>
			</unit>
			<unit id="347" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method updates the game based on the current state machine state.</source>
				</segment>
			</unit>
			<unit id="348" translate="yes">
				<segment state="initial">
					<source>When the game is in the active state, Marble Maze updates the camera to follow the marble, updates the view matrix part of the constant buffers, and updates the physics simulation.</source>
				</segment>
			</unit>
			<unit id="349" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method updates the position of the camera.</source>
				</segment>
			</unit>
			<unit id="350" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Marble Maze uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_resetCamera</pc> variable to flag that the camera must be reset to be located directly above the marble.</source>
				</segment>
			</unit>
			<unit id="351" translate="yes">
				<segment state="initial">
					<source>The camera is reset when the game starts or the marble falls through the maze.</source>
				</segment>
			</unit>
			<unit id="352" translate="yes">
				<segment state="initial">
					<source>When the main menu or high score display screen is active, the camera is set at a constant location.</source>
				</segment>
			</unit>
			<unit id="353" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>Otherwise, Marble Maze uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">timeDelta</pc> parameter to interpolate the position of the camera between its current and target positions.</source>
				</segment>
			</unit>
			<unit id="354" translate="yes">
				<segment state="initial">
					<source>The target position is slightly above and in front of the marble.</source>
				</segment>
			</unit>
			<unit id="355" translate="yes">
				<segment state="initial">
					<source>Using the elapsed frame time enables the camera to gradually follow, or chase, the marble.</source>
				</segment>
			</unit>
			<unit id="356" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method updates the constant buffers for the marble and the maze.</source>
				</segment>
			</unit>
			<unit id="357" translate="yes">
				<segment state="initial">
					<source>The maze’s model, or world, matrix always remains the identity matrix.</source>
				</segment>
			</unit>
			<unit id="358" translate="yes">
				<segment state="initial">
					<source>Except for the main diagonal, whose elements are all ones, the identity matrix is a square matrix composed of zeros.</source>
				</segment>
			</unit>
			<unit id="359" translate="yes">
				<segment state="initial">
					<source>The marble’s model matrix is based on its position matrix times its rotation matrix.</source>
				</segment>
			</unit>
			<unit id="360" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">mul</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">translation</pc> functions are defined in BasicMath.h.</source>
				</segment>
			</unit>
			<unit id="361" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](adding-input-and-interactivity-to-the-marble-maze-sample.md)</data>
				</originalData>
				<segment state="initial">
					<source>For information about how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method reads user input and simulates the motion of the marble, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Adding input and interactivity to the Marble Maze sample</pc>.</source>
				</segment>
			</unit>
			<unit id="362" translate="yes">
				<segment state="initial">
					<source>Rendering the scene</source>
				</segment>
			</unit>
			<unit id="363" translate="yes">
				<segment state="initial">
					<source>When a scene is rendered, these steps are typically included.</source>
				</segment>
			</unit>
			<unit id="364" translate="yes">
				<segment state="initial">
					<source>Set the current render target depth-stencil buffer.</source>
				</segment>
			</unit>
			<unit id="365" translate="yes">
				<segment state="initial">
					<source>Clear the render and stencil views.</source>
				</segment>
			</unit>
			<unit id="366" translate="yes">
				<segment state="initial">
					<source>Prepare the vertex and pixel shaders for drawing.</source>
				</segment>
			</unit>
			<unit id="367" translate="yes">
				<segment state="initial">
					<source>Render the 3-D objects in the scene.</source>
				</segment>
			</unit>
			<unit id="368" translate="yes">
				<segment state="initial">
					<source>Render any 2-D object that you want to appear in front of the scene.</source>
				</segment>
			</unit>
			<unit id="369" translate="yes">
				<segment state="initial">
					<source>Present the rendered image to the monitor.</source>
				</segment>
			</unit>
			<unit id="370" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Render</pc> method binds the render target and depth stencil views, clears those views, draws the scene, and then draws the overlay.</source>
				</segment>
			</unit>
			<unit id="371" translate="yes">
				<segment state="initial">
					<source>Preparing the render targets</source>
				</segment>
			</unit>
			<unit id="372" translate="yes">
				<segment state="initial">
					<source>Before you render your scene, you must set the current render target depth-stencil buffer.</source>
				</segment>
			</unit>
			<unit id="373" translate="yes">
				<segment state="initial">
					<source>If your scene is not guaranteed to draw over every pixel on the screen, also clear the render and stencil views.</source>
				</segment>
			</unit>
			<unit id="374" translate="yes">
				<segment state="initial">
					<source>Marble Maze clears the render and stencil views on every frame to ensure that there are no visible artifacts from the previous frame.</source>
				</segment>
			</unit>
			<unit id="375" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff476464)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Render</pc> method calls the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID3D11DeviceContext::OMSetRenderTargets</pc></pc> method to set the render target and the depth-stencil buffer as the current ones.</source>
				</segment>
			</unit>
			<unit id="376" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/desktop/ff476377)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_renderTargetView</pc> member variable, an <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID3D11RenderTargetView</pc></pc> object, and the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">m\_depthStencilView</pc> member variable, an <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ID3D11DepthStencilView</pc></pc> object, are defined and initialized by the <pc dataRefEnd="id14" dataRefStart="id13" id="p7">DirectXBase</pc> class.</source>
				</segment>
			</unit>
			<unit id="377" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476377)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11RenderTargetView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DepthStencilView</pc></pc> interfaces support the texture view mechanism that is provided by Direct3D 10 and later.</source>
				</segment>
			</unit>
			<unit id="378" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb205128)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about texture views, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Texture Views (Direct3D 10)</pc>.</source>
				</segment>
			</unit>
			<unit id="379" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476464)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OMSetRenderTargets</pc></pc> method prepares the output-merger stage of the Direct3D pipeline.</source>
				</segment>
			</unit>
			<unit id="380" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb205120)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about the output-merger stage, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Output-Merger Stage</pc>.</source>
				</segment>
			</unit>
			<unit id="381" translate="yes">
				<segment state="initial">
					<source>Preparing the vertex and pixel shaders</source>
				</segment>
			</unit>
			<unit id="382" translate="yes">
				<segment state="initial">
					<source>Before you render the scene objects, perform the following steps to prepare the vertex and pixel shaders for drawing:</source>
				</segment>
			</unit>
			<unit id="383" translate="yes">
				<segment state="initial">
					<source>Set the shader input layout as the current layout.</source>
				</segment>
			</unit>
			<unit id="384" translate="yes">
				<segment state="initial">
					<source>Set the vertex and pixel shaders as the current shaders.</source>
				</segment>
			</unit>
			<unit id="385" translate="yes">
				<segment state="initial">
					<source>Update any constant buffers with data that you have to pass to the shaders.</source>
				</segment>
			</unit>
			<unit id="386" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>  Marble Maze uses one pair of vertex and pixel shaders for all 3-D objects.</source>
				</segment>
			</unit>
			<unit id="387" translate="yes">
				<segment state="initial">
					<source>If your game uses more than one pair of shaders, you must perform these steps each time you draw objects that use different shaders.</source>
				</segment>
			</unit>
			<unit id="388" translate="yes">
				<segment state="initial">
					<source>To reduce the overhead that is associated with changing the shader state, we recommend that you group render calls for all objects that use the same shaders.</source>
				</segment>
			</unit>
			<unit id="389" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#loading_shaders)</data>
				</originalData>
				<segment state="initial">
					<source>The section <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Loading shaders</pc> in this document describes how the input layout is created when the vertex shader is created.</source>
				</segment>
			</unit>
			<unit id="390" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff476454)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Render</pc> method uses the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID3D11DeviceContext::IASetInputLayout</pc></pc> method to set this layout as the current layout.</source>
				</segment>
			</unit>
			<unit id="391" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Render</pc> method uses the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID3D11DeviceContext::VSSetShader</pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ID3D11DeviceContext::PSSetShader</pc></pc> methods to set the vertex and pixel shaders as the current shaders, respectively.</source>
				</segment>
			</unit>
			<unit id="392" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff476486)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>After the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Render</pc> sets the shaders and their input layout, it uses the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID3D11DeviceContext::UpdateSubresource</pc></pc> method to update the constant buffer with the model, view, and projection matrices for the maze.</source>
				</segment>
			</unit>
			<unit id="393" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UpdateSubresource</pc> method copies the matrix data from CPU memory to GPU memory.</source>
				</segment>
			</unit>
			<unit id="394" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Recall that the model and view components of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConstantBuffer</pc> structure are updated in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MarbleMaze::Update</pc> method.</source>
				</segment>
			</unit>
			<unit id="395" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff476491)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/desktop/ff476470)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Render</pc> method then calls the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID3D11DeviceContext::VSSetConstantBuffers</pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ID3D11DeviceContext::PSSetConstantBuffers</pc></pc> methods to set this constant buffer as the current one.</source>
				</segment>
			</unit>
			<unit id="396" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Render</pc> method performs similar steps to prepare the marble to be rendered.</source>
				</segment>
			</unit>
			<unit id="397" translate="yes">
				<segment state="initial">
					<source>Rendering the maze and the marble</source>
				</segment>
			</unit>
			<unit id="398" translate="yes">
				<segment state="initial">
					<source>After you activate the current shaders, you can draw your scene objects.</source>
				</segment>
			</unit>
			<unit id="399" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Render</pc> method calls the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SDKMesh::Render</pc> method to render the maze mesh.</source>
				</segment>
			</unit>
			<unit id="400" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Render</pc> method performs similar steps to render the marble.</source>
				</segment>
			</unit>
			<unit id="401" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>As mentioned earlier in this document, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SDKMesh</pc> class is provided for demonstration purposes, but we do not recommend it for use in a production-quality game.</source>
				</segment>
			</unit>
			<unit id="402" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476456)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/desktop/ff476453)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/desktop/ff476410)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>However, notice that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SDKMesh::RenderMesh</pc> method, which is called by <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SDKMesh::Render</pc>, uses the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceContext::IASetVertexBuffers</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ID3D11DeviceContext::IASetIndexBuffer</pc></pc> methods to set the current vertex and index buffers that define the mesh, and the <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">ID3D11DeviceContext::DrawIndexed</pc></pc> method to draw the buffers.</source>
				</segment>
			</unit>
			<unit id="403" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476898)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about how to work with vertex and index buffers, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Introduction to Buffers in Direct3D 11</pc>.</source>
				</segment>
			</unit>
			<unit id="404" translate="yes">
				<segment state="initial">
					<source>Drawing the user interface and overlay</source>
				</segment>
			</unit>
			<unit id="405" translate="yes">
				<segment state="initial">
					<source>After drawing 3-D scene objects, Marble Maze draws the 2-D UI elements that appear in front of the scene.</source>
				</segment>
			</unit>
			<unit id="406" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Render</pc> method ends by drawing the user interface and the overlay.</source>
				</segment>
			</unit>
			<unit id="407" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/hh404479)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UserInterface::Render</pc> method uses an <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID2D1DeviceContext</pc></pc> object to draw the UI elements.</source>
				</segment>
			</unit>
			<unit id="408" translate="yes">
				<segment state="initial">
					<source>This method sets the drawing state, draws all active UI elements, and then restores the previous drawing state.</source>
				</segment>
			</unit>
			<unit id="409" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SampleOverlay::Render</pc> method uses a similar technique to draw the overlay bitmap.</source>
				</segment>
			</unit>
			<unit id="410" translate="yes">
				<segment state="initial">
					<source>Presenting the scene</source>
				</segment>
			</unit>
			<unit id="411" translate="yes">
				<segment state="initial">
					<source>After drawing all 2-D and 3-D scene objects, Marble Maze presents the rendered image to the monitor.</source>
				</segment>
			</unit>
			<unit id="412" translate="yes">
				<segment state="initial">
					<source>It synchronizes drawing to the vertical blank to ensure that time is not spent time drawing frames that will never be actually shown on the display.</source>
				</segment>
			</unit>
			<unit id="413" translate="yes">
				<segment state="initial">
					<source>Marble Maze also handles device changes when it presents the scene.</source>
				</segment>
			</unit>
			<unit id="414" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>After the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Render</pc> method returns, the game loop calls the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MarbleMaze::Present</pc> method to send the rendered image to the monitor or display.</source>
				</segment>
			</unit>
			<unit id="415" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze</pc> class does not override the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectXBase::Present</pc> method.</source>
				</segment>
			</unit>
			<unit id="416" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXBase::Present</pc> method calls <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IDXGISwapChain1::Present</pc></pc> to perform the present operation, as shown in the following example:</source>
				</segment>
			</unit>
			<unit id="417" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/hh404631)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>In this example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_swapChain</pc> is an <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IDXGISwapChain1</pc></pc> object.</source>
				</segment>
			</unit>
			<unit id="418" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#initializing)</data>
				</originalData>
				<segment state="initial">
					<source>The initialization of this object is described in the section <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Initializing Direct3D and Direct2D</pc> in this document.</source>
				</segment>
			</unit>
			<unit id="419" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
				</originalData>
				<segment state="initial">
					<source>The first parameter to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::Present</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">SyncInterval</pc>, specifies the number of vertical blanks to wait before presenting the frame.</source>
				</segment>
			</unit>
			<unit id="420" translate="yes">
				<segment state="initial">
					<source>Marble Maze specifies 1 so that it waits until the next vertical blank.</source>
				</segment>
			</unit>
			<unit id="421" translate="yes">
				<segment state="initial">
					<source>A vertical blank is the time between when one frame finishes drawing to the monitor and the next frame begins.</source>
				</segment>
			</unit>
			<unit id="422" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::Present1</pc></pc> method returns an error code that indicates that the device was removed or otherwise failed.</source>
				</segment>
			</unit>
			<unit id="423" translate="yes">
				<segment state="initial">
					<source>In this case, Marble Maze reinitializes the device.</source>
				</segment>
			</unit>
			<unit id="424" translate="yes">
				<segment state="initial">
					<source>Next steps</source>
				</segment>
			</unit>
			<unit id="425" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](adding-input-and-interactivity-to-the-marble-maze-sample.md)</data>
				</originalData>
				<segment state="initial">
					<source>Read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Adding input and interactivity to the Marble Maze sample</pc> for information about some of the key practices to keep in mind when you work with input devices.</source>
				</segment>
			</unit>
			<unit id="426" translate="yes">
				<segment state="initial">
					<source>This document discusses how Marble Maze supports touch, accelerometer, Xbox 360 controller, and mouse input.</source>
				</segment>
			</unit>
			<unit id="427" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="428" translate="yes">
				<segment state="initial">
					<source>Adding input and interactivity to the Marble Maze sample</source>
				</segment>
			</unit>
			<unit id="429" translate="yes">
				<segment state="initial">
					<source>Marble Maze application structure</source>
				</segment>
			</unit>
			<unit id="430" translate="yes">
				<segment state="initial">
					<source>Developing Marble Maze, a UWP game in C++ and DirectX</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>