<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">8d626d907c089daa2426c2905b269d6ba37f5ae6</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci1\threading-async\call-asynchronous-apis-in-csharp-or-visual-basic.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">109315b3283ff75b135e08163d3962cf911d7ccb</mda:meta><mda:meta type="olxliffhash">816d92275b38c0288dcf2c53c61a7adccf7ac1eb</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Call asynchronous APIs in C# or Visual Basic</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>The Universal Windows Platform (UWP) includes many asynchronous APIs to ensure that your app remains responsive when it does work that might take an extended amount of time.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Call asynchronous APIs in C# or Visual Basic</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>The Universal Windows Platform (UWP) includes many asynchronous APIs to ensure that your app remains responsive when it does work that might take an extended amount of time.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>This topic discusses how to use asynchronous methods from the UWP in C# or Microsoft Visual Basic.</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>Asynchronous APIs keep your app from waiting for large operations to complete before continuing execution.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>For example, an app that downloads info from the Internet might spend several seconds waiting for the info to arrive.</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>If you use a synchronous method to retrieve the info, the app is blocked until the method returns.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>The app won't respond to user interaction and because it seems non-responsive, the user might become frustrated.</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>By providing asynchronous APIs, the UWP helps to ensure that your app stays responsive to the user when it's performing long operations.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Most of the asynchronous APIs in the UWP don't have synchronous counterparts, so you need to be sure to understand how to use the asynchronous APIs with C# or Visual Basic in your Universal Windows Platform (UWP) app.</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Here we show how to call asynchronous APIs of the UWP.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>Using asynchronous APIs</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>By convention, asynchronous methods are given names that end in "Async".</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>You typically call asynchronous APIs in response to a user's action, such as when the user clicks a button.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>Calling an asynchronous method in an event handler is one of the simplest ways of using asynchronous APIs.</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Here we use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">await</pc> operator as an example.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Suppose that you have an app that lists the titles of blog posts from a certain location.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209265)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The app has a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> that the user clicks to get the titles.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209652)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The titles are displayed in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBlock</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>When the user clicks the button, it is important that the app remains responsive while it waits for the info from the blog's website.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243460)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To ensure this responsiveness, the UWP provides an asynchronous method, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SyndicationClient.RetrieveFeedAsync</pc></pc>, to download the feed.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243460)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The example here gets the lists of blog posts from a blog by calling the asynchronous method, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SyndicationClient.RetrieveFeedAsync</pc></pc>, and awaiting the result.</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">[!code-csharp</data>
					<data id="id2">]</data>
					<data id="id3">[</data>
					<data id="id4">](./AsyncSnippets/csharp/MainPage.xaml.cs#SnippetDownloadRSS)</data>
					<data id="id5">
</data>
					<data id="id6">[!code-vb</data>
					<data id="id7">]</data>
					<data id="id8">[</data>
					<data id="id9">](./AsyncSnippets/vbnet/MainPage.xaml.vb#SnippetDownloadRSS)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Main</pc></pc><ph dataRef="id5" id="ph1" /><pc dataRefEnd="id7" dataRefStart="id6" id="p3"><pc dataRefEnd="id9" dataRefStart="id8" id="p4">Main</pc></pc></source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>There are a couple of important things about this example.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">`SyndicationFeed feed = await client.RetrieveFeedAsync(feedUri)`</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">[</data>
					<data id="id5">](https://msdn.microsoft.com/library/windows/apps/BR243460)</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
				</originalData>
				<segment state="initial">
					<source>First, the line, <ph dataRef="id1" id="ph1" /> uses the <pc dataRefEnd="id3" dataRefStart="id2" id="p1">await</pc> operator with the call to the asynchronous method, <pc dataRefEnd="id5" dataRefStart="id4" id="p2"><pc dataRefEnd="id7" dataRefStart="id6" id="p3">RetrieveFeedAsync</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You can think of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">await</pc> operator as telling the compiler that you are calling an asynchronous method, which causes the compiler to do some extra work so you don’t have to.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Next, the declaration of the event handler includes the keyword <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc>.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You must include this keyword in the method declaration of any method in which you use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">await</pc> operator.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In this topic, we won't go into a lot of the details of what the compiler does with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">await</pc> operator, but let's examine what your app does so that it is asynchronous and responsive.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Consider what happens when you use synchronous code.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">`SyndicationClient.RetrieveFeed`</data>
				</originalData>
				<segment state="initial">
					<source>For example, suppose that there is a method called <ph dataRef="id1" id="ph1" /> that is synchronous.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">`SyndicationFeed feed = client.RetrieveFeed(feedUri)`</data>
					<data id="id2">`SyndicationFeed feed = await client.RetrieveFeedAsync(feedUri)`</data>
					<data id="id3">`RetrieveFeed`</data>
				</originalData>
				<segment state="initial">
					<source>(There is no such method, but imagine that there is.) If your app included the line <ph dataRef="id1" id="ph1" />, instead of <ph dataRef="id2" id="ph2" />, execution of the app would stop until the return value of <ph dataRef="id3" id="ph3" /> is available.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227737)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>And while your app waits for the method to complete, it can't respond to any other events, such another <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Click</pc></pc> event.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<originalData>
					<data id="id1">`RetrieveFeed`</data>
				</originalData>
				<segment state="initial">
					<source>That is, your app would be blocked until <ph dataRef="id1" id="ph1" /> returns.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">`client.RetrieveFeedAsync`</data>
				</originalData>
				<segment state="initial">
					<source>But if you call <ph dataRef="id1" id="ph1" />, the method initiates the retrieval and immediately returns.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR243460)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>When you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">await</pc> with <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">RetrieveFeedAsync</pc></pc>, the app temporarily exits the event handler.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Then it can process other events while <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RetrieveFeedAsync</pc> executes asynchronously.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>This keeps the app responsive to the user.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR243485)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">`SyndicationFeed feed = await client.RetrieveFeedAsync(feedUri)`</data>
				</originalData>
				<segment state="initial">
					<source>When <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RetrieveFeedAsync</pc> completes and the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">SyndicationFeed</pc></pc> is available, the app essentially reenters the event handler where it left off, after <ph dataRef="id7" id="ph1" />, and finishes the rest of the method.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">`RetrieveFeed`</data>
				</originalData>
				<segment state="initial">
					<source>The nice thing about using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">await</pc> operator is that the code doesn't look much different from how the code looks if you used the imaginary <ph dataRef="id3" id="ph1" /> method.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>There are ways to write asynchronous code in C# or Visual Basic without the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">await</pc> operator, but the resulting code tends to emphasize the mechanics of executing asynchronously.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>This makes asynchronous code hard to write, hard to understand, and hard to maintain.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>By using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">await</pc> operator, you get the benefits of an asynchronous app without making your code complex.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Return types and results of asynchronous APIs</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243460)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR243485)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>If you followed the link to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RetrieveFeedAsync</pc></pc>, you might have noticed that the return type of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">RetrieveFeedAsync</pc> is not a <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">SyndicationFeed</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">`IAsyncOperationWithProgress&lt;SyndicationFeed, RetrievalProgress&gt;`</data>
				</originalData>
				<segment state="initial">
					<source>Instead, the return type is <ph dataRef="id1" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>Viewed from the raw syntax, an asynchronous API returns an object that contains the result within it.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>While it is common, and sometimes useful, to think of an asynchronous method as being awaitable, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">await</pc> operator actually operates on the method’s return value, not on the method.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When you apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">await</pc> operator, what you get back is the result of calling <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetResult</pc> on the object returned by the method.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In the example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SyndicationFeed</pc> is the result of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">RetrieveFeedAsync.GetResult()</pc>.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>When you use an asynchronous method, you can examine the signature to see what you’ll get back after awaiting the value returned from the method.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>All asynchronous APIs in the UWP return one of the following types:</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IAsyncOperation<ph dataRef="id1" id="ph1" />TResult</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IAsyncOperationWithProgress<ph dataRef="id1" id="ph1" />TResult, TProgress</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>IAsyncAction</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IAsyncActionWithProgress<ph dataRef="id1" id="ph1" />TProgress</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">`      TResult`</data>
				</originalData>
				<segment state="initial">
					<source>The result type of an asynchronous method is the same as the <ph dataRef="id1" id="ph1" /> type parameter.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">`TResult`</data>
				</originalData>
				<segment state="initial">
					<source>Types without a <ph dataRef="id1" id="ph1" /> don't have a result.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You can think of the result as being <pc dataRefEnd="id2" dataRefStart="id1" id="p1">void</pc>.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/831f9wka.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In Visual Basic, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Sub</pc> procedure is equivalent to a method with a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">void</pc> return type.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>The table here gives examples of asynchronous methods and lists the return type and result type of each.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>Asynchronous method</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>Return type</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Result type</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>SyndicationClient.RetrieveFeedAsync</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IAsyncOperationWithProgress<ph dataRef="id1" id="ph1" />SyndicationFeed, RetrievalProgress</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>SyndicationFeed</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>FileOpenPicker.PickSingleFileAsync</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IAsyncOperation<ph dataRef="id1" id="ph1" />StorageFile</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>StorageFile</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>XmlDocument.SaveToFileAsync</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>IAsyncAction</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>void</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>InkStrokeContainer.LoadAsync</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IAsyncActionWithProgress<ph dataRef="id1" id="ph1" />UInt64</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>void</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>DataReader.LoadAsync</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208120)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">&amp;lt;</data>
					<data id="id8">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataReaderLoadOperation</pc></pc>, a custom results class that implements <pc dataRefEnd="id6" dataRefStart="id5" id="p3">IAsyncOperation<ph dataRef="id7" id="ph1" />UInt32<ph dataRef="id8" id="ph2" /></pc></source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>UInt32</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/br230232.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.threading.tasks.task.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/dd321424.aspx)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">&amp;lt;</data>
					<data id="id14">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>Asynchronous methods that are defined in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">.NET for UWP apps</pc></pc> have the return type <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Task</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Task<ph dataRef="id13" id="ph1" />TResult<ph dataRef="id14" id="ph2" /></pc></pc>.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR206580)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Methods that return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Task</pc> are similar to the asynchronous methods in the UWP that return <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IAsyncAction</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In each case, the result of the asynchronous method is <pc dataRefEnd="id2" dataRefStart="id1" id="p1">void</pc>.</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR206598)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">&amp;lt;</data>
					<data id="id10">&amp;gt;</data>
					<data id="id11">`TResult`</data>
				</originalData>
				<segment state="initial">
					<source>The return type <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Task<ph dataRef="id3" id="ph1" />TResult<ph dataRef="id4" id="ph2" /></pc> is similar to <pc dataRefEnd="id6" dataRefStart="id5" id="p2"><pc dataRefEnd="id8" dataRefStart="id7" id="p3">IAsyncOperation<ph dataRef="id9" id="ph3" />TResult<ph dataRef="id10" id="ph4" /></pc></pc> in that the result of the asynchronous method when running the task is the same type as the <ph dataRef="id11" id="ph5" /> type parameter.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/br230302.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">.NET for UWP apps</pc> and tasks, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">.NET for Windows Runtime apps overview</pc>.</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Handling errors</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When you use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">await</pc> operator to retrieve your results from an asynchronous method, you can use a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">try/catch</pc> block to handle errors that occur in asynchronous methods, just as you do for synchronous methods.</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The previous example wraps the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RetrieveFeedAsync</pc> method and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">await</pc> operation in a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">try/catch</pc> block to handle errors when an exception is thrown.</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>When asynchronous methods call other asynchronous methods, any asynchronous method that results in an exception will be propagated to the outer methods.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This means that you can put a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">try/catch</pc> block on the outer-most method to catch errors for the nested asynchronous methods.</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>Again, this is similar to how you catch exceptions for synchronous methods.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>However, you can't use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">await</pc> in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">catch</pc> block.</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc>  Starting with C# in Microsoft Visual Studio 2005, you can use <pc dataRefEnd="id4" dataRefStart="id3" id="p2">await</pc> in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">catch</pc> block.</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>Summary and next steps</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>The pattern of calling an asynchronous method that we show here is the simplest one to use when you call asynchronous APIs in an event handler.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can also use this pattern when you call an asynchronous method in an overridden method that returns <pc dataRefEnd="id2" dataRefStart="id1" id="p1">void</pc> or a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Sub</pc> in Visual Basic.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>As you encounter asynchronous methods in the UWP, it is important to remember:</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>By convention, asynchronous methods are given names that end in "Async".</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Any method that uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">await</pc> operator must have its declaration marked with the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">async</pc> keyword.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When an app finds the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">await</pc> operator, the app remains responsive to user interaction while the asynchronous method executes.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>Awaiting the value returned by an asynchronous method returns an object that contains the result.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>In most cases, the result contained within the return value is what's useful, not the return value itself.</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>You can find the type of the value that is contained inside the result by looking at the return type of the async method.</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Using asynchronous APIs and <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> patterns is often a way to improve the responsiveness of your app.</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>The example in this topic outputs text that looks like this.</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>