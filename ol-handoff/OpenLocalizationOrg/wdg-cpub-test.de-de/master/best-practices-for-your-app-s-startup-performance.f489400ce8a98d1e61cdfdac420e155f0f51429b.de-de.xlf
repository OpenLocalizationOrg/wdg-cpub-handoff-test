<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">cf95b9dbce0b164237a3edfd801984a592112c74</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\debug-test-perf\best-practices-for-your-app-s-startup-performance.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">838445d08aa1f590cbab8ee38b7ba5c02870ca65</mda:meta><mda:meta type="olxliffhash">a5c2cb1e10bf4416ff9c6be5ef68759347634412</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Best practices for your app's startup performance</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Create Universal Windows Platform (UWP) apps with optimal startup times by improving the way you handle launch and activation.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Best practices for your app's startup performance</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Create Universal Windows Platform (UWP) apps with optimal startup times by improving the way you handle launch and activation.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Best practices for your app's startup performance</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>In part, users perceive whether your app is fast or slow based on how long it takes to start up.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>For the purposes of this topic, an app's startup time begins when the user starts the app, and ends when the user can interact with the app in some meaningful way.</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>This section provides suggestions on how to get better performance out of your app when it starts.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>Measuring your app's startup time</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>Be sure to start your app a few times before you actually measure its startup time.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>This gives you a baseline for your measurement and ensures that you're measuring as reasonably short a startup time as possible.</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>By the time your UWP app arrives on your customers' computers, your app has been compiled with the .NET Native toolchain.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>.NET Native is an ahead-of-time compilation technology that converts MSIL into natively-runnable machine code.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>.NET Native apps start faster, use less memory, and use less battery than their MSIL counterparts.</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Applications built with .NET Native statically link in a custom runtime and the new converged .NET Core that can run on all devices, so they don’t depend on the in-box .NET implementation.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>On your development machine, by default your app uses .NET Native if you’re building it in “Release” mode, and it uses CoreCLR if you’re building it in “Debug” mode.</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>You can configure this in Visual Studio from the Build page in “Properties” (C#) or Compile-&gt;Advanced in "My Project" (VB).</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Look for a checkbox that says “Compile with .NET Native Toolchain”.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>Of course, you should take measurements that are representative of what the end user will experience.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>So, if you're not sure you're compiling your app to native code on your development machine, you could run the Native Image Generator (Ngen.exe) tool to precompile your app before you measure its startup time.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>The following procedure describes how to run Ngen.exe to precompile your app.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>To run Ngen.exe</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Run your app at least one time to ensure that Ngen.exe detects it.</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Open the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Task Scheduler</pc> by doing one of the following:</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>Search for "Task Scheduler" from the start screen.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>Run "taskschd.msc."</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In the left-hand pane of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Task Scheduler</pc>, expand <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Task Scheduler Library</pc>.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Expand <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Microsoft.</pc></source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Expand <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows.</pc></source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Select <pc dataRefEnd="id2" dataRefStart="id1" id="p1">.NET Framework</pc>.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Select <pc dataRefEnd="id2" dataRefStart="id1" id="p1">.NET Framework NGEN 4.x</pc> from the task list.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If you are using a 64-bit computer, there is also a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">.NET Framework NGEN v4.x 64</pc>.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If you are building a 64-bit app, select .<pc dataRefEnd="id2" dataRefStart="id1" id="p1">NET Framework NGEN v4.x 64</pc>.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>From the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Action</pc> menu, click <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Run</pc>.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Ngen.exe precompiles all the apps on the machine that have been used and do not have native images.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>If there are a lot of apps that need to be precompiled, this can take a long time, but subsequent runs are much faster.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>When you recompile your app, the native image is no longer used.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Instead, the app is just-in-time compiled, which means that it is compiled as the app runs.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>You must rerun Ngen.exe to get a new native image.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>Defer work as long as possible</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>To increase your app's startup time, do only the work that absolutely needs to be done to let the user start interacting with the app.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>This can be especially beneficial if you can delay loading additional assemblies.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>The common language runtime loads an assembly the first time it is used.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>If you can minimize the number of assemblies that are loaded, you might be able to improve your app's startup time and its memory consumption.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Do long-running work independently</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Your app can be interactive even though there are parts of the app that aren't fully functional.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>For example, if your app displays data that takes a while to retrieve, you can make that code execute independently of the app's startup code by retrieving the data asynchronously.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>When the data is available, populate the app's user interface with the data.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Many of the Universal Windows Platform (UWP) APIs that retrieve data are asynchronous, so you will probably be retrieving data asynchronously anyway.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt187337)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about asynchronous APIs, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Call asynchronous APIs in C# or Visual Basic</pc>.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>If you do work that doesn't use asynchronous APIs, you can use the Task class to do long running work so that you don't block the user from interacting with the app.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>This will keep your app responsive to the user while the data loads.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>If your app takes an especially long time to load part of its UI, consider adding a string in that area that says something like, "Getting latest data," so that your users know that the app is still processing.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Minimize startup time</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>All but the simplest apps require a perceivable amount of time to load resources, parse XAML, set up data structures, and run logic at activation.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>Here, we analyze the process of activation by breaking it into three phases.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>We also provide tips for reducing the time spent in each phase, and techniques for making each phase of your app's startup more palatable to the user.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>The activation period is the time between the moment a user starts the app and the moment the app is functional.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>This is a critical time because it’s a user’s first impression of your app.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>They expect instant and continuous feedback from the system and apps.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>The system and the app are perceived to be broken or poorly designed when apps don't start quickly.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>Even worse, if an app takes too long to activate, the Process Lifetime Manager (PLM) might kill it, or the user might uninstall it.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>Introduction to the stages of startup</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>Startup involves a number of moving pieces, and all of them need to be correctly coordinated for the best user experience.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>The following steps occur between your user clicking on your app tile and the application content being shown.</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>The Windows shell starts the process and Main is called.</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>The Application object is created.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>(Project template) Constructor calls InitializeComponent, which causes App.xaml to be parsed and objects created.</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>Application.OnLaunched event is raised.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>(ProjectTemplate) App code creates a Frame and navigates to MainPage.</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>(ProjectTemplate) Mainpage constructor calls InitializeComponent which causes MainPage.xaml to be parsed and objects created.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>ProjectTemplate) Window.Current.Activate() is called.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>XAML Platform runs the Layout pass including Measure &amp; Arrange.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>ApplyTemplate will cause control template content to be created for each control, which is typically the bulk of Layout time for startup.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>Render is called to create visuals for all the window contents.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>Frame is presented to the Desktop Windows Manager (DWM).</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>Do less in your Startup path</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>Keep your startup code path free from anything that is not needed for your first frame.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>If you have user dlls containing controls that are not needed during first frame, consider delay loading them.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>If you have a portion of your UI dependent on data from the cloud, then split that UI.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>First, bring up the UI that is not dependent on cloud data and asynchronously bring up the cloud-dependent UI.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>You should also consider caching data locally so that the application will work offline or not be affected by slow network connectivity.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>Show progress UI if your UI is waiting for data.</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>Be cautious of app designs that involve a lot of parsing of configuration files, or UI that is dynamically generated by code.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Reduce element count</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>Startup performance in a XAML app is directly correlated to the number of elements you create during startup.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>The fewer elements you create, the less time your app will take to start up.</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>As a rough benchmark, consider each element to take 1ms to create.</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>Templates used in items controls can have the biggest impact, as they are repeated multiple times.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](optimize-gridview-and-listview.md)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView and GridView UI optimization</pc>.</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>UserControls and control templates will be expanded, so those should also be taken into account.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>If you create any XAML that does not appear on the screen, then you should justify whether those pieces of XAML should be created during your startup.</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://blogs.msdn.com/b/visualstudio/archive/2015/02/24/introducing-the-ui-debugging-tools-for-xaml.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Visual Studio Live Visual Tree</pc> window shows the child element counts for each node in the tree.</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>Live visual tree.</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Use x:DeferLoadStrategy</pc>.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>Collapsing an element, or setting its opacity to 0, will not prevent the element from being created.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>Using x:DeferLoadStrategy, you can delay the loading of a piece of UI, and load it when needed.</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>This is good way to delay processing UI that is not visible during the startup screen, so that you can load it when needed, or as part of a set of delayed logic.</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>To trigger the loading, you need only call FindName for the element.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204785)</data>
				</originalData>
				<segment state="initial">
					<source>For an example and more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:DeferLoadStrategy attribute</pc>.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Virtualization</pc>.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>If you have list or repeater content in your UI then it’s highly advised that you use UI virtualization.</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>If list UI is not virtualized then you are paying the cost of creating all the elements up front, and that can slow down your startup.</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](optimize-gridview-and-listview.md)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView and GridView UI optimization</pc>.</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>Application performance is not only about raw performance, it’s also about perception.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>Changing the order of operations so that visual aspects occur first will commonly make the user feel like the application is faster.</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>Users will consider the application loaded when the content is on the screen.</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>Commonly, applications need to do multiple things as part of the startup, and not all of that is required to bring up the UI, so those should be delayed or prioritized lower than the UI.</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>This topic talks about the “first frame” which comes from animation/TV, and is a measure of how long until content is seen by the end user.</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>Improve startup perception</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>Let’s use the example of a simple online game to identify each phase of startup and different techniques to give the user feedback throughout the process.</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>For this example, the first phase of activation is the time between the user tapping the game’s tile and the game starting to run its code.</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>During this time, the system doesn’t have any content to display to the user to even indicate that the correct game has started.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<segment state="initial">
					<source>But providing a splash screen gives that content to the system.</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>The game then informs the user that the first phase of activation has completed by replacing the static splash screen with its own UI when it begins running code.</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>The second phase of activation encompasses creating and initializing structures critical for the game.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>If an app can quickly create its initial UI with the data available after the first phase of activation, then the second phase is trivial and you can display the UI immediately.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>Otherwise we recommend that the app display a loading page while it is initialized.</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<segment state="initial">
					<source>What the loading page looks like is up to you and it can be as simple as displaying a progress bar or a progress ring.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<segment state="initial">
					<source>The key point is that the app indicates that it is performing tasks before becoming responsive.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>In the case of the game, it would like to display its initial screen but that UI requires that some images and sounds be loaded from disk into memory.</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>These tasks take a couple of seconds, so the app keeps the user informed by replacing the splash screen with a loading page, which shows a simple animation related to the theme of the game.</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>The third stage begins after the game has a minimal set of info to create an interactive UI, which replaces the loading page.</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<segment state="initial">
					<source>At this point the only info available to the online game is the content that the app loaded from disk.</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>The game can ship with enough content to create an interactive UI; but because it’s an online game it won’t be functional until it connects to the internet and downloads some additional info.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>Until it has all the info it needs to be functional, the user can interact with the UI, but features that need additional data from the web should give feedback that content is still loading.</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<segment state="initial">
					<source>It may take some time for an app to become fully functional, so it’s important that functionality be made available as soon as possible.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>Now that we identified the three stages of activation in the online game, let’s tie them to actual code.</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>Phase 1</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>Before an app starts, it needs to tell the system what it wants to display as the splash screen.</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>It does so by providing an image and background color to the SplashScreen element in an app’s manifest, as in the example.</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>Windows displays this after the app begins activation.</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt187306)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Add a splash screen</pc>.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>Use the app’s constructor only to initialize data structures that are critical to the app.</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>The constructor is called only the first time the app is run and not necessarily each time the app is activated.</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>For example, the constructor isn't called for an app that has been run, placed in the background, and then activated via the search contract.</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>Phase 2</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<segment state="initial">
					<source>There are a number of reasons for an app to be activated, each of which you may want to handle differently.</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242330)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/Hh701797)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242331)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/Hh701799)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
					<data id="id17">[</data>
					<data id="id18">](https://msdn.microsoft.com/library/windows/apps/Hh701801)</data>
					<data id="id19">**</data>
					<data id="id20">**</data>
					<data id="id21">[</data>
					<data id="id22">](https://msdn.microsoft.com/library/windows/apps/BR242335)</data>
					<data id="id23">**</data>
					<data id="id24">**</data>
					<data id="id25">[</data>
					<data id="id26">](https://msdn.microsoft.com/library/windows/apps/BR242336)</data>
					<data id="id27">**</data>
					<data id="id28">**</data>
					<data id="id29">[</data>
					<data id="id30">](https://msdn.microsoft.com/library/windows/apps/Hh701806)</data>
					<data id="id31">**</data>
					<data id="id32">**</data>
				</originalData>
				<segment state="initial">
					<source>You can override <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnActivated</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OnCachedFileUpdaterActivated</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">OnFileActivated</pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">OnFileOpenPickerActivated</pc></pc>, <pc dataRefEnd="id18" dataRefStart="id17" id="p9"><pc dataRefEnd="id20" dataRefStart="id19" id="p10">OnFileSavePickerActivated</pc></pc>, <pc dataRefEnd="id22" dataRefStart="id21" id="p11"><pc dataRefEnd="id24" dataRefStart="id23" id="p12">OnLaunched</pc></pc>, <pc dataRefEnd="id26" dataRefStart="id25" id="p13"><pc dataRefEnd="id28" dataRefStart="id27" id="p14">OnSearchActivated</pc></pc>, and <pc dataRefEnd="id30" dataRefStart="id29" id="p15"><pc dataRefEnd="id32" dataRefStart="id31" id="p16">OnShareTargetActivated</pc></pc> methods to handle each reason of activation.</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209051)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209046)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>One of the things that an app must do in these methods is create a UI, assign it to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Window.Content</pc></pc>, and then call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Window.Activate</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>At this point the splash screen is replaced by the UI that the app created.</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<segment state="initial">
					<source>This visual could either be loading screen or the app's actual UI if enough info is available at activation to create it.</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>Apps that display a loading page in the activation handler begin work to create the UI in the background.</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208723)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>After that element has been created, its <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.Loaded</pc></pc> event occurs.</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>In the event handler you replace the window's content, which is currently the loading screen, with the newly created home page.</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>It’s critical that an app with an extended initialization period show a loading page.</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209046)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Aside from providing the sure feedback about the activation process, the process will be terminated if <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Window.Activate</pc></pc> is not called within 15 seconds of the start of the activation process.</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=234889)</data>
				</originalData>
				<segment state="initial">
					<source>For an example of using extended splash screens, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Splash screen sample</pc>.</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>Phase 3</source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<segment state="initial">
					<source>Just because the app displayed the UI doesn't mean it is completely ready for use.</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>In the case of our game, the UI is displayed with placeholders for features that require data from the internet.</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<segment state="initial">
					<source>At this point the game downloads the additional data needed to make the app fully functional and progressively enables features as data is acquired.</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<segment state="initial">
					<source>Sometimes much of the content needed for activation can be packaged with the app.</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>Such is the case with a simple game.</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>This makes the activation process quite simple.</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>But many programs (such as news readers and photo viewers) must pull info from the web to become functional.</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<segment state="initial">
					<source>This data can be large and take a fair amount of time to download.</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<segment state="initial">
					<source>How the app gets this data during the activation process can have a huge impact on the perceived performance of an app.</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>You could display a loading page, or worse, a splash screen, for minutes if an app tried to download an entire data set it needs for functionality in phase one or two of activation.</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<segment state="initial">
					<source>This makes an app look like it’s hung or cause it to be terminated by the system.</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>We recommend that an app download the minimal amount of data to show an interactive UI with placeholder elements in phase 2 and then progressively load data, which replaces the placeholder elements, in phase 3.</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](optimize-gridview-and-listview.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info on dealing with data, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optimize ListView and GridView</pc>.</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<segment state="initial">
					<source>How exactly an app reacts to each phase of startup is completely up to you, but providing the user as much feedback as possible (splash screen, loading screen, UI while data loads) makes the user feel as though an app, and the system as a whole, are fast.</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>Minimize managed assemblies in the startup path</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>Reusable code often comes in the form of modules (DLLs) included in a project.</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>Loading these modules requires accessing the disk, and as you can imagine, the cost of doing so can add up.</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>This has the greatest impact on cold startup, but it can have an impact on warm startup, too.</source>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<segment state="initial">
					<source>In the case of C# and Visual Basic, the CLR tries to delay that cost as much as possible by loading assemblies on demand.</source>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<segment state="initial">
					<source>That is, the CLR doesn’t load a module until an executed method references it.</source>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<segment state="initial">
					<source>So, reference only assemblies that are necessary to the launch of your app in startup code so that the CLR doesn’t load unnecessary modules.</source>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>If you have unused code paths in your startup path that have unnecessary references, you can move these code paths to other methods to avoid the unnecessary loads.</source>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<segment state="initial">
					<source>Another way to reduce module loads is to combine your app modules.</source>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<segment state="initial">
					<source>Loading one large assembly typically takes less time than loading two small ones.</source>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<segment state="initial">
					<source>This is not always possible, and you should combine modules only if it doesn't make a material difference to developer productivity or code reusability.</source>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=251609)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/ff191077.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>You can use tools such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PerfView</pc> or the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows Performance Analyzer (WPA)</pc> to find out what modules are loaded on startup.</source>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<segment state="initial">
					<source>Make smart web requests</source>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>You can dramatically improve the loading time of an app by packaging its contents locally, including XAML, images, and any other files important to the app.</source>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<segment state="initial">
					<source>Disk operations are faster than network operations.</source>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>If an app needs a particular file at initialization, you can reduce the overall startup time by loading it from disk instead of retrieving it from a remote server.</source>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<segment state="initial">
					<source>Journal and Cache Pages Efficiently</source>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<segment state="initial">
					<source>The Frame control provides navigation features.</source>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<segment state="initial">
					<source>It offers navigation to a Page (Navigate method), navigation journaling (BackStack/ForwardStack properties, GoForward/GoBack method), Page caching (Page.NavigationCacheMode), and serialization support (GetNavigationState method).</source>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<segment state="initial">
					<source>The performance to be aware of with Frame is primarily around the journaling and page caching.</source>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Frame journaling</pc>.</source>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<segment state="initial">
					<source>When you navigate to a page with Frame.Navigate(), a PageStackEntry for the current page is added to Frame.BackStack collection.</source>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<segment state="initial">
					<source>PageStackEntry is relatively small, but there’s no built-in limit to the size of the BackStack collection.</source>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<segment state="initial">
					<source>Potentially, a user could navigate in a loop and grow this collection indefinitely.</source>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<segment state="initial">
					<source>The PageStackEntry also includes the parameter that was passed to the Frame.Navigate() method.</source>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<segment state="initial">
					<source>It’s recommended that that parameter be a primitive serializable type (such as an int or string), in order to allow the Frame.GetNavigationState() method to work.</source>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<segment state="initial">
					<source>But that parameter could potentially reference an object that accounts for more significant amounts of working set or other resources, making each entry in the BackStack that much more expensive.</source>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<segment state="initial">
					<source>For example, you could potentially use a StorageFile as a parameter, and consequently the BackStack is keeping an indefinite number of files open.</source>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<segment state="initial">
					<source>Therefore it’s recommended to keep the navigation parameters small, and to limit the size of the BackStack.</source>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<segment state="initial">
					<source>The BackStack is a standard vector (IList in C#, Platform::Vector in C++/CX), and so can be trimmed simply by removing entries.</source>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Page caching</pc>.</source>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<segment state="initial">
					<source>By default, when you navigate to a page with the Frame.Navigate method, a new instance of the page is instantiated.</source>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<segment state="initial">
					<source>Similarly, if you then navigate back to the previous page with Frame.GoBack, a new instance of the previous page is allocated.</source>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<segment state="initial">
					<source>Frame, though, offers an optional page cache that can avoid these instantiations.</source>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<segment state="initial">
					<source>To get a page put into the cache, use the Page.NavigationCacheMode property.</source>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>Setting that mode to Required will force the page to be cached, setting it to Enabled will allow it to be cached.</source>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<segment state="initial">
					<source>By default the cache size is 10 pages, but this can be overridden with the Frame.CacheSize property.</source>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<segment state="initial">
					<source>All Required pages will be cached, and if there are fewer than CacheSize Required pages, Enabled pages can be cached as well.</source>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<segment state="initial">
					<source>Page caching can help performance by avoiding instantiations, and therefore improving navigation performance.</source>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<segment state="initial">
					<source>Page caching can hurt performance by over-caching and therefore impacting working set.</source>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<segment state="initial">
					<source>Therefore it’s recommend to use page caching as appropriate for your application.</source>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<segment state="initial">
					<source>For example, say you have an app that shows a list of items in a Frame, and when you tap on an item, it navigates the frame to a detail page for that item.</source>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<segment state="initial">
					<source>The list page should probably be set to cache.</source>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<segment state="initial">
					<source>If the detail page is the same for all items, it should probably be cached as well.</source>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<segment state="initial">
					<source>But if the detail page is more heterogeneous, it might be better to leave caching off.</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>