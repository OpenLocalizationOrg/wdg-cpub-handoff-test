<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">67beb04cc87765a4c2edb249a61ba300cd9a7544</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci1\xaml-platform\xaml-namescopes.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">cf6c0aff6d641c26a700ea06b7f59f07e1dd9e28</mda:meta><mda:meta type="olxliffhash">226c1b4d7d75561457010953758ec1c4d79a38e6</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>A XAML namescope stores relationships between the XAML-defined names of objects and their instance equivalents.</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>This concept is similar to the wider meaning of the term namescope in other programming languages and technologies.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>XAML namescopes</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>XAML namescopes</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML namescope</pc> stores relationships between the XAML-defined names of objects and their instance equivalents.</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>This concept is similar to the wider meaning of the term <pc dataRefEnd="id2" dataRefStart="id1" id="p1">namescope</pc> in other programming languages and technologies.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>How XAML namescopes are defined</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>Names in XAML namescopes enable user code to reference the objects that were initially declared in XAML.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>The internal result of parsing XAML is that the runtime creates a set of objects that retain some or all of the relationships these objects had in the XAML declarations.</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>These relationships are maintained as specific object properties of the created objects, or are exposed to utility methods in the programming model APIs.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The most typical use of a name in a XAML namescope is as a direct reference to an object instance, which is enabled by the markup compile pass as a project build action, combined with a generated <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InitializeComponent</pc> method in the partial class templates.</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can also use the utility method <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> yourself at run time to return a reference to objects that were defined with a name in the XAML markup.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>More about build actions and XAML</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>What happens technically is that the XAML itself undergoes a markup compiler pass at the same time that the XAML and the partial class it defines for code-behind are compiled together.</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](x-name-attribute.md)</data>
				</originalData>
				<segment state="initial">
					<source>Each object element with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Name</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:Name attribute</pc> defined in the markup generates an internal field with a name that matches the XAML name.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>This field is initially empty.</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Then the class generates an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InitializeComponent</pc> method that is called only after all the XAML is loaded.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Within the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InitializeComponent</pc> logic, each internal field is then populated with the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FindName</pc></pc> return value for the equivalent name string.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>You can observe this infrastructure for yourself by looking at the ".g" (generated) files that are created for each XAML page in the /obj subfolder of a Windows Runtime app project after compilation.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You can also see the fields and <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InitializeComponent</pc> method as members of your resulting assemblies if you reflect over them or otherwise examine their interface language contents.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Specifically for Visual C++ component extensions (C++/CX) apps, a backing field for an <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:Name</pc> reference is not created for the root element of a XAML file.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>If you need to reference the root object from C++/CX code-behind, use other APIs or tree traversal.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208739)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For example you can call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> for a known named child element and then call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Parent</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Creating objects at run time with XamlReader.Load</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228048)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>XAML can be also be used as the string input for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XamlReader.Load</pc></pc> method, which acts analogously to the initial XAML source parse operation.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlReader.Load</pc> creates a new disconnected tree of objects at run time.</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>The disconnected tree can then be attached to some point on the main object tree.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br210101)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/br243378)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>You must explicitly connect your created object tree, either by adding it to a content property collection such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Children</pc>, or by setting some other property that takes an object value (for example, loading a new <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ImageBrush</pc></pc> for a <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Fill</pc></pc> property value).</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>XAML namescope implications of XamlReader.Load</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228048)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The preliminary XAML namescope defined by the new object tree created by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XamlReader.Load</pc></pc> evaluates any defined names in the provided XAML for uniqueness.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If names in the provided XAML are not internally unique at this point, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlReader.Load</pc> throws an exception.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>The disconnected object tree does not attempt to merge its XAML namescope with the main application XAML namescope, if or when it is connected to the main application object tree.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>After you connect the trees, your app has a unified object tree, but that tree has discrete XAML namescopes within it.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The divisions occur at the connection points between objects, where you set some property to be the value returned from a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlReader.Load</pc> call.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The complication of having discrete and disconnected XAML namescopes is that calls to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> method as well as direct managed object references no longer operate against a unified XAML namescope.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Instead, the particular object that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FindName</pc> is called on implies the scope, with the scope being the XAML namescope that the calling object is within.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>In the direct managed object reference case, the scope is implied by the class where the code exists.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Typically, the code-behind for run-time interaction of a "page" of app content exists in the partial class that backs the root "page", and therefore the XAML namescope is the root XAML namescope.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br228048)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>If you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> to get a named object in the root XAML namescope, the method will not find the objects from a discrete XAML namescope created by <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">XamlReader.Load</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Conversely, if you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FindName</pc> from an object obtained from out of the discrete XAML namescope, the method will not find named objects in the root XAML namescope.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This discrete XAML namescope issue only affects finding objects by name in XAML namescopes when using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> call.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>To get references to objects that are defined in a different XAML namescope, you can use several techniques:</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208739)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br227514)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Walk the entire tree in discrete steps with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Parent</pc></pc> and/or collection properties that are known to exist in your object tree structure (such as the collection returned by <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Panel.Children</pc></pc>).</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>If you are calling from a discrete XAML namescope and want the root XAML namescope, it is always easy to get a reference to the main window currently displayed.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">`Window.Current.Content`</data>
				</originalData>
				<segment state="initial">
					<source>You can get the visual root (the root XAML element, also known as the content source) from the current application window in one line of code with the call <ph dataRef="id1" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208706)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>You can then cast to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement</pc></pc> and call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FindName</pc></pc> from this scope.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228048)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you are calling from the root XAML namescope and want an object within a discrete XAML namescope, the best thing to do is to plan ahead in your code and retain a reference to the object that was returned by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XamlReader.Load</pc></pc> and then added to the main object tree.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This object is now a valid object for calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> within the discrete XAML namescope.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>You could keep this object available as a global variable or otherwise pass it by using method parameters.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>You can avoid names and XAML namescope considerations entirely by examining the visual tree.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br243038)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VisualTreeHelper</pc></pc> API enables you to traverse the visual tree in terms of parent objects and child collections, based purely on position and index.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>XAML namescopes in templates</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Templates in XAML provide the ability to reuse and reapply content in a straightforward way, but templates might also include elements with names defined at the template level.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>That same template might be used multiple times in a page.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>For this reason, templates define their own XAML namescopes, independent of the containing page where the style or template is applied.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>Consider this example:</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>Here, the same template is applied to two different controls.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>If templates did not have discrete XAML namescopes, the "MyTextBlock" name used in the template would cause a name collision.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>However, the root XAML namescope does not contain the name from either template.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>Because of the separate XAML namescopes, finding named elements within a template from the scope of the page where the template is applied requires a different technique.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209416)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Rather than calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> on some object in the object tree, you first obtain the object that has the template applied, and then call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetTemplateChild</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetTemplateChild</pc> method from your control implementation code.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetTemplateChild</pc> method is protected, so only the control author has access to it.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Also, there are conventions that control authors should follow in order to name parts and template parts and report these as attribute values applied to the control class.</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>This technique makes the names of important parts discoverable to control users who might wish to apply a different template, which would need to replace the named parts in order to maintain control functionality.</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>XAML overview</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>x:Name attribute</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>Quickstart: Control templates</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>XamlReader.Load</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>FindName</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>