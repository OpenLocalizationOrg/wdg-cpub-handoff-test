<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">a145ae776cdb0485d5048bfb956b0f33494b7971</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\controls-and-patterns\tiles-and-notifications-periodic-notification-overview.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">5663ca8b8869efb2ffed9e71c74a7340bc44d26f</mda:meta><mda:meta type="olxliffhash">b364ffbbb9c25ad0756fce9a8c702d0657f0b698</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Periodic notifications, which are also called polled notifications, update tiles and badges at a fixed interval by downloading content from a cloud service.</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Periodic notification overview</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Periodic notification overview</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Periodic notifications, which are also called polled notifications, update tiles and badges at a fixed interval by downloading content from a cloud service.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>To use periodic notifications, your client app code needs to provide two pieces of information:</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>The Uniform Resource Identifier (URI) of a web location for Windows to poll for tile or badge updates for your app</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>How often that URI should be polled</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>Periodic notifications enable your app to get live tile updates with minimal cloud service and client investment.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>Periodic notifications are a good delivery method for distributing the same content to a wide audience.</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](http://go.microsoft.com/fwlink/p/?linkid=231476)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   You can learn more by downloading the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Push and periodic notifications sample</pc> for Windows 8.1 and re-using its source code in your Windows 10 app.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>How it works</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Periodic notifications require that your app hosts a cloud service.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>The service will be polled periodically by all users who have the app installed.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>At each polling interval, such as once an hour, Windows sends an HTTP GET request to the URI, downloads the requested tile or badge content (as XML) that is supplied in response to the request, and displays the content on the app's tile.</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Note that periodic updates cannot be used with toast notifications.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh465417)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/xaml/hh868252)</data>
				</originalData>
				<segment state="initial">
					<source>Toast is best delivered through <pc dataRefEnd="id2" dataRefStart="id1" id="p1">scheduled</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">push</pc> notifications.</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>URI location and XML content</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Any valid HTTP or HTTPS web address can be used as the URI to be polled.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>The cloud server's response includes the downloaded content.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tiles-and-notifications-adaptive-tiles-schema.md)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br212851)</data>
				</originalData>
				<segment state="initial">
					<source>The content returned from the URI must conform to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tile</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Badge</pc> XML schema specification, and must be UTF-8 encoded.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#expiry)</data>
					<data id="id3">[</data>
					<data id="id4">](#taggo)</data>
				</originalData>
				<segment state="initial">
					<source>You can use defined HTTP headers to specify the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">expiration time</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">tag</pc> for the notification.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Polling Behavior</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Call one of these methods to begin polling:</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701684)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StartPeriodicUpdate</pc></pc> (Tile)</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701611)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StartPeriodicUpdate</pc></pc> (Badge)</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh967945)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StartPeriodicUpdateBatch</pc></pc> (Tile)</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>When you call one of these methods, the URI is immediately polled and the tile or badge is updated with the received contents.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>After this initial poll, Windows continues to provide updates at the requested interval.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701697)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Polling continues until you explicitly stop it (with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TileUpdater.StopPeriodicUpdate</pc></pc>), your app is uninstalled, or, in the case of a secondary tile, the tile is removed.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Otherwise, Windows continues to poll for updates to your tile or badge even if your app is never launched again.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>The recurrence interval</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>You specify the recurrence interval as a parameter of the methods listed above.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>Note that while Windows makes a best effort to poll as requested, the interval is not precise.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>The requested poll interval can be delayed by up to 15 minutes at the discretion of Windows.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>The start time</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>You optionally can specify a particular time of day to begin polling.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>Consider an app that changes its tile content just once a day.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>In such a case, we recommend that you poll close to the time that you update your cloud service.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>For example, if a daily shopping site publishes the day's offers at 8 AM, poll for new tile content shortly after 8 AM.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>If you provide a start time, the first call to the method polls for content immediately.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>Then, regular polling starts within 15 minutes of the provided start time.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>Automatic retry behavior</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>The URI is polled only if the device is online.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>If the network is available but the URI cannot be contacted for any reason, this iteration of the polling interval is skipped, and the URI will be polled again at the next interval.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>If the device is in an off, sleep, or hibernated state when a polling interval is reached, the URI is polled when the device returns from its off or sleep state.</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Expiration of tile and badge notifications</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>By default, periodic tile and badge notifications expire three days from the time they are downloaded.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>When a notification expires, the content is removed from the badge, tile, or queue and is no longer shown to the user.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>It is a best practice to set an explicit expiration time on all periodic tile and badge notifications, using a time that makes sense for your app or notification, to ensure that the content does not persist longer than it is relevant.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>An explicit expiration time is essential for content with a defined life span.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>It also assures the removal of stale content if your cloud service becomes unreachable, or if the user disconnects from the network for an extended period of time.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Your cloud service sets an expiration date and time for a notification by including the X-WNS-Expires HTTP header in the response payload.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=253706)</data>
				</originalData>
				<segment state="initial">
					<source>The X-WNS-Expires HTTP header conforms to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HTTP-date format</pc>.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701684)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh967945)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StartPeriodicUpdate</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">StartPeriodicUpdateBatch</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>For example, during a stock market's active trading day, you can set the expiration for a stock price update to twice that of your polling interval (such as one hour after receipt if you are polling every half-hour).</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>As another example, a news app might determine that one day is an appropriate expiration time for a daily news tile update.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>Periodic notifications in the notification queue</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh781199)</data>
				</originalData>
				<segment state="initial">
					<source>You can use periodic tile updates with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">notification cycling</pc>.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>By default, a tile on the Start screen shows the content of a single notification until it is replaced by a new notification.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>When you enable cycling, up to five notifications are maintained in a queue and the tile cycles through them.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>If the queue has reached its capacity of five notifications, the next new notification replaces the oldest notification in the queue.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>However, by setting tags on your notifications, you can affect the queue's replacement policy.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh465435.aspx#pncodes_x_wns_tag)</data>
				</originalData>
				<segment state="initial">
					<source>A tag is an app-specific, case-insensitive string of up to 16 alphanumeric characters, specified in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">X-WNS-Tag</pc> HTTP header in the response payload.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>Windows compares the tag of an incoming notification with the tags of all notifications already in the queue.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>If a match is found, the new notification replaces the queued notification with the same tag.</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>If no match is found, the default replacement rule is applied and the new notification replaces the oldest notification in the queue.</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>You can use notification queuing and tagging to implement a variety of rich notification scenarios.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>For example, a stock app could send five notifications, each about a different stock and each tagged with a stock name.</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>This prevents the queue from ever containing two notifications for the same stock, the older of which is out of date.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh781199)</data>
				</originalData>
				<segment state="initial">
					<source>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Using the notification queue</pc>.</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>Enabling the notification queue</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh465429)</data>
				</originalData>
				<segment state="initial">
					<source>To implement a notification queue, first enable the queue for your tile (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">How to use the notification queue with local notifications</pc>).</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>The call to enable the queue needs to be done only once in your app's lifetime, but there is no harm in calling it each time your app is launched.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Polling for more than one notification at a time</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>You must provide a unique URI for each notification that you'd like Windows to download for your tile.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh967945)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>By using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StartPeriodicUpdateBatch</pc></pc> method, you can provide up to five URIs at once for use with the notification queue.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>Each URI is polled for a single notification payload, at or near the same time.</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>Each polled URI can return its own expiration and tag value.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>Guidelines for periodic notifications</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>How to set up periodic notifications for badges</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>How to set up periodic notifications for tiles</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>