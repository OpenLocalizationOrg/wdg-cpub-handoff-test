<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">fe18c8200e4bcdc3420ee4f6d279839ef20963e6</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\winrt-components\creating-windows-runtime-components-in-csharp-and-visual-basic.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">5a930166415287719cc4465770b4a11455b8e471</mda:meta><mda:meta type="olxliffhash">925a9b62e0bb78ce79825e83796a7f3632c8dcda</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Creating Windows Runtime Components in C# and Visual Basic</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Starting with the .NET Framework 4.5, you can use managed code to create your own Windows Runtime types, packaged in a Windows Runtime component.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Creating Windows Runtime Components in C# and Visual Basic</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>\[Some information relates to pre-released product which may be substantially modified before it's commercially released.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Microsoft makes no warranties, express or implied, with respect to the information provided here.\]</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>Starting with the .NET Framework 4.5, you can use managed code to create your own Windows Runtime types, packaged in a Windows Runtime component.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>You can use your component in Universal Windows Platform (UWP) apps with C++, JavaScript, Visual Basic, or C#.</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>This article outlines the rules for creating a component, and discusses some aspects of .NET Framework support for the Windows Runtime.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>In general, that support is designed to be transparent to the .NET Framework programmer.</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>However, when you create a component to use with JavaScript or C++, you need to be aware of differences in the way those languages support the Windows Runtime.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you are creating a component for use only in UWP apps with Visual Basic or C#, and the component does not contain UWP controls, consider using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Class Library</pc> template instead of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows Runtime Component</pc> template.</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>There are fewer restrictions on a simple class library.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>This article contains the following sections:</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Declaring types in Windows Runtime Components</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Internally, the Windows Runtime types in your component can use any .NET Framework functionality that's allowed in a Universal Windows app.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/mt185501.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>(See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">.NET for UWP apps</pc> overview for more information.) Externally, the members of your types can expose only Windows Runtime types for their parameters and return values.</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>The following list describes the limitations on .NET Framework types that are exposed from Windows Runtime Components.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>The fields, parameters, and return values of all the public types and members in your component must be Windows Runtime types.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>This restriction includes the Windows Runtime types that you create as well as types that are provided by the Windows Runtime itself.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>It also includes a number of .NET Framework types.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>The inclusion of these types is part of the support the .NET Framework provides to enable the natural use of the Windows Runtime in managed code: Your code appears to use familiar .NET Framework types instead of the underlying Windows Runtime types.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>For example, you can use .NET Framework primitive types such as Int32 and Double, certain fundamental types such as DateTimeOffset and Uri, and some commonly used generic interface types such as IEnumerable<ph dataRef="id1" id="ph1" />T<ph dataRef="id2" id="ph2" /> (IEnumerable(Of T) in Visual Basic) and IDictionary<ph dataRef="id3" id="ph3" />TKey,TValue<ph dataRef="id4" id="ph4" />.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>(Note that the type arguments of these generic types must be Windows Runtime types.) This is discussed in the sections Passing Windows Runtime types to managed code and Passing managed types to the Windows Runtime, later in this article.</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Public classes and interfaces can contain methods, properties, and events.</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>You can declare delegates for your events, or use the EventHandler<ph dataRef="id1" id="ph1" />T<ph dataRef="id2" id="ph2" /> delegate.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>A public class or interface cannot:</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>Be generic.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>Implement an interface that is not a Windows Runtime interface.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>(However, you can create your own Windows Runtime interfaces and implement them.)</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Derive from types that are not in the Windows Runtime, such as System.Exception and System.EventArgs.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>All public types must have a root namespace that matches the assembly name, and the assembly name must not begin with "Windows".</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc>  By default, Visual Studio projects have namespace names that match the assembly name.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>In Visual Basic, the Namespace statement for this default namespace is not shown in your code.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>Public structures can't have any members other than public fields, and those fields must be value types or strings.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Public classes must be <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sealed</pc> (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">NotInheritable</pc> in Visual Basic).</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>If your programming model requires polymorphism, you can create a public interface and implement that interface on the classes that must be polymorphic.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>Debugging your component</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>If both your Universal Windows app and your component are built with managed code, you can debug them at the same time.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>When you're testing your component as part of a Universal Windows app using C++, you can debug managed and native code at the same time.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>The default is native code only.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>To debug both native C++ code and managed code</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Open the shortcut menu for your Visual C++ project, and choose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Properties</pc>.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In the property pages, under <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Configuration Properties</pc>, choose <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Debugging</pc>.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Choose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Debugger Type</pc>, and in the drop-down list box change <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Native Only</pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Mixed (Managed and Native)</pc>.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Choose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OK</pc>.</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Set breakpoints in native and managed code.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>When you're testing your component as part of a Universal Windows app using JavaScript, by default the solution is in JavaScript debugging mode.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>In Visual Studio, you can't debug JavaScript and managed code at the same time.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>To debug managed code instead of JavaScript</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Open the shortcut menu for your JavaScript project, and choose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Properties</pc>.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In the property pages, under <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Configuration Properties</pc>, choose <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Debugging</pc>.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Choose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Debugger Type</pc>, and in the drop-down list box change <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Script Only</pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Managed Only</pc>.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Choose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OK</pc>.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Set breakpoints in managed code and debug as usual.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>Passing Windows Runtime types to managed code</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>As mentioned previously in the section Declaring types in Windows Runtime Components, certain .NET Framework types can appear in the signatures of members of public classes.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>This is part of the support that the .NET Framework provides to enable the natural use of the Windows Runtime in managed code.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>It includes primitive types and some classes and interfaces.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>When your component is used from JavaScript or from C++ code, it's important to know how your .NET Framework types appear to the caller.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript</pc> for examples with JavaScript.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>This section discusses commonly used types.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>In the .NET Framework, primitive types like the Int32 structure have many useful properties and methods, such as the TryParse method.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>By contrast, primitive types and structures in the Windows Runtime only have fields.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>When you pass these types to managed code, they appear to be .NET Framework types, and you can use the properties and methods of the .NET Framework types as you normally would.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>The following list summarizes the substitutions that are made automatically in the IDE:</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>For the Windows Runtime primitives Int32, Int64, Single, Double, Boolean, String (an immutable collection of Unicode characters), Enum, UInt32, UInt64, and Guid, use the type of the same name in the System namespace.</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>For UInt8, use System.Byte.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>For Char16, use System.Char.</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>For the IInspectable interface, use System.Object.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>If C# or Visual Basic provides a language keyword for any of these types, you can use the language keyword instead.</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>In addition to primitive types, some basic, commonly used Windows Runtime types appear in managed code as their .NET Framework equivalents.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>For example, suppose your JavaScript code uses the Windows.Foundation.Uri class, and you want to pass it to a C# or Visual Basic method.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>The equivalent type in managed code is the .NET Framework System.Uri class, and that's the type to use for the method parameter.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>You can tell when a Windows Runtime type appears as a .NET Framework type, because IntelliSense in Visual Studio hides the Windows Runtime type when you're writing managed code, and presents the equivalent .NET Framework type.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>(Usually the two types have the same name.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>However, note that the Windows.Foundation.DateTime structure appears in managed code as System.DateTimeOffset and not as System.DateTime.)</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>For some commonly used collection types, the mapping is between the interfaces that are implemented by a Windows Runtime type and the interfaces that are implemented by the corresponding .NET Framework type.</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>As with the types mentioned above, you declare parameter types by using the .NET Framework type.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>This hides some differences between the types and makes writing .NET Framework code more natural.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>The following table lists the most common of these generic interface types, along with other common class and interface mappings.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>For a complete list of Windows Runtime types that the .NET Framework maps, see .NET Framework mappings of Windows Runtime types.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>Windows Runtime</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>.NET Framework</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IIterable<ph dataRef="id1" id="ph1" />T</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IEnumerable<ph dataRef="id1" id="ph1" />T</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IVector<ph dataRef="id1" id="ph1" />T</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IList<ph dataRef="id1" id="ph1" />T</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IVectorView<ph dataRef="id1" id="ph1" />T</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IReadOnlyList<ph dataRef="id1" id="ph1" />T</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IMap<ph dataRef="id1" id="ph1" />K, V</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IDictionary<ph dataRef="id1" id="ph1" />TKey, TValue</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IMapView<ph dataRef="id1" id="ph1" />K, V</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IReadOnlyDictionary<ph dataRef="id1" id="ph1" />TKey, TValue</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>IKeyValuePair<ph dataRef="id1" id="ph1" />K, V</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
				</originalData>
				<segment state="initial">
					<source>KeyValuePair<ph dataRef="id1" id="ph1" />TKey, TValue</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>IBindableIterable</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>IEnumerable</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>IBindableVector</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>IList</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>Windows.UI.Xaml.Data.INotifyPropertyChanged</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>System.ComponentModel.INotifyPropertyChanged</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>Windows.UI.Xaml.Data.PropertyChangedEventHandler</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>System.ComponentModel.PropertyChangedEventHandler</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>Windows.UI.Xaml.Data.PropertyChangedEventArgs</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>System.ComponentModel.PropertyChangedEventArgs</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>When a type implements more than one interface, you can use any of the interfaces it implements as a parameter type or return type of a member.</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
					<data id="id5">&amp;lt;</data>
					<data id="id6">&amp;gt;</data>
					<data id="id7">&amp;lt;</data>
					<data id="id8">&amp;lt;</data>
					<data id="id9">&amp;gt;&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>For example, you can pass or return a Dictionary<ph dataRef="id1" id="ph1" />int, string<ph dataRef="id2" id="ph2" /> (Dictionary(Of Integer, String) in Visual Basic) as IDictionary<ph dataRef="id3" id="ph3" />int, string<ph dataRef="id4" id="ph4" />, IReadOnlyDictionary<ph dataRef="id5" id="ph5" />int, string<ph dataRef="id6" id="ph6" />, or IEnumerable<ph dataRef="id7" id="ph7" />System.Collections.Generic.KeyValuePair<ph dataRef="id8" id="ph8" />TKey, TValue<ph dataRef="id9" id="ph9" />.</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>  JavaScript uses the interface that appears first in the list of interfaces that a managed type implements.</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>For example, if you return Dictionary<ph dataRef="id1" id="ph1" />int, string<ph dataRef="id2" id="ph2" /> to JavaScript code, it appears as IDictionary<ph dataRef="id3" id="ph3" />int, string<ph dataRef="id4" id="ph4" /> no matter which interface you specify as the return type.</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>This means that if the first interface doesn't include a member that appears on later interfaces, that member isn't visible to JavaScript.</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>In the Windows Runtime, IMap<ph dataRef="id1" id="ph1" />K, V<ph dataRef="id2" id="ph2" /> and IMapView<ph dataRef="id3" id="ph3" />K, V<ph dataRef="id4" id="ph4" /> are iterated by using IKeyValuePair.</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
					<data id="id5">&amp;lt;</data>
					<data id="id6">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>When you pass them to managed code, they appear as IDictionary<ph dataRef="id1" id="ph1" />TKey, TValue<ph dataRef="id2" id="ph2" /> and IReadOnlyDictionary<ph dataRef="id3" id="ph3" />TKey, TValue<ph dataRef="id4" id="ph4" />, so naturally you use System.Collections.Generic.KeyValuePair<ph dataRef="id5" id="ph5" />TKey, TValue<ph dataRef="id6" id="ph6" /> to enumerate them.</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>The way interfaces appear in managed code affects the way types that implement these interfaces appear.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>For example, the PropertySet class implements IMap<ph dataRef="id1" id="ph1" />K, V<ph dataRef="id2" id="ph2" />, which appears in managed code as IDictionary<ph dataRef="id3" id="ph3" />TKey, TValue<ph dataRef="id4" id="ph4" />.</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>PropertySet appears as if it implemented IDictionary<ph dataRef="id1" id="ph1" />TKey, TValue<ph dataRef="id2" id="ph2" /> instead of IMap<ph dataRef="id3" id="ph3" />K, V<ph dataRef="id4" id="ph4" />, so in managed code it appears to have an Add method, which behaves like the Add method on .NET Framework dictionaries.</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>It doesn't appear to have an Insert method.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)</data>
				</originalData>
				<segment state="initial">
					<source>You can see this example in the article <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript</pc>.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>Passing managed types to the Windows Runtime</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<segment state="initial">
					<source>As discussed in the previous section, some Windows Runtime types can appear as .NET Framework types in the signatures of your component's members, or in the signatures of Windows Runtime members when you use them in the IDE.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<segment state="initial">
					<source>When you pass .NET Framework types to these members or use them as the return values of your component's members, they appear to the code on the other side as the corresponding Windows Runtime type.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)</data>
				</originalData>
				<segment state="initial">
					<source>For examples of the effects this can have when your component is called from JavaScript, see the "Returning managed types from your component" section in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript</pc>.</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>Overloaded methods</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>In the Windows Runtime, methods can be overloaded.</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.defaultoverloadattribute.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>However, if you declare multiple overloads with the same number of parameters, you must apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows.Foundation.Metadata.DefaultOverloadAttribute</pc> attribute to only one of those overloads.</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>That overload is the only one you can call from JavaScript.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, in the following code the overload that takes an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">int</pc> (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">Integer</pc> in Visual Basic) is the default overload.</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>  JavaScript allows you to pass any value to OverloadExample, and coerces the value to the type that is required by the parameter.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>You can call OverloadExample with "forty-two", "42", or 42.3, but all those values are passed to the default overload.</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>The default overload in the previous example returns 0, 42, and 42 respectively.</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>You cannot apply the DefaultOverloadAttribute attribute to constructors.</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>All the constructors in a class must have different numbers of parameters.</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>Implementing IStringable</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>Starting with Windows 8.1, the Windows Runtime includes an IStringable interface whose single method, IStringable.ToString, provides basic formatting support comparable to that provided by Object.ToString.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>If you do choose to implement IStringable in a public managed type that is exported in a Windows Runtime component, the following restrictions apply:</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>You can define the IStringable interface only in a "class implements" relationship, such as the following code in C#:</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>Or the following Visual Basic code:</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>You cannot implement IStringable on an interface.</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<segment state="initial">
					<source>You cannot declare a parameter to be of type IStringable.</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<segment state="initial">
					<source>IStringable cannot be the return type of a method, property, or field.</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>You cannot hide your IStringable implementation from base classes by using a method definition such as the following:</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>Instead, the IStringable.ToString implementation must always override the base class implementation.</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<segment state="initial">
					<source>You can hide a ToString implementation only by invoking it on a strongly typed class instance.</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>Note that under a variety of conditions, calls from native code to a managed type that implements IStringable or hides its ToString implementation can produce unexpected behavior.</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>Asynchronous operations</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
					<data id="id5">&amp;lt;</data>
					<data id="id6">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>To implement an asynchronous method in your component, add "Async" to the end of the method name and return one of the Windows Runtime interfaces that represent asynchronous actions or operations: IAsyncAction, IAsyncActionWithProgress<ph dataRef="id1" id="ph1" />TProgress<ph dataRef="id2" id="ph2" />, IAsyncOperation<ph dataRef="id3" id="ph3" />TResult<ph dataRef="id4" id="ph4" />, or IAsyncOperationWithProgress<ph dataRef="id5" id="ph5" />TResult, TProgress<ph dataRef="id6" id="ph6" />.</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/dd321424.aspx)</data>
					<data id="id5">&amp;lt;</data>
					<data id="id6">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>You can use .NET Framework tasks (the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Task</pc> class and generic <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Task<ph dataRef="id5" id="ph1" />TResult<ph dataRef="id6" id="ph2" /></pc> class) to implement your asynchronous method.</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/system.threading.tasks.task.run.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>You must return a task that represents an ongoing operation, such as a task that is returned from an asynchronous method written in C# or Visual Basic, or a task that is returned from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Task.Run</pc> method.</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/system.threading.tasks.task.start.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>If you use a constructor to create the task, you must call its <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Task.Start</pc> method before returning it.</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A method that uses await (Await in Visual Basic) requires the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> keyword (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">Async</pc> in Visual Basic).</source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If you expose such a method from a Windows Runtime component, apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> keyword to the delegate that you pass to the Run method.</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/system.windowsruntimesystemextensions.asasyncaction.aspx)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/hh779745.aspx)</data>
					<data id="id5">&amp;lt;</data>
					<data id="id6">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>For asynchronous actions and operations that do not support cancellation or progress reporting, you can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">WindowsRuntimeSystemExtensions.AsAsyncAction</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">AsAsyncOperation<ph dataRef="id5" id="ph1" />TResult<ph dataRef="id6" id="ph2" /></pc> extension method to wrap the task in the appropriate interface.</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>For example, the following code implements an asynchronous method by using the Task.Run<ph dataRef="id1" id="ph1" />TResult<ph dataRef="id2" id="ph2" /> method to start a task.</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>The AsAsyncOperation<ph dataRef="id1" id="ph1" />TResult<ph dataRef="id2" id="ph2" /> extension method returns the task as a Windows Runtime asynchronous operation.</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br211867.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>The following JavaScript code shows how the method could be called by using a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">WinJS.Promise</pc> object.</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>The function that is passed to the then method is executed when the asynchronous call completes.</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>The stringList parameter contains the list of strings that is returned by the DownloadAsStringAsync method, and the function does whatever processing is required.</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/system.runtime.interopservices.windowsruntime.asyncinfo.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>For asynchronous actions and operations that support cancellation or progress reporting, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AsyncInfo</pc> class to generate a started task and to hook up the cancellation and progress reporting features of the task with the cancellation and progress reporting features of the appropriate Windows Runtime interface.</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)</data>
				</originalData>
				<segment state="initial">
					<source>For an example that supports both cancellation and progress reporting, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript</pc>.</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>Note that you can use the methods of the AsyncInfo class even if your asynchronous method doesn't support cancellation or progress reporting.</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/hh138298.aspx)</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>If you use a Visual Basic lambda function or a C# anonymous method, don't supply parameters for the token and <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IProgress<ph dataRef="id3" id="ph1" />T<ph dataRef="id4" id="ph2" /></pc> interface.</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>If you use a C# lambda function, supply a token parameter but ignore it.</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/hh779740.aspx)</data>
					<data id="id5">&amp;lt;</data>
					<data id="id6">&amp;gt;</data>
					<data id="id7">&amp;lt;</data>
					<data id="id8">&amp;lt;</data>
					<data id="id9">&amp;gt;&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>The previous example, which used the AsAsyncOperation<ph dataRef="id1" id="ph1" />TResult<ph dataRef="id2" id="ph2" /> method, looks like this when you use the <pc dataRefEnd="id4" dataRefStart="id3" id="p1">AsyncInfo.Run<ph dataRef="id5" id="ph3" />TResult<ph dataRef="id6" id="ph4" />(Func<ph dataRef="id7" id="ph5" />CancellationToken, Task<ph dataRef="id8" id="ph6" />TResult<ph dataRef="id9" id="ph7" /></pc>) method overload instead:</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<originalData>
					<data id="id1">&amp;lt;</data>
					<data id="id2">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>If you create an asynchronous method that optionally supports cancellation or progress reporting, consider adding overloads that don't have parameters for a cancellation token or the IProgress<ph dataRef="id1" id="ph1" />T<ph dataRef="id2" id="ph2" /> interface.</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>Throwing exceptions</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>You can throw any exception type that is included in the .NET for Windows apps.</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>You can't declare your own public exception types in a Windows Runtime component, but you can declare and throw non-public types.</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>If your component doesn't handle the exception, a corresponding exception is raised in the code that called your component.</source>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<segment state="initial">
					<source>The way the exception appears to the caller depends on the way the calling language supports the Windows Runtime.</source>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<segment state="initial">
					<source>In JavaScript, the exception appears as an object in which the exception message is replaced by a stack trace.</source>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<segment state="initial">
					<source>When you debug your app in Visual Studio, you can see the original message text displayed in the debugger exception dialog box, identified as "WinRT Information".</source>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>You can't access the original message text from JavaScript code.</source>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc>  Currently, the stack trace contains the managed exception type, but we don't recommend parsing the trace to identify the exception type.</source>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<segment state="initial">
					<source>Instead, use an HRESULT value as described later in this section.</source>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<segment state="initial">
					<source>In C++, the exception appears as a platform exception.</source>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh710414.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>If the managed exception's HResult property can be mapped to the HRESULT of a specific platform exception, the specific exception is used; otherwise, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Platform::COMException</pc> exception is thrown.</source>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<segment state="initial">
					<source>The message text of the managed exception is not available to C++ code.</source>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>If a specific platform exception was thrown, the default message text for that exception type appears; otherwise, no message text appears.</source>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh699896.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Exceptions (C++/CX)</pc>.</source>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>In C# or Visual Basic, the exception is a normal managed exception.</source>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<segment state="initial">
					<source>When you throw an exception from your component, you can make it easier for a JavaScript or C++ caller to handle the exception by throwing a non-public exception type whose HResult property value is specific to your component.</source>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh710415.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>The HRESULT is available to a JavaScript caller through the exception object's number property, and to a C++ caller through the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">COMException::HResult</pc> property.</source>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Use a negative value for your HRESULT.</source>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<segment state="initial">
					<source>A positive value is interpreted as success, and no exception is thrown in the JavaScript or C++ caller.</source>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<segment state="initial">
					<source>Declaring and raising events</source>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<segment state="initial">
					<source>When you declare a type to hold the data for your event, derive from Object instead of from EventArgs, because EventArgs is not a Windows Runtime type.</source>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/db0etb8x.aspx)</data>
					<data id="id3">&amp;lt;</data>
					<data id="id4">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EventHandler<ph dataRef="id3" id="ph1" />TEventArgs<ph dataRef="id4" id="ph2" /></pc> as the type of the event, and use your event argument type as the generic type argument.</source>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<segment state="initial">
					<source>Raise the event just as you would in a .NET Framework application.</source>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<segment state="initial">
					<source>When your Windows Runtime component is used from JavaScript or C++, the event follows the Windows Runtime event pattern that those languages expect.</source>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<segment state="initial">
					<source>When you use the component from C# or Visual Basic, the event appears as an ordinary .NET Framework event.</source>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">]()</data>
				</originalData>
				<segment state="initial">
					<source>An example is provided in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript</pc>.</source>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If you implement custom event accessors (declare an event with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom</pc> keyword, in Visual Basic), you must follow the Windows Runtime event pattern in your implementation.</source>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](custom-events-and-event-accessors-in-windows-runtime-components.md)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom events and event accessors in Windows Runtime Components</pc>.</source>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<segment state="initial">
					<source>Note that when you handle the event from C# or Visual Basic code, it still appears to be an ordinary .NET Framework event.</source>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<segment state="initial">
					<source>Next steps</source>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<segment state="initial">
					<source>After you’ve created a Windows Runtime component for your own use, you may find that the functionality it encapsulates is useful to other developers.</source>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<segment state="initial">
					<source>You have two options for packaging a component for distribution to other developers.</source>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/jj614475.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Distributing a managed Windows Runtime component</pc>.</source>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/br212458.aspx)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about Visual Basic and C# language features, and .NET Framework support for the Windows Runtime, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Visual Basic and C# language reference</pc>.</source>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<segment state="initial">
					<source>.NET for Windows Store Apps Overview</source>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<segment state="initial">
					<source>.NET for UWP apps</source>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<segment state="initial">
					<source>Walkthrough: Creating a Simple Windows Runtime Component and calling it from JavaScript</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>