<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">a881a1a8fcfb22a48bae33d10654fb1b2096f76a</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\tutorial--assembling-the-rendering-pipeline.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">f8894a24097a2d49f369c37ae7b6a2bd42be7290</mda:meta><mda:meta type="olxliffhash">e69ca8b2fb7ea969974ad1792ee5255d9afd3c51</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Assemble the rendering framework</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Now, it's time to look at how the sample game uses that structure and state to display its graphics.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Assemble the rendering framework</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>By now, you've seen how to structure a Universal Windows Platform (UWP) game to work with the Windows Runtime, and how to define a state machine to handle the flow of the game.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Now, it's time to look at how the sample game uses that structure and state to display its graphics.</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>Here, we look at how to implement a rendering framework, starting from the initialization of the graphics device through the presentation of the graphics objects for display.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>Objective</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>To understand how to set up a basic rendering framework to display the graphics output for a UWP DirectX game.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](#code_sample)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The following code files are not discussed here, but provide classes and methods referred to in this topic and are <pc dataRefEnd="id4" dataRefStart="id3" id="p2">provided as code at the end of this topic</pc>:</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Animate.h/.cpp</pc>.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicLoader.h/.cpp</pc>.</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Provides methods for loading meshes, shaders and textures, both synchronously and asynchronously.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>Very useful!</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">MeshObject.h/.cpp</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SphereMesh.h/.cpp</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CylinderMesh.h/.cpp</pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p4">FaceMesh.h/.cpp</pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5">WorldMesh.h/.cpp</pc>.</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Contains the definitions of the object primitives used in the game, such as the ammo spheres, the cylinder and cone obstacles, and the walls of the shooting gallery.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>(<pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameObject.cpp</pc>, briefly discussed in this topic, contains the method for rendering these primitives.)</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Level.h/.cpp</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Level\[1-6\].h/.cpp</pc>.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>Contains the configuration for each of the games six levels, including the success criteria and the number and position of the targets and obstacles.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">TargetTexture.h/.cpp</pc>.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>Contains a set of methods for drawing the bitmaps used as the textures on the targets.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>These files contain code that is not specific to UWP DirectX games.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>But you can review them separately if you'd like more implementation details.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#code_sample)</data>
				</originalData>
				<segment state="initial">
					<source>This section covers three key files from the game sample (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">provided as code at the end of this topic</pc>):</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Camera.h/.cpp</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>GameRenderer.h/.cpp</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>PrimObject.h/.cpp</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>Again, we assume that you understand basic 3D programming concepts like meshes, vertices, and textures.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476345)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about Direct3D 11 programming in general, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Programming Guide for Direct3D 11</pc>.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>With that said, let's look at the work that must be done to put our game on the screen.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>An overview of the Windows Runtime and DirectX</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>DirectX is a fundamental part of the Windows Runtime and of the Windows 10 experience.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404534)</data>
				</originalData>
				<segment state="initial">
					<source>All of Windows 10's visuals are built on top of DirectX, and you have the same direct line to the same low-level graphics interface, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DXGI</pc>, which provides an abstraction layer for the graphics hardware and its drivers.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>All the Direct3D 11 APIs are available for you to talk to DXGI directly.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>The result is fast, high performing graphics in your games that give you access to all the latest graphics hardware features.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh700482)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh700478)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>To add DirectX support to a UWP app, you create a view provider for DirectX resources by implementing the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IFrameworkViewSource</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IFrameworkView</pc></pc> interfaces.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>These provide a factory pattern for your view provider type and the implementation of your DirectX view provider, respectively.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br225016)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The UWP singleton, represented by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreApplication</pc></pc> object, runs this implementation.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--building-the-games-metro-style-app-framework.md)</data>
				</originalData>
				<segment state="initial">
					<source>In <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Defining the game's UWP framework</pc>, we looked at how the renderer fit into the game sample's app framework.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Now, let's look at how the game renderer connects to the view and builds the graphics that define the look of the game.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>Defining the renderer</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameRenderer</pc> abstract type inherits from the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectXBase</pc> renderer type, adds support for stereo 3-D, and declares constant buffers and resources for the shaders that create and define our graphic primitives.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's the definition of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameRenderer</pc>.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br244983)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Because the Direct3D 11 APIs are defined as COM APIs, you must provide <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ComPtr</pc></pc> references to the objects defined by these APIs.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>These objects are automatically freed when their last reference goes out of scope when the app terminates.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>The game sample declares 4 specific constant buffers:</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_constantBufferNeverChanges</pc>.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>This constant buffer contains the lighting parameters.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>It's set one time and never changes again.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_constantBufferChangeOnResize</pc>.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>This constant buffer contains the projection matrix.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>The projection matrix is dependent on the size and aspect ratio of the window.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>It's updated only when the window size changes.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_constantBufferChangesEveryFrame</pc>.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>This constant buffer contains the view matrix.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>This matrix is dependent on the camera position and look direction (the normal to the projection) and changes only one time per frame.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_constantBufferChangesEveryPrim</pc>.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>This constant buffer contains the model matrix and material properties of each primitive.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>The model matrix transforms vertices from local coordinates into world coordinates.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>These constants are specific to each primitive and are updated for every draw call.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>The whole idea of multiple constant buffers with different frequencies is to reduce the amount of data that must be sent to the GPU per frame.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>Therefore, the sample separates constants into different buffers based on the frequency that they must be updated.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>This is a best practice for Direct3D programming.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The renderer contains the shader objects that compute our primitives and textures: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_vertexShader</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">m\_pixelShader</pc>.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>The vertex shader processes the primitives and the basic lighting, and the pixel shader (sometimes called a fragment shader) processes the textures and any per-pixel effects.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>There are two versions of these shaders (regular and flat) for rendering different primitives.</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>The flat versions are much simpler and don't do specular highlights or any per pixel lighting effects.</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>These are used for the walls and make rendering faster on lower powered devices.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff729481)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The renderer class contains the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectWrite and Direct2D</pc> resources used for the overlay and the Heads Up Display (the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GameHud</pc> object).</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>The overlay and HUD are drawn on top of the render target when projection is complete in the graphics pipeline.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>The renderer also defines the shader resource objects that hold the textures for the primitives.</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>Some of these textures are pre-defined (DDS textures for the walls and floor of the world as well as the ammo spheres).</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>Now, it's time to see how this object is created!</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>Initializing the renderer</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The sample game calls this <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Initialize</pc> method as part of the CoreApplication initialization sequence in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">App::SetWindow</pc>.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>This is a pretty straightforward method.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>It checks to see if the renderer had been previously initialized, and if it hasn't, it instantiates the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameHud</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GameInfoOverlay</pc> objects.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>After that, the renderer initialization process runs the base implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Initialize</pc> provided on the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectXBase</pc> class it inherited from.</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When the DirectXBase initialization completes, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameInfoOverlay</pc> object is initialized.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>After initialization is complete, it's time to look at the methods for creating and loading the graphics resources for the game.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>Creating and loading DirectX graphics resources</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>The first order of business in any game is to establish a connection to our graphics interface, create the resources we need to draw the graphics, and then set up a render target into which we can draw those graphics.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In the game sample (and in the Microsoft Visual Studio<pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectX 11 App (Universal Windows)</pc> template), this process is implemented with three methods:</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>CreateDeviceIndependentResources</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>CreateDeviceResources</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>CreateWindowSizeDependentResources</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Now, in the game sample, we override two of these methods (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDeviceIndependentResources</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDeviceResources</pc>) provided on the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DirectXBase</pc> class implemented in the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">DirectX 11 App (Universal Windows)</pc> template.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For each of these override methods, we first call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXBase</pc> implementations they override, and then add more implementation details specific to the game sample.</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Be aware that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXBase</pc> class implementation included with the game sample has been modified from the version provided in the Visual Studio template to include stereoscopic view support and includes pre-rotation of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SwapBuffer</pc> object.</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateWindowSizeDependentResources</pc> is not overridden by the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GameRenderer</pc> object.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>We use the implementation of it provided in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXBase</pc> class.</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh465077)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXBase</pc> base implementations of these methods, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">How to set up your UWP DirectX app to display a view</pc>.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/dd368038)</data>
				</originalData>
				<segment state="initial">
					<source>The first of these overridden methods, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDeviceIndependentResources</pc>, calls the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GameHud::CreateDeviceIndependentResources</pc> method to create the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DirectWrite</pc> text resources that use the Segoe UI font, which is the font used by most UWP apps.</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>CreateDeviceIndependentResources</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>The sample uses four text formatters: two for title header and title body text, and two for body text.</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>This is used in much of the overlay text.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The second method, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDeviceResources</pc>, loads the specific resources for the game that will be computed on the graphics device.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>Let's look at the code for this method.</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>CreateDeviceResources</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In this example, in normal execution, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDeviceResources</pc> method just calls the base class method and then calls the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GameHud::CreateDeviceResources</pc> method (also listed previously).</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>If there's a problem later with the underlying graphics device, it might have to be re-initialized.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In this case, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDeviceResources</pc> method initiates a set of async tasks to create the game device resources.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This is done through a sequence of two methods: a call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDeviceResourcesAsync</pc>, and then, when it completes, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">FinalizeCreateGameDeviceResources</pc>.</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>CreateGameDeviceResourcesAsync and FinalizeCreateGameDeviceResources</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDeviceResourcesAsync</pc> is a method that runs as a separate set of async tasks to load the game resources.</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Because it's expected to run on a separate thread, it only has access to the Direct3D 11 device methods (those defined on <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device</pc></pc>) and not the device context methods (the methods defined on <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceContext</pc></pc>), so it has the option to not perform any rendering.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FinalizeCreateGameDeviceResources</pc> method runs on the main thread and does have access to the Direct3D 11 device context methods.</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>The sequence of events for loading the game devices resources proceeds as follows.</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDeviceResourcesAsync</pc> first initializes constant buffers for the primitives.</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>Constant buffers are low-latency, fixed-width buffers that hold the data that a shader uses during shader execution.</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>(Think of these buffers as passing data to the shader that is constant over the execution of the particular draw call.) In this sample, the buffers contain the data that the shaders will use to:</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>Place the light sources and set their color when the renderer initializes</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>Compute the view matrix whenever the window is resized</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>Compute the projection matrix for every frame update</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<segment state="initial">
					<source>Compute the transformations of the primitives on every render update</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>The constants receive the source information (vertices) and transform the vertex coordinates and data from model space into the device space.</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>Ultimately, this data results in texel coordinates and pixels in the render target.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>Next, the game renderer object creates a loader for the shaders that will perform the computation.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>(See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicLoader.cpp</pc> in the sample for the specific implementation.)</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Then, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDeviceResourcesAsync</pc> initiates async tasks for loading all the texture resources into <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ShaderResourceViews</pc>.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<segment state="initial">
					<source>These texture resources are stored in the DirectDraw Surface (DDS) textures that came with the sample.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>DDS textures are a lossy texture format that work with DirectX Texture Compression (DXTC).</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>We use these textures on the walls, ceiling and floor of the world, and on the ammo spheres and pillar obstacles.</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>Finally, it returns a task group that contains all the async tasks created by the method.</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The calling function waits for the completion of all these async tasks, and then calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FinalizeCreateGameDeviceResources</pc>.</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff476486)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">`m_deviceContext-&gt;UpdateSubresource`</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">FinalizeCreateGameDeviceResources</pc> loads the initial data into the constant buffers with a device context method call to <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID3D11DeviceContext::UpdateSubresource</pc></pc>: <ph dataRef="id7" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>This method creates the mesh objects for the sphere, cylinder, face, and world game objects and the associated materials.</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<segment state="initial">
					<source>It then walks the game object list associating the appropriate device resources with each object.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The textures for the ringed and numbered target objects are procedurally generated using the code in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TargetTexture.cpp</pc>.</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The renderer creates an instance of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TargetTexture</pc> type, which creates the bitmap texture for the target objects in the game when we call the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">TargetTexture::CreateTextureResourceView</pc> method.</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>The resulting texture is composed of concentric colored rings, with a numeric value on the top.</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>These generated resources are associated with the appropriate target game objects.</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">`m_gameResourcesLoaded`</data>
				</originalData>
				<segment state="initial">
					<source>Lastly, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FinalizeCreateGameDeviceResources</pc> set the <ph dataRef="id3" id="ph1" /> Boolean global variable to indicate that all resources are now loaded.</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>The game has the resources to display the graphics in the current window, and it can recreate those resources as the window changes.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>Now, let's look at the camera used to define the player's view of the scene in that window.</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>Implementing the camera object</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>The game has the code in place to update the world in its own coordinate system (sometimes called the world space or scene space).</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>All objects, including the camera, are positioned and oriented in this space.</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<segment state="initial">
					<source>In the sample game, the camera's position along with the look vectors (the "look at" vector that points directly into the scene from the camera, and the "look up" vector that is upwards perpendicular to it) define the camera space.</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<segment state="initial">
					<source>The projection parameters determine how much of that space is actually visible in the final scene; and the Field of View (FoV), aspect ratio, and clipping planes define the projection transformation.</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>A vertex shader does the heavy lifting of converting from the model coordinates to device coordinates with the following algorithm (where V is a vector and M is a matrix):</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>.</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<segment state="initial">
					<source>is a transformation matrix for model coordinates to world coordinates.</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>This is provided by the primitive.</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>(We'll review this in the section on primitives, here.)</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>is a transformation matrix for world coordinates to view coordinates.</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>This is provided by the view matrix of the camera.</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>is a transformation matrix for view coordinates to device coordinates.</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>This is provided by the projection of the camera.</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The shader code in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">VertexShader.hlsl</pc> is loaded with these vectors and matrices from the constant buffers, and performs this transformation for every vertex.</source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Camera</pc> object defines the view and projection matrices.</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>Let's look at how the sample game declares it.</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>There are two 4x4 matrices that define the transformations to the view and projection coordinates, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_viewMatrix</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">m\_projectionMatrix</pc>.</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<segment state="initial">
					<source>(For stereo projection, you use two projection matrices: one for each eye's view.) They are calculated with these two methods, respectively:</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>SetViewParams</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>SetProjParams</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>The code for these two methods looks like this:</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>We get the resulting view and projection data by calling the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">View</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Projection</pc> methods, respectively, on the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Camera</pc> object.</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>These calls occur in the next step we review, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameRenderer::Render</pc> method called in the game loop.</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>Now, let's look at how the game creates the framework to draw our game graphics using the camera.</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<segment state="initial">
					<source>This includes defining the primitives that comprise the game world and its elements.</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>Defining the primitives</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<segment state="initial">
					<source>In the game sample code, we define and implement the primitives in two base classes and the corresponding specializations for each primitive type.</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">MeshObject.h/.cpp</pc> defines the base class for all mesh objects.</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SphereMesh.h/.cpp</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CylinderMesh.h/.cpp</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">FaceMesh.h/.cpp</pc>, and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">WorldMesh.h/.cpp</pc> files contain the code that populates the constant buffers for each primitive with the vertex and vertex normal data that defines the primitive's geometry.</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>These code files are a good place to start if you're looking to understand how to create Direct3D primitives in your own game app, but we won't cover them here as it's too specific to this game's implementation.</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>For now, we assume that the vertex buffers for each primitive have been populated, and look at how the game sample handles those buffers to update the game itself.</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The base class for objects that represent the primitives from the perspective of the game is defined in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameObject.h./.cpp.</pc></source>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This class, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameObject</pc>, defines the fields and methods for the common behaviors across all primitives.</source>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<segment state="initial">
					<source>Each primitive object type derives from it.</source>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<segment state="initial">
					<source>Let's look at how it's defined:</source>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>Most of the fields contain data about the state, visual properties, or position of the primitive in the game world.</source>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<segment state="initial">
					<source>There are a few methods in particular that are necessary in most games:</source>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Mesh</pc>.</source>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Gets the mesh geometry for the primitive, which is stored in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_mesh</pc>.</source>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This geometry is defined in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MeshObject.h/.cpp</pc>.</source>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">IsTouching</pc>.</source>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>This method determines if the primitive is within a specific distance of a point, and returns the point on the surface closest to the point and the normal to the surface of the object at that point.</source>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<segment state="initial">
					<source>Because the sample is only concerned with ammo-primitive collisions, this is enough for the game's dynamics.</source>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>It is not a general purpose primitive-primitive intersection function, although it could be used as the basis for one.</source>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">AnimatePosition</pc>.</source>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<segment state="initial">
					<source>Updates the movement and animation for the primitive.</source>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">UpdatePosition</pc>.</source>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<segment state="initial">
					<source>Updates the position of the object in the world coordinate space.</source>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Render</pc>.</source>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<segment state="initial">
					<source>Puts the material properties of the primitive into the primitive constant buffer and then renders (draws) the primitive geometry using the device context.</source>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<segment state="initial">
					<source>It's a good practice to create a base object type that defines the minimum set of methods for a primitive because most games have a very large number of primitives, and the code can quickly become difficult to manage.</source>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<segment state="initial">
					<source>It also simplifies game code when the update loop can treat the primitives polymorphically, letting the objects themselves define their own update and rendering behaviors.</source>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<segment state="initial">
					<source>Let's look at the basic rendering of a primitive in the game sample.</source>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<segment state="initial">
					<source>Rendering the primitives</source>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The primitives in the game sample use the base <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Render</pc> method implemented on the parent <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GameObject</pc> class, as here:</source>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameObject::Render</pc> method updates the primitive constant buffer with the data specific to a given primitive.</source>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<segment state="initial">
					<source>The game uses multiple constant buffers, but only needs to update these buffers one time per primitive.</source>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<segment state="initial">
					<source>Think of the constant buffers as input to the shaders that run for each primitive.</source>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Some data is static (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_constantBufferNeverChanges</pc>); some data is constant over the frame (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">m\_constantBufferChangesEveryFrame)</pc>, like the position of the camera; and some data is specific to the primitive, like its color and textures (<pc dataRefEnd="id6" dataRefStart="id5" id="p3">m\_constantBufferChangesEveryPrim</pc>).</source>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<segment state="initial">
					<source>The game renderer separates these inputs into different constant buffers to optimize the memory bandwidth that the CPU and GPU use.</source>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<segment state="initial">
					<source>This approach also helps to minimize the amount of data the GPU needs to keep track of.</source>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Remember, the GPU has a big queue of commands, and each time the game calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Draw</pc>, that command is queued along with the data associated with it.</source>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When the game updates the primitive constant buffer and issues the next <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Draw</pc> command, the graphics driver adds this next command and the associated data to the queue.</source>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>If the game draws 100 primitives, it could potentially have 100 copies of the constant buffer data in the queue.</source>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<segment state="initial">
					<source>We want to minimize the amount of data the game is sending to the GPU, so the game uses a separate primitive constant buffer that only contains the updates for each primitive.</source>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If a collision (a hit) is detected, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameObject::Render</pc> checks the current context, which indicates whether the target has been hit by an ammo sphere.</source>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<segment state="initial">
					<source>If the target has been hit, this method applies a hit material, which reverses the colors of the rings of the target to indicate a successful hit to the player.</source>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<segment state="initial">
					<source>Otherwise, it applies the default material with the same method.</source>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In both cases, it sets the material by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Material::RenderSetup</pc>, which sets the appropriate constants into the constant buffer.</source>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476473)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>Then, it calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext::PSSetShaderResources</pc></pc> to set the corresponding texture resource for the pixel shader, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceContext::VSSetShader</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ID3D11DeviceContext::PSSetShader</pc></pc> to set the vertex shader and pixel shader objects themselves, respectively.</source>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's how <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Material::RenderSetup</pc> configures the constant buffers and assigns the shader resources.</source>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<segment state="initial">
					<source>Again, note that the constant buffer is the one used for updating changes to primitives, specifically.</source>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Material</pc> class is defined in <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Material.h/.cpp</pc>.</source>
				</segment>
			</unit>
			<unit id="311" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Finally, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PrimObject::Render</pc> calls the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Render</pc> method for the underlying <pc dataRefEnd="id6" dataRefStart="id5" id="p3">MeshObject</pc> object.</source>
				</segment>
			</unit>
			<unit id="312" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Now, the game sample’s <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MeshObject::Render</pc> method queues the drawing command to execute the shaders on the GPU using the current scene state.</source>
				</segment>
			</unit>
			<unit id="313" translate="yes">
				<segment state="initial">
					<source>The vertex shader converts the geometry (vertices) from model coordinates into device (world) coordinates, taking into account where the camera is and the perspective transformation.</source>
				</segment>
			</unit>
			<unit id="314" translate="yes">
				<segment state="initial">
					<source>Lastly, the pixel shaders render the transformed triangles into the back buffer using the texture set above.</source>
				</segment>
			</unit>
			<unit id="315" translate="yes">
				<segment state="initial">
					<source>This happens on the actual rendering process!</source>
				</segment>
			</unit>
			<unit id="316" translate="yes">
				<segment state="initial">
					<source>Creating the vertex and pixel shaders</source>
				</segment>
			</unit>
			<unit id="317" translate="yes">
				<segment state="initial">
					<source>At this point, the game sample has defined the primitives to draw and the constant buffers that define their rendering.</source>
				</segment>
			</unit>
			<unit id="318" translate="yes">
				<segment state="initial">
					<source>These constant buffers serve as the sets of parameters to the shaders that run on the graphics device.</source>
				</segment>
			</unit>
			<unit id="319" translate="yes">
				<segment state="initial">
					<source>These shader programs come in two types:</source>
				</segment>
			</unit>
			<unit id="320" translate="yes">
				<segment state="initial">
					<source>Vertex shaders perform per-vertex operations, such as vertex transformations and lighting.</source>
				</segment>
			</unit>
			<unit id="321" translate="yes">
				<segment state="initial">
					<source>Pixel (or fragment) shaders perform per-pixel operations, such as texturing and per-pixel lighting.</source>
				</segment>
			</unit>
			<unit id="322" translate="yes">
				<segment state="initial">
					<source>They can also be used to perform post-processing effects on bitmaps, such as the final render target.</source>
				</segment>
			</unit>
			<unit id="323" translate="yes">
				<segment state="initial">
					<source>The shader code is defined using High-Level Shader Language (HLSL), which, in Direct3D 11, is compiled from a program created with a C-like syntax.</source>
				</segment>
			</unit>
			<unit id="324" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509635)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>(The complete syntax can be found <pc dataRefEnd="id2" dataRefStart="id1" id="p1">here</pc>.) The two principal shaders for the sample game are defined in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">PixelShader.hlsl</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">VertexShader.hlsl</pc>.</source>
				</segment>
			</unit>
			<unit id="325" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>(There are also two "low power" shaders defined for low power devices: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PixelShaderFlat.hlsl</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">VertexShaderFlat.hlsl</pc>.</source>
				</segment>
			</unit>
			<unit id="326" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>These two shaders provide reduced effects, such as a lack of specular highlights on textures surfaces.) FInally, there is an .hlsli file that contains the format of the constant buffers, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConstantBuffers.hlsli</pc>.</source>
				</segment>
			</unit>
			<unit id="327" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConstantBuffers.hlsli</pc> is defined like this:</source>
				</segment>
			</unit>
			<unit id="328" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">VertexShader.hlsl</pc> is defined like this:</source>
				</segment>
			</unit>
			<unit id="329" translate="yes">
				<segment state="initial">
					<source>VertexShader.hlsl</source>
				</segment>
			</unit>
			<unit id="330" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">main</pc> function in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">VertexShader.hlsl</pc> performs the vertex transformation sequence we discussed in the camera section.</source>
				</segment>
			</unit>
			<unit id="331" translate="yes">
				<segment state="initial">
					<source>It's run one time per vertex.</source>
				</segment>
			</unit>
			<unit id="332" translate="yes">
				<segment state="initial">
					<source>The resultant outputs are passed to the pixel shader code for texturing and material effects.</source>
				</segment>
			</unit>
			<unit id="333" translate="yes">
				<segment state="initial">
					<source>PixelShader.hlsl</source>
				</segment>
			</unit>
			<unit id="334" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">main</pc> function in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">PixelShader.hlsl</pc> takes the 2-D projections of the triangle surfaces for each primitive in the scene, and computes the color value for each pixel of the visible surfaces based on the textures and effects (in this case, specular lighting) applied to them.</source>
				</segment>
			</unit>
			<unit id="335" translate="yes">
				<segment state="initial">
					<source>Now, let's bring all these ideas (primitives, camera, and shaders) together, and see how the sample game builds the complete rendering process.</source>
				</segment>
			</unit>
			<unit id="336" translate="yes">
				<segment state="initial">
					<source>Rendering the frame for output</source>
				</segment>
			</unit>
			<unit id="337" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--defining-the-main-game-loop.md)</data>
				</originalData>
				<segment state="initial">
					<source>We briefly discussed this method in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Defining the main game object</pc>.</source>
				</segment>
			</unit>
			<unit id="338" translate="yes">
				<segment state="initial">
					<source>Now, let's look at it in a little more detail.</source>
				</segment>
			</unit>
			<unit id="339" translate="yes">
				<segment state="initial">
					<source>The game has all the pieces to assemble a view for output: primitives and the rules for their behavior, a camera object to provide the player's view of the game world, and the graphics resources for drawing.</source>
				</segment>
			</unit>
			<unit id="340" translate="yes">
				<segment state="initial">
					<source>Now, let's look at the process that brings it all together.</source>
				</segment>
			</unit>
			<unit id="341" translate="yes">
				<segment state="initial">
					<source>If stereo 3D is enabled, set the following rendering process to run two times, one time for each eye.</source>
				</segment>
			</unit>
			<unit id="342" translate="yes">
				<segment state="initial">
					<source>The whole scene is enclosed in a bounding world volume, so draw every pixel (even those we don’t need) to clear the color planes of the render target.</source>
				</segment>
			</unit>
			<unit id="343" translate="yes">
				<segment state="initial">
					<source>Set the depth stencil buffer to the default value.</source>
				</segment>
			</unit>
			<unit id="344" translate="yes">
				<segment state="initial">
					<source>Update the constant buffer for frame update data by using the camera's view matrix and data.</source>
				</segment>
			</unit>
			<unit id="345" translate="yes">
				<segment state="initial">
					<source>Set up the Direct3D context to use the four content buffers that were defined earlier.</source>
				</segment>
			</unit>
			<unit id="346" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Render</pc> method on each primitive object.</source>
				</segment>
			</unit>
			<unit id="347" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This results in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Draw</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DrawIndexed</pc> call on the context to draw the geometry of that each primitive.</source>
				</segment>
			</unit>
			<unit id="348" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Specifically, this <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Draw</pc> call queues commands and data to the GPU, as parameterized by the constant buffer data.</source>
				</segment>
			</unit>
			<unit id="349" translate="yes">
				<segment state="initial">
					<source>Each draw call executes the vertex shader one time per vertex, and then the pixel shader one time for every pixel of each triangle in the primitive.</source>
				</segment>
			</unit>
			<unit id="350" translate="yes">
				<segment state="initial">
					<source>The textures are part of the state that the pixel shader uses to do the rendering.</source>
				</segment>
			</unit>
			<unit id="351" translate="yes">
				<segment state="initial">
					<source>Draw the HUD and the overlay using the Direct2D context.</source>
				</segment>
			</unit>
			<unit id="352" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXBase::Present</pc>.</source>
				</segment>
			</unit>
			<unit id="353" translate="yes">
				<segment state="initial">
					<source>And the game has updated the display!</source>
				</segment>
			</unit>
			<unit id="354" translate="yes">
				<segment state="initial">
					<source>Altogether, this is the basic process for implementing the graphics framework of a game.</source>
				</segment>
			</unit>
			<unit id="355" translate="yes">
				<segment state="initial">
					<source>Of course, the larger your game, the more abstractions you must put in place to handle that complexity, such as entire hierarchies of object types and animation behaviors, and more complex methods for loading and managing assets such as meshes and textures.</source>
				</segment>
			</unit>
			<unit id="356" translate="yes">
				<segment state="initial">
					<source>Next steps</source>
				</segment>
			</unit>
			<unit id="357" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--adding-a-user-interface.md)</data>
					<data id="id3">[</data>
					<data id="id4">](tutorial--adding-controls.md)</data>
					<data id="id5">[</data>
					<data id="id6">](tutorial--adding-sound.md)</data>
				</originalData>
				<segment state="initial">
					<source>Moving forward, let's look at a few important parts of the game sample that we've only discussed in passing: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">the user interface overlay</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">the input controls</pc>, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">the sound</pc>.</source>
				</segment>
			</unit>
			<unit id="358" translate="yes">
				<segment state="initial">
					<source>Complete sample code for this section</source>
				</segment>
			</unit>
			<unit id="359" translate="yes">
				<segment state="initial">
					<source>Camera.h</source>
				</segment>
			</unit>
			<unit id="360" translate="yes">
				<segment state="initial">
					<source>Camera.cpp</source>
				</segment>
			</unit>
			<unit id="361" translate="yes">
				<segment state="initial">
					<source>GameRenderer.h</source>
				</segment>
			</unit>
			<unit id="362" translate="yes">
				<segment state="initial">
					<source>GameRenderer.cpp</source>
				</segment>
			</unit>
			<unit id="363" translate="yes">
				<segment state="initial">
					<source>GameObject.h</source>
				</segment>
			</unit>
			<unit id="364" translate="yes">
				<segment state="initial">
					<source>GameObject.cpp</source>
				</segment>
			</unit>
			<unit id="365" translate="yes">
				<segment state="initial">
					<source>Animate.h</source>
				</segment>
			</unit>
			<unit id="366" translate="yes">
				<segment state="initial">
					<source>Animate.cpp</source>
				</segment>
			</unit>
			<unit id="367" translate="yes">
				<segment state="initial">
					<source>BasicLoader.h</source>
				</segment>
			</unit>
			<unit id="368" translate="yes">
				<segment state="initial">
					<source>BasicLoader.cpp</source>
				</segment>
			</unit>
			<unit id="369" translate="yes">
				<segment state="initial">
					<source>MeshObject.h</source>
				</segment>
			</unit>
			<unit id="370" translate="yes">
				<segment state="initial">
					<source>MeshObject.cpp</source>
				</segment>
			</unit>
			<unit id="371" translate="yes">
				<segment state="initial">
					<source>SphereMesh.h</source>
				</segment>
			</unit>
			<unit id="372" translate="yes">
				<segment state="initial">
					<source>SphereMesh.cpp</source>
				</segment>
			</unit>
			<unit id="373" translate="yes">
				<segment state="initial">
					<source>CylinderMesh.h</source>
				</segment>
			</unit>
			<unit id="374" translate="yes">
				<segment state="initial">
					<source>CylinderMesh.cpp</source>
				</segment>
			</unit>
			<unit id="375" translate="yes">
				<segment state="initial">
					<source>FaceMesh.h</source>
				</segment>
			</unit>
			<unit id="376" translate="yes">
				<segment state="initial">
					<source>FaceMesh.cpp</source>
				</segment>
			</unit>
			<unit id="377" translate="yes">
				<segment state="initial">
					<source>WorldMesh.h</source>
				</segment>
			</unit>
			<unit id="378" translate="yes">
				<segment state="initial">
					<source>WorldMesh.cpp</source>
				</segment>
			</unit>
			<unit id="379" translate="yes">
				<segment state="initial">
					<source>Level.h</source>
				</segment>
			</unit>
			<unit id="380" translate="yes">
				<segment state="initial">
					<source>Level.cpp</source>
				</segment>
			</unit>
			<unit id="381" translate="yes">
				<segment state="initial">
					<source>Level1.h</source>
				</segment>
			</unit>
			<unit id="382" translate="yes">
				<segment state="initial">
					<source>Level1.cpp</source>
				</segment>
			</unit>
			<unit id="383" translate="yes">
				<segment state="initial">
					<source>Level2.h</source>
				</segment>
			</unit>
			<unit id="384" translate="yes">
				<segment state="initial">
					<source>Level2.cpp</source>
				</segment>
			</unit>
			<unit id="385" translate="yes">
				<segment state="initial">
					<source>Level3.h</source>
				</segment>
			</unit>
			<unit id="386" translate="yes">
				<segment state="initial">
					<source>Level3.cpp</source>
				</segment>
			</unit>
			<unit id="387" translate="yes">
				<segment state="initial">
					<source>Level4.h</source>
				</segment>
			</unit>
			<unit id="388" translate="yes">
				<segment state="initial">
					<source>Level4.cpp</source>
				</segment>
			</unit>
			<unit id="389" translate="yes">
				<segment state="initial">
					<source>Level5.h</source>
				</segment>
			</unit>
			<unit id="390" translate="yes">
				<segment state="initial">
					<source>Level5.cpp</source>
				</segment>
			</unit>
			<unit id="391" translate="yes">
				<segment state="initial">
					<source>Level6.h</source>
				</segment>
			</unit>
			<unit id="392" translate="yes">
				<segment state="initial">
					<source>Level6.cpp</source>
				</segment>
			</unit>
			<unit id="393" translate="yes">
				<segment state="initial">
					<source>TargetTexture.h</source>
				</segment>
			</unit>
			<unit id="394" translate="yes">
				<segment state="initial">
					<source>TargetTexture.cpp</source>
				</segment>
			</unit>
			<unit id="395" translate="yes">
				<segment state="initial">
					<source>Material.h</source>
				</segment>
			</unit>
			<unit id="396" translate="yes">
				<segment state="initial">
					<source>Material.cpp</source>
				</segment>
			</unit>
			<unit id="397" translate="yes">
				<segment state="initial">
					<source>Note</source>
				</segment>
			</unit>
			<unit id="398" translate="yes">
				<segment state="initial">
					<source>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</source>
				</segment>
			</unit>
			<unit id="399" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>If you’re developing for Windows 8.x or Windows Phone 8.x, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archived documentation</pc>.</source>
				</segment>
			</unit>
			<unit id="400" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="401" translate="yes">
				<segment state="initial">
					<source>Create a simple UWP game with DirectX</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>