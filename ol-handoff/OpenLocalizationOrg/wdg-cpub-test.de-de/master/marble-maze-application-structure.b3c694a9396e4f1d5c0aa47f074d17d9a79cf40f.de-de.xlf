<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">92e5e7eb25ef5a808e7fc8e1e9f47c453d4a5942</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\marble-maze-application-structure.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">1b7b4ef8f35d8472123b23bd67dc050a8d434d57</mda:meta><mda:meta type="olxliffhash">57f3134f0cd2adf70b5e2f0c28377deb60309e3c</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Marble Maze application structure</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>The structure of a DirectX Universal Windows Platform (UWP) app differs from that of a traditional desktop application.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Marble Maze application structure</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>The structure of a DirectX Universal Windows Platform (UWP) app differs from that of a traditional desktop application.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208296)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Instead of working with handle types such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HWND</pc> and functions such as <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateWindow</pc>, the Windows Runtime provides interfaces such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Windows::UI::Core::ICoreWindow</pc></pc> so that you can develop UWP apps in a more modern, object-oriented manner.</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>This section of the documentation shows how the Marble Maze application code is structured.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](http://go.microsoft.com/fwlink/?LinkId=624011)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The sample code that corresponds to this document is found in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectX Marble Maze game sample</pc>.</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>Here are some of the key points that this document discusses for when you structure your game code:</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>In the initialization phase, set up runtime and library components that your game uses.</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>Also load game-specific resources.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>UWP apps must start processing events within 5 seconds of launch.</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Therefore, load only essential resources when you load your app.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>Games should load large resources in the background and display a progress screen.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>In the game loop, respond to Windows events, read user input, update scene objects, and render the scene.</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Use event handlers to respond to window events.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>(These replace the window messages from desktop Windows applications.)</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>Use a state machine to control the flow and order of the game logic.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>File organization</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>Some of the components in Marble Maze can be reused with any game with little or no modification.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>For your own game, you can adapt the organization and ideas that these files provide.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>The following table briefly describes the important source code files.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Files</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Description</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Audio.h, Audio.cpp</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Audio</pc> class, which manages audio resources.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>BasicLoader.h, BasicLoader.cpp</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicLoader</pc> class, which provides utility methods that help you load textures, meshes, and shaders.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>BasicMath.h</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Defines structures and functions that help you work with vector and matrix data and computations.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Many of these functions are compatible with HLSL shader types.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>BasicReaderWriter.h, BasicReaderWriter.cpp</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicReaderWriter</pc> class, which uses the Windows Runtime to read and write file data in a UWP app.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>BasicShapes.h, BasicShapes.cpp</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicShapes</pc> class, which provides utility methods for creating basic shapes such as cubes and spheres.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>(These files are not used by the Marble Maze implementation).</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>BasicTimer.h, BasicTimer.cpp</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicTimer</pc> class, which provides an easy way to get total and elapsed times.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Camera.h, Camera.cpp</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Camera</pc> class, which provides the position and orientation of a camera.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>Collision.h, Collision.cpp</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>Manages collision info between the marble and other objects, such as the maze.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>DDSTextureLoader.h, DDSTextureLoader.cpp</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDDSTextureFromMemory</pc> function, which loads textures that are in .dds format from a memory buffer.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>DirectXApp.h, DirectXApp.cpp</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXApp</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DirectXAppSource</pc> classes, which encapsulate the view (window, thread, and events) of the app.</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>DirectXBase.h, DirectXBase.cpp</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXBase</pc> class, which provides infrastructure that is common to many DirectX UWP apps.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>DirectXSample.h</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Defines utility functions that can be used by DirectX UWP apps.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>LoadScreen.h, LoadScreen.cpp</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">LoadScreen</pc> class, which displays a loading screen during app initialization.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>MarbleMaze.h, MarbleMaze.cpp</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze</pc> class, which manages game-specific resources and defines much of the game logic.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>MediaStreamer.h, MediaStreamer.cpp</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaStreamer</pc> class, which uses Media Foundation to help the game manage audio resources.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>PersistentState.h, PersistentState.cpp</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PersistentState</pc> class, which reads and writes primitive data types from and to a backing store.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>Physics.h, Physics.cpp</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Physics</pc> class, which implements the physics simulation between the marble and the maze.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>Primitives.h</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>Defines geometric types that are used by the game.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>SampleOverlay.h, SampleOverlay.cpp</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SampleOverlay</pc> class, which provides common 2-D and user-interface data and operations.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>SDKMesh.h, SDKMesh.cpp</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SDKMesh</pc> class, which loads and renders meshes that are in SDK Mesh (.sdkmesh) format.</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>UserInterface.h, UserInterface.cpp</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>Defines functionality that's related to the user interface, such as the menu system and the high score table.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>Design-time versus run-time resource formats</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>When you can, use run-time formats instead of design-time formats to more efficiently load game resources.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">design-time</pc> format is the format you use when you design your resource.</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>Typically, 3-D designers work with design-time formats.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>Some design-time formats are also text-based so that you can modify them in any text-based editor.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>Design-time formats can be verbose and contain more information than your game requires.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">run-time</pc> format is the binary format that is read by your game.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>Run-time formats are typically more compact and more efficient to load than the corresponding design-time formats.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>This is why the majority of games use run-time assets at run time.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>Although your game can directly read a design-time format, there are several benefits to using a separate run-time format.</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>Because run-time formats are often more compact, they require less disk space and require less time to transfer over a network.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Also, run-time formats are often represented as memory-mapped data structures.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>Therefore, they can be loaded into memory much faster than, for example, an XML-based text file.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>Finally, because separate run-time formats are typically binary-encoded, they are more difficult for the end-user to modify.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>HLSL shaders are one example of resources that use different design-time and run-time formats.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>Marble Maze uses .hlsl as the design-time format, and .cso as the run-time format.</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>A .hlsl file holds source code for the shader; a .cso file holds the corresponding shader byte code.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>When you convert .hlsl files offline and provide .cso files with your game, you avoid the need to convert HLSL source files to byte code when your game loads.</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>For instructional reasons, the Marble Maze project includes both the design-time format and the run-time format for many resources, but you only have to maintain the design-time formats in the source project for your own game because you can convert them to run-time formats when you need them.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>This documentation shows how to convert the design-time formats to the run-time formats.</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>Application life cycle</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>Marble Maze follows the life cycle of a typical UWP app.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt243287)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about the life cycle of a UWP app, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">App lifecycle</pc>.</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>When a UWP game initializes, it typically initializes runtime components such as Direct3D, Direct2D, and any input, audio, or physics libraries that it uses.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>It also loads game-specific resources that are required before the game begins.</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>This initialization occurs one time during a game session.</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>After initialization, games typically run the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">game loop</pc>.</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>In this loop, games typically perform four actions: process Windows events, collect input, update scene objects, and render the scene.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>When the game updates the scene, it can apply the current input state to the scene objects and simulate physical events, such as object collisions.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>The game can also perform other activities such as playing sound effects or sending data over the network.</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>When the game renders the scene, it captures the current state of the scene and draws it to the display device.</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>The following sections describe these activities in greater detail.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>Adding to the template</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectX 11 App (Universal Windows)</pc> template creates a core window that you can render to with Direct3D.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The template also includes the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeviceResources</pc> class that creates all of the Direct3D device resources needed for rendering 3D content in a UWP app.</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AppMain</pc> class creates the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MarbleMaze</pc> class object, starts the loading of resources, loops to update the timer, and calls the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">MarbleMaze</pc> render method each frame.</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateWindowSizeDependentResources</pc>, Update, and Render methods for this class call the corresponding methods in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MarbleMaze</pc> class.</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows where the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AppMain</pc> constructor creates the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MarbleMaze</pc> class object.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>The device resources class is passed to the class so it can use the Direct3D objects for rendering.</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AppMain</pc> class also starts loading the deferred resources for the game.</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>See the next section for more detail.</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXPage</pc> constructor sets up the event handlers, creates the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DeviceResources</pc> class, and creates the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">AppMain</pc> class.</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When the handlers for these events are called, they pass the input to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze</pc> class.</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>Loading game assets in the background</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>To ensure that your game can respond to window events within 5 seconds after it is launched, we recommend that you load your game assets asynchronously, or in the background.</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>As assets load in the background, your game can respond to window events.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  You can also display the main menu when it is ready, and allow the remaining assets to continue loading in the background.</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>If the user selects an option from the menu before all resources are loaded, you can indicate that scene resources are continuing to load by displaying a progress bar, for example.</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>Even if your game contains relatively few game assets, it is good practice to load them asynchronously for two reasons.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>One reason is that it is difficult to guarantee that all of your resources will load quickly on all devices and all configurations.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>Also, by incorporating asynchronous loading early, your code is ready to scale as you add functionality.</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Asynchronous asset loading begins with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AppMain::Load</pc> method.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh750113.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This method uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task Class (Concurrency Runtime)</pc></pc> class to load game assets in the background.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze</pc> class defines the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">m\_deferredResourcesReady</pc> flag to indicate that asynchronous loading is complete.</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::LoadDeferredResources</pc> method loads the game resources and then sets this flag.</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The update (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc>) and render (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">MarbleMaze::Render</pc>) phases of the app check this flag.</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<segment state="initial">
					<source>When this flag is set, the game continues as normal.</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>If the flag is not yet set, the game shows the loading screen.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt187334)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about asynchronous programming for UWP apps, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Asynchronous programming in C++</pc>.</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh750113.aspx)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc>   If you’re writing game code that is part of a Windows Runtime C++ Library (in other words, a DLL), consider whether to read <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Creating Asynchronous Operations in C++ for Windows Store Apps</pc> to learn how to create asynchronous operations that can be consumed by apps and other libraries.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>The game loop</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectPage::OnRendering</pc> method runs the main game loop.</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>This method is called every frame.</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To help separate view and window code from game-specific code, we implemented the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXApp::Run</pc> method to forward update and render calls to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MarbleMaze</pc> object.</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectPage::OnRendering</pc> method also defines the game timer, which is used for animation and physics simulation.</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectPage::OnRendering</pc> method, which includes the main game loop.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>The game loop updates the total time and frame time variables, and then updates and renders the scene.</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>This also makes sure that content is only rendered when the window is visible.</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>The state machine</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
				</originalData>
				<segment state="initial">
					<source>Games typically contain a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">state machine</pc> (also known as a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">finite state machine</pc>, or FSM) to control the flow and order of the game logic.</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<segment state="initial">
					<source>A state machine contains a given number of states and the ability to transition among them.</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">*</data>
					<data id="id4">*</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
				</originalData>
				<segment state="initial">
					<source>A state machine typically starts from an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">initial</pc> state, transitions to one or more <pc dataRefEnd="id4" dataRefStart="id3" id="p2">intermediate</pc> states, and possibly ends at a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">terminal</pc> state.</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>A game loop often uses a state machine so that it can perform the logic that is specific to the current game state.</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Marble Maze defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GameState</pc> enumeration, which defines each possible state of the game.</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MainMenu</pc> state, for example, defines that the main menu appears, and that the game is not active.</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Conversely, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InGameActive</pc> state defines that the game is active, and that the menu does not appear.</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze</pc> class defines the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">m\_gameState</pc> member variable to hold the active game state.</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MarbleMaze::Render</pc> methods use the switch statement to perform logic for the current state.</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows what this switch statement might look like for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method (details are removed to illustrate the structure).</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>When game logic or rendering depends on a specific game state, we emphasize it in this documentation.</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>Handling app and window events</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>The Windows Runtime provides an object-oriented event-handling system so that you can more easily manage Windows messages.</source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<segment state="initial">
					<source>To consume an event in an application, you must provide an event handler, or event-handling method, that responds to the event.</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>You must also register the event handler with the event source.</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<segment state="initial">
					<source>This process is often referred to as event wiring.</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<segment state="initial">
					<source>Supporting suspend, resume, and restart</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>Marble Maze is suspended when the user switches away from it or when Windows enters a low power state.</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>The game is resumed when the user moves it to the foreground or when Windows comes out of a low power state.</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>Generally, you don't close apps.</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<segment state="initial">
					<source>Windows can terminate the app when it's in the suspended state and Windows requires the resources, such as memory, that the app is using.</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<segment state="initial">
					<source>Windows notifies an app when it is about to be suspended or resumed, but it doesn't notify the app when it's about to be terminated.</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>Therefore, your app must be able to save—at the point when Windows notifies your app that it is about to be suspended—any data that would be required to restore the current user state when the app is restarted.</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<segment state="initial">
					<source>If your app has significant user state that is expensive to save, you may also need to save state regularly, even before your app receives the suspend notification.</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>Marble Maze responds to suspend and resume notifications for two reasons:</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<segment state="initial">
					<source>When the app is suspended, the game saves the current game state and pauses audio playback.</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<segment state="initial">
					<source>When the app is resumed, the game resumes audio playback.</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>When the app is closed and later restarted, the game resumes from its previous state.</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>Marble Maze performs the following tasks to support suspend and resume:</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>It saves its state to persistent storage at key points in the game, such as when the user reaches a checkpoint.</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>It responds to suspend notifications by saving its state to persistent storage.</source>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<segment state="initial">
					<source>It responds to resume notifications by loading its state from persistent storage.</source>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<segment state="initial">
					<source>It also loads the previous state during startup.</source>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>To support suspend and resume, Marble Maze defines the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PersistentState</pc> class.</source>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>(See PersistentState.h and PersistentState.cpp).</source>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br226054)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This class uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::Foundation::Collections::IPropertySet</pc></pc> interface to read and write properties.</source>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/desktop/ee419475)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/hh755812.aspx)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PersistentState</pc> class provides methods that read and write primitive data types (such as <pc dataRefEnd="id4" dataRefStart="id3" id="p2">bool</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">int</pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p4">float</pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">XMFLOAT3</pc></pc>, and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Platform::String</pc></pc>), from and to a backing store.</source>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze</pc> class holds a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">PersistentState</pc> object.</source>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze</pc> constructor initializes this object and provides the local application data store as the backing data store.</source>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Marble Maze saves its state when the marble passes over a checkpoint or the goal (in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Update</pc> method), and when the window loses focus (in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MarbleMaze::OnFocusChange</pc> method).</source>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>If your game holds a large amount of state data, we recommend that you occasionally save state to persistent storage in a similar manner because you only have a few seconds to respond to the suspend notification.</source>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<segment state="initial">
					<source>Therefore, when your app receives a suspend notification, it only has to save the state data that has changed.</source>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>To respond to suspend and resume notifications, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXPage</pc> class defines the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SaveInternalState</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">LoadInternalState</pc> methods that are called on suspend and resume.</source>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::OnSuspending</pc> method handles the suspend event and the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MarbleMaze::OnResuming</pc> method handles the resume event.</source>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::OnSuspending</pc> method saves game state and suspends audio.</source>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::SaveState</pc> method saves game state values such as the current position and velocity of the marble, the most recent checkpoint, and the high-score table.</source>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<segment state="initial">
					<source>When the game resumes, it only has to resume audio.</source>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<segment state="initial">
					<source>It doesn't have to load state from persistent storage because the state is already loaded in memory.</source>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](adding-audio-to-the-marble-maze-sample.md)</data>
				</originalData>
				<segment state="initial">
					<source>How the game suspends and resumes audio is explained in the document <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Adding audio to the Marble Maze sample</pc>.</source>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To support restart, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::Initialize</pc> method, which is called during startup, calls the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MarbleMaze::LoadState</pc> method.</source>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MarbleMaze::LoadState</pc> method reads and applies the state to the game objects.</source>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<segment state="initial">
					<source>This method also sets the current game state to paused if the game was paused or active when it was suspended.</source>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<segment state="initial">
					<source>We pause the game so that the user is not surprised by unexpected activity.</source>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<segment state="initial">
					<source>It also moves to the main menu if the game was not in a gameplay state when it was suspended.</source>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>  Marble Maze doesn't distinguish between cold starting—that is, starting for the first time without a prior suspend event—and resuming from a suspended state.</source>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<segment state="initial">
					<source>This is recommended design for all UWP apps.</source>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh465118)</data>
				</originalData>
				<segment state="initial">
					<source>For more examples that demonstrate how to store and retrieve settings and files from the local application data store, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Quickstart: Local application data</pc>.</source>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt299098)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about application data, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Store and retrieve settings and other app data</pc>.</source>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<segment state="initial">
					<source>Next steps</source>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](adding-visual-content-to-the-marble-maze-sample.md)</data>
				</originalData>
				<segment state="initial">
					<source>Read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Adding visual content to the Marble Maze sample</pc> for information about some of the key practices to keep in mind when you work with visual resources.</source>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<segment state="initial">
					<source>Adding visual content to the Marble Maze sample</source>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>Marble Maze sample fundamentals</source>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<segment state="initial">
					<source>Developing Marble Maze, a UWP game in C++ and DirectX</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>