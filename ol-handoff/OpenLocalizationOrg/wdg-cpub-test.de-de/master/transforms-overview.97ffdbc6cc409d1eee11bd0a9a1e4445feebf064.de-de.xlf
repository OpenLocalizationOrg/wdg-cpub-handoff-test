<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">bd147a56fcb996b5f11ae813c073f70a9c350afd</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci1\graphics\transforms-overview.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">de23ab395997e1d8d0069ff4ffaf583a75a9e6a9</mda:meta><mda:meta type="olxliffhash">af9279608393f7d278143a165b3576605bd03fc7</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Transforms overview</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Learn how to use transforms in the Windows Runtime&amp;\#160;API, by changing the relative coordinate systems of elements in the UI.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Transforms overview</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Learn how to use transforms in the Windows Runtime API, by changing the relative coordinate systems of elements in the UI.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>This can be used to adjust the appearance of individual XAML elements, such as scaling, rotating, or transforming the position in x-y space.</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>What is a transform?</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">transform</pc> defines how to map, or transform, points from one coordinate space to another coordinate space.</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>When a transform is applied to a UI element, it changes how that UI element is rendered to the screen as part of the UI.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>Think of transforms in four broad classifications: translation, rotation, scaling and skew (or shear).</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>For the purposes of using graphics APIs to change the appearance of UI elements, it's usually easiest to create transforms that define only one operation at a time.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>So the Windows Runtime defines a discrete class for each of these transform classifications:</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243027)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.translatetransform.x.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.translatetransform.y)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TranslateTransform</pc></pc>: translates an element in x-y space, by setting values for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">X</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Y</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242940)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.scaletransform.centerx.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.scaletransform.centery.aspx)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.scaletransform.scalex.aspx)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
					<data id="id17">[</data>
					<data id="id18">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.scaletransform.scaleyproperty)</data>
					<data id="id19">**</data>
					<data id="id20">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScaleTransform</pc></pc>: scales the transform based on a center point, by setting values for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CenterX</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">CenterY</pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">ScaleX</pc></pc> and <pc dataRefEnd="id18" dataRefStart="id17" id="p9"><pc dataRefEnd="id20" dataRefStart="id19" id="p10">ScaleY</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242932)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.rotatetransform.angle.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.rotatetransform.centerx.aspx)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.rotatetransform.centery)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RotateTransform</pc></pc>: rotates in x-y space, by setting values for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Angle</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">CenterX</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">CenterY</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242950)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.skewtransform.anglex.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.skewtransform.angley.aspx)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.skewtransform.centerx.aspx)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
					<data id="id17">[</data>
					<data id="id18">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.scaletransform.centeryproperty)</data>
					<data id="id19">**</data>
					<data id="id20">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SkewTransform</pc></pc>: skews or shears in x-y space, by setting values for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">AngleX</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">AngleY</pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">CenterX</pc></pc> and <pc dataRefEnd="id18" dataRefStart="id17" id="p9"><pc dataRefEnd="id20" dataRefStart="id19" id="p10">CenterY</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243027)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242940)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Of these, you're likely to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TranslateTransform</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ScaleTransform</pc></pc> most often for UI scenarios.</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR228105)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR243022)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>You can combine transforms, and there are two Windows Runtime classes that support this: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositeTransform</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TransformGroup</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CompositeTransform</pc>, transforms are applied in this order: scale, skew, rotate, translate.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TransformGroup</pc> instead of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositeTransform</pc> if you want the transforms applied in a different order.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR228105)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositeTransform</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>Transforms and layout</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>In XAML layout, transforms are applied after the layout pass is complete, so available space calculations and other layout decisions have been made before the transforms are applied.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242704)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Because layout comes first, you'll sometimes get unexpected results if you transform elements that are in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Grid</pc></pc> cell or similar layout container that allocates space during layout.</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>The transformed element may appear truncated or obscured because it's trying to draw into an area that didn't calculate the post-transform dimensions when dividing space within its parent container.</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>You may need to experiment with the transform results and adjust some settings.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, instead of relying on adaptive layout and star sizing, you may need to change the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Center</pc> properties or declare fixed pixel measurements for layout space to make sure the parent allots enough space.</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>**Migration note:  **Windows Presentation Foundation (WPF) had a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">LayoutTransform</pc> property that applied transforms prior to the layout pass.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>But Windows Runtime XAML doesn't support a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">LayoutTransform</pc> property.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>(Microsoft Silverlight didn't have this property either.)</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Applying a transform to a UI element</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208980)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When you apply a transform to an object, you typically do so to set the property <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement.RenderTransform</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Setting this property does not literally change the object pixel by pixel.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>What the property really does is apply the transform within the local coordinate space in which that object exists.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243027)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Then the rendering logic and operation (post-layout) renders the combined coordinate spaces, making it look like the object has changed appearance and also potentially its layout position (if <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TranslateTransform</pc></pc> was applied).</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>By default, each render transform is centered at the origin of the target object's local coordinate system—its (0,0).</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243027)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The only exception is a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TranslateTransform</pc></pc>, which has no center properties to set because the translation effect is the same regardless of where it is centered.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>But the other transforms each have properties that set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CenterX</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CenterY</pc> values.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208980)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208911)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.rendertransformorigin.aspx)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>Whenever you use transforms with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement.RenderTransform</pc></pc>, remember that there's another property on <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">UIElement</pc></pc> that affects how the transform behaves: <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">RenderTransformOrigin</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>What <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RenderTransformOrigin</pc> declares is whether the whole transform should apply to the default (0,0) point of an element or to some other origin point within the relative coordinate space of that element.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>For typical elements, (0,0) places the transform to the top left corner.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Depending on what effect you want, you might choose to change <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RenderTransformOrigin</pc> rather than adjusting the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CenterX</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CenterY</pc> values on transforms.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5"> / </data>
					<data id="id6">**</data>
					<data id="id7">**</data>
				</originalData>
				<segment state="initial">
					<source>Note that if you apply both <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RenderTransformOrigin</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CenterX</pc><ph dataRef="id5" id="ph1" /><pc dataRefEnd="id7" dataRefStart="id6" id="p3">CenterY</pc> values, the results can be pretty confusing, especially if you're animating any of the values.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>For hit-testing purposes, an object to which a transform is applied continues to respond to input in an expected way that's consistent to its visual appearance in x-y space.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243027)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR243371)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.pointerpressed.aspx)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, if you've used a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TranslateTransform</pc></pc> to move a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Rectangle</pc></pc> 400 pixels laterally in the UI, that <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Rectangle</pc> responds to <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">PointerPressed</pc></pc> events when the user presses the point where the <pc dataRefEnd="id16" dataRefStart="id15" id="p8">Rectangle</pc> appears visually.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You won't get false events if the user presses the area where the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Rectangle</pc> was before being translated.</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>For any z-index considerations that affect hit testing, applying a transform makes no difference; the z-index that governs which element handles input events for a point in x-y space is still evaluated using the child order as declared in a container.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209267)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.canvas.zindex.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>That order is usually the same as the order in which you declare the elements in XAML, although for child elements of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Canvas</pc></pc> object you can adjust the order by applying the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Canvas.ZIndex</pc></pc> attached property to child elements.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>Other transform properties</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR228082)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR228080)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR228076)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Brush.Transform</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Brush.RelativeTransform</pc></pc>: These influence how a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Brush</pc></pc> uses coordinate space within the area that the <pc dataRefEnd="id14" dataRefStart="id13" id="p7">Brush</pc> is applied to set visual properties such as foregrounds and backgrounds.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242962)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR210101)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR210108)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>These transforms aren't relevant for the most common brushes (which are typically setting solid colors with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SolidColorBrush</pc></pc>) but might be occasionally useful when painting areas with an <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ImageBrush</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">LinearGradientBrush</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR210066)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR243356)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Geometry.Transform</pc></pc>: You might use this property to apply a transform to a geometry prior to using that geometry for a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Path.Data</pc></pc> property value.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>Animating a transform</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243006)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Transform</pc></pc> objects can be animated.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>To animate a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Transform</pc>, apply an animation of a compatible type to the property you want to animate.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243136)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR243136usingkeyframes)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/xaml/system.double.aspx)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>This typically means you're using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DoubleAnimation</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DoubleAnimationUsingKeyFrames</pc></pc> objects to define the animation, because all of the transform properties are of type <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Double</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208980)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Animations that affect a transform that's used for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement.RenderTransform</pc></pc> value are not considered to be dependent animations, even if they have a nonzero duration.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](storyboarded-animations.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about dependent animations, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc>.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208751)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208718)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR208706)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR243027)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>If you animate properties to produce an effect similar to a transform in terms of the net visual appearance—for example, animating the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Width</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Height</pc></pc> of a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">FrameworkElement</pc></pc> rather than applying a <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">TranslateTransform</pc></pc>—such animations are almost always treated as dependent animations.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>You'd have to enable the animations and there could be significant performance issues with the animation, especially if you're trying to support user interaction while that object is being animated.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>For that reason it's preferable to use a transform and animate it rather than animating any other property where the animation would be treated as a dependent animation.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243006)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208980)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>To target the transform, there must be an existing <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Transform</pc></pc> as the value for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">RenderTransform</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>You typically put an element for the appropriate transform type in the initial XAML, sometimes with no properties set on that transform.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>You typically use an indirect targeting technique to apply animations to the properties of a transform.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](storyboarded-animations.md)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt185586)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about indirect targeting syntax, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Property-path syntax</pc>.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Default styles for controls sometimes define animations of transforms as part of their visual-state behavior.</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227538)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242932)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, the visual states for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ProgressRing</pc></pc> use animated <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">RotateTransform</pc></pc> values to "spin" the dots in the ring.</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>Here's a simple example of how to animate a transform.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.media.rotatetransform.angle.aspx)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242932)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR243371)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>In this case, it's animating the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Angle</pc></pc> of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">RotateTransform</pc></pc> to spin a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Rectangle</pc></pc> in place around its visual center.</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">`(UIElement.RenderTransform).(RotateTransform.Angle)`</data>
				</originalData>
				<segment state="initial">
					<source>This example names the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RotateTransform</pc> so doesn't need indirect animation targeting, but you could alternatively leave the transform unnamed, name the element that the transform's applied to, and use indirect targeting such as <ph dataRef="id3" id="ph1" />.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>Accounting for coordinate frames of reference at run time</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.transformtovisual.aspx)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR243006)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> has a method named <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TransformToVisual</pc></pc>, which can generate a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Transform</pc></pc> that correlates the coordinate frames of reference for two UI elements.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>You can use this to compare an element to the app's default coordinate frame of reference if you pass the root visual as the first parameter.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>This can be useful if you've captured an input event from a different element, or if you are trying to predict layout behavior without actually requesting a layout pass.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR212141)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
				</originalData>
				<segment state="initial">
					<source>Event data obtained from pointer events provides access to a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetCurrentPoint</pc></pc> method, where you can specify a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">relativeTo</pc> parameter to change the coordinate frame of reference to a specific element rather than the app default.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242038)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This approach simply applies a translate transform internally and transforms the x-y coordinate data for you when it creates the returned <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerPoint</pc></pc> object.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>Describing a transform mathematically</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>A transform can be described in terms of a transformation matrix.</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>A 3×3 matrix is used to describe the transformations in a two-dimensional, x-y plane.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Affine transformation matrices can be multiplied to form any number of linear transformations, such as rotation and skew (shear), followed by translation.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>The final column of an affine transformation matrix is equal to (0, 0, 1), so you need to specify only the members of the first two columns in the mathematical description.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>The mathematical description of a transform might be useful to you if you have a mathematical background or a familiarity with graphics-programming techniques that also use matrices to describe transformations of coordinate space.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243006)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR210137)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>There's a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Transform</pc></pc>-derived class that enables you to express a transformation directly in terms of its 3×3 matrix: <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MatrixTransform</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.media.matrixtransform.matrix.aspx)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/Hh673847)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/Hh673853)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
					<data id="id15">[</data>
					<data id="id16">](https://msdn.microsoft.com/library/windows/apps/Hh673851)</data>
					<data id="id17">**</data>
					<data id="id18">**</data>
					<data id="id19">[</data>
					<data id="id20">](https://msdn.microsoft.com/library/windows/apps/Hh673849)</data>
					<data id="id21">**</data>
					<data id="id22">**</data>
					<data id="id23">[</data>
					<data id="id24">](https://msdn.microsoft.com/library/windows/apps/Hh673810)</data>
					<data id="id25">**</data>
					<data id="id26">**</data>
					<data id="id27">[</data>
					<data id="id28">](https://msdn.microsoft.com/library/windows/apps/Hh673816)</data>
					<data id="id29">**</data>
					<data id="id30">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">MatrixTransform</pc> has a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Matrix</pc></pc> property, which holds a structure that has six properties: <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">M11</pc></pc>, <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">M12</pc></pc>, <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">M21</pc></pc>, <pc dataRefEnd="id20" dataRefStart="id19" id="p10"><pc dataRefEnd="id22" dataRefStart="id21" id="p11">M22</pc></pc>, <pc dataRefEnd="id24" dataRefStart="id23" id="p12"><pc dataRefEnd="id26" dataRefStart="id25" id="p13">OffsetX</pc></pc> and <pc dataRefEnd="id28" dataRefStart="id27" id="p14"><pc dataRefEnd="id30" dataRefStart="id29" id="p15">OffsetY</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR210127)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Each <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Matrix</pc></pc> property uses a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Double</pc> value and corresponds to the six relevant values (columns 1 and 2) of an affine transformation matrix.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>M11</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>M21</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>0</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>M12</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>M22</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>0</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>OffsetX</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>OffsetY</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>1</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243027)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242940)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242932)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR242950)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
					<data id="id17">[</data>
					<data id="id18">](https://msdn.microsoft.com/library/windows/apps/BR210137)</data>
					<data id="id19">**</data>
					<data id="id20">**</data>
					<data id="id21">[</data>
					<data id="id22">](https://msdn.microsoft.com/library/windows/apps/BR210127)</data>
					<data id="id23">**</data>
					<data id="id24">**</data>
				</originalData>
				<segment state="initial">
					<source>Any transform that you could describe with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TranslateTransform</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ScaleTransform</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">RotateTransform</pc></pc>, or <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">SkewTransform</pc></pc> object could be described equally by a <pc dataRefEnd="id18" dataRefStart="id17" id="p9"><pc dataRefEnd="id20" dataRefStart="id19" id="p10">MatrixTransform</pc></pc> with a <pc dataRefEnd="id22" dataRefStart="id21" id="p11"><pc dataRefEnd="id24" dataRefStart="id23" id="p12">Matrix</pc></pc> value.</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>But you typically just use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TranslateTransform</pc> and the others because the properties on those transform classes are easier to conceptualize than setting the vector components in a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Matrix</pc>.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR242356)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>It's also easier to animate the discrete properties of transforms; a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Matrix</pc> is actually a structure and not a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyObject</pc></pc>, so it can't support animated individual values.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR210137)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Some XAML design tools that enable you to apply transformation operations will serialize the results as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MatrixTransform</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR210127)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In this case it may be best to use the same design tool again to change the transformation effect and serialize the XAML again, rather than trying to manipulate the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Matrix</pc></pc> values yourself directly in the XAML.</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>3-D transforms</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
				</originalData>
				<segment state="initial">
					<source>You can apply 3-D effects to any <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> by using <pc dataRefEnd="id6" dataRefStart="id5" id="p3">perspective transforms</pc>.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>For example, you can create the illusion that an object is rotated toward or away from you in a perspective plane.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.projection.aspx)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR210192)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>To do this, set the<pc dataRefEnd="id2" dataRefStart="id1" id="p1">UIElement</pc> object's <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Projection</pc></pc> property as a <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">PlaneProjection</pc></pc> value.</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PlaneProjection</pc> class defines how the transform is rendered in a simulated 3-D space.</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](3-d-perspective-effects.md)</data>
				</originalData>
				<segment state="initial">
					<source>This type of transform is described in more detail in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">3-D perspective effects for XAML UI</pc>.</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR243006)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR210192)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   It's technically possible to get similar results by using the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Transform</pc></pc> classes in combination, but the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">PlaneProjection</pc></pc> technique usually looks better with images as brushes and it's much easier to get the property values right.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>Drawing shapes</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>3-D perspective effects for XAML UI</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>Transform</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>