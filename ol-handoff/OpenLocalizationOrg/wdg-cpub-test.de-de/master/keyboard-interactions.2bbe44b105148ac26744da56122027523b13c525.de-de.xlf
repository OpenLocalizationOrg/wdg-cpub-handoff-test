<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">24ba2386709b046259bca0c81abafd8bcd3bb31d</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\input-and-devices\keyboard-interactions.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">15fbf3188bd57c02c07ea653ff33ca83cd0295f6</mda:meta><mda:meta type="olxliffhash">49a829984ee60eab1b9c6557d0ac3f48ad961141</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Respond to keystroke actions from hardware or software keyboards in your apps using both keyboard and class event handlers.</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Keyboard interactions</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Keyboard interactions</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Keyboard input is an important part of the overall user interaction experience for apps.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>The keyboard is indispensable to people with certain disabilities or users who just consider it a more efficient way to interact with an app.</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>For example, users should be able to navigate your app by using Tab and arrow keys, activate UI elements by using Spacebar and Enter, and access commands by using keyboard shortcuts.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>keyboard hero image</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>Important APIs</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>KeyDown</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>KeyUp</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>KeyRoutedEventArgs</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>A well-designed keyboard UI is an important aspect of software accessibility.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>It enables users with vision impairments or who have certain motor disabilities to navigate an app and interact with its features.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Such users might not be able to operate a mouse and instead rely on various assistive technologies such as keyboard enhancement tools, on-screen keyboards, screen enlargers, screen readers, and voice input utilities.</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Users can interact with universal apps through a hardware keyboard and two software keyboards: the On-Screen Keyboard (OSK) and the touch keyboard.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>On-Screen Keyboard</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>The On-Screen Keyboard is a visual, software keyboard that you can use instead of the physical keyboard to type and enter data using touch, mouse, pen/stylus or other pointing device (a touch screen is not required).</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>The On-Screen Keyboard is provided for systems that don't have a physical keyboard, or for users whose mobility impairments prevent them from using traditional physical input devices.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>The On-Screen Keyboard emulates most, if not all, the functionality of a hardware keyboard.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source>The On-Screen Keyboard can be turned on from the Keyboard page in Settings <ph dataRef="id1" id="ph1" /> Ease of access.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The On-Screen Keyboard has priority over the touch keyboard, which won't be shown if the On-Screen Keyboard is present.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>the on-screen keyboard</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>On-Screen Keyboard</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Touch keyboard</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>The touch keyboard is a visual, software keyboard used for text entry with touch input.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>It is not a replacement for the On-Screen Keyboard as it's used for text input only (it doesn't emulate the hardware keyboard).</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Depending on the device, the touch keyboard appears when a text field or other editable text control gets focus, or when the user manually enables it through the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Notification Center</pc>:</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>touch keyboard icon in the notification center</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">&amp;gt;</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The user might have to go to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Tablet mode</pc> screen in Settings <ph dataRef="id5" id="ph1" /> System and turn on "Make Windows more touch-friendly when using your device as a tablet" to enable the automatic appearance of the touch keyboard.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>If your app sets focus programmatically to a text input control, the touch keyboard is not invoked.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>This eliminates unexpected behaviors not instigated directly by the user.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>However, the keyboard does automatically hide when focus is moved programmatically to a non-text input control.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<segment state="initial">
					<source>The touch keyboard typically remains visible while the user navigates between controls in a form.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>This behavior can vary based on the other control types within the form.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>The following is a list of non-edit controls that can receive focus during a text entry session using the touch keyboard without dismissing the keyboard.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>Rather than needlessly churn the UI and potentially disorient the user, the touch keyboard remains in view because the user is likely to go back and forth between these controls and text entry with the touch keyboard.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>Check box</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>Combo box</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Radio button</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>Scroll bar</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>Tree</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>Tree item</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>Menu</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>Menu bar</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>Menu item</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<segment state="initial">
					<source>Toolbar</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>List</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>List item</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Here are examples of different modes for the touch keyboard.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>The first image is the default layout, the second is the thumb layout (which might not be available in all languages).</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>Here are examples of different modes for the touch keyboard.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>The first image is the default layout, the second is the thumb layout (which might not be available in all languages).</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>**The touch keyboard in default layout mode:  **</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>the touch keyboard in default layout mode</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>**The touch keyboard in expanded layout mode:  **</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>the touch keyboard in expanded layout mode</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>**The touch keyboard in default thumb layout mode:  **</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>the touch keyboard in thumb layout mode</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>**The touch keyboard in numeric thumb layout mode:  **</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>the touch keyboard in numeric thumb layout mode</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>Successful keyboard interactions enable users to accomplish basic app scenarios using only the keyboard; that is, users can reach all interactive elements and activate default functionality.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>A number of factors can affect the degree of success, including keyboard navigation, access keys for accessibility, and accelerator (or shortcut) keys for advanced users.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](#keyboard_command_patterns)</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The touch keyboard does not support toggle and most system commands (see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Patterns</pc>).</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>Navigation</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>To use a control (including navigation elements) with the keyboard, the control must have focus.</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>One way for a control to receive keyboard focus is to make it accessible via tab navigation.</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>A well designed keyboard navigation model provides a logical and predictable tab order that enables a user to explore and use your app quickly and efficiently.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>All interactive controls should have tab stops (unless they are in a group), whereas non-interactive controls, such as labels, should not.</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>A set of related controls can be made into a control group and assigned a single tab stop.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>Control groups are used for sets of controls that behave like a single control, such as radio buttons.</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>They can also be used when there too many controls to navigate efficiently with the Tab key alone.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>The arrow keys, Home, End, Page Up, and Page Down move input focus among the controls within a group (it is not possible to navigate out of a control group using these keys).</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>You should set initial keyboard focus on the element that users will intuitively (or most likely) interact with first when your app starts.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Often, this is the main content view of the app so that a user can immediately start using the arrow keys to scroll the app content.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>Don’t set initial keyboard focus on an element with potentially negative, or even disastrous, results.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>This can prevent loss of data or system access.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>Try to rank and present the most important commands, controls, and content first in both the tab order and the display order (or visual hierarchy).</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>However, the actual display position can depend on the parent layout container and certain properties of the child elements that influence the layout.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>In particular, layouts that use a grid metaphor or a table metaphor can have a reading order quite different from the tab order.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>This is not always a problem, but you should test your app's functionality, both as a touchable UI and as a keyboard-accessible UI.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>Tab order should follow reading order, whenever possible.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>This can reduce confusion and is dependent on locale and language.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>Associate keyboard buttons with appropriate UI (back and forward buttons) in your app.</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>Try to make navigating back to the start screen of your app and between key content as easy and straightforward as possible.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Use the arrow keys as keyboard shortcuts for proper inner navigation among child elements of composite elements.</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>If tree view nodes have separate child elements for handling expand–collapse and node activation, use the left and right arrow keys to provide keyboard expand–collapse functionality.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>This is consistent with the platform controls.</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>Because the touch keyboard occludes a large portion of the screen, the Universal Windows Platform (UWP) ensures that the input field with focus scrolls into view as a user navigates through the controls on the form, including controls that are not currently in view.</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>Custom controls should emulate this behavior.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>a form with and without the touch keyboard showing</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>In some cases, there are UI elements that should stay on the screen the entire time.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>Design the UI so that the form controls are contained in a panning region and the important UI elements are static.</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>For example:</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>a form that contains areas that should always stay in view</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>Activation</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>A control can be activated in a number of different ways, whether it currently has focus or not.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>Spacebar, Enter, and Esc</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>The spacebar should activate the control with input focus.</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>The Enter key should activate a default control or the control with input focus.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>A default control is the control with initial focus or one that responds exclusively to the Enter key (typically it changes with input focus).</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>In addition, the Esc key should close or exit transitory UI, such as menus and dialogs.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>The Calculator app shown here uses the spacebar to activate the button with focus, locks the Enter key to the “=” button, and locks the Esc key to the “C” button.</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>the calculator app</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>Keyboard modifiers</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>Keyboard modifiers fall into the following categories:</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>Category</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>Description</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>Shortcut key</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Perform a common action without UI such as "Ctrl-S" for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Save</pc>.</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>Implement keyboard shortcuts for key app functionality.</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>Not every command has, or requires, a shortcut.</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>Access key/Hot key</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Assigned to every visible, top-level control such as "Alt-F" for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">File</pc> menu.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<segment state="initial">
					<source>An access key does not invoke or activate a command.</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>Accelerator key</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>Perform default system or app-defined commands such as "Alt-PrtScrn" for screen capture, "Alt-Tab" to switch apps, or "F1" for help.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>A command associated with an accelerator key does not have to be a menu item.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>Application key/Menu key</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<segment state="initial">
					<source>Show context menu.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<segment state="initial">
					<source>Window key/Command key</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Activate system commands such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">System Menu</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Lock Screen</pc>, or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Show Desktop</pc>.</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>Access keys and accelerator keys support interaction with controls directly instead of navigating to them using the Tab key.</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>While some controls have intrinsic labels, such as command buttons, check boxes, and radio buttons, other controls have external labels, such as list views.</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<segment state="initial">
					<source>For controls with external labels, the access key is assigned to the label, which, when invoked, sets focus to an element or value within the associated control.</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The example here, shows the access keys for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Page Layout</pc> tab in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Word</pc>.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>the access keys for the page layout tab in word</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<segment state="initial">
					<source>Here, the Indent Left text field value is highlighted after entering the access key identified in the associated label.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>the indent left text field value is highlighted after entering the access key identified in the associated label</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>Usability and accessibility</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>A well-designed keyboard interaction experience is an important aspect of software accessibility.</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>It enables users with vision impairments or who have certain motor disabilities to navigate an app and interact with its features.</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>Such users might be unable to operate a mouse and must, instead, rely on various assistive technologies that include keyboard enhancement tools and on-screen keyboards (along with screen enlargers, screen readers, and voice input utilities).</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>For these users, comprehensiveness is more important than consistency.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>Experienced users often have a strong preference for using the keyboard, because keyboard-based commands can be entered more quickly and don't require removing their hands from the keyboard.</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>For these users, efficiency and consistency are crucial; comprehensiveness is important only for the most frequently used commands.</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>There are subtle distinctions when designing for usability and accessibility, which is why two different keyboard access mechanisms are supported.</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>Access keys have the following characteristics:</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<segment state="initial">
					<source>An access key is a shortcut to a UI element in your app.</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<segment state="initial">
					<source>They use the Alt key plus an alphanumeric key.</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<segment state="initial">
					<source>They are primarily for accessibility.</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>They are assigned to all menus and most dialog box controls.</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<segment state="initial">
					<source>They aren't intended to be memorized, so they are documented directly in the UI by underlining the corresponding control label character.</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>They have effect only in the current window, and navigate to the corresponding menu item or control.</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>They aren't assigned consistently because they can't always be.</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>However, access keys should be assigned consistently for commonly used commands, especially commit buttons.</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>They are localized.</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>Because access keys aren't intended to be memorized, they are assigned to a character that is early in the label to make them easy to find, even if there is a keyword that appears later in the label.</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>In contrast, accelerator keys have the following characteristics:</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>An accelerator key is a shortcut to an app command.</source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<segment state="initial">
					<source>They primarily use Ctrl and Function key sequences (Windows system shortcut keys also use Alt+non-alphanumeric keys and the Windows logo key).</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>They are primarily for efficiency for advanced users.</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<segment state="initial">
					<source>They are assigned only to the most commonly used commands.</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<segment state="initial">
					<source>They are intended to be memorized, and are documented only in menus, tooltips, and Help.</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>They have effect throughout the entire program, but have no effect if they don't apply.</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>They must be assigned consistently because they are memorized and not directly documented.</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>They aren't localized.</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<segment state="initial">
					<source>Because accelerator keys are intended to be memorized, the most frequently used accelerator keys ideally use letters from the first or most memorable characters within the command's keywords, such as Ctrl+C for Copy and Ctrl+Q for Request.</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<segment state="initial">
					<source>Users should be able to accomplish all tasks supported by your app using only the hardware keyboard or the On-Screen Keyboard.</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>You should provide an easy way for users who rely on screen readers and other assistive technology to discover your app's accelerator keys.</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<segment state="initial">
					<source>Communicate accelerator keys by using tooltips, accessible names, accessible descriptions, or some other form of on-screen communication.</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>At a minimum, access and accelerator keys should be well documented in your app's Help content.</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<segment state="initial">
					<source>Don’t assign well-known or standard accelerator keys to other functionality.</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<segment state="initial">
					<source>For example, Ctrl+F is typically used for find or search.</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>Don’t bother trying to assign access keys to all interactive controls in a dense UI.</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>Just ensure the most important and the most used have access keys, or use control groups and assign an access key to the control group label.</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>Don't change commands using keyboard modifiers.</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>Doing so is undiscoverable and can cause confusion.</source>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<segment state="initial">
					<source>Don't disable a control while it has input focus.</source>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<segment state="initial">
					<source>This can interfere with keyboard input.</source>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<segment state="initial">
					<source>To ensure successful keyboard interaction experiences, it is critical to test your app thoroughly and exclusively with the keyboard.</source>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<segment state="initial">
					<source>Text input</source>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<segment state="initial">
					<source>Always query the device capabilities when relying on keyboard input.</source>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<segment state="initial">
					<source>On some devices (such as phone), the touch keyboard can only be used for text input as it does not provide many of the accelerators or command keys found on a hardware keyboard (such as alt, the function keys, or the Windows Logo key).</source>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<segment state="initial">
					<source>Don't make users navigate the app using the touch keyboard.</source>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<segment state="initial">
					<source>Depending on the control getting focus, the touch keyboard might get dismissed.</source>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<segment state="initial">
					<source>Try to display the keyboard throughout the entire interaction with your form.</source>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<segment state="initial">
					<source>This eliminates UI churn that can disorient the user in the middle of a form or text entry flow.</source>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<segment state="initial">
					<source>Ensure that users can always see the input field that they're typing into.</source>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<segment state="initial">
					<source>The touch keyboard occludes half of the screen, so the input field with focus should scroll into view as the user traverses the form.</source>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<segment state="initial">
					<source>A standard hardware keyboard or OSK consists of seven types of keys, each supporting unique functionality:</source>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<segment state="initial">
					<source>Character key: sends a literal character to the window with input focus.</source>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<segment state="initial">
					<source>Modifier key: alters the function of a primary key when pressed simultaneously, such as Ctrl, Alt, Shift, and the Windows logo key.</source>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<segment state="initial">
					<source>Navigation key: moves input focus or text input location, such as the Tab, Home, End, Page Up, Page Down, and directional arrow keys.</source>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<segment state="initial">
					<source>Editing key: manipulates text, such as the Shift, Tab, Enter, Insert, Backspace, and Delete keys.</source>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<segment state="initial">
					<source>Function key: performs a special function, such as F1 through F12 keys.</source>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<segment state="initial">
					<source>Toggle key: puts the system into a mode, such as Caps Lock, ScrLk, and Num Lock keys.</source>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<segment state="initial">
					<source>Command key: performs a system task or command activation, such as Spacebar, Enter, Esc, Pause/Break, and Print Screen keys.</source>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<segment state="initial">
					<source>In addition to these categories, a secondary class of keys and key combinations exist that can be used as shortcuts to app functionality:</source>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<segment state="initial">
					<source>Access key: exposes controls or menu items by pressing the Alt key with a character key, indicated by underlining of the access key character assignment in a menu, or displaying of the access key character(s) in an overlay.</source>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<segment state="initial">
					<source>Accelerator key: exposes app commands by pressing a function key or the Ctrl key with a character key.</source>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<segment state="initial">
					<source>Your app might or might not have UI that corresponds to the command.</source>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<segment state="initial">
					<source>Another class of key combinations, known as secure attention sequence (SAS), cannot be intercepted by an app.</source>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<segment state="initial">
					<source>This is a security feature intended to protect the user's system during login, and include Ctrl-Alt-Del and Win-L.</source>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<segment state="initial">
					<source>The Notepad app is shown here with the expanded File menu that includes both access keys and accelerator keys.</source>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<segment state="initial">
					<source>the notepad app with expanded file menu that includes both access keys and accelerator keys.</source>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<segment state="initial">
					<source>Keyboard commands</source>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<segment state="initial">
					<source>The following is a comprehensive list of the keyboard interactions provided across the various devices that support keyboard input.</source>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<segment state="initial">
					<source>Some devices and platforms require native keystrokes and interactions, these are noted.</source>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<segment state="initial">
					<source>When designing custom controls and interactions, use this keyboard language consistently to make your app feel familiar, dependable, and easy to learn.</source>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<segment state="initial">
					<source>Don't redefine the default keyboard shortcuts.</source>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<segment state="initial">
					<source>The following tables list frequently used keyboard commands.</source>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=325424)</data>
				</originalData>
				<segment state="initial">
					<source>For a complete list of keyboard commands, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows Keyboard Shortcut Keys</pc>.</source>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<segment state="initial">
					<source>Navigation commands</source>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<segment state="initial">
					<source>Action</source>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<segment state="initial">
					<source>Key command</source>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<segment state="initial">
					<source>Back</source>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<segment state="initial">
					<source>Alt+Left or the back button on special keyboards</source>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<segment state="initial">
					<source>Forward</source>
				</segment>
			</unit>
			<unit id="311" translate="yes">
				<segment state="initial">
					<source>Alt+Right</source>
				</segment>
			</unit>
			<unit id="312" translate="yes">
				<segment state="initial">
					<source>Up</source>
				</segment>
			</unit>
			<unit id="313" translate="yes">
				<segment state="initial">
					<source>Alt+Up</source>
				</segment>
			</unit>
			<unit id="314" translate="yes">
				<segment state="initial">
					<source>Cancel or Escape from current mode</source>
				</segment>
			</unit>
			<unit id="315" translate="yes">
				<segment state="initial">
					<source>Esc</source>
				</segment>
			</unit>
			<unit id="316" translate="yes">
				<segment state="initial">
					<source>Move through items in a list</source>
				</segment>
			</unit>
			<unit id="317" translate="yes">
				<segment state="initial">
					<source>Arrow key (Left, Right, Up, Down)</source>
				</segment>
			</unit>
			<unit id="318" translate="yes">
				<segment state="initial">
					<source>Jump to next list of items</source>
				</segment>
			</unit>
			<unit id="319" translate="yes">
				<segment state="initial">
					<source>Ctrl+Left</source>
				</segment>
			</unit>
			<unit id="320" translate="yes">
				<segment state="initial">
					<source>Semantic zoom</source>
				</segment>
			</unit>
			<unit id="321" translate="yes">
				<segment state="initial">
					<source>Ctrl++ or Ctrl+-</source>
				</segment>
			</unit>
			<unit id="322" translate="yes">
				<segment state="initial">
					<source>Jump to a named item in a collection</source>
				</segment>
			</unit>
			<unit id="323" translate="yes">
				<segment state="initial">
					<source>Start typing item name</source>
				</segment>
			</unit>
			<unit id="324" translate="yes">
				<segment state="initial">
					<source>Next page</source>
				</segment>
			</unit>
			<unit id="325" translate="yes">
				<segment state="initial">
					<source>Page Up, Page Down or Spacebar</source>
				</segment>
			</unit>
			<unit id="326" translate="yes">
				<segment state="initial">
					<source>Next tab</source>
				</segment>
			</unit>
			<unit id="327" translate="yes">
				<segment state="initial">
					<source>Ctrl+Tab</source>
				</segment>
			</unit>
			<unit id="328" translate="yes">
				<segment state="initial">
					<source>Previous tab</source>
				</segment>
			</unit>
			<unit id="329" translate="yes">
				<segment state="initial">
					<source>Ctrl+Shift+Tab</source>
				</segment>
			</unit>
			<unit id="330" translate="yes">
				<segment state="initial">
					<source>Open app bar</source>
				</segment>
			</unit>
			<unit id="331" translate="yes">
				<segment state="initial">
					<source>Windows+Z</source>
				</segment>
			</unit>
			<unit id="332" translate="yes">
				<segment state="initial">
					<source>Activate or Navigate into an item</source>
				</segment>
			</unit>
			<unit id="333" translate="yes">
				<segment state="initial">
					<source>Enter</source>
				</segment>
			</unit>
			<unit id="334" translate="yes">
				<segment state="initial">
					<source>Select</source>
				</segment>
			</unit>
			<unit id="335" translate="yes">
				<segment state="initial">
					<source>Spacebar</source>
				</segment>
			</unit>
			<unit id="336" translate="yes">
				<segment state="initial">
					<source>Continuously select</source>
				</segment>
			</unit>
			<unit id="337" translate="yes">
				<segment state="initial">
					<source>Shift+Arrow key</source>
				</segment>
			</unit>
			<unit id="338" translate="yes">
				<segment state="initial">
					<source>Select all</source>
				</segment>
			</unit>
			<unit id="339" translate="yes">
				<segment state="initial">
					<source>Ctrl+A</source>
				</segment>
			</unit>
			<unit id="340" translate="yes">
				<segment state="initial">
					<source>Common commands</source>
				</segment>
			</unit>
			<unit id="341" translate="yes">
				<segment state="initial">
					<source>Action</source>
				</segment>
			</unit>
			<unit id="342" translate="yes">
				<segment state="initial">
					<source>Key command</source>
				</segment>
			</unit>
			<unit id="343" translate="yes">
				<segment state="initial">
					<source>Pin an item</source>
				</segment>
			</unit>
			<unit id="344" translate="yes">
				<segment state="initial">
					<source>Ctrl+Shift+1</source>
				</segment>
			</unit>
			<unit id="345" translate="yes">
				<segment state="initial">
					<source>Save</source>
				</segment>
			</unit>
			<unit id="346" translate="yes">
				<segment state="initial">
					<source>Ctrl+S</source>
				</segment>
			</unit>
			<unit id="347" translate="yes">
				<segment state="initial">
					<source>Find</source>
				</segment>
			</unit>
			<unit id="348" translate="yes">
				<segment state="initial">
					<source>Ctrl+F</source>
				</segment>
			</unit>
			<unit id="349" translate="yes">
				<segment state="initial">
					<source>Print</source>
				</segment>
			</unit>
			<unit id="350" translate="yes">
				<segment state="initial">
					<source>Ctrl+P</source>
				</segment>
			</unit>
			<unit id="351" translate="yes">
				<segment state="initial">
					<source>Copy</source>
				</segment>
			</unit>
			<unit id="352" translate="yes">
				<segment state="initial">
					<source>Ctrl+C</source>
				</segment>
			</unit>
			<unit id="353" translate="yes">
				<segment state="initial">
					<source>Cut</source>
				</segment>
			</unit>
			<unit id="354" translate="yes">
				<segment state="initial">
					<source>Ctrl+X</source>
				</segment>
			</unit>
			<unit id="355" translate="yes">
				<segment state="initial">
					<source>New item</source>
				</segment>
			</unit>
			<unit id="356" translate="yes">
				<segment state="initial">
					<source>Ctrl+N</source>
				</segment>
			</unit>
			<unit id="357" translate="yes">
				<segment state="initial">
					<source>Paste</source>
				</segment>
			</unit>
			<unit id="358" translate="yes">
				<segment state="initial">
					<source>Ctrl+V</source>
				</segment>
			</unit>
			<unit id="359" translate="yes">
				<segment state="initial">
					<source>Open</source>
				</segment>
			</unit>
			<unit id="360" translate="yes">
				<segment state="initial">
					<source>Ctrl+O</source>
				</segment>
			</unit>
			<unit id="361" translate="yes">
				<segment state="initial">
					<source>Open address (for example, a URL in Internet Explorer)</source>
				</segment>
			</unit>
			<unit id="362" translate="yes">
				<segment state="initial">
					<source>Ctrl+L or Alt+D</source>
				</segment>
			</unit>
			<unit id="363" translate="yes">
				<segment state="initial">
					<source>Media navigation commands</source>
				</segment>
			</unit>
			<unit id="364" translate="yes">
				<segment state="initial">
					<source>Action</source>
				</segment>
			</unit>
			<unit id="365" translate="yes">
				<segment state="initial">
					<source>Key command</source>
				</segment>
			</unit>
			<unit id="366" translate="yes">
				<segment state="initial">
					<source>Play/Pause</source>
				</segment>
			</unit>
			<unit id="367" translate="yes">
				<segment state="initial">
					<source>Ctrl+P</source>
				</segment>
			</unit>
			<unit id="368" translate="yes">
				<segment state="initial">
					<source>Next item</source>
				</segment>
			</unit>
			<unit id="369" translate="yes">
				<segment state="initial">
					<source>Ctrl+F</source>
				</segment>
			</unit>
			<unit id="370" translate="yes">
				<segment state="initial">
					<source>Preview item</source>
				</segment>
			</unit>
			<unit id="371" translate="yes">
				<segment state="initial">
					<source>Ctrl+B</source>
				</segment>
			</unit>
			<unit id="372" translate="yes">
				<segment state="initial">
					<source>Note: The media navigation key commands for Play/Pause and Next item are the same as the key commands for Print and Find, respectively.</source>
				</segment>
			</unit>
			<unit id="373" translate="yes">
				<segment state="initial">
					<source>Common commands should take priority over media navigation commands.</source>
				</segment>
			</unit>
			<unit id="374" translate="yes">
				<segment state="initial">
					<source>For example, if an app supports both plays media and prints, the key command Ctrl+P should print.</source>
				</segment>
			</unit>
			<unit id="375" translate="yes">
				<segment state="initial">
					<source>Visual feedback</source>
				</segment>
			</unit>
			<unit id="376" translate="yes">
				<segment state="initial">
					<source>Use focus rectangles only with keyboard interactions.</source>
				</segment>
			</unit>
			<unit id="377" translate="yes">
				<segment state="initial">
					<source>If the user initiates a touch interaction, make the keyboard UI gradually fade away.</source>
				</segment>
			</unit>
			<unit id="378" translate="yes">
				<segment state="initial">
					<source>This keeps the UI clean and uncluttered.</source>
				</segment>
			</unit>
			<unit id="379" translate="yes">
				<segment state="initial">
					<source>Don't display visual feedback if an element doesn't support interaction (such as static text).</source>
				</segment>
			</unit>
			<unit id="380" translate="yes">
				<segment state="initial">
					<source>Again, this keeps the UI clean and uncluttered.</source>
				</segment>
			</unit>
			<unit id="381" translate="yes">
				<segment state="initial">
					<source>Try to display visual feedback concurrently for all elements that represent the same input target.</source>
				</segment>
			</unit>
			<unit id="382" translate="yes">
				<segment state="initial">
					<source>Try to provide on-screen buttons (such as + and -) as hints for emulating touch-based manipulations such as panning, rotating, zooming, and so on.</source>
				</segment>
			</unit>
			<unit id="383" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](guidelines-for-visualfeedback.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more general guidance on visual feedback, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Guidelines for visual feedback</pc>.</source>
				</segment>
			</unit>
			<unit id="384" translate="yes">
				<segment state="initial">
					<source>Keyboard events and focus</source>
				</segment>
			</unit>
			<unit id="385" translate="yes">
				<segment state="initial">
					<source>The following keyboard events can occur for both hardware and touch keyboards.</source>
				</segment>
			</unit>
			<unit id="386" translate="yes">
				<segment state="initial">
					<source>Event</source>
				</segment>
			</unit>
			<unit id="387" translate="yes">
				<segment state="initial">
					<source>Description</source>
				</segment>
			</unit>
			<unit id="388" translate="yes">
				<segment state="initial">
					<source>KeyDown</source>
				</segment>
			</unit>
			<unit id="389" translate="yes">
				<segment state="initial">
					<source>Occurs when a key is pressed.</source>
				</segment>
			</unit>
			<unit id="390" translate="yes">
				<segment state="initial">
					<source>KeyUp</source>
				</segment>
			</unit>
			<unit id="391" translate="yes">
				<segment state="initial">
					<source>Occurs when a key is released.</source>
				</segment>
			</unit>
			<unit id="392" translate="yes">
				<segment state="initial">
					<source>Important</source>
				</segment>
			</unit>
			<unit id="393" translate="yes">
				<segment state="initial">
					<source>Some Windows Runtime controls handle input events internally.</source>
				</segment>
			</unit>
			<unit id="394" translate="yes">
				<segment state="initial">
					<source>In these cases, it might appear that an input event doesn't occur because your event listener doesn't invoke the associated handler.</source>
				</segment>
			</unit>
			<unit id="395" translate="yes">
				<segment state="initial">
					<source>Typically, this subset of keys is processed by the class handler to provide built in support of basic keyboard accessibility.</source>
				</segment>
			</unit>
			<unit id="396" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209265)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh967982)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/hh967989)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/br227737)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> class overrides the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OnKeyDown</pc></pc> events for both the Space key and the Enter key (as well as <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">OnPointerPressed</pc></pc>) and routes them to the <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Click</pc></pc> event of the control.</source>
				</segment>
			</unit>
			<unit id="397" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208941)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>When a key press is handled by the control class, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyDown</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyUp</pc></pc> events are not raised.</source>
				</segment>
			</unit>
			<unit id="398" translate="yes">
				<segment state="initial">
					<source>This provides a built-in keyboard equivalent for invoking the button, similar to tapping it with a finger or clicking it with a mouse.</source>
				</segment>
			</unit>
			<unit id="399" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208941)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Keys other than Space or Enter still fire <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyDown</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyUp</pc></pc> events.</source>
				</segment>
			</unit>
			<unit id="400" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt185584)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about how class-based handling of events works (specifically, the "Input event handlers in controls" section), see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Events and routed events overview</pc>.</source>
				</segment>
			</unit>
			<unit id="401" translate="yes">
				<segment state="initial">
					<source>Controls in your UI generate keyboard events only when they have input focus.</source>
				</segment>
			</unit>
			<unit id="402" translate="yes">
				<segment state="initial">
					<source>An individual control gains focus when the user clicks or taps directly on that control in the layout, or uses the Tab key to step into a tab sequence within the content area.</source>
				</segment>
			</unit>
			<unit id="403" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702161)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can also call a control's <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Focus</pc></pc> method to force focus.</source>
				</segment>
			</unit>
			<unit id="404" translate="yes">
				<segment state="initial">
					<source>This is necessary when you implement shortcut keys, because keyboard focus is not set by default when your UI loads.</source>
				</segment>
			</unit>
			<unit id="405" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#shortcut_keys_example)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Shortcut keys example</pc> later in this topic.</source>
				</segment>
			</unit>
			<unit id="406" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209422)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208933)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>For a control to receive input focus, it must be enabled, visible, and have <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsTabStop</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">HitTestVisible</pc></pc> property values of <pc dataRefEnd="id10" dataRefStart="id9" id="p5">true</pc>.</source>
				</segment>
			</unit>
			<unit id="407" translate="yes">
				<segment state="initial">
					<source>This is the default state for most controls.</source>
				</segment>
			</unit>
			<unit id="408" translate="yes">
				<segment state="initial">
					<source>When a control has input focus, it can raise and respond to keyboard input events as described later in this topic.</source>
				</segment>
			</unit>
			<unit id="409" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208927)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208943)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>You can also respond to a control that is receiving or losing focus by handling the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GotFocus</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">LostFocus</pc></pc> events.</source>
				</segment>
			</unit>
			<unit id="410" translate="yes">
				<segment state="initial">
					<source>By default, the tab sequence of controls is the order in which they appear in the Extensible Application Markup Language (XAML).</source>
				</segment>
			</unit>
			<unit id="411" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209461)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>However, you can modify this order by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TabIndex</pc></pc> property.</source>
				</segment>
			</unit>
			<unit id="412" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh868161)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Implementing keyboard accessibility</pc>.</source>
				</segment>
			</unit>
			<unit id="413" translate="yes">
				<segment state="initial">
					<source>Keyboard event handlers</source>
				</segment>
			</unit>
			<unit id="414" translate="yes">
				<segment state="initial">
					<source>An input event handler implements a delegate that provides the following information:</source>
				</segment>
			</unit>
			<unit id="415" translate="yes">
				<segment state="initial">
					<source>The sender of the event.</source>
				</segment>
			</unit>
			<unit id="416" translate="yes">
				<segment state="initial">
					<source>The sender reports the object where the event handler is attached.</source>
				</segment>
			</unit>
			<unit id="417" translate="yes">
				<segment state="initial">
					<source>Event data.</source>
				</segment>
			</unit>
			<unit id="418" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh943072)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For keyboard events, that data will be an instance of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyRoutedEventArgs</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="419" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227904)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The delegate for handlers is <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyEventHandler</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="420" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh943074)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/hh943075)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>The most relevant properties of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KeyRoutedEventArgs</pc> for most handler scenarios are <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Key</pc></pc> and possibly <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">KeyStatus</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="421" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208810)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OriginalSource</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="422" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Because the keyboard events are routed events, the event data provides <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OriginalSource</pc>.</source>
				</segment>
			</unit>
			<unit id="423" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If you deliberately allow events to bubble up through an object tree, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OriginalSource</pc> is sometimes the object of concern rather than sender.</source>
				</segment>
			</unit>
			<unit id="424" translate="yes">
				<segment state="initial">
					<source>However, that depends on your design.</source>
				</segment>
			</unit>
			<unit id="425" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/mt185584)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about how you might use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OriginalSource</pc> rather than sender, see the "Keyboard Routed Events" section of this topic, or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Events and routed events overview</pc>.</source>
				</segment>
			</unit>
			<unit id="426" translate="yes">
				<segment state="initial">
					<source>Attaching a keyboard event handler</source>
				</segment>
			</unit>
			<unit id="427" translate="yes">
				<segment state="initial">
					<source>You can attach keyboard event-handler functions for any object that includes the event as a member.</source>
				</segment>
			</unit>
			<unit id="428" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208911)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This includes any <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> derived class.</source>
				</segment>
			</unit>
			<unit id="429" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242704)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The following XAML example shows how to attach handlers for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyUp</pc></pc> event for a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Grid</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="430" translate="yes">
				<segment state="initial">
					<source>You can also attach an event handler in code.</source>
				</segment>
			</unit>
			<unit id="431" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt185584)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Events and routed events overview</pc>.</source>
				</segment>
			</unit>
			<unit id="432" translate="yes">
				<segment state="initial">
					<source>Defining a keyboard event handler</source>
				</segment>
			</unit>
			<unit id="433" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows the incomplete event handler definition for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyUp</pc></pc> event handler that was attached in the preceding example.</source>
				</segment>
			</unit>
			<unit id="434" translate="yes">
				<segment state="initial">
					<source>Using KeyRoutedEventArgs</source>
				</segment>
			</unit>
			<unit id="435" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh943072)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>All keyboard events use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyRoutedEventArgs</pc></pc> for event data, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">KeyRoutedEventArgs</pc> contains the following properties:</source>
				</segment>
			</unit>
			<unit id="436" translate="yes">
				<segment state="initial">
					<source>Key</source>
				</segment>
			</unit>
			<unit id="437" translate="yes">
				<segment state="initial">
					<source>KeyStatus</source>
				</segment>
			</unit>
			<unit id="438" translate="yes">
				<segment state="initial">
					<source>Handled</source>
				</segment>
			</unit>
			<unit id="439" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208810)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208809)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OriginalSource</pc></pc> (inherited from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">RoutedEventArgs</pc></pc>)</source>
				</segment>
			</unit>
			<unit id="440" translate="yes">
				<segment state="initial">
					<source>Key</source>
				</segment>
			</unit>
			<unit id="441" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208941)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyDown</pc></pc> event is raised if a key is pressed.</source>
				</segment>
			</unit>
			<unit id="442" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Likewise, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyUp</pc></pc> is raised if a key is released.</source>
				</segment>
			</unit>
			<unit id="443" translate="yes">
				<segment state="initial">
					<source>Usually, you listen to the events to process a specific key value.</source>
				</segment>
			</unit>
			<unit id="444" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh943074)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To determine which key is pressed or released, check the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Key</pc></pc> value in the event data.</source>
				</segment>
			</unit>
			<unit id="445" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br241812)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Key</pc> returns a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">VirtualKey</pc></pc> value.</source>
				</segment>
			</unit>
			<unit id="446" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">VirtualKey</pc> enumeration includes all the supported keys.</source>
				</segment>
			</unit>
			<unit id="447" translate="yes">
				<segment state="initial">
					<source>Modifier keys</source>
				</segment>
			</unit>
			<unit id="448" translate="yes">
				<segment state="initial">
					<source>Modifier keys are keys such as Ctrl or Shift that users typically press in combination with other keys.</source>
				</segment>
			</unit>
			<unit id="449" translate="yes">
				<segment state="initial">
					<source>Your app can use these combinations as keyboard shortcuts to invoke app commands.</source>
				</segment>
			</unit>
			<unit id="450" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208941)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>You detect shortcut key combinations by using code in your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyDown</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyUp</pc></pc> event handlers.</source>
				</segment>
			</unit>
			<unit id="451" translate="yes">
				<segment state="initial">
					<source>You can then track the pressed state of the modifier keys you are interested in.</source>
				</segment>
			</unit>
			<unit id="452" translate="yes">
				<segment state="initial">
					<source>When a keyboard event occurs for a non-modifier key, you can check whether a modifier key is in the pressed state at the same time.</source>
				</segment>
			</unit>
			<unit id="453" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The Alt key is represented by the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">VirtualKey.Menu</pc> value.</source>
				</segment>
			</unit>
			<unit id="454" translate="yes">
				<segment state="initial">
					<source>Shortcut keys example</source>
				</segment>
			</unit>
			<unit id="455" translate="yes">
				<segment state="initial">
					<source>The following example demonstrates how to implement shortcut keys.</source>
				</segment>
			</unit>
			<unit id="456" translate="yes">
				<segment state="initial">
					<source>In this example, users can control media playback using Play, Pause, and Stop buttons or Ctrl+P, Ctrl+A, and Ctrl+S keyboard shortcuts.</source>
				</segment>
			</unit>
			<unit id="457" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209081)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The button XAML shows the shortcuts by using tooltips and <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties</pc></pc> properties in the button labels.</source>
				</segment>
			</unit>
			<unit id="458" translate="yes">
				<segment state="initial">
					<source>This self-documentation is important to increase the usability and accessibility of your app.</source>
				</segment>
			</unit>
			<unit id="459" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt244347)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Keyboard accessibility</pc>.</source>
				</segment>
			</unit>
			<unit id="460" translate="yes">
				<segment state="initial">
					<source>Note also that the page sets input focus to itself when it is loaded.</source>
				</segment>
			</unit>
			<unit id="461" translate="yes">
				<segment state="initial">
					<source>Without this step, no control has initial input focus, and the app does not raise input events until the user sets the input focus manually (for example, by tabbing to or clicking a control).</source>
				</segment>
			</unit>
			<unit id="462" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh759762)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/hh759763)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Setting <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationProperties.AcceleratorKey</pc></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">AutomationProperties.AccessKey</pc></pc> in XAML provides string information, which documents the shortcut key for invoking that particular action.</source>
				</segment>
			</unit>
			<unit id="463" translate="yes">
				<segment state="initial">
					<source>The information is captured by Microsoft UI Automation clients such as Narrator, and is typically provided directly to the user.</source>
				</segment>
			</unit>
			<unit id="464" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AutomationProperties.AcceleratorKey</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.AccessKey</pc> does not have any action on its own.</source>
				</segment>
			</unit>
			<unit id="465" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208941)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>You will still need to attach handlers for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyDown</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyUp</pc></pc> events in order to actually implement the keyboard shortcut behavior in your app.</source>
				</segment>
			</unit>
			<unit id="466" translate="yes">
				<segment state="initial">
					<source>Also, the underline text decoration for an access key is not provided automatically.</source>
				</segment>
			</unit>
			<unit id="467" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209982)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You must explicitly underline the text for the specific key in your mnemonic as inline <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Underline</pc></pc> formatting if you wish to show underlined text in the UI.</source>
				</segment>
			</unit>
			<unit id="468" translate="yes">
				<segment state="initial">
					<source>Keyboard routed events</source>
				</segment>
			</unit>
			<unit id="469" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208941)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Certain events are routed events, including <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyDown</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyUp</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="470" translate="yes">
				<segment state="initial">
					<source>Routed events use the bubbling routing strategy.</source>
				</segment>
			</unit>
			<unit id="471" translate="yes">
				<segment state="initial">
					<source>The bubbling routing strategy means that an event originates from a child object and is then routed up to successive parent objects in the object tree.</source>
				</segment>
			</unit>
			<unit id="472" translate="yes">
				<segment state="initial">
					<source>This presents another opportunity to handle the same event and interact with the same event data.</source>
				</segment>
			</unit>
			<unit id="473" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209267)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br209265)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>Consider the following XAML example, which handles <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyUp</pc></pc> events for a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Canvas</pc></pc> and two <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Button</pc></pc> objects.</source>
				</segment>
			</unit>
			<unit id="474" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In this case, if you release a key while focus is held by either <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Button</pc> object, it raises the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyUp</pc> event.</source>
				</segment>
			</unit>
			<unit id="475" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The event is then bubbled up to the parent <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Canvas</pc>.</source>
				</segment>
			</unit>
			<unit id="476" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The following example shows how to implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyUp</pc></pc> event handler for the corresponding XAML content in the preceding example.</source>
				</segment>
			</unit>
			<unit id="477" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208810)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Notice the use of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OriginalSource</pc></pc> property in the preceding handler.</source>
				</segment>
			</unit>
			<unit id="478" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Here, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OriginalSource</pc> reports the object that raised the event.</source>
				</segment>
			</unit>
			<unit id="479" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209635)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The object could not be the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">StackPanel</pc></pc> because the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">StackPanel</pc> is not a control and cannot have focus.</source>
				</segment>
			</unit>
			<unit id="480" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Only one of the two buttons within the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StackPanel</pc> could possibly have raised the event, but which one?</source>
				</segment>
			</unit>
			<unit id="481" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>You use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OriginalSource</pc> to distinguish the actual event source object, if you are handling the event on a parent object.</source>
				</segment>
			</unit>
			<unit id="482" translate="yes">
				<segment state="initial">
					<source>The Handled property in event data</source>
				</segment>
			</unit>
			<unit id="483" translate="yes">
				<segment state="initial">
					<source>Depending on your event handling strategy, you might want only one event handler to react to a bubbling event.</source>
				</segment>
			</unit>
			<unit id="484" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209265)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For instance, if you have a specific <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyUp</pc></pc> handler attached to one of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Button</pc></pc> controls, it would have the first opportunity to handle that event.</source>
				</segment>
			</unit>
			<unit id="485" translate="yes">
				<segment state="initial">
					<source>In this case, you might not want the parent panel to also handle the event.</source>
				</segment>
			</unit>
			<unit id="486" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh943073)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For this scenario, you can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Handled</pc></pc> property in the event data.</source>
				</segment>
			</unit>
			<unit id="487" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh943073)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The purpose of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Handled</pc></pc> property in a routed event data class is to report that another handler you registered earlier on the event route has already acted.</source>
				</segment>
			</unit>
			<unit id="488" translate="yes">
				<segment state="initial">
					<source>This influences the behavior of the routed event system.</source>
				</segment>
			</unit>
			<unit id="489" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When you set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">true</pc> in an event handler, that event stops routing and is not sent to successive parent elements.</source>
				</segment>
			</unit>
			<unit id="490" translate="yes">
				<segment state="initial">
					<source>AddHandler and already-handled keyboard events</source>
				</segment>
			</unit>
			<unit id="491" translate="yes">
				<segment state="initial">
					<source>You can use a special technique for attaching handlers that can act on events that you already marked as handled.</source>
				</segment>
			</unit>
			<unit id="492" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702399)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This technique uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AddHandler</pc></pc> method to register a handler, rather than using XAML attributes or language-specific syntax for adding handlers, such as += in C#.</source>
				</segment>
			</unit>
			<unit id="493" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208808)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>A limitation of this technique in general is that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AddHandler</pc> API takes a parameter of type <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">RoutedEvent</pc></pc> that identifies the routed event in question.</source>
				</segment>
			</unit>
			<unit id="494" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh943073)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Not all routed events provide a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RoutedEvent</pc> identifier, and this consideration thus affects which routed events can still be handled in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Handled</pc></pc> case.</source>
				</segment>
			</unit>
			<unit id="495" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208941)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/hh702416)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/hh702418)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
					<data id="id17">[</data>
					<data id="id18">](https://msdn.microsoft.com/library/windows/apps/br208911)</data>
					<data id="id19">**</data>
					<data id="id20">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyDown</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyUp</pc></pc> events have routed event identifiers (<pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">KeyDownEvent</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">KeyUpEvent</pc></pc>) on <pc dataRefEnd="id18" dataRefStart="id17" id="p9"><pc dataRefEnd="id20" dataRefStart="id19" id="p10">UIElement</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="496" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209706)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>However, other events such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBox.TextChanged</pc></pc> do not have routed event identifiers and thus cannot be used with the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">AddHandler</pc> technique.</source>
				</segment>
			</unit>
			<unit id="497" translate="yes">
				<segment state="initial">
					<source>Commanding</source>
				</segment>
			</unit>
			<unit id="498" translate="yes">
				<segment state="initial">
					<source>A small number of UI elements provide built-in support for commanding.</source>
				</segment>
			</unit>
			<unit id="499" translate="yes">
				<segment state="initial">
					<source>Commanding uses input-related routed events in its underlying implementation.</source>
				</segment>
			</unit>
			<unit id="500" translate="yes">
				<segment state="initial">
					<source>It enables processing of related UI input, such as a certain pointer action or a specific accelerator key, by invoking a single command handler.</source>
				</segment>
			</unit>
			<unit id="501" translate="yes">
				<segment state="initial">
					<source>If commanding is available for a UI element, consider using its commanding APIs instead of any discrete input events.</source>
				</segment>
			</unit>
			<unit id="502" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227740)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ButtonBase.Command</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="503" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227885)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can also implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ICommand</pc></pc> to encapsulate command functionality that you invoke from ordinary event handlers.</source>
				</segment>
			</unit>
			<unit id="504" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This enables you to use commanding even when there is no <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Command</pc> property available.</source>
				</segment>
			</unit>
			<unit id="505" translate="yes">
				<segment state="initial">
					<source>Text input and controls</source>
				</segment>
			</unit>
			<unit id="506" translate="yes">
				<segment state="initial">
					<source>Certain controls react to keyboard events with their own handling.</source>
				</segment>
			</unit>
			<unit id="507" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209683)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For instance, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBox</pc></pc> is a control that is designed to capture and then visually represent text that was entered by using the keyboard.</source>
				</segment>
			</unit>
			<unit id="508" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208941)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br209706)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>It uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyUp</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyDown</pc></pc> in its own logic to capture keystrokes, then also raises its own <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">TextChanged</pc></pc> event if the text actually changed.</source>
				</segment>
			</unit>
			<unit id="509" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208941)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br209683)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>You can still generally add handlers for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyUp</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyDown</pc></pc> to a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">TextBox</pc></pc>, or any related control that is intended to process text input.</source>
				</segment>
			</unit>
			<unit id="510" translate="yes">
				<segment state="initial">
					<source>However, as part of its intended design, a control might not respond to all key values that are directed to it through key events.</source>
				</segment>
			</unit>
			<unit id="511" translate="yes">
				<segment state="initial">
					<source>Behavior is specific to each control.</source>
				</segment>
			</unit>
			<unit id="512" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227736)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209265)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>As an example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ButtonBase</pc></pc> (the base class for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Button</pc></pc>) processes <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">KeyUp</pc></pc> so that it can check for the Spacebar or Enter key.</source>
				</segment>
			</unit>
			<unit id="513" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br227737)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">ButtonBase</pc> considers <pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyUp</pc> equivalent to a mouse left button down for purposes of raising a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Click</pc></pc> event.</source>
				</segment>
			</unit>
			<unit id="514" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh967983)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>This processing of the event is accomplished when <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ButtonBase</pc> overrides the virtual method <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">OnKeyUp</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="515" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh943073)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>In its implementation, it sets <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Handled</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">true</pc>.</source>
				</segment>
			</unit>
			<unit id="516" translate="yes">
				<segment state="initial">
					<source>The result is that any parent of a button that is listening for a key event, in the case of a Spacebar, would not receive the already-handled event for its own handlers.</source>
				</segment>
			</unit>
			<unit id="517" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209683)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Another example is <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBox</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="518" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Some keys, such as the ARROW keys, are not considered text by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TextBox</pc> and are instead considered specific to the control UI behavior.</source>
				</segment>
			</unit>
			<unit id="519" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TextBox</pc> marks these event cases as handled.</source>
				</segment>
			</unit>
			<unit id="520" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh967982)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5"> / </data>
					<data id="id6">[</data>
					<data id="id7">](https://msdn.microsoft.com/library/windows/apps/hh967983)</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
				</originalData>
				<segment state="initial">
					<source>Custom controls can implement their own similar override behavior for key events by overriding <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnKeyDown</pc></pc><ph dataRef="id5" id="ph1" /><pc dataRefEnd="id7" dataRefStart="id6" id="p3"><pc dataRefEnd="id9" dataRefStart="id8" id="p4">OnKeyUp</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="521" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209683)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7"> / </data>
					<data id="id8">**</data>
					<data id="id9">**</data>
				</originalData>
				<segment state="initial">
					<source>If your custom control processes specific accelerator keys, or has control or focus behavior that is similar to the scenario described for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBox</pc></pc>, you should place this logic in your own <pc dataRefEnd="id6" dataRefStart="id5" id="p3">OnKeyDown</pc><ph dataRef="id7" id="ph1" /><pc dataRefEnd="id9" dataRefStart="id8" id="p4">OnKeyUp</pc> overrides.</source>
				</segment>
			</unit>
			<unit id="522" translate="yes">
				<segment state="initial">
					<source>The touch keyboard</source>
				</segment>
			</unit>
			<unit id="523" translate="yes">
				<segment state="initial">
					<source>Text input controls provide automatic support for the touch keyboard.</source>
				</segment>
			</unit>
			<unit id="524" translate="yes">
				<segment state="initial">
					<source>When the user sets the input focus to a text control by using touch input, the touch keyboard appears automatically.</source>
				</segment>
			</unit>
			<unit id="525" translate="yes">
				<segment state="initial">
					<source>When the input focus is not on a text control, the touch keyboard is hidden.</source>
				</segment>
			</unit>
			<unit id="526" translate="yes">
				<segment state="initial">
					<source>When the touch keyboard appears, it automatically repositions your UI to ensure that the focused element remains visible.</source>
				</segment>
			</unit>
			<unit id="527" translate="yes">
				<segment state="initial">
					<source>This can cause other important areas of your UI to move off screen.</source>
				</segment>
			</unit>
			<unit id="528" translate="yes">
				<segment state="initial">
					<source>However, you can disable the default behavior and make your own UI adjustments when the touch keyboard appears.</source>
				</segment>
			</unit>
			<unit id="529" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=231633)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Responding to the appearance of the on-screen keyboard sample</pc>.</source>
				</segment>
			</unit>
			<unit id="530" translate="yes">
				<segment state="initial">
					<source>If you create a custom control that requires text input, but does not derive from a standard text input control, you can add touch keyboard support by implementing the correct UI Automation control patterns.</source>
				</segment>
			</unit>
			<unit id="531" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](respond-to-the-presence-of-the-touch-keyboard.md)</data>
					<data id="id3">[</data>
					<data id="id4">](http://go.microsoft.com/fwlink/p/?linkid=246019)</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Respond to the presence of the touch keyboard</pc> and the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Touch keyboard sample</pc>.</source>
				</segment>
			</unit>
			<unit id="532" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208941)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Key presses on the touch keyboard raise <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyDown</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyUp</pc></pc> events just like key presses on hardware keyboards.</source>
				</segment>
			</unit>
			<unit id="533" translate="yes">
				<segment state="initial">
					<source>However, the touch keyboard will not raise input events for Ctrl+A, Ctrl+Z, Ctrl+X, Ctrl+C, and Ctrl+V, which are reserved for text manipulation in the input control.</source>
				</segment>
			</unit>
			<unit id="534" translate="yes">
				<segment state="initial">
					<source>You can make it much faster and easier for users to enter data in your app by setting the input scope of the text control to match the kind of data you expect the user to enter.</source>
				</segment>
			</unit>
			<unit id="535" translate="yes">
				<segment state="initial">
					<source>The input scope provides a hint at the type of text input expected by the control so the system can provide a specialized touch keyboard layout for the input type.</source>
				</segment>
			</unit>
			<unit id="536" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702632)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh702028)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, if a text box is used only to enter a 4-digit PIN, set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">InputScope</pc></pc> property to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Number</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="537" translate="yes">
				<segment state="initial">
					<source>This tells the system to show the numeric keypad layout, which makes it easier for the user to enter the PIN.</source>
				</segment>
			</unit>
			<unit id="538" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt280229)</data>
				</originalData>
				<segment state="initial">
					<source>For more detail, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Use input scope to change the touch keyboard</pc>.</source>
				</segment>
			</unit>
			<unit id="539" translate="yes">
				<segment state="initial">
					<source>Additional articles in this section</source>
				</segment>
			</unit>
			<unit id="540" translate="yes">
				<segment state="initial">
					<source>Topic</source>
				</segment>
			</unit>
			<unit id="541" translate="yes">
				<segment state="initial">
					<source>Description</source>
				</segment>
			</unit>
			<unit id="542" translate="yes">
				<segment state="initial">
					<source>Respond to the presence of the touch keyboard</source>
				</segment>
			</unit>
			<unit id="543" translate="yes">
				<segment state="initial">
					<source>Learn how to tailor the UI of your app when showing or hiding the touch keyboard.</source>
				</segment>
			</unit>
			<unit id="544" translate="yes">
				<segment state="initial">
					<source>Related articles</source>
				</segment>
			</unit>
			<unit id="545" translate="yes">
				<segment state="initial">
					<source>Developers</source>
				</segment>
			</unit>
			<unit id="546" translate="yes">
				<segment state="initial">
					<source>Identify input devices</source>
				</segment>
			</unit>
			<unit id="547" translate="yes">
				<segment state="initial">
					<source>Respond to the presence of the touch keyboard</source>
				</segment>
			</unit>
			<unit id="548" translate="yes">
				<segment state="initial">
					<source>Designers</source>
				</segment>
			</unit>
			<unit id="549" translate="yes">
				<segment state="initial">
					<source>Keyboard design guidelines</source>
				</segment>
			</unit>
			<unit id="550" translate="yes">
				<segment state="initial">
					<source>Samples</source>
				</segment>
			</unit>
			<unit id="551" translate="yes">
				<segment state="initial">
					<source>Basic input sample</source>
				</segment>
			</unit>
			<unit id="552" translate="yes">
				<segment state="initial">
					<source>Low latency input sample</source>
				</segment>
			</unit>
			<unit id="553" translate="yes">
				<segment state="initial">
					<source>Focus visuals sample</source>
				</segment>
			</unit>
			<unit id="554" translate="yes">
				<segment state="initial">
					<source>Archive Samples</source>
				</segment>
			</unit>
			<unit id="555" translate="yes">
				<segment state="initial">
					<source>Input sample</source>
				</segment>
			</unit>
			<unit id="556" translate="yes">
				<segment state="initial">
					<source>Input: Device capabilities sample</source>
				</segment>
			</unit>
			<unit id="557" translate="yes">
				<segment state="initial">
					<source>Input: Touch keyboard sample</source>
				</segment>
			</unit>
			<unit id="558" translate="yes">
				<segment state="initial">
					<source>Responding to the appearance of the on-screen keyboard sample</source>
				</segment>
			</unit>
			<unit id="559" translate="yes">
				<segment state="initial">
					<source>XAML text editing sample</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>