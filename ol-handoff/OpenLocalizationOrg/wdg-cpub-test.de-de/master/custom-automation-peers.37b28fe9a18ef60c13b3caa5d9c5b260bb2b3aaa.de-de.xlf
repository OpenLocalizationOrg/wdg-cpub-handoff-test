<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">19b991686461d12e511fadf6ff40831d4b284815</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\accessibility\custom-automation-peers.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">b174e5e003e842c4d0887459ba32d36151a13b81</mda:meta><mda:meta type="olxliffhash">12f6753571c0e17d7bd09b775fec738db4616569</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Describes the concept of automation peers for Microsoft UI Automation, and how you can provide automation support for your own custom UI class.</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Custom automation peers</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Custom automation peers</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Describes the concept of automation peers for Microsoft UI Automation, and how you can provide automation support for your own custom UI class.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>UI Automation provides a framework that automation clients can use to examine or operate the user interfaces of a variety of UI platforms and frameworks.</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>If you are writing a Universal Windows Platform (UWP) app, the classes that you use for your UI already provide UI Automation support.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>You can derive from existing, non-sealed classes to define a new kind of UI control or support class.</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>In the process of doing so, your class might add behavior that should have accessibility support but that the default UI Automation support does not cover.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In this case, you should extend the existing UI Automation support by deriving from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> class that the base implementation used, adding any necessary support to your peer implementation, and informing the Universal Windows Platform (UWP) control infrastructure that it should create your new peer.</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>UI Automation enables not only accessibility applications and assistive technologies, such as screen readers, but also quality-assurance (test) code.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>In either scenario, UI Automation clients can examine user-interface elements and simulate user interaction with your app from other code outside your app.</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee684076)</data>
				</originalData>
				<segment state="initial">
					<source>For info about UI Automation across all platforms and in its wider meaning, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Overview</pc>.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>There are two distinct audiences who use the UI Automation framework.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>UI Automation <pc dataRefEnd="id2" dataRefStart="id1" id="p1">clients</pc> call UI Automation APIs to learn about all of the UI that is currently displayed to the user.</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>For example, an assistive technology such as a screen reader acts as a UI Automation client.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>The UI is presented as a tree of automation elements that are related.</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>The UI Automation client might be interested in just one app at a time, or in the entire tree.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>The UI Automation client can use UI Automation APIs to navigate the tree and to read or change information in the automation elements.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>UI Automation <pc dataRefEnd="id2" dataRefStart="id1" id="p1">providers</pc> contribute information to the UI Automation tree, by implementing APIs that expose the elements in the UI that they introduced as part of their app.</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>When you create a new control, you should now act as a participant in the UI Automation provider scenario.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>As a provider, you should ensure that all UI Automation clients can use the UI Automation framework to interact with your control for both accessibility and testing purposes.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Typically there are parallel APIs in the UI Automation framework: one API for UI Automation clients and another, similarly named API for UI Automation providers.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>For the most part, this topic covers the APIs for the UI Automation provider, and specifically the classes and interfaces that enable provider extensibility in that UI framework.</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Occasionally we mention UI Automation APIs that the UI Automation clients use, to provide some perspective, or provide a lookup table that correlates the client and provider APIs.</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee684021)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about the client perspective, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Client Programmer's Guide</pc>.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>Note</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>UI Automation clients don't typically use managed code and aren't typically implemented as a UWP app (they are usually desktop apps).</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<segment state="initial">
					<source>UI Automation is based on a standard and not a specific implementation or framework.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Many existing UI Automation clients, including assistive technology products such as screen readers, use Component Object Model (COM) interfaces to interact with UI Automation, the system, and the apps that run in child windows.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee684007)</data>
				</originalData>
				<segment state="initial">
					<source>For more info on the COM interfaces and how to write a UI Automation client using COM, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Fundamentals</pc>.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Determining the existing state of UI Automation support for your custom UI class</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Before you attempt to implement an automation peer for a custom control, you should test whether the base class and its automation peer already provides the accessibility or automation support that you need.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242472)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In many cases, the combination of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElementAutomationPeer</pc></pc> implementations, specific peers, and the patterns they implement can provide a basic but satisfactory accessibility experience.</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<segment state="initial">
					<source>Whether this is true depends on how many changes you made to the object model exposure to your control versus its base class.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>Also, this depends on whether your additions to base class functionality correlate to new UI elements in the template contract or to the visual appearance of the control.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>In some cases your changes might introduce new aspects of user experience that require additional accessibility support.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Even if using the existing base peer class provides the basic accessibility support, it is still a best practice to define a peer so that you can report precise <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ClassName</pc> information to UI Automation for automated testing scenarios.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>This consideration is especially important if you are writing a control that is intended for third-party consumption.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<segment state="initial">
					<source>Automation peer classes</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>The UWP builds on existing UI Automation techniques and conventions used by previous managed-code UI frameworks such as Windows Forms, Windows Presentation Foundation (WPF) and Microsoft Silverlight.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<segment state="initial">
					<source>Many of the control classes and their function and purpose also have their origin in a previous UI framework.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<segment state="initial">
					<source>By convention, peer class names begin with the control class name and end with "AutomationPeer".</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242458)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209265)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ButtonAutomationPeer</pc></pc> is the peer class for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Button</pc></pc> control class.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For purposes of this topic, we treat the properties that are related to accessibility as being more important when you implement a control peer.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671596)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/Ee684007)</data>
				</originalData>
				<segment state="initial">
					<source>But for a more general concept of UI Automation support, you should implement a peer in accordance with recommendations as documented by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Provider Programmer's Guide</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">UI Automation Fundamentals</pc>.</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Those topics don't cover the specific <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> APIs that you would use to provide the information in the UWP framework for UI Automation, but they do describe the properties that identify your class or provide other information or interaction.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>Peers, patterns and control types</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">control pattern</pc> is an interface implementation that exposes a particular aspect of a control's functionality to a UI Automation client.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>UI Automation clients use the properties and methods exposed through a control pattern to retrieve information about capabilities of the control, or to manipulate the control's behavior at run time.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>Control patterns provide a way to categorize and expose a control's functionality independent of the control type or the appearance of the control.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, a control that presents a tabular interface uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Grid</pc> control pattern to expose the number of rows and columns in the table, and to enable a UI Automation client to retrieve items from the table.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>As other examples, the UI Automation client can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Invoke</pc> control pattern for controls that can be invoked, such as buttons, and the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Scroll</pc> control pattern for controls that have scroll bars, such as list boxes, list views, or combo boxes.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Each control pattern represents a separate type of functionality, and control patterns can be combined to describe the full set of functionality supported by a particular control.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Control patterns relate to UI as interfaces relate to COM objects.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>In COM, you can query an object to ask what interfaces it supports and then use those interfaces to access functionality.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>In UI Automation, UI Automation clients can query a UI Automation element to find out which control patterns it supports, and then interact with the element and its peered control through the properties, methods, events, and structures exposed by the supported control patterns.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<segment state="initial">
					<source>One of the main purposes of an automation peer is to report to a UI Automation client which control patterns the UI element can support through its peer.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpattern)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>To do this, UI Automation providers implement new peers that change the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPattern</pc></pc> method behavior by overriding the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetPatternCore</pc></pc> method.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>UI Automation clients make calls that the UI Automation provider maps to calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetPattern</pc>.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>UI Automation clients query for each specific pattern that they want to interact with.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If the peer supports the pattern, it returns an object reference to itself; otherwise it returns <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc>.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If the return is not <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc>, the UI Automation client expects that it can call APIs of the pattern interface as a client, in order to interact with that control pattern.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">control type</pc> is a way to broadly define the functionality of a control that the peer represents.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>This is a different concept than a control pattern because while a pattern informs UI Automation what info it can get or what actions it can perform through a particular interface, the control type exists one level above that.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Each control type has guidance about these aspects of UI Automation:</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>UI Automation control patterns: A control type might support more than one pattern, each of which represents a different classification of info or interaction.</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>Each control type has a set of control patterns that the control must support, a set that is optional, and a set that the control must not support.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>UI Automation property values: Each control type has a set of properties that the control must support.</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671594)</data>
				</originalData>
				<segment state="initial">
					<source>These are the general properties, as described in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Properties Overview</pc>, not the ones that are pattern-specific.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>UI Automation events: Each control type has a set of events that the control must support.</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671221)</data>
				</originalData>
				<segment state="initial">
					<source>Again these are general, not pattern-specific, as described in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Events Overview</pc>.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>UI Automation tree structure: Each control type defines how the control must appear in the UI Automation tree structure.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>Regardless of how automation peers for the framework are implemented, UI Automation client functionality isn't tied to the UWP, and in fact it's likely that existing UI Automation clients such as assistive technologies will use other programming models, such as COM.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In COM, clients can <pc dataRefEnd="id2" dataRefStart="id1" id="p1">QueryInterface</pc> for the COM control pattern interface that implements the requested pattern or the general UI Automation framework for properties, events or tree examination.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>For the patterns, the UI Automation framework marshals that interface code across into UWP code running against the app's UI Automation provider and the relevant peer.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>When you implement control patterns for a managed-code framework such as a Windows Store app using C# or Microsoft Visual Basic, you can use .NET Framework interfaces to represent these patterns instead of using the COM interface representation.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR242582)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, the UI Automation pattern interface for a Microsoft .NET provider implementation of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Invoke</pc> pattern is <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IInvokeProvider</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](control-patterns-and-interfaces.md)</data>
				</originalData>
				<segment state="initial">
					<source>For a list of control patterns, provider interfaces, and their purpose, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Control patterns and interfaces</pc>.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671197)</data>
				</originalData>
				<segment state="initial">
					<source>For the list of the control types, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Control Types Overview</pc>.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>Guidance for how to implement control patterns</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<segment state="initial">
					<source>The control patterns and what they're intended for are part of a larger definition of the UI Automation framework, and don't just apply to the accessibility support for a Windows Store app.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<segment state="initial">
					<source>When you implement a control pattern you should make sure you're implementing it in a way that matches the guidance as documented on MSDN and also in the UI Automation specification.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<segment state="initial">
					<source>If you're looking for guidance, you can generally use the MSDN topics and won't need to refer to the specification.</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671292)</data>
				</originalData>
				<segment state="initial">
					<source>Guidance for each pattern is documented here: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Implementing UI Automation Control Patterns</pc>.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>You'll notice that each topic under this area has an "Implementation Guidelines and Conventions" section and "Required Members" section.</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671201)</data>
				</originalData>
				<segment state="initial">
					<source>The guidance usually refers to specific APIs of the relevant control pattern interface in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Control Pattern Interfaces for Providers</pc> reference.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>Those interfaces are the native/COM interfaces (and their APIs use COM-style syntax).</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209225)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>But everything you see there has an equivalent in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Automation.Provider</pc></pc> namespace.</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>If you're using the default automation peers and expanding on their behavior, those peers have already been written in conformance to UI Automation guidelines.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671292)</data>
				</originalData>
				<segment state="initial">
					<source>If they support control patterns, you can rely on that pattern support conforming with guidance at <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Implementing UI Automation Control Patterns</pc>.</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671633)</data>
				</originalData>
				<segment state="initial">
					<source>If a control peer reports that it's representative of a control type defined by UI Automation, then the guidance documented at <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Supporting UI Automation Control Types</pc> has been followed by that peer.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>Nevertheless you might need additional guidance for control patterns or control types in order to follow the UI Automation recommendations in your peer implementation.</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>That would be particularly true if you're implementing pattern or control type support that doesn't yet exist as a default implementation in a UWP control.</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>For example, the pattern for annotations isn't implemented in any of the default XAML controls.</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>But you might have an app that uses annotations extensively and therefore you want to surface that functionality to be accessible.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh738493)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>For this scenario, your peer should implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAnnotationProvider</pc></pc> and should probably report itself as the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Document</pc> control type with appropriate properties to indicate that your documents support annotation.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671292)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/Ee671633)</data>
				</originalData>
				<segment state="initial">
					<source>We recommend that you use the guidance that you see for the patterns under <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Implementing UI Automation Control Patterns</pc> or control types under <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Supporting UI Automation Control Types</pc> as orientation and general guidance.</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>You might even try following some of the API links for descriptions and remarks as to the purpose of the APIs.</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209225)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>But for syntax specifics that are needed for UWP app programming, find the equivalent API within the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Automation.Provider</pc></pc> namespace and use those reference pages for more info.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>Built-in automation peer classes</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>In general, elements implement an automation peer class if they accept UI activity from the user, or if they contain information needed by users of assistive technologies that represent the interactive or meaningful UI of apps.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>Not all UWP visual elements have automation peers.</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209265)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209683)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Examples of classes that implement automation peers are <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TextBox</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209250)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR227511)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242704)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR209267)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>Examples of classes that do not implement automation peers are <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Border</pc></pc> and classes based on <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Panel</pc></pc>, such as <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Grid</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Canvas</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc> has no peer because it is providing a layout behavior that is visual only.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>There is no accessibility-relevant way for the user to interact with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc>.</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Whatever child elements a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc> contains are instead reported to UI Automation trees as child elements of the next available parent in the tree that has a peer or element representation.</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>UI Automation and UWP process boundaries</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>Typically, UI Automation client code that accesses a UWP app runs out-of-process.</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<segment state="initial">
					<source>The UI Automation framework infrastructure enables information to get across the process boundary.</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee684007)</data>
				</originalData>
				<segment state="initial">
					<source>This concept is explained in more detail in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Fundamentals</pc>.</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>OnCreateAutomationPeer</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208911_oncreateautomationpeer)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>All classes that derive from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> contain the protected virtual method <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OnCreateAutomationPeer</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The object initialization sequence for automation peers calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OnCreateAutomationPeer</pc> to get the automation peer object for each control and thus to construct a UI Automation tree for run-time use.</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>UI Automation code can use the peer to get information about a control’s characteristics and features and to simulate interactive use by means of its control patterns.</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>A custom control that supports automation must override <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OnCreateAutomationPeer</pc> and return an instance of a class that derives from <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationPeer</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227736)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR242460)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, if a custom control derives from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ButtonBase</pc></pc> class, the object returned by <pc dataRefEnd="id6" dataRefStart="id5" id="p3">OnCreateAutomationPeer</pc> should derive from <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ButtonBaseAutomationPeer</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911_oncreateautomationpeer)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you're writing a custom control class and intend to also supply a new automation peer, you should override the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnCreateAutomationPeer</pc></pc> method for your custom control so that it returns a new instance of your peer.</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Your peer class must derive directly or indirectly from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">`NumericUpDown`</data>
					<data id="id2">`NumericUpDownPeer`</data>
				</originalData>
				<segment state="initial">
					<source>For example, the following code declares that the custom control <ph dataRef="id1" id="ph1" /> should use the peer <ph dataRef="id2" id="ph2" /> for UI Automation purposes.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>C</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>VB</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>C++</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR208911_oncreateautomationpeer)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">OnCreateAutomationPeer</pc></pc> implementation should do nothing more than initialize a new instance of your custom automation peer, passing the calling control as owner, and return that instance.</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>Do not attempt additional logic in this method.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In particular, any logic that could potentially lead to destruction of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> within the same call may result in unexpected runtime behavior.</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911_oncreateautomationpeer)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">*</data>
					<data id="id6">*</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>In typical implementations of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnCreateAutomationPeer</pc></pc>, the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">owner</pc> is specified as <pc dataRefEnd="id8" dataRefStart="id7" id="p4">this</pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Me</pc> because the method override is in the same scope as the rest of the control class definition.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>The actual peer class definition can be done in the same code file as the control or in a separate code file.</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242563)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The peer definitions all exist in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Automation.Peers</pc></pc> namespace that is a separate namespace from the controls that they provide peers for.</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911_oncreateautomationpeer)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can choose to declare your peers in separate namespaces also, as long as you reference the necessary namespaces for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnCreateAutomationPeer</pc></pc> method call.</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>Choosing the correct peer base class</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Make sure that your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> is derived from a base class that gives you the best match for the existing peer logic of the control class you are deriving from.</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<originalData>
					<data id="id1">`NumericUpDown`</data>
					<data id="id2">[</data>
					<data id="id3">](https://msdn.microsoft.com/library/windows/apps/BR227863)</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">[</data>
					<data id="id7">](https://msdn.microsoft.com/library/windows/apps/BR242506)</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
				</originalData>
				<segment state="initial">
					<source>In the case of the previous example, because <ph dataRef="id1" id="ph1" /> derives from <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">RangeBase</pc></pc>, there is a <pc dataRefEnd="id7" dataRefStart="id6" id="p3"><pc dataRefEnd="id9" dataRefStart="id8" id="p4">RangeBaseAutomationPeer</pc></pc> class available that you should base your peer on.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242590)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>By using the closest matching peer class in parallel to how you derive the control itself, you can avoid overriding at least some of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IRangeValueProvider</pc></pc> functionality because the base peer class already implements it.</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209390)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The base <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control</pc></pc> class does not have a corresponding peer class.</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR242472)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>If you need a peer class to correspond to a custom control that derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Control</pc>, derive the custom peer class from <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FrameworkElementAutomationPeer</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209365)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208911_oncreateautomationpeer)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>If you derive from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentControl</pc></pc> directly, that class has no default automation peer behavior because there is no <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OnCreateAutomationPeer</pc></pc> implementation that references a peer class.</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR242472)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>So make sure either to implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OnCreateAutomationPeer</pc> to use your own peer, or to use <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FrameworkElementAutomationPeer</pc></pc> as the peer if that level of accessibility support is adequate for your control.</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR242472)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  You don't typically derive from <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationPeer</pc></pc> rather than <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">FrameworkElementAutomationPeer</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you did derive directly from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AutomationPeer</pc> you'll need to duplicate a lot of basic accessibility support that would otherwise come from <pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElementAutomationPeer</pc>.</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<segment state="initial">
					<source>Initialization of a custom peer class</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<segment state="initial">
					<source>The automation peer should define a type-safe constructor that uses an instance of the owner control for base initialization.</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<originalData>
					<data id="id1">*</data>
					<data id="id2">*</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR242506)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR242472)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">*</data>
					<data id="id12">*</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR242472_owner)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>In the next example, the implementation passes the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">owner</pc> value on to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">RangeBaseAutomationPeer</pc></pc> base, and ultimately it is the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">FrameworkElementAutomationPeer</pc></pc> that actually uses <pc dataRefEnd="id12" dataRefStart="id11" id="p6">owner</pc> to set <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">FrameworkElementAutomationPeer.Owner</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>C</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>VB</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>C++</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>Core methods of AutomationPeer</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>For UWP infrastructure reasons, the overridable methods of an automation peer are part of a pair of methods: the public access method that the UI Automation provider uses as a forwarding point for UI Automation clients, and the protected "Core" customization method that a UWP class can override to influence the behavior.</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>The method pair is wired together by default in such a way that the call to the access method always invokes the parallel "Core" method that has the provider implementation, or as a fallback, invokes a default implementation from the base classes.</source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<segment state="initial">
					<source>When implementing a peer for a custom control, override any of the "Core" methods from the base automation peer class where you want to expose behavior that is unique to your custom control.</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>UI Automation code gets information about your control by calling public methods of the peer class.</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<segment state="initial">
					<source>To provide information about your control, override each method with a name that ends with "Core" when your control implementation and design creates accessibility scenarios or other UI Automation scenarios that differ from what's supported by the base automation peer class.</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getclassnamecore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>At a minimum, whenever you define a new peer class, implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetClassNameCore</pc></pc> method, as shown in the next example.</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>C</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  You might want to store the strings as constants rather than directly in the method body, but that is up to you.</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getclassnamecore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetClassNameCore</pc></pc>, you won't need to localize this string.</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">LocalizedControlType</pc> property is used any time a localized string is needed by a UI Automation client, not <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClassName</pc>.</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<segment state="initial">
					<source>GetAutomationControlType</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getautomationcontroltype)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Some assistive technologies use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetAutomationControlType</pc></pc> value directly when reporting characteristics of the items in a UI Automation tree, as additional information beyond the UI Automation <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Name</pc>.</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getautomationcontroltypecore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If your control is significantly different from the control you are deriving from and you want to report a different control type from what is reported by the base peer class used by the control, you must implement a peer and override <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetAutomationControlTypeCore</pc></pc> in your peer implementation.</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242803)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209365)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>This is particularly important if you derive from a generalized base class such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsControl</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ContentControl</pc></pc>, where the base peer doesn't provide precise information about control type.</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getautomationcontroltypecore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209182)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Your implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetAutomationControlTypeCore</pc></pc> describes your control by returning an <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">AutomationControlType</pc></pc> value.</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Although you can return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AutomationControlType.Custom</pc>, you should return one of the more specific control types if it accurately describes your control's main scenarios.</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>Here's an example.</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>C</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR209182)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR209185_getlocalizedcontroltypecore)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Unless you specify <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationControlType.Custom</pc></pc>, you don't have to implement <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">GetLocalizedControlTypeCore</pc></pc> to provide a <pc dataRefEnd="id12" dataRefStart="id11" id="p6">LocalizedControlType</pc> property value to clients.</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>UI Automation common infrastructure provides translated strings for every possible <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AutomationControlType</pc> value other than <pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationControlType.Custom</pc>.</source>
				</segment>
			</unit>
			<unit id="270" translate="yes">
				<segment state="initial">
					<source>GetPattern and GetPatternCore</source>
				</segment>
			</unit>
			<unit id="271" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A peer's implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> returns the object that supports the pattern that is requested in the input parameter.</source>
				</segment>
			</unit>
			<unit id="272" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpattern)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242496)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Specifically, a UI Automation client calls a method that is forwarded to the provider's <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPattern</pc></pc> method, and specifies a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PatternInterface</pc></pc> enumeration value that names the requested pattern.</source>
				</segment>
			</unit>
			<unit id="273" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Your override of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetPatternCore</pc> should return the object that implements the specified pattern.</source>
				</segment>
			</unit>
			<unit id="274" translate="yes">
				<segment state="initial">
					<source>That object is the peer itself, because the peer should implement the corresponding pattern interface any time that it reports that it supports a pattern.</source>
				</segment>
			</unit>
			<unit id="275" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If your peer does not have a custom implementation of a pattern, but you know that the peer's base does implement the pattern, you can call the base type's implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetPatternCore</pc> from your <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc>.</source>
				</segment>
			</unit>
			<unit id="276" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A peer's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetPatternCore</pc> should return <pc dataRefEnd="id4" dataRefStart="id3" id="p2">null</pc> if a pattern is not supported by the peer.</source>
				</segment>
			</unit>
			<unit id="277" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>However, instead of returning <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> directly from your implementation, you would usually rely on the call to the base implementation to return <pc dataRefEnd="id4" dataRefStart="id3" id="p2">null</pc> for any unsupported pattern.</source>
				</segment>
			</unit>
			<unit id="278" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>When a pattern is supported, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> implementation can return <pc dataRefEnd="id6" dataRefStart="id5" id="p3">this</pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Me</pc>.</source>
				</segment>
			</unit>
			<unit id="279" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpattern)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The expectation is that the UI Automation client will cast the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPattern</pc></pc> return value to the requested pattern interface whenever it is not <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc>.</source>
				</segment>
			</unit>
			<unit id="280" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If a peer class inherits from another peer, and all necessary support and pattern reporting is already handled by the base class, implementing <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> isn't necessary.</source>
				</segment>
			</unit>
			<unit id="281" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227863)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242506)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242496)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">[</data>
					<data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR242590)</data>
					<data id="id15">**</data>
					<data id="id16">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, if you are implementing a range control that derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RangeBase</pc></pc>, and your peer derives from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">RangeBaseAutomationPeer</pc></pc>, that peer returns itself for <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PatternInterface.RangeValue</pc></pc> and has working implementations of the <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">IRangeValueProvider</pc></pc> interface that supports the pattern.</source>
				</segment>
			</unit>
			<unit id="282" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242506)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Although it is not the literal code, this example approximates the implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> already present in <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">RangeBaseAutomationPeer</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="283" translate="yes">
				<segment state="initial">
					<source>C</source>
				</segment>
			</unit>
			<unit id="284" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you are implementing a peer where you don't have all the support you need from a base peer class, or you want to change or add to the set of base-inherited patterns that your peer can support, then you should override <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> to enable UI Automation clients to use the patterns.</source>
				</segment>
			</unit>
			<unit id="285" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209225)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For a list of the provider patterns that are available in the UWP implementation of UI Automation support, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Automation.Provider</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="286" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242496)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpattern)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Each such pattern has a corresponding value of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PatternInterface</pc></pc> enumeration, which is how UI Automation clients request the pattern in a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetPattern</pc></pc> call.</source>
				</segment>
			</unit>
			<unit id="287" translate="yes">
				<segment state="initial">
					<source>A peer can report that it supports more than one pattern.</source>
				</segment>
			</unit>
			<unit id="288" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242496)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If so, the override should include return path logic for each supported <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PatternInterface</pc></pc> value and return the peer in each matching case.</source>
				</segment>
			</unit>
			<unit id="289" translate="yes">
				<segment state="initial">
					<source>It is expected that the caller will request only one interface at a time, and it is up to the caller to cast to the expected interface.</source>
				</segment>
			</unit>
			<unit id="290" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's an example of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> override for a custom peer.</source>
				</segment>
			</unit>
			<unit id="291" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242590)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242653)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>It reports the support for two patterns, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IRangeValueProvider</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IToggleProvider</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="292" translate="yes">
				<segment state="initial">
					<source>The control here is a media display control that can display as full-screen (the toggle mode) and that has a progress bar within which users can select a position (the range control).</source>
				</segment>
			</unit>
			<unit id="293" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=238570)</data>
				</originalData>
				<segment state="initial">
					<source>This code came from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML accessibility sample</pc>.</source>
				</segment>
			</unit>
			<unit id="294" translate="yes">
				<segment state="initial">
					<source>C</source>
				</segment>
			</unit>
			<unit id="295" translate="yes">
				<segment state="initial">
					<source>Forwarding patterns from subelements</source>
				</segment>
			</unit>
			<unit id="296" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> method implementation can also specify a subelement or part as a pattern provider for its host.</source>
				</segment>
			</unit>
			<unit id="297" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242803)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209527)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>This example mimics how <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsControl</pc></pc> transfers scroll-pattern handling to the peer of its internal <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ScrollViewer</pc></pc> control.</source>
				</segment>
			</unit>
			<unit id="298" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242472_createpeerforelement)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>To specify a subelement for pattern handling, this code gets the subelement object, creates a peer for the subelement by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.CreatePeerForElement</pc></pc> method, and returns the new peer.</source>
				</segment>
			</unit>
			<unit id="299" translate="yes">
				<segment state="initial">
					<source>C</source>
				</segment>
			</unit>
			<unit id="300" translate="yes">
				<segment state="initial">
					<source>Other Core methods</source>
				</segment>
			</unit>
			<unit id="301" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](keyboard-accessibility.md)</data>
				</originalData>
				<segment state="initial">
					<source>Your control may need to support keyboard equivalents for primary scenarios; for more info about why this might be necessary, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Keyboard accessibility</pc>.</source>
				</segment>
			</unit>
			<unit id="302" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getacceleratorkeycore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209185_getaccesskeycore)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Implementing the key support is necessarily part of the control code and not the peer code because that is part of a control's logic, but your peer class should override the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetAcceleratorKeyCore</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetAccessKeyCore</pc></pc> methods to report to UI Automation clients which keys are used.</source>
				</segment>
			</unit>
			<unit id="303" translate="yes">
				<segment state="initial">
					<source>Consider that the strings that report key information might need to be localized, and should therefore come from resources, not hard-coded strings.</source>
				</segment>
			</unit>
			<unit id="304" translate="yes">
				<segment state="initial">
					<source>If you are providing a peer for a class that supports a collection, it's best to derive from both functional classes and peer classes that already have that kind of collection support.</source>
				</segment>
			</unit>
			<unit id="305" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getchildrencore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If you can't do so, peers for controls that maintain child collections may have to override the collection-related peer method <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetChildrenCore</pc></pc> to properly report the parent-child relationships to the UI Automation tree.</source>
				</segment>
			</unit>
			<unit id="306" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_iscontentelementcore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209185_iscontrolelementcore)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsContentElementCore</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IsControlElementCore</pc></pc> methods to indicate whether your control contains data content or fulfills an interactive role in the user interface (or both).</source>
				</segment>
			</unit>
			<unit id="307" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>By default, both methods return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc>.</source>
				</segment>
			</unit>
			<unit id="308" translate="yes">
				<segment state="initial">
					<source>These settings improve the usability of assistive technologies such as screen readers, which may use these methods to filter the automation tree.</source>
				</segment>
			</unit>
			<unit id="309" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>If your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> method transfers pattern handling to a subelement peer, the subelement peer's <pc dataRefEnd="id6" dataRefStart="id5" id="p3">IsControlElementCore</pc> method can return <pc dataRefEnd="id8" dataRefStart="id7" id="p4">false</pc> to hide the subelement peer from the automation tree.</source>
				</segment>
			</unit>
			<unit id="310" translate="yes">
				<segment state="initial">
					<source>Some controls may support labeling scenarios, where a text label part supplies information for a non-text part, or a control is intended to be in a known labeling relationship with another control in the UI.</source>
				</segment>
			</unit>
			<unit id="311" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getlabeledbycore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If it's possible to provide a useful class-based behavior, you can override <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetLabeledByCore</pc></pc> to provide this behavior.</source>
				</segment>
			</unit>
			<unit id="312" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getboundingrectanglecore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209185_getclickablepointcore)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetBoundingRectangleCore</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetClickablePointCore</pc></pc> are used mainly for automated testing scenarios.</source>
				</segment>
			</unit>
			<unit id="313" translate="yes">
				<segment state="initial">
					<source>If you want to support automated testing for your control, you might want to override these methods.</source>
				</segment>
			</unit>
			<unit id="314" translate="yes">
				<segment state="initial">
					<source>This might be desired for range-type controls, where you can't suggest just a single point because where the user clicks in coordinate space has a different effect on a range.</source>
				</segment>
			</unit>
			<unit id="315" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209745)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR225870)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, the default <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollBar</pc></pc> automation peer overrides <pc dataRefEnd="id6" dataRefStart="id5" id="p3">GetClickablePointCore</pc> to return a "not a number" <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Point</pc></pc> value.</source>
				</segment>
			</unit>
			<unit id="316" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getlivesettingcore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetLiveSettingCore</pc></pc> influences the control default for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">LiveSetting</pc> value for UI Automation.</source>
				</segment>
			</unit>
			<unit id="317" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/JJ191519)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You might want to override this if you want your control to return a value other than <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationLiveSetting.Off</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="318" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/JJ191516)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>For more info on what <pc dataRefEnd="id2" dataRefStart="id1" id="p1">LiveSetting</pc> represents, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationProperties.LiveSetting</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="319" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getorientationcore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209184)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>You might override <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetOrientationCore</pc></pc> if your control has a settable orientation property that can map to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">AutomationOrientation</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="320" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242522)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242546)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollBarAutomationPeer</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SliderAutomationPeer</pc></pc> classes do this.</source>
				</segment>
			</unit>
			<unit id="321" translate="yes">
				<segment state="initial">
					<source>Base implementation in FrameworkElementAutomationPeer</source>
				</segment>
			</unit>
			<unit id="322" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242472)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The base implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElementAutomationPeer</pc></pc> provides some UI Automation information that can be interpreted from various layout and behavior properties that are defined at the framework level.</source>
				</segment>
			</unit>
			<unit id="323" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getboundingrectanglecore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR225994)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetBoundingRectangleCore</pc></pc>: Returns a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Rect</pc></pc> structure based on the known layout characteristics.</source>
				</segment>
			</unit>
			<unit id="324" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR209185_isoffscreen)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Returns a 0-value <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Rect</pc> if <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IsOffscreen</pc></pc> is <pc dataRefEnd="id8" dataRefStart="id7" id="p4">true</pc>.</source>
				</segment>
			</unit>
			<unit id="325" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getclickablepointcore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR225870)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetClickablePointCore</pc></pc>: Returns a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Point</pc></pc> structure based on the known layout characteristics, as long as there is a nonzero <pc dataRefEnd="id10" dataRefStart="id9" id="p5">BoundingRectangle</pc>.</source>
				</segment>
			</unit>
			<unit id="326" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getnamecore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209185_getnamecore)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetNameCore</pc></pc>: More extensive behavior than can be summarized here; see <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetNameCore</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="327" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209365)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Basically, it attempts a string conversion on any known content of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentControl</pc></pc> or related classes that have content.</source>
				</segment>
			</unit>
			<unit id="328" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh759769)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>Also, if there is a value for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">LabeledBy</pc></pc>, that item's <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Name</pc> value is used as the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Name</pc>.</source>
				</segment>
			</unit>
			<unit id="329" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_haskeyboardfocuscore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209390_focusstate)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR209390_isenabled)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">HasKeyboardFocusCore</pc></pc>: Evaluated based on the owner's <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FocusState</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IsEnabled</pc></pc> properties.</source>
				</segment>
			</unit>
			<unit id="330" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Elements that aren't controls always return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">false</pc>.</source>
				</segment>
			</unit>
			<unit id="331" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_isenabledcore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209390_isenabled)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR209390)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsEnabledCore</pc></pc>: Evaluated based on the owner's <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IsEnabled</pc></pc> property if it is a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Control</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="332" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Elements that aren't controls always return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc>.</source>
				</segment>
			</unit>
			<unit id="333" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>This doesn't mean that the owner is enabled in the conventional interaction sense; it means that the peer is enabled despite the owner not having an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IsEnabled</pc> property.</source>
				</segment>
			</unit>
			<unit id="334" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_iskeyboardfocusablecore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR209390)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsKeyboardFocusableCore</pc></pc>: Returns <pc dataRefEnd="id6" dataRefStart="id5" id="p3">true</pc> if owner is a <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Control</pc></pc>; otherwise it is <pc dataRefEnd="id12" dataRefStart="id11" id="p6">false</pc>.</source>
				</segment>
			</unit>
			<unit id="335" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_isoffscreencore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208911_visibility)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR209006)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
					<data id="id15">[</data>
					<data id="id16">](https://msdn.microsoft.com/library/windows/apps/BR209185_isoffscreen)</data>
					<data id="id17">**</data>
					<data id="id18">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsOffscreenCore</pc></pc>: A <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Visibility</pc></pc> of <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Hidden</pc></pc> on the owner element or any of its parents equates to a <pc dataRefEnd="id14" dataRefStart="id13" id="p7">true</pc> value for <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">IsOffscreen</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="336" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227842)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Exception: a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Popup</pc></pc> object can be visible even if its owner's parents are not.</source>
				</segment>
			</unit>
			<unit id="337" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_setfocuscore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209390_focus)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetFocusCore</pc></pc>: Calls <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Focus</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="338" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getparent)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208739)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetParent</pc></pc>: Calls <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement.Parent</pc></pc> from the owner, and looks up the appropriate peer.</source>
				</segment>
			</unit>
			<unit id="339" translate="yes">
				<segment state="initial">
					<source>This isn't an override pair with a "Core" method, so you can't change this behavior.</source>
				</segment>
			</unit>
			<unit id="340" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Default UWP peers implement a behavior by using internal native code that implements the UWP, not necessarily by using actual UWP code.</source>
				</segment>
			</unit>
			<unit id="341" translate="yes">
				<segment state="initial">
					<source>You won't be able to see the code or logic of the implementation through common language runtime (CLR) reflection or other techniques.</source>
				</segment>
			</unit>
			<unit id="342" translate="yes">
				<segment state="initial">
					<source>You also won't see distinct reference pages for subclass-specific overrides of base peer behavior.</source>
				</segment>
			</unit>
			<unit id="343" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getnamecore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242550)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, there might be additional behavior for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetNameCore</pc></pc> of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TextBoxAutomationPeer</pc></pc>, which won't be described on the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">AutomationPeer.GetNameCore</pc> reference page, and there is no reference page for <pc dataRefEnd="id12" dataRefStart="id11" id="p6">TextBoxAutomationPeer.GetNameCore</pc>.</source>
				</segment>
			</unit>
			<unit id="344" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>There isn't even a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TextBoxAutomationPeer.GetNameCore</pc> reference page.</source>
				</segment>
			</unit>
			<unit id="345" translate="yes">
				<segment state="initial">
					<source>Instead, read the reference topic for the most immediate peer class, and look for implementation notes in the Remarks section.</source>
				</segment>
			</unit>
			<unit id="346" translate="yes">
				<segment state="initial">
					<source>Peers and AutomationProperties</source>
				</segment>
			</unit>
			<unit id="347" translate="yes">
				<segment state="initial">
					<source>Your automation peer should provide appropriate default values for your control's accessibility-related information.</source>
				</segment>
			</unit>
			<unit id="348" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209081)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Note that any app code that uses the control can override some of that behavior by including <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties</pc></pc> attached-property values on control instances.</source>
				</segment>
			</unit>
			<unit id="349" translate="yes">
				<segment state="initial">
					<source>Callers can do this either for the default controls or for custom controls.</source>
				</segment>
			</unit>
			<unit id="350" translate="yes">
				<segment state="initial">
					<source>For example, the following XAML creates a button that has two customized UI Automation properties:</source>
				</segment>
			</unit>
			<unit id="351" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209081)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](basic-accessibility-information.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties</pc></pc> attached properties, see <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Basic accessibility information</pc>.</source>
				</segment>
			</unit>
			<unit id="352" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Some of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> methods exist because of the general contract of how UI Automation providers are expected to report information, but these methods are not typically implemented in control peers.</source>
				</segment>
			</unit>
			<unit id="353" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209081)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This is because that info is expected to be provided by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties</pc></pc> values applied to the app code that uses the controls in a specific UI.</source>
				</segment>
			</unit>
			<unit id="354" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh759769)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, most apps would define the labeling relationship between two different controls in the UI by applying a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.LabeledBy</pc></pc> value.</source>
				</segment>
			</unit>
			<unit id="355" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getlabeledbycore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>However, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">LabeledByCore</pc></pc> is implemented in certain peers that represent data or item relationships in a control, such as using a header part to label a data-field part, labeling items with their containers, or similar scenarios.</source>
				</segment>
			</unit>
			<unit id="356" translate="yes">
				<segment state="initial">
					<source>Implementing patterns</source>
				</segment>
			</unit>
			<unit id="357" translate="yes">
				<segment state="initial">
					<source>Let's look at how to write a peer for a control that implements an expand-collapse behavior by implementing the control pattern interface for expand-collapse.</source>
				</segment>
			</unit>
			<unit id="358" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpattern)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242496)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The peer should enable the accessibility for the expand-collapse behavior by returning itself whenever <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPattern</pc></pc> is called with a value of <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PatternInterface.ExpandCollapse</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="359" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671242)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The peer should then inherit the provider interface for that pattern (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IExpandCollapseProvider</pc></pc>) and provide implementations for each of the members of that provider interface.</source>
				</segment>
			</unit>
			<unit id="360" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242570)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242569)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242570collapsestate)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>In this case the interface has three members to override: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Expand</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Collapse</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ExpandCollapseState</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="361" translate="yes">
				<segment state="initial">
					<source>It's helpful to plan ahead for accessibility in the API design of the class itself.</source>
				</segment>
			</unit>
			<unit id="362" translate="yes">
				<segment state="initial">
					<source>Whenever you have a behavior that is potentially requested either as a result of typical interactions with a user who is working in the UI or through an automation provider pattern, provide a single method that either the UI response or the automation pattern can call.</source>
				</segment>
			</unit>
			<unit id="363" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242570)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242569)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/desktop/Ee671242)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, if your control has button parts that have wired event handlers that can expand or collapse the control, and has keyboard equivalents for those actions, have these event handlers call the same method that you call from within the body of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Expand</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Collapse</pc></pc> implementations for <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IExpandCollapseProvider</pc></pc> in the peer.</source>
				</segment>
			</unit>
			<unit id="364" translate="yes">
				<segment state="initial">
					<source>Using a common logic method can also be a useful way to make sure that your control's visual states are updated to show logical state in a uniform way, regardless of how the behavior was invoked.</source>
				</segment>
			</unit>
			<unit id="365" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242472_owner)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>A typical implementation is that the provider APIs first call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Owner</pc></pc> for access to the control instance at run time.</source>
				</segment>
			</unit>
			<unit id="366" translate="yes">
				<segment state="initial">
					<source>Then the necessary behavior methods can be called on that object.</source>
				</segment>
			</unit>
			<unit id="367" translate="yes">
				<segment state="initial">
					<source>C</source>
				</segment>
			</unit>
			<unit id="368" translate="yes">
				<segment state="initial">
					<source>An alternate implementation is that the control itself can reference its peer.</source>
				</segment>
			</unit>
			<unit id="369" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_raiseautomationevent)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>This is a common pattern if you are raising automation events from the control, because the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RaiseAutomationEvent</pc></pc> method is a peer method.</source>
				</segment>
			</unit>
			<unit id="370" translate="yes">
				<segment state="initial">
					<source>UI Automation events</source>
				</segment>
			</unit>
			<unit id="371" translate="yes">
				<segment state="initial">
					<source>UI Automation events fall into the following categories.</source>
				</segment>
			</unit>
			<unit id="372" translate="yes">
				<segment state="initial">
					<source>Event</source>
				</segment>
			</unit>
			<unit id="373" translate="yes">
				<segment state="initial">
					<source>Description</source>
				</segment>
			</unit>
			<unit id="374" translate="yes">
				<segment state="initial">
					<source>Property change</source>
				</segment>
			</unit>
			<unit id="375" translate="yes">
				<segment state="initial">
					<source>Fires when a property on a UI Automation element or control pattern changes.</source>
				</segment>
			</unit>
			<unit id="376" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242653_togglestate)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, if a client needs to monitor an app's check box control, it can register to listen for a property change event on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ToggleState</pc></pc> property.</source>
				</segment>
			</unit>
			<unit id="377" translate="yes">
				<segment state="initial">
					<source>When the check box control is checked or unchecked, the provider fires the event and the client can act as necessary.</source>
				</segment>
			</unit>
			<unit id="378" translate="yes">
				<segment state="initial">
					<source>Element action</source>
				</segment>
			</unit>
			<unit id="379" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Fires when a change in the UI results from user or programmatic activity; for example, when a button is clicked or invoked through the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Invoke</pc> pattern.</source>
				</segment>
			</unit>
			<unit id="380" translate="yes">
				<segment state="initial">
					<source>Structure change</source>
				</segment>
			</unit>
			<unit id="381" translate="yes">
				<segment state="initial">
					<source>Fires when the structure of the UI Automation tree changes.</source>
				</segment>
			</unit>
			<unit id="382" translate="yes">
				<segment state="initial">
					<source>The structure changes when new UI items become visible, hidden, or removed on the desktop.</source>
				</segment>
			</unit>
			<unit id="383" translate="yes">
				<segment state="initial">
					<source>Global change</source>
				</segment>
			</unit>
			<unit id="384" translate="yes">
				<segment state="initial">
					<source>Fires when actions of global interest to the client occur, such as when the focus shifts from one element to another, or when a child window closes.</source>
				</segment>
			</unit>
			<unit id="385" translate="yes">
				<segment state="initial">
					<source>Some events do not necessarily mean that the state of the UI has changed.</source>
				</segment>
			</unit>
			<unit id="386" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209683_textchanged)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, if the user tabs to a text-entry field and then clicks a button to update the field, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextChanged</pc></pc> event fires even if the user did not actually change the text.</source>
				</segment>
			</unit>
			<unit id="387" translate="yes">
				<segment state="initial">
					<source>When processing an event, it may be necessary for a client application to check whether anything has actually changed before taking action.</source>
				</segment>
			</unit>
			<unit id="388" translate="yes">
				<segment state="initial">
					<source>AutomationEvents identifiers</source>
				</segment>
			</unit>
			<unit id="389" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209183)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>UI Automation events are identified by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationEvents</pc></pc> values.</source>
				</segment>
			</unit>
			<unit id="390" translate="yes">
				<segment state="initial">
					<source>The values of the enumeration uniquely identify the kind of event.</source>
				</segment>
			</unit>
			<unit id="391" translate="yes">
				<segment state="initial">
					<source>Raising events</source>
				</segment>
			</unit>
			<unit id="392" translate="yes">
				<segment state="initial">
					<source>UI Automation clients can subscribe to automation events.</source>
				</segment>
			</unit>
			<unit id="393" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_raiseautomationevent)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In the automation peer model, peers for custom controls must report changes to control state that are relevant to accessibility by calling the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RaiseAutomationEvent</pc></pc> method.</source>
				</segment>
			</unit>
			<unit id="394" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_raisepropertychangedevent)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Similarly, when a key UI Automation property value changes, custom control peers should call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RaisePropertyChangedEvent</pc></pc> method.</source>
				</segment>
			</unit>
			<unit id="395" translate="yes">
				<segment state="initial">
					<source>The next code example shows how to get the peer object from within the control definition code and call a method to fire an event from that peer.</source>
				</segment>
			</unit>
			<unit id="396" translate="yes">
				<segment state="initial">
					<source>As an optimization, the code determines whether there are any listeners for this event type.</source>
				</segment>
			</unit>
			<unit id="397" translate="yes">
				<segment state="initial">
					<source>Firing the event and creating the peer object only when there are listeners avoids unnecessary overhead and helps the control remain responsive.</source>
				</segment>
			</unit>
			<unit id="398" translate="yes">
				<segment state="initial">
					<source>C</source>
				</segment>
			</unit>
			<unit id="399" translate="yes">
				<segment state="initial">
					<source>Peer navigation</source>
				</segment>
			</unit>
			<unit id="400" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getchildren)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209185_getparent)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>After locating an automation peer, a UI Automation client can navigate the peer structure of an app by calling the peer object's <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetChildren</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetParent</pc></pc> methods.</source>
				</segment>
			</unit>
			<unit id="401" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getchildrencore)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Navigation among UI elements within a control is supported by the peer's implementation of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetChildrenCore</pc></pc> method.</source>
				</segment>
			</unit>
			<unit id="402" translate="yes">
				<segment state="initial">
					<source>The UI Automation system calls this method to build up a tree of subelements contained within a control; for example, list items in a list box.</source>
				</segment>
			</unit>
			<unit id="403" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR242472)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>The default <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetChildrenCore</pc> method in <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FrameworkElementAutomationPeer</pc></pc> traverses the visual tree of elements to build the tree of automation peers.</source>
				</segment>
			</unit>
			<unit id="404" translate="yes">
				<segment state="initial">
					<source>Custom controls can override this method to expose a different representation of child elements to automation clients, returning the automation peers of elements that convey information or allow user interaction.</source>
				</segment>
			</unit>
			<unit id="405" translate="yes">
				<segment state="initial">
					<source>Native automation support for text patterns</source>
				</segment>
			</unit>
			<unit id="406" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242496)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Some of the default UWP app automation peers provide control pattern support for the text pattern (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PatternInterface.Text</pc></pc>).</source>
				</segment>
			</unit>
			<unit id="407" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242627)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>But they provide this support through native methods, and the peers involved won't note the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ITextProvider</pc></pc> interface in the (managed) inheritance.</source>
				</segment>
			</unit>
			<unit id="408" translate="yes">
				<segment state="initial">
					<source>Still, if a managed or non-managed UI Automation client queries the peer for patterns, it will report support for the text pattern, and provide behavior for parts of the pattern when client APIs are called.</source>
				</segment>
			</unit>
			<unit id="409" translate="yes">
				<segment state="initial">
					<source>If you intend to derive from one of the UWP app text controls and also create a custom peer that derives from one of the text-related peers, check the Remarks sections for the peer to learn more about any native-level support for patterns.</source>
				</segment>
			</unit>
			<unit id="410" translate="yes">
				<segment state="initial">
					<source>You can access the native base behavior in your custom peer if you call the base implementation from your managed provider interface implementations, but it's difficult to modify what the base implementation does because the native interfaces on both the peer and its owner control aren't exposed.</source>
				</segment>
			</unit>
			<unit id="411" translate="yes">
				<segment state="initial">
					<source>Generally you should either use the base implementations as-is (call base only) or completely replace the functionality with your own managed code and don't call the base implementation.</source>
				</segment>
			</unit>
			<unit id="412" translate="yes">
				<segment state="initial">
					<source>The latter is an advanced scenario, you'll need good familiarity with the text services framework being used by your control in order to support the accessibility requirements when using that framework.</source>
				</segment>
			</unit>
			<unit id="413" translate="yes">
				<segment state="initial">
					<source>AutomationProperties.AccessibilityView</source>
				</segment>
			</unit>
			<unit id="414" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209081_accessibilityview)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In addition to providing a custom peer, you can also adjust the tree view representation for any control instance, by setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.AccessibilityView</pc></pc> in XAML.</source>
				</segment>
			</unit>
			<unit id="415" translate="yes">
				<segment state="initial">
					<source>This isn't implemented as part of a peer class, but we'll mention it here because it's germane to overall accessibility support either for custom controls or for templates you customize.</source>
				</segment>
			</unit>
			<unit id="416" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209081_accessibilityview)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The main scenario for using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.AccessibilityView</pc></pc> is to deliberately omit certain controls in a template from the UI Automation views, because they don't meaningfully contribute to the accessibility view of the entire control.</source>
				</segment>
			</unit>
			<unit id="417" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>To prevent this, set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AutomationProperties.AccessibilityView</pc> to "Raw".</source>
				</segment>
			</unit>
			<unit id="418" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209081_accessibilityview)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.AccessibilityView</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="419" translate="yes">
				<segment state="initial">
					<source>Throwing exceptions from automation peers</source>
				</segment>
			</unit>
			<unit id="420" translate="yes">
				<segment state="initial">
					<source>The APIs that you are implementing for your automation peer support are permitted to throw exceptions.</source>
				</segment>
			</unit>
			<unit id="421" translate="yes">
				<segment state="initial">
					<source>It's expected any UI Automation clients that are listening are robust enough to continue on after most exceptions are thrown.</source>
				</segment>
			</unit>
			<unit id="422" translate="yes">
				<segment state="initial">
					<source>In all likelihood that listener is looking at an all-up automation tree that includes apps other than your own, and it's an unacceptable client design to bring down the entire client just because one area of the tree threw a peer-based exception when the client called its APIs.</source>
				</segment>
			</unit>
			<unit id="423" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](T:System.ArgumentNullException)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>For parameters that are passed in to your peer, it's acceptable to validate the input, and for example throw <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ArgumentNullException</pc></pc> if it was passed <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc> and that's not a valid value for your implementation.</source>
				</segment>
			</unit>
			<unit id="424" translate="yes">
				<segment state="initial">
					<source>However, if there are subsequent operations performed by your peer, remember that the peer's interactions with the hosting control have something of an asynchronous character to them.</source>
				</segment>
			</unit>
			<unit id="425" translate="yes">
				<segment state="initial">
					<source>Anything a peer does won't necessarily block the UI thread in the control (and it probably shouldn't).</source>
				</segment>
			</unit>
			<unit id="426" translate="yes">
				<segment state="initial">
					<source>So you could have situations where an object was available or had certain properties when the peer was created or when an automation peer method was first called, but in the meantime the control state has changed.</source>
				</segment>
			</unit>
			<unit id="427" translate="yes">
				<segment state="initial">
					<source>For these cases, there are two dedicated exceptions that a provider can throw:</source>
				</segment>
			</unit>
			<unit id="428" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh673741)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Throw <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ElementNotAvailableException</pc></pc> if you're unable to access either the peer's owner or a related peer element based on the original info your API was passed.</source>
				</segment>
			</unit>
			<unit id="429" translate="yes">
				<segment state="initial">
					<source>For example, you might have a peer that's trying to run its methods but the owner has since been removed from the UI, such as a modal dialog that's been closed.</source>
				</segment>
			</unit>
			<unit id="430" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671218)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For a non-.NET client, this maps to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIA\_E\_ELEMENTNOTAVAILABLE</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="431" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh673748)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209390_isenabled)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">`=`</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
				</originalData>
				<segment state="initial">
					<source>Throw <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ElementNotEnabledException</pc></pc> if there still is an owner, but that owner is in a mode such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IsEnabled</pc></pc><ph dataRef="id9" id="ph1" /><pc dataRefEnd="id11" dataRefStart="id10" id="p5">false</pc> that's blocking some of the specific programmatic changes that your peer is trying to accomplish.</source>
				</segment>
			</unit>
			<unit id="432" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671218)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>For a non-.NET client, this maps to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIA\_E\_ELEMENTNOTENABLED</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="433" translate="yes">
				<segment state="initial">
					<source>Beyond this, peers should be relatively conservative regarding exceptions that they throw from their peer support.</source>
				</segment>
			</unit>
			<unit id="434" translate="yes">
				<segment state="initial">
					<source>Most clients won't be able to handle exceptions from peers and turn these into actionable choices that their users can make when interacting with the client.</source>
				</segment>
			</unit>
			<unit id="435" translate="yes">
				<segment state="initial">
					<source>So sometimes a no-op, and catching exceptions without rethrowing within your peer implementations, is a better strategy than is throwing exceptions every time something the peer tries to do doesn't work.</source>
				</segment>
			</unit>
			<unit id="436" translate="yes">
				<segment state="initial">
					<source>Consider also that most UI Automation clients aren't written in managed code.</source>
				</segment>
			</unit>
			<unit id="437" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Most are written in COM and are just checking for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">S\_OK</pc> in an <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HRESULT</pc> whenever they call a UI Automation client method that ends up accessing your peer.</source>
				</segment>
			</unit>
			<unit id="438" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="439" translate="yes">
				<segment state="initial">
					<source>Accessibility</source>
				</segment>
			</unit>
			<unit id="440" translate="yes">
				<segment state="initial">
					<source>XAML accessibility sample</source>
				</segment>
			</unit>
			<unit id="441" translate="yes">
				<segment state="initial">
					<source>FrameworkElementAutomationPeer</source>
				</segment>
			</unit>
			<unit id="442" translate="yes">
				<segment state="initial">
					<source>AutomationPeer</source>
				</segment>
			</unit>
			<unit id="443" translate="yes">
				<segment state="initial">
					<source>OnCreateAutomationPeer</source>
				</segment>
			</unit>
			<unit id="444" translate="yes">
				<segment state="initial">
					<source>Control patterns and interfaces</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>