<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">cf9b09714f4a05e42103b4650e8e766bc69624ec</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\load-a-game-asset.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">fc1bfede9f1ba2de4f468b838789fabcee45639b</mda:meta><mda:meta type="olxliffhash">9b56b13c9eb3cccc557a19e60d6dc76cbcb9236c</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Load resources in your DirectX game</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Most games, at some point, load resources and assets (such as shaders, textures, predefined meshes or other graphics data) from local storage or some other data stream.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Load resources in your DirectX game</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Most games, at some point, load resources and assets (such as shaders, textures, predefined meshes or other graphics data) from local storage or some other data stream.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Here, we walk you through a high-level view of what you must consider when loading these files to use in your Universal Windows Platform (UWP) game.</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>For example, the meshes for polygonal objects in your game might have been created with another tool, and exported to a specific format.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>The same is true for textures, and more so: while a flat, uncompressed bitmap can be commonly written by most tools and understood by most graphics APIs, it can be extremely inefficient for use in your game.</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>Here, we guide you through the basic steps for loading three different types of graphic resources for use with Direct3D: meshes (models), textures (bitmaps), and compiled shader objects.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>What you need to know</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>Technologies</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>Parallel Patterns Library (ppltasks.h)</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>Prerequisites</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<segment state="initial">
					<source>Understand the basic Windows Runtime</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Understand asynchronous tasks</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Understand the basic concepts of 3-D graphics programming.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>This sample also includes three code files for resource loading and management.</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>You'll encounter the code objects defined in these files throughout this topic.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>BasicLoader.h/.cpp</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<segment state="initial">
					<source>BasicReaderWriter.h/.cpp</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<segment state="initial">
					<source>DDSTextureLoader.h/.cpp</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>The complete code for these samples can be found in the following links.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<segment state="initial">
					<source>Topic</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>Description</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<segment state="initial">
					<source>Complete code for BasicLoader</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>Complete code for a class and methods that convert and load graphics mesh objects into memory.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<segment state="initial">
					<source>Complete code for BasicReaderWriter</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>Complete code for a class and methods for reading and writing binary data files in general.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](complete-code-for-basicloader.md)</data>
				</originalData>
				<segment state="initial">
					<source>Used by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicLoader</pc> class.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>Complete code for DDSTextureLoader</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Complete code for a class and method that loads a DDS texture from memory.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<segment state="initial">
					<source>Instructions</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>Asynchronous loading</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Asynchronous loading is handled using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task</pc> template from the Parallel Patterns Library (PPL).</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task</pc> contains a method call followed by a lambda that processes the results of the async call after it completes, and usually follows the format of:</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Tasks can be chained together using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">.then()</pc> syntax, so that when one operation completes, another async operation that depends on the results of the prior operation can be run.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<segment state="initial">
					<source>In this way, you can load, convert, and manage complex assets on separate threads in a way that appears almost invisible to the player.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt187334)</data>
				</originalData>
				<segment state="initial">
					<source>For more details, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Asynchronous programming in C++</pc>.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Now, let's look at the basic structure for declaring and creating an async file loading method, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ReadDataAsync</pc>.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In this code, when your code calls the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ReadDataAsync</pc> method defined above, a task is created to read a buffer from the file system.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208119)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Once it completes, a chained task takes the buffer and streams the bytes from that buffer into an array using the static <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataReader</pc></pc> type.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's the call you make to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ReadDataAsync</pc>.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>When it completes, your code receives an array of bytes read from the provided file.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Since <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ReadDataAsync</pc> itself is defined as a task, you can use a lambda to perform a specific operation when the byte array is returned, such as passing that byte data to a DirectX function that can use it.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>If your game is sufficiently simple, load your resources with a method like this when the user starts the game.</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh700505)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You can do this before you start the main game loop from some point in the call sequence of your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IFrameworkView::Run</pc></pc> implementation.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>Again, you call your resource loading methods asynchronously so the game can start quicker and so the player doesn't have to wait until the loading completes before engaging in early interactions.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<segment state="initial">
					<source>However, you don't want to start the game proper until all of the async loading has completed!</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>Create some method for signaling when loading is complete, such as a specific field, and use the lambdas on your loading method(s) to set that signal when finished.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>Check the variable before starting any components that use those loaded resources.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>Here's an example using the async methods defined in BasicLoader.cpp to load shaders, a mesh, and a texture when the game starts up.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Notice that it sets a specific field on the game object, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_loadingComplete</pc>, when all of the loading methods finish.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Note that the tasks have been aggregated using the &amp;&amp; operator such that the lambda that sets the loading complete flag is triggered only when all of the tasks complete.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>Note that if you have multiple flags, you have the possibility of race conditions.</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>For example, if the lambda sets two flags sequentially to the same value, another thread may only see the first flag set if it examines them before the second flag is set.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<segment state="initial">
					<source>You've seen how to load resource files asynchronously.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](complete-code-for-basicreaderwriter.md)</data>
					<data id="id3">[</data>
					<data id="id4">](complete-code-for-basicloader.md)</data>
				</originalData>
				<segment state="initial">
					<source>Synchronous file loads are much simpler, and you can find examples of them in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Complete code for BasicReaderWriter</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Complete code for BasicLoader</pc>.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<segment state="initial">
					<source>Of course, different resource and asset types often require additional processing or conversion before they are ready to be used in your graphics pipeline.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<segment state="initial">
					<source>Let's take a look at three specific types of resources: meshes, textures, and shaders.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>Loading meshes</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<segment state="initial">
					<source>Meshes are vertex data, either generated procedurally by code within your game or exported to a file from another app (like 3DStudio MAX or Alias WaveFront) or tool.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<segment state="initial">
					<source>These meshes represent the models in your game, from simple primitives like cubes and spheres to cars and houses and characters.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<segment state="initial">
					<source>They often contain color and animation data, as well, depending on their format.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<segment state="initial">
					<source>We'll focus on meshes that contain only vertex data.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>To load a mesh correctly, you must know the format of the data in the file for the mesh.</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Our simple <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicReaderWriter</pc> type above simply reads the data in as a byte stream; it doesn't know that the byte data represents a mesh, much less a specific mesh format as exported by another application!</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>You must perform the conversion as you bring the mesh data into memory.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>(You should always try to package asset data in a format that's as close to the internal representation as possible.</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<segment state="initial">
					<source>Doing so will reduce resource utilization and save time.)</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>Let's get the byte data from the mesh's file.</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>The format in the example assumes that the file is a sample-specific format suffixed with .vbo.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>(Again, this format is not the same as OpenGL's VBO format.) Each vertex itself maps to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicVertex</pc> type, which is a struct defined in the code for the obj2vbo converter tool.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>The layout of the vertex data in the .vbo file looks like this:</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>The first 32 bits (4 bytes) of the data stream contain the number of vertices (numVertices) in the mesh, represented as a uint32 value.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>The next 32 bits (4 bytes) of the data stream contain the number of indices in the mesh (numIndices), represented as a uint32 value.</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>After that, the subsequent (numVertices \* sizeof(<pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicVertex</pc>)) bits contain the vertex data.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>The last (numIndices \* 16) bits of data contain the index data, represented as a sequence of uint16 values.</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<segment state="initial">
					<source>The point is this: know the bit-level layout of the mesh data you have loaded.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<segment state="initial">
					<source>Also, be sure you are consistent with endian-ness.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<segment state="initial">
					<source>All Windows 8 platforms are little-endian.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In the example, you call a method, CreateMesh, from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">LoadMeshAsync</pc> method to perform this bit-level interpretation.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateMesh</pc> interprets the byte data loaded from the file, and creates a vertex buffer and an index buffer for the mesh by passing the vertex and index lists, respectively, to <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ID3D11Device::CreateBuffer</pc></pc> and specifying either D3D11\_BIND\_VERTEX\_BUFFER or D3D11\_BIND\_INDEX\_BUFFER.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Here's the code used in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicLoader</pc>:</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<segment state="initial">
					<source>You typically create a vertex/index buffer pair for every mesh you use in your game.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<segment state="initial">
					<source>Where and when you load the meshes is up to you.</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<segment state="initial">
					<source>If you have a lot of meshes, you may only want to load some from the disk at specific points in the game, such as during specific, pre-defined loading states.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<segment state="initial">
					<source>For large meshes, like terrain data, you can stream the vertices from a cache, but that is a more complex procedure and not in the scope of this topic.</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>Again, know your vertex data format!</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<segment state="initial">
					<source>There are many, many ways to represent vertex data across the tools used to create models.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<segment state="initial">
					<source>There are also many different ways to represent the input layout of the vertex data to Direct3D, such as triangle lists and strips.</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476898)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/bb147291)</data>
				</originalData>
				<segment state="initial">
					<source>For more information about vertex data, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Introduction to Buffers in Direct3D 11</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Primitives</pc>.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>Next, let's look at loading textures.</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>Loading textures</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>The most common asset in a game—and the one that comprises most of the files on disk and in memory—are textures.</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>Like meshes, textures can come in a variety of formats, and you convert them to a format that Direct3D can use when you load them.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>Textures also come in a wide variety of types and are used to create different effects.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>MIP levels for textures can be used to improve the look and performance of distance objects; dirt and light maps are used to layer effects and detail atop a base texture; and normal maps are used in per-pixel lighting calculations.</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>In a modern game, a typical scene can potentially have thousands of individual textures, and your code must effectively manage them all!</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>Also like meshes, there are a number of specific formats that are used to make memory usage for efficient.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<segment state="initial">
					<source>Since textures can easily consume a large portion of the GPU (and system) memory, they are often compressed in some fashion.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>You aren't required to use compression on your game's textures, and you can use any compression/decompression algorithm(s) you want as long as you provide the Direct3D shaders with data in a format it can understand (like a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Texture2D</pc></pc> bitmap).</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>Direct3D provides support for the DXT texture compression algorithms, although every DXT format may not be supported in the player's graphics hardware.</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<segment state="initial">
					<source>DDS files contain DXT textures (and other texture compression formats as well), and are suffixed with .dds.</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<segment state="initial">
					<source>A DDS file is a binary file that contains the following information:</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>A DWORD (magic number) containing the four character code value 'DDS ' (0x20534444).</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>A description of the data in the file.</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb943982)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/bb943984)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>The data is described with a header description using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DDS\_HEADER</pc></pc>; the pixel format is defined using <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DDS\_PIXELFORMAT</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Note that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DDS\_HEADER</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DDS\_PIXELFORMAT</pc> structures replace the deprecated DDSURFACEDESC2, DDSCAPS2 and DDPIXELFORMAT DirectDraw 7 structures.</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">DDS\_HEADER</pc> is the binary equivalent of DDSURFACEDESC2 and DDSCAPS2.</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">DDS\_PIXELFORMAT</pc> is the binary equivalent of DDPIXELFORMAT.</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/bb943984)</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">[</data>
					<data id="id10">](https://msdn.microsoft.com/library/windows/desktop/bb943983)</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source>If the value of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">dwFlags</pc> in <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DDS\_PIXELFORMAT</pc></pc> is set to DDPF\_FOURCC and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">dwFourCC</pc> is set to "DX10" an additional <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">DDS\_HEADER\_DXT10</pc></pc> structure will be present to accommodate texture arrays or DXGI formats that cannot be expressed as an RGB pixel format such as floating point formats, sRGB formats etc. When the <pc dataRefEnd="id14" dataRefStart="id13" id="p7">DDS\_HEADER\_DXT10</pc> structure is present, the entire data description will looks like this.</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>A pointer to an array of bytes that contains the main surface data.</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<segment state="initial">
					<source>A pointer to an array of bytes that contains the remaining surfaces such as; mipmap levels, faces in a cube map, depths in a volume texture.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb205578)</data>
					<data id="id3">[</data>
					<data id="id4">](https://msdn.microsoft.com/library/windows/desktop/bb205577)</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/desktop/bb205579)</data>
				</originalData>
				<segment state="initial">
					<source>Follow these links for more information about the DDS file layout for a: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">texture</pc>, a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">cube map</pc>, or a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">volume texture</pc>.</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>Many tools export to the DDS format.</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>If you don't have a tool to export your texture to this format, consider creating one.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb943991)</data>
				</originalData>
				<segment state="initial">
					<source>For more detail on the DDS format and how to work with it in your code, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Programming Guide for DDS</pc>.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<segment state="initial">
					<source>In our example, we'll use DDS.</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<segment state="initial">
					<source>As with other resource types, you read the data from a file as a stream of bytes.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>Once your loading task completes, the lambda call runs code (the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateTexture</pc> method) to process the stream of bytes into a format that Direct3D can use.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>In the previous snippet, the lambda checks to see if the filename has an extension of "dds".</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>If it does, you assume that it is a DDS texture.</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>If not, well, use the Windows Imaging Component (WIC) APIs to discover the format and decode the data as a bitmap.</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Either way, the result is a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Texture2D</pc></pc> bitmap (or an error).</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>When this code completes, you have a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Texture2D</pc></pc> in memory, loaded from an image file.</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>As with meshes, you probably have a lot of them in your game and in any given scene.</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<segment state="initial">
					<source>Consider creating caches for regularly accessed textures per-scene or per-level, rather than loading them all when the game or level starts.</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">[</data>
					<data id="id4">](complete-code-for-ddstextureloader.md)</data>
				</originalData>
				<segment state="initial">
					<source>(The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDDSTextureFromMemory</pc> method called in the above sample can be explored in full in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Complete code for DDSTextureLoader</pc>.)</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>Also, individual textures or texture "skins" may map to specific mesh polygons or surfaces.</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<segment state="initial">
					<source>This mapping data is usually exported by the tool an artist or designer used to create the model and the textures.</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>Make sure that you capture this information as well when you load the exported data, as you will use it map the correct textures to the corresponding surfaces when you perform fragment shading.</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>Loading shaders</source>
				</segment>
			</unit>
			<unit id="235" translate="yes">
				<segment state="initial">
					<source>Shaders are compiled High Level Shader Language (HLSL) files that are loaded into memory and invoked at specific stages of the graphics pipeline.</source>
				</segment>
			</unit>
			<unit id="236" translate="yes">
				<segment state="initial">
					<source>The most common and essential shaders are the vertex and pixel shaders, which process the individual vertices of your mesh and the pixels in the scene's viewport(s), respectively.</source>
				</segment>
			</unit>
			<unit id="237" translate="yes">
				<segment state="initial">
					<source>The HLSL code is executed to transform the geometry, apply lighting effects and textures, and perform post-processing on the rendered scene.</source>
				</segment>
			</unit>
			<unit id="238" translate="yes">
				<segment state="initial">
					<source>A Direct3D game can have a number of different shaders, each one compiled into a separate CSO (Compiled Shader Object, .cso) file.</source>
				</segment>
			</unit>
			<unit id="239" translate="yes">
				<segment state="initial">
					<source>Normally, you don't have so many that you need to load them dynamically, and in most cases, you can simply load them when the game is starting, or on a per-level basis (such as a shader for rain effects).</source>
				</segment>
			</unit>
			<unit id="240" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The code in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicLoader</pc> class provides a number of overloads for different shaders, including vertex, geometry, pixel, and hull shaders.</source>
				</segment>
			</unit>
			<unit id="241" translate="yes">
				<segment state="initial">
					<source>The code below covers pixel shaders as an example.</source>
				</segment>
			</unit>
			<unit id="242" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](complete-code-for-basicloader.md)</data>
				</originalData>
				<segment state="initial">
					<source>(You can review the complete code in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Complete code for BasicLoader</pc>.)</source>
				</segment>
			</unit>
			<unit id="243" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In this example, you use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">BasicReaderWriter</pc> instance (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">m\_basicReaderWriter</pc>) to read in the supplied compiled shader object (.cso) file as a byte stream.</source>
				</segment>
			</unit>
			<unit id="244" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476513)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Once that task completes, the lambda calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device::CreatePixelShader</pc></pc> with the byte data loaded from the file.</source>
				</segment>
			</unit>
			<unit id="245" translate="yes">
				<segment state="initial">
					<source>Your callback must set some flag indicating that the load was successful, and your code must check this flag before running the shader.</source>
				</segment>
			</unit>
			<unit id="246" translate="yes">
				<segment state="initial">
					<source>Vertex shaders are bit more complex.</source>
				</segment>
			</unit>
			<unit id="247" translate="yes">
				<segment state="initial">
					<source>For a vertex shader, you also load a separate input layout that defines the vertex data.</source>
				</segment>
			</unit>
			<unit id="248" translate="yes">
				<segment state="initial">
					<source>The following code can be used to asynchronously load a vertex shader along with a custom vertex input layout.</source>
				</segment>
			</unit>
			<unit id="249" translate="yes">
				<segment state="initial">
					<source>Be sure that the vertex information that you load from your meshes can be correctly represented by this input layout!</source>
				</segment>
			</unit>
			<unit id="250" translate="yes">
				<segment state="initial">
					<source>Let's create the input layout before you load the vertex shader.</source>
				</segment>
			</unit>
			<unit id="251" translate="yes">
				<segment state="initial">
					<source>In this particular layout, each vertex has the following data processed by the vertex shader:</source>
				</segment>
			</unit>
			<unit id="252" translate="yes">
				<segment state="initial">
					<source>A 3D coordinate position (x, y, z) in the model's coordinate space, represented as a trio of 32-bit floating point values.</source>
				</segment>
			</unit>
			<unit id="253" translate="yes">
				<segment state="initial">
					<source>A normal vector for the vertex, also represented as three 32-bit floating point values.</source>
				</segment>
			</unit>
			<unit id="254" translate="yes">
				<segment state="initial">
					<source>A transformed 2D texture coordinate value (u, v) , represented as a pair of 32-bit floating values.</source>
				</segment>
			</unit>
			<unit id="255" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb509647)</data>
				</originalData>
				<segment state="initial">
					<source>These per-vertex input elements are called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">HLSL semantics</pc>, and they are a set of defined registers used to pass data to and from your compiled shader object.</source>
				</segment>
			</unit>
			<unit id="256" translate="yes">
				<segment state="initial">
					<source>Your pipeline runs the vertex shader once for every vertex in the mesh that you've loaded.</source>
				</segment>
			</unit>
			<unit id="257" translate="yes">
				<segment state="initial">
					<source>The semantics define the input to (and output from) the vertex shader as it runs, and provide this data for your per-vertex computations in your shader's HLSL code.</source>
				</segment>
			</unit>
			<unit id="258" translate="yes">
				<segment state="initial">
					<source>Now, load the vertex shader object.</source>
				</segment>
			</unit>
			<unit id="259" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476524)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>In this code, once you've read in the byte data for the vertex shader's CSO file, you create the vertex shader by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device::CreateVertexShader</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="260" translate="yes">
				<segment state="initial">
					<source>After that, you create your input layout for the shader in the same lambda.</source>
				</segment>
			</unit>
			<unit id="261" translate="yes">
				<segment state="initial">
					<source>Other shader types, such as hull and geometry shaders, can also require specific configuration.</source>
				</segment>
			</unit>
			<unit id="262" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](complete-code-for-basicloader.md)</data>
					<data id="id3">[</data>
					<data id="id4">]( http://go.microsoft.com/fwlink/p/?LinkID=265132)</data>
				</originalData>
				<segment state="initial">
					<source>Complete code for a variety of shader loading methods is provided in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Complete code for BasicLoader</pc> and in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Direct3D resource loading sample</pc>.</source>
				</segment>
			</unit>
			<unit id="263" translate="yes">
				<segment state="initial">
					<source>Remarks</source>
				</segment>
			</unit>
			<unit id="264" translate="yes">
				<segment state="initial">
					<source>At this point, you should understand and be able to create or modify methods for asynchronously loading common game resources and assets, such as meshes, textures, and compiled shaders.</source>
				</segment>
			</unit>
			<unit id="265" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="266" translate="yes">
				<segment state="initial">
					<source>Direct3D resource loading sample</source>
				</segment>
			</unit>
			<unit id="267" translate="yes">
				<segment state="initial">
					<source>Complete code for BasicLoader</source>
				</segment>
			</unit>
			<unit id="268" translate="yes">
				<segment state="initial">
					<source>Complete code for BasicReaderWriter</source>
				</segment>
			</unit>
			<unit id="269" translate="yes">
				<segment state="initial">
					<source>Complete code for DDSTextureLoader</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>