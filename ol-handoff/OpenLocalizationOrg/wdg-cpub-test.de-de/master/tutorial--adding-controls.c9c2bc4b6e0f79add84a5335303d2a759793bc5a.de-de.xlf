<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="de-de" version="2.0" xml:space="preserve" xmlns="urn:oasis:names:tc:xliff:document:2.0">
	<file id="1">
		<mda:metadata>
			<mda:metaGroup>
				<mda:meta type="tool-id">mdxliff</mda:meta>
				<mda:meta type="tool-name">mdxliff</mda:meta>
				<mda:meta type="tool-version">1.0-10daaac</mda:meta>
				<mda:meta type="tool-company">Microsoft</mda:meta>
			</mda:metaGroup>
		<mda:metaGroup><mda:meta type="olfilehash">58f31b6a9b85aa3b33a7ed1e230708ab29f6fcd4</mda:meta><mda:meta type="olfilepath">wdg-cpub-test\ndolci2\gaming\tutorial--adding-controls.md</mda:meta><mda:meta type="oltranslationpriority"></mda:meta><mda:meta type="oltranslationtype">Human Translation</mda:meta><mda:meta type="olskeletonhash">69c14bf5a8ab07258c5eeebaf3495843385fe855</mda:meta><mda:meta type="olxliffhash">253dd2987cf0bffe13a4d26fd1e6ad22e4263556</mda:meta></mda:metaGroup></mda:metadata>
		<group id="content">
			<unit id="101" translate="yes">
				<segment state="initial">
					<source>Add controls</source>
				</segment>
			</unit>
			<unit id="102" translate="yes">
				<segment state="initial">
					<source>Now, we take a look at how the game sample implements move-look controls in a 3-D game, and how to develop basic touch, mouse, and game controller controls.</source>
				</segment>
			</unit>
			<unit id="103" translate="yes">
				<segment state="initial">
					<source>Add controls</source>
				</segment>
			</unit>
			<unit id="104" translate="yes">
				<segment state="initial">
					<source>\[ Updated for UWP apps on Windows 10.</source>
				</segment>
			</unit>
			<unit id="105" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
				</segment>
			</unit>
			<unit id="106" translate="yes">
				<segment state="initial">
					<source>Now, we take a look at how the game sample implements move-look controls in a 3-D game, and how to develop basic touch, mouse, and game controller controls.</source>
				</segment>
			</unit>
			<unit id="107" translate="yes">
				<segment state="initial">
					<source>Objective</source>
				</segment>
			</unit>
			<unit id="108" translate="yes">
				<segment state="initial">
					<source>To implement mouse/keyboard, touch, and Xbox controller controls in a Universal Windows Platform (UWP) game with DirectX.</source>
				</segment>
			</unit>
			<unit id="109" translate="yes">
				<segment state="initial">
					<source>UWP game apps and controls</source>
				</segment>
			</unit>
			<unit id="110" translate="yes">
				<segment state="initial">
					<source>A good UWP game supports a broad variety of interfaces.</source>
				</segment>
			</unit>
			<unit id="111" translate="yes">
				<segment state="initial">
					<source>A potential player might have Windows 10 on a tablet with no physical buttons, or a media PC with an Xbox controller attached, or the latest desktop gaming rig with a high-performance mouse and gaming keyboard.</source>
				</segment>
			</unit>
			<unit id="112" translate="yes">
				<segment state="initial">
					<source>Your game should support all of these devices if the game design allows it.</source>
				</segment>
			</unit>
			<unit id="113" translate="yes">
				<segment state="initial">
					<source>This sample supports all three.</source>
				</segment>
			</unit>
			<unit id="114" translate="yes">
				<segment state="initial">
					<source>It's a simple first-person shooting game, and the move-look controls that are standard for this genre are easily implemented for all three types of input.</source>
				</segment>
			</unit>
			<unit id="115" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--adding-move-look-controls-to-your-directx-game.md)</data>
					<data id="id3">[</data>
					<data id="id4">](tutorial--adding-touch-controls-to-your-directx-game.md)</data>
				</originalData>
				<segment state="initial">
					<source>For more info about controls, and move-look controls specifically, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Move-look controls for games</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Touch controls for games</pc>.</source>
				</segment>
			</unit>
			<unit id="116" translate="yes">
				<segment state="initial">
					<source>Common control behaviors</source>
				</segment>
			</unit>
			<unit id="117" translate="yes">
				<segment state="initial">
					<source>Touch controls and mouse/keyboard controls have a very similar core implementation.</source>
				</segment>
			</unit>
			<unit id="118" translate="yes">
				<segment state="initial">
					<source>In a UWP app, a pointer is simply a point on the screen.</source>
				</segment>
			</unit>
			<unit id="119" translate="yes">
				<segment state="initial">
					<source>You can move it by sliding the mouse or sliding your finger on the touch screen.</source>
				</segment>
			</unit>
			<unit id="120" translate="yes">
				<segment state="initial">
					<source>As a result, you can register for a single set of events, and not worry about whether the player is using a mouse or a touch screen to move and press the pointer.</source>
				</segment>
			</unit>
			<unit id="121" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>When the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MoveLookController</pc> class in the game sample is initialized, it registers for four pointer-specific events and one mouse-specific event:</source>
				</segment>
			</unit>
			<unit id="122" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208278)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindow::PointerPressed</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="123" translate="yes">
				<segment state="initial">
					<source>The left or right mouse button was pressed (and held), or the touch surface was touched.</source>
				</segment>
			</unit>
			<unit id="124" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208276)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindow::PointerMoved</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="125" translate="yes">
				<segment state="initial">
					<source>The mouse moved, or a drag action was made on the touch surface.</source>
				</segment>
			</unit>
			<unit id="126" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208279)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindow::PointerReleased</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="127" translate="yes">
				<segment state="initial">
					<source>The left mouse button was released, or the object contacting the touch surface was lifted.</source>
				</segment>
			</unit>
			<unit id="128" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208275)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindow::PointerExited</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="129" translate="yes">
				<segment state="initial">
					<source>The pointer moved out of the main window.</source>
				</segment>
			</unit>
			<unit id="130" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh758356)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows::Devices::Input::MouseMoved</pc></pc>.</source>
				</segment>
			</unit>
			<unit id="131" translate="yes">
				<segment state="initial">
					<source>The mouse moved a certain distance.</source>
				</segment>
			</unit>
			<unit id="132" translate="yes">
				<segment state="initial">
					<source>Be aware that we are only interested in mouse movement delta values, and not the current x-y position.</source>
				</segment>
			</unit>
			<unit id="133" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh405053)</data>
				</originalData>
				<segment state="initial">
					<source>The Xbox controller is handled separately, using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XInput</pc> APIs.</source>
				</segment>
			</unit>
			<unit id="134" translate="yes">
				<segment state="initial">
					<source>We talk about the implementation of game controller controls in a bit.</source>
				</segment>
			</unit>
			<unit id="135" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>In the game sample, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MoveLookController</pc> class has three controller-specific states, regardless of the control type:</source>
				</segment>
			</unit>
			<unit id="136" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">None</pc>.</source>
				</segment>
			</unit>
			<unit id="137" translate="yes">
				<segment state="initial">
					<source>This is the initialized state for the controller.</source>
				</segment>
			</unit>
			<unit id="138" translate="yes">
				<segment state="initial">
					<source>The game is not anticipating any controller input.</source>
				</segment>
			</unit>
			<unit id="139" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">WaitForInput</pc>.</source>
				</segment>
			</unit>
			<unit id="140" translate="yes">
				<segment state="initial">
					<source>The game is paused and is waiting for the player to continue.</source>
				</segment>
			</unit>
			<unit id="141" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Active</pc>.</source>
				</segment>
			</unit>
			<unit id="142" translate="yes">
				<segment state="initial">
					<source>The game is running, processing player input.</source>
				</segment>
			</unit>
			<unit id="143" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Active</pc> state is the state when the player is actively playing the game.</source>
				</segment>
			</unit>
			<unit id="144" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>During this state, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MoveLookController</pc> instance is processing input events from all enabled input devices and interpreting the player's intentions based on the aggregated event data.</source>
				</segment>
			</unit>
			<unit id="145" translate="yes">
				<segment state="initial">
					<source>As a result, it updates the velocity and look direction (the view plane normal) of the player's view and shares the updated data with the game after Update is called from the game loop.</source>
				</segment>
			</unit>
			<unit id="146" translate="yes">
				<segment state="initial">
					<source>Be aware that the player can take more than one action at the same time.</source>
				</segment>
			</unit>
			<unit id="147" translate="yes">
				<segment state="initial">
					<source>For example, he or she could be firing spheres while moving the camera.</source>
				</segment>
			</unit>
			<unit id="148" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>All of these inputs are tracked in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Active</pc> state, with different pointer IDs corresponding to different pointer actions.</source>
				</segment>
			</unit>
			<unit id="149" translate="yes">
				<segment state="initial">
					<source>This is necessary because from a player's perspective, a pointer event in the firing rectangle is different from one in the move rectangle or in the rest of the screen.</source>
				</segment>
			</unit>
			<unit id="150" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208278)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>When a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerPressed</pc></pc> event is received, the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">MoveLookController</pc> obtains the pointer ID value created by the window.</source>
				</segment>
			</unit>
			<unit id="151" translate="yes">
				<segment state="initial">
					<source>The pointer ID represents a specific type of input.</source>
				</segment>
			</unit>
			<unit id="152" translate="yes">
				<segment state="initial">
					<source>For example, on a multi-touch device, there may be several different active inputs at the same time.</source>
				</segment>
			</unit>
			<unit id="153" translate="yes">
				<segment state="initial">
					<source>The IDs are used to keep track of which input the player is using.</source>
				</segment>
			</unit>
			<unit id="154" translate="yes">
				<segment state="initial">
					<source>If one event is in the move rectangle of the touch screen, a pointer ID is assigned to track any pointer events in move rectangle.</source>
				</segment>
			</unit>
			<unit id="155" translate="yes">
				<segment state="initial">
					<source>Other pointer events in the fire rectangle are tracked separately, with a separate pointer ID.</source>
				</segment>
			</unit>
			<unit id="156" translate="yes">
				<segment state="initial">
					<source>(We talk about this some more in the section on touch controls.)</source>
				</segment>
			</unit>
			<unit id="157" translate="yes">
				<segment state="initial">
					<source>Input from the mouse has yet another ID and is also handled separately.</source>
				</segment>
			</unit>
			<unit id="158" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>After the pointer events have been mapped to a specific game action, it's time to update the data the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MoveLookController</pc> object shares with the main game loop.</source>
				</segment>
			</unit>
			<unit id="159" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">**</data>
					<data id="id12">**</data>
				</originalData>
				<segment state="initial">
					<source>When called, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Update</pc> method in the game sample processes the input and updates the velocity and look direction variables (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">m\_velocity</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">m\_lookdirection</pc>), which the game loop then retrieves by calling the public <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Velocity</pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5">LookDirection</pc> methods on the <pc dataRefEnd="id12" dataRefStart="id11" id="p6">MoveLookController</pc> instance.</source>
				</segment>
			</unit>
			<unit id="160" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The game loop can test to see if the player is firing by calling the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IsFiring</pc> method on the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MoveLookController</pc> instance.</source>
				</segment>
			</unit>
			<unit id="161" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MoveLookController</pc> checks to see if the player has pressed the fire button on one of the three input types.</source>
				</segment>
			</unit>
			<unit id="162" translate="yes">
				<segment state="initial">
					<source>If the player moves the pointer outside the main window of the game, or presses the pause button (the P key or the Xbox controller start button), the game must be paused.</source>
				</segment>
			</unit>
			<unit id="163" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MoveLookController</pc> registered the press, and informs the game loop when it calls the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsPauseRequested</pc> method.</source>
				</segment>
			</unit>
			<unit id="164" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
				</originalData>
				<segment state="initial">
					<source>At that point, if <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IsPauseRequested</pc> returns <pc dataRefEnd="id4" dataRefStart="id3" id="p2">true</pc>, the game loop then calls <pc dataRefEnd="id6" dataRefStart="id5" id="p3">WaitForPress</pc> on the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">MoveLookController</pc> to move the controller into the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">WaitForInput</pc> state.</source>
				</segment>
			</unit>
			<unit id="165" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Then, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MoveLookController</pc> waits for the player to select one of the menu items to load, continue, or exit the game, and stop processing gameplay input events until it returns to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Active</pc> state.</source>
				</segment>
			</unit>
			<unit id="166" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](#code_sample)</data>
				</originalData>
				<segment state="initial">
					<source>See the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">complete code sample for this section</pc>.</source>
				</segment>
			</unit>
			<unit id="167" translate="yes">
				<segment state="initial">
					<source>Now, let's look at the implementation of each of the three control types in a little more detail.</source>
				</segment>
			</unit>
			<unit id="168" translate="yes">
				<segment state="initial">
					<source>Implementing relative mouse controls</source>
				</segment>
			</unit>
			<unit id="169" translate="yes">
				<segment state="initial">
					<source>If mouse movement is detected, we want use that movement to determine the new pitch and yaw of the camera.</source>
				</segment>
			</unit>
			<unit id="170" translate="yes">
				<segment state="initial">
					<source>We do that by implementing relative mouse controls, where we handle the relative distance the mouse has moved—the delta between the start of the movement and the stop—as opposed to recording the absolute x-y pixel coordinates of the motion.</source>
				</segment>
			</unit>
			<unit id="171" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh758353)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
					<data id="id7">[</data>
					<data id="id8">](https://msdn.microsoft.com/library/windows/apps/hh758358)</data>
					<data id="id9">**</data>
					<data id="id10">**</data>
					<data id="id11">[</data>
					<data id="id12">](https://msdn.microsoft.com/library/windows/apps/hh758356)</data>
					<data id="id13">**</data>
					<data id="id14">**</data>
				</originalData>
				<segment state="initial">
					<source>To do that, we obtain the changes in the X (the horizontal motion) and the Y (the vertical motion) coordinates by examining the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MouseDelta::X</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">MouseDelta::Y</pc> fields on the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Windows::Device::Input::MouseEventArgs::MouseDelta</pc></pc> argument object returned by the <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">MouseMoved</pc></pc> event.</source>
				</segment>
			</unit>
			<unit id="172" translate="yes">
				<segment state="initial">
					<source>Implementing touch controls</source>
				</segment>
			</unit>
			<unit id="173" translate="yes">
				<segment state="initial">
					<source>Touch controls are the trickiest to develop, because they are the most complex and require the most fine-tuning to be effective.</source>
				</segment>
			</unit>
			<unit id="174" translate="yes">
				<segment state="initial">
					<source>In the game sample, a rectangle in the lower left quadrant of the screen is used as a directional pad, where sliding your thumb left and right in this space slides the camera left and right, and sliding your thumb up and down moves the camera forward and backward.</source>
				</segment>
			</unit>
			<unit id="175" translate="yes">
				<segment state="initial">
					<source>A rectangle in the lower right quadrant of the screen can be pressed to fire the spheres.</source>
				</segment>
			</unit>
			<unit id="176" translate="yes">
				<segment state="initial">
					<source>Aiming (pitch and yaw) are controlled by sliding your finger on the parts of the screen not reserved for moving and firing; as your finger moves, the camera (with fixed cross hairs) moves similarly.</source>
				</segment>
			</unit>
			<unit id="177" translate="yes">
				<segment state="initial">
					<source>The move and fire rectangles are created by two methods in the sample code:</source>
				</segment>
			</unit>
			<unit id="178" translate="yes">
				<segment state="initial">
					<source>We treat touch device pointer events for the other regions of the screen as look commands.</source>
				</segment>
			</unit>
			<unit id="179" translate="yes">
				<segment state="initial">
					<source>If the screen is resized, these rectangles must be computed again (and redrawn).</source>
				</segment>
			</unit>
			<unit id="180" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If a touch device pointer event is raised in one of these regions and the game state is set to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Active</pc>, it's assigned a pointer ID, as we discussed earlier.</source>
				</segment>
			</unit>
			<unit id="181" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208278)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>If a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerPressed</pc></pc> event has occurred in one of the three control regions, the move rectangle, the fire rectangle, or the rest of the screen (the look control), the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">MoveLookController</pc> assigns the pointer ID for the pointer that fired the event to a specific variable that corresponds to the region of the screen the event was fired in.</source>
				</segment>
			</unit>
			<unit id="182" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>For example, if the event occurred in the move rectangle, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_movePointerID</pc> variable is set to the pointer ID that fired the event.</source>
				</segment>
			</unit>
			<unit id="183" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>A Boolean "in use" variable (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">m\_lookInUse</pc>, in the example) is also set to indicate that the control has not been released yet.</source>
				</segment>
			</unit>
			<unit id="184" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208276)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Now, let's look at how the game sample handles the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerMoved</pc></pc> touch screen event.</source>
				</segment>
			</unit>
			<unit id="185" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MoveLookController</pc> checks the pointer ID to determine where the event occurred, and takes one of the following actions:</source>
				</segment>
			</unit>
			<unit id="186" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208276)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerMoved</pc></pc> event occurred in the move or fire rectangle, update the pointer position for the controller.</source>
				</segment>
			</unit>
			<unit id="187" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208276)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>If the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerMoved</pc></pc> event occurred somewhere in the rest of the screen (defined as the look controls), calculate the change in pitch and yaw of the look direction vector.</source>
				</segment>
			</unit>
			<unit id="188" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208279)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Lastly, let's look at how the game sample handles the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerReleased</pc></pc> touch screen event.</source>
				</segment>
			</unit>
			<unit id="189" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208279)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>If the ID of the pointer that fired the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerReleased</pc></pc> event is the ID of the previously recorded move pointer, the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">MoveLookController</pc> sets the velocity to 0 because the player has stopped touching the move rectangle.</source>
				</segment>
			</unit>
			<unit id="190" translate="yes">
				<segment state="initial">
					<source>If it didn't set the velocity to 0, the player would keep moving!</source>
				</segment>
			</unit>
			<unit id="191" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If you want to implement some form of inertia, this is where you add the method that begins returning the velocity to 0 over future calls to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Update</pc> from the game loop.</source>
				</segment>
			</unit>
			<unit id="192" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208279)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">**</data>
					<data id="id6">**</data>
				</originalData>
				<segment state="initial">
					<source>Otherwise, if the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerReleased</pc></pc> event fired in the fire rectangle or the look region, the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">MoveLookController</pc> resets the specific pointer IDs.</source>
				</segment>
			</unit>
			<unit id="193" translate="yes">
				<segment state="initial">
					<source>That's the basics of how touch screen controls are implemented in the game sample.</source>
				</segment>
			</unit>
			<unit id="194" translate="yes">
				<segment state="initial">
					<source>Let's move on to mouse and keyboard controls.</source>
				</segment>
			</unit>
			<unit id="195" translate="yes">
				<segment state="initial">
					<source>Implementing mouse and keyboard controls</source>
				</segment>
			</unit>
			<unit id="196" translate="yes">
				<segment state="initial">
					<source>The game sample implements these mouse and keyboard controls:</source>
				</segment>
			</unit>
			<unit id="197" translate="yes">
				<segment state="initial">
					<source>The W, S, A, and D keys move the player view forward, backward, left, and right, respectively.</source>
				</segment>
			</unit>
			<unit id="198" translate="yes">
				<segment state="initial">
					<source>Pressing X and the space bar move the view up and down, respectively.</source>
				</segment>
			</unit>
			<unit id="199" translate="yes">
				<segment state="initial">
					<source>Pressing the P key pauses the game.</source>
				</segment>
			</unit>
			<unit id="200" translate="yes">
				<segment state="initial">
					<source>Moving the mouse puts the player in control of the rotation (the pitch and yaw) of the camera view.</source>
				</segment>
			</unit>
			<unit id="201" translate="yes">
				<segment state="initial">
					<source>Clicking the left button fires a sphere.</source>
				</segment>
			</unit>
			<unit id="202" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208271)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
					<data id="id5">[</data>
					<data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208270)</data>
					<data id="id7">**</data>
					<data id="id8">**</data>
				</originalData>
				<segment state="initial">
					<source>To use the keyboard, the game sample registers for two extra events: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CoreWindow::KeyUp</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CoreWindow::KeyDown</pc></pc>, which handle the press and the release of a key, respectively.</source>
				</segment>
			</unit>
			<unit id="203" translate="yes">
				<segment state="initial">
					<source>The mouse is treated a little differently from the touch controls, even though it uses a pointer.</source>
				</segment>
			</unit>
			<unit id="204" translate="yes">
				<segment state="initial">
					<source>Obviously, it doesn't use the move and fire rectangles, as that would be very cumbersome for the player: how could they press the move and fire controls at the same time?</source>
				</segment>
			</unit>
			<unit id="205" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>As noted earlier, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MoveLookController</pc> controller engages the look controls whenever the mouse is moved, and engages the fire controls when the left mouse button is pressed, as shown here.</source>
				</segment>
			</unit>
			<unit id="206" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208279)</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>Now, let's look at how the game sample handles the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerReleased</pc></pc> mouse event.</source>
				</segment>
			</unit>
			<unit id="207" translate="yes">
				<segment state="initial">
					<source>When the player stops pressing one of the mouse buttons, the input is complete: the spheres stop firing.</source>
				</segment>
			</unit>
			<unit id="208" translate="yes">
				<segment state="initial">
					<source>But, because look is always enabled, the game continues to use the same mouse pointer to track the ongoing look events.</source>
				</segment>
			</unit>
			<unit id="209" translate="yes">
				<segment state="initial">
					<source>Now, let's look at the last of control types: the Xbox controller.</source>
				</segment>
			</unit>
			<unit id="210" translate="yes">
				<segment state="initial">
					<source>It's handled separately from the touch and mouse controls, because it doesn't use the pointer object.</source>
				</segment>
			</unit>
			<unit id="211" translate="yes">
				<segment state="initial">
					<source>Implementing Xbox controller controls</source>
				</segment>
			</unit>
			<unit id="212" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh405053)</data>
				</originalData>
				<segment state="initial">
					<source>In the game sample, Xbox controller support is added by calls to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XInput</pc> APIs, which are set of APIs designed to simplify programming for game controllers.</source>
				</segment>
			</unit>
			<unit id="213" translate="yes">
				<segment state="initial">
					<source>In the game sample, we use the Xbox controller's left analog stick for player movement, the right analog stick for the look controls, and the right trigger to fire.</source>
				</segment>
			</unit>
			<unit id="214" translate="yes">
				<segment state="initial">
					<source>We use the start button to pause and resume the game.</source>
				</segment>
			</unit>
			<unit id="215" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
					<data id="id3">**</data>
					<data id="id4">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Update</pc> method on the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MoveLookController</pc> instance immediately checks to see if a game controller is connected, and then checks the controller state.</source>
				</segment>
			</unit>
			<unit id="216" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>If the game controller is in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Active</pc> state, this method checks to see if a user moved the left analog stick in a specific direction.</source>
				</segment>
			</unit>
			<unit id="217" translate="yes">
				<segment state="initial">
					<source>But the movement on the stick in a specific direction must register as larger than the radius of the dead zone; otherwise, nothing will happen.</source>
				</segment>
			</unit>
			<unit id="218" translate="yes">
				<segment state="initial">
					<source>This dead zone radius is necessary to present "drifting," which is when the controller picks up minute movements from the player's thumb as it rests on the stick.</source>
				</segment>
			</unit>
			<unit id="219" translate="yes">
				<segment state="initial">
					<source>If we don't have this dead zone, the player can get annoyed very quickly, as the controls feel very fidgety.</source>
				</segment>
			</unit>
			<unit id="220" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Update</pc> method then performs the same check on the right stick, to see if the player has changed the direction the camera is looking, as long as the movement on the stick is longer than another dead zone radius.</source>
				</segment>
			</unit>
			<unit id="221" translate="yes">
				<originalData>
					<data id="id1">**</data>
					<data id="id2">**</data>
				</originalData>
				<segment state="initial">
					<source><pc dataRefEnd="id2" dataRefStart="id1" id="p1">Update</pc> computes the new pitch and yaw, and then checks to see if the user pressed the right analog trigger, our fire button.</source>
				</segment>
			</unit>
			<unit id="222" translate="yes">
				<segment state="initial">
					<source>And that's how this sample implements a full set of control options.</source>
				</segment>
			</unit>
			<unit id="223" translate="yes">
				<segment state="initial">
					<source>Again, remember that a good UWP app supports a range of control options, so players with different form factors and devices can play in the way they prefer!</source>
				</segment>
			</unit>
			<unit id="224" translate="yes">
				<segment state="initial">
					<source>Next steps</source>
				</segment>
			</unit>
			<unit id="225" translate="yes">
				<segment state="initial">
					<source>We've reviewed every major component of a UWP DirectX game except one: audio!</source>
				</segment>
			</unit>
			<unit id="226" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](tutorial--adding-sound.md)</data>
				</originalData>
				<segment state="initial">
					<source>Music and sound effects are important to any game, so let's discuss <pc dataRefEnd="id2" dataRefStart="id1" id="p1">adding sound</pc>!</source>
				</segment>
			</unit>
			<unit id="227" translate="yes">
				<segment state="initial">
					<source>Complete sample code for this section</source>
				</segment>
			</unit>
			<unit id="228" translate="yes">
				<segment state="initial">
					<source>MoveLookController.h</source>
				</segment>
			</unit>
			<unit id="229" translate="yes">
				<segment state="initial">
					<source>MoveLookController.cpp</source>
				</segment>
			</unit>
			<unit id="230" translate="yes">
				<segment state="initial">
					<source>Note</source>
				</segment>
			</unit>
			<unit id="231" translate="yes">
				<segment state="initial">
					<source>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</source>
				</segment>
			</unit>
			<unit id="232" translate="yes">
				<originalData>
					<data id="id1">[</data>
					<data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
				</originalData>
				<segment state="initial">
					<source>If you’re developing for Windows 8.x or Windows Phone 8.x, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archived documentation</pc>.</source>
				</segment>
			</unit>
			<unit id="233" translate="yes">
				<segment state="initial">
					<source>Related topics</source>
				</segment>
			</unit>
			<unit id="234" translate="yes">
				<segment state="initial">
					<source>Create a simple UWP game with DirectX</source>
				</segment>
			</unit>
		</group>
	</file>
</xliff>